<Type Name="ResourceReader" FullName="System.Resources.ResourceReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cc2329cf6988186b9da27d48b6c8d95189893181" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69275949" /></Metadata><TypeSignature Language="C#" Value="public sealed class ResourceReader : System.Resources.IResourceReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ResourceReader extends System.Object implements class System.Collections.IEnumerable, class System.IDisposable, class System.Resources.IResourceReader" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ResourceReader&#xA;Implements IResourceReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceReader sealed : System::Resources::IResourceReader" />
  <TypeSignature Language="F#" Value="type ResourceReader = class&#xA;    interface IResourceReader&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.Reader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Resources.IResourceReader</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wylicza zasoby w pliku zasobów binarnych (. resources) przez odczyt sekwencyjnych par nazwa zasobu/wartość.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 Klasa zapewnia standardową implementację <xref:System.Resources.IResourceReader>interfejsu. <xref:System.Resources.ResourceReader> <xref:System.Resources.ResourceReader> Wystąpienie reprezentuje autonomiczny plik resources lub plik resources, który jest osadzony w zestawie. Służy do wyliczania zasobów w pliku Resources i pobierania ich par nazwa/wartość. Różni się od <xref:System.Resources.ResourceManager> klasy, która jest używana do pobierania określonych nazwanych zasobów z pliku Resources, który jest osadzony w zestawie. Klasa jest używana do pobierania zasobów, których nazwy są znane z wyprzedzeniem, <xref:System.Resources.ResourceReader> natomiast Klasa jest przydatna do pobierania zasobów, których liczba lub precyzyjne nazwy nie są znane w czasie kompilacji. <xref:System.Resources.ResourceManager> Na przykład aplikacja może używać pliku zasobów do przechowywania informacji o konfiguracji, które są zorganizowane w sekcje i elementy w sekcji, gdzie liczba sekcji lub elementów w sekcji nie jest znana z góry. Zasoby mogą następnie być nazwane `Section1`ogólnie (takie jak `Section1Item1` `Section1Item2`,,, itd.) i pobierane przy użyciu <xref:System.Resources.ResourceReader> obiektu.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejs. Po zakończeniu korzystania z typu należy usunąć jego wartość bezpośrednio lub pośrednio. Aby usunąć typ bezpośrednio <xref:System.IDisposable.Dispose%2A> , wywołaj jego metodę `try` / `catch` w bloku. Aby usunąć go pośrednio, użyj konstrukcji języka, takiej jak `using` (in C#) lub `Using` (w Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Używanie obiektu implementującego <xref:System.IDisposable> interfejs IDisposable" w temacie dotyczącym interfejsu.  
  
 Aby uzyskać więcej informacji o korzystaniu z <xref:System.Resources.ResourceReader> klasy, zobacz następujące sekcje:  
  
-   [Tworzenie wystąpienia obiektu ResourceReader](#instantiate)  
  
-   [Wyliczanie zasobów obiektu ResourceReader](#enumerate)  
  
    -   [Pobieranie zasobów przy użyciu właściwości IDictionaryEnumerator](#idictionaryenumerator)  
  
    -   [Pobieranie zasobów według nazwy z GetResourceData](#getresourcedata)  
  
<a name="instantiate"></a>   
## <a name="instantiating-a-resourcereader-object"></a>Utworzenie wystąpienia obiektu ResourceReader  
 Plik resources to plik binarny, który został skompilowany z pliku tekstowego lub pliku XML. resx przez [Resgen. exe (Generator plików zasobów)](~/docs/framework/tools/resgen-exe-resource-file-generator.md). <xref:System.Resources.ResourceReader> Obiekt może reprezentować autonomiczny plik resources lub plik resources, który został osadzony w zestawie.  
  
 Aby utworzyć wystąpienie <xref:System.Resources.ResourceReader> obiektu, który odczytuje z autonomicznego pliku Resources, <xref:System.Resources.ResourceReader> Użyj konstruktora klasy ze strumieniem wejściowym lub ciągiem zawierającym nazwę pliku Resources. Poniższy przykład ilustruje oba podejścia. Pierwsze tworzy wystąpienie <xref:System.Resources.ResourceReader> obiektu, który reprezentuje plik resources o nazwie `Resources1.resources` przy użyciu jego nazwy pliku. Drugi tworzy wystąpienie <xref:System.Resources.ResourceReader> obiektu, który reprezentuje plik resources o nazwie `Resources2.resources` przy użyciu strumienia utworzonego na podstawie pliku.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#2)]  
  
 Aby utworzyć <xref:System.Resources.ResourceReader> obiekt, który reprezentuje osadzony plik resources, Utwórz <xref:System.Reflection.Assembly> wystąpienie obiektu z zestawu, w którym jest osadzony plik resources. Jego <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> Metoda <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> zwraca obiekt, który może zostać przesłany do konstruktora. <xref:System.IO.Stream> Poniższy przykład tworzy wystąpienie <xref:System.Resources.ResourceReader> obiektu, który reprezentuje osadzony plik resources.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#3)]
 [!code-vb[System.Resources.ResourceReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#3)]  
  
<a name="enumerate"></a>   
## <a name="enumerating-a-resourcereader-objects-resources"></a>Wyliczanie zasobów obiektu ResourceReader  
 Aby wyliczyć zasoby w pliku Resources, należy wywołać <xref:System.Resources.ResourceReader.GetEnumerator%2A> metodę, która <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> zwraca obiekt. Należy wywołać metodę `IDictionaryEnumerator.MoveNext` , aby przejść z jednego zasobu do następnego. Metoda zwraca wartość `false` , gdy wszystkie zasoby w pliku Resources zostały wyliczone.  
  
> [!NOTE]
>  <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> Chociaż Klasa implementuje interfejs i metodę, Metodaniezapewniaimplementacji.<xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> <xref:System.Collections.IEnumerable> <xref:System.Resources.ResourceReader> Zamiast tego <xref:System.Collections.IDictionaryEnumerator> Metoda zwraca obiekt interfejsu, który zapewnia dostęp do pary nazwa/wartość każdego zasobu. <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType>  
  
 Poszczególne zasoby można pobrać na dwa sposoby:  
  
-   Można powtórzyć każdy zasób w <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> kolekcji i użyć <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> właściwości do pobrania nazwy i wartości zasobu. Zalecamy tę technikę, gdy wszystkie zasoby są tego samego typu lub wiesz, jaki typ danych każdego z zasobów.  
  
-   Podczas iteracji <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> kolekcji można pobrać nazwy poszczególnych zasobów i <xref:System.Resources.ResourceReader.GetResourceData%2A> wywołać metodę, aby pobrać dane zasobu. Zalecamy to podejście, jeśli nie znasz typu danych poszczególnych zasobów lub jeśli poprzednie podejście zgłasza wyjątki.  
  
<a name="idictionaryenumerator"></a>   
### <a name="retrieving-resources-by-using-idictionaryenumerator-properties"></a>Pobieranie zasobów za pomocą właściwości IDictionaryEnumerator  
 Pierwsza metoda wyliczania zasobów w pliku Resources polega bezpośrednio na pobieraniu pary nazwa/wartość każdego zasobu. Po wywołaniu `IDictionaryEnumerator.MoveNext` metody w celu przejścia do każdego zasobu w kolekcji można pobrać nazwę zasobu <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> z właściwości i danych zasobu z <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> właściwości.  
  
 Poniższy przykład pokazuje, jak pobrać nazwę i wartość każdego zasobu w pliku Resources przy użyciu <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> właściwości i. <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> Aby uruchomić ten przykład, Utwórz następujący plik tekstowy o nazwie ApplicationResources. txt, aby zdefiniować zasoby ciągu.  
  
```  
Title="Contact Information"  
Label1="First Name:"  
Label2="Middle Name:"  
Label3="Last Name:"  
Label4="SSN:"  
Label5="Street Address:"  
Label6="City:"  
Label7="State:"  
Label8="Zip Code:"  
Label9="Home Phone:"  
Label10="Business Phone:"  
Label11="Mobile Phone:"  
Label12="Other Phone:"  
Label13="Fax:"  
Label14="Email Address:"  
Label15="Alternate Email Address:"  
```  
  
 Następnie można przekonwertować plik zasobów tekstowych na plik binarny o nazwie ApplicationResources. resources przy użyciu następującego polecenia:  
  
 **Resgen ApplicationResources. txt**  
  
 Poniższy przykład używa <xref:System.Resources.ResourceReader> klasy, aby wyliczyć każdy zasób w autonomicznym pliku Binary. resources i wyświetlić jego nazwę klucza i odpowiednią wartość.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/class1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/class1.vb#1)]  
  
 Próba pobrania danych zasobu z <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> właściwości może zgłosić następujące wyjątki:  
  
-   A <xref:System.FormatException> Jeśli dane nie są w oczekiwanym formacie.  
  
-   A <xref:System.IO.FileNotFoundException> Jeśli nie można odnaleźć zestawu, który zawiera typ, do którego należy dane.  
  
-   A <xref:System.TypeLoadException> Jeśli nie można odnaleźć typu, do którego należą dane.  
  
 Zazwyczaj te wyjątki są generowane, jeśli plik resources został zmodyfikowany ręcznie, jeśli zestaw, w którym zdefiniowano typ, nie został dołączony do aplikacji lub został przypadkowo usunięty lub jeśli zestaw jest starszą wersją, która jest wcześniejsza Typ. W przypadku zgłoszenia jednego z tych wyjątków można pobrać zasoby przez Wyliczenie poszczególnych zasobów i wywołanie <xref:System.Resources.ResourceReader.GetResourceData%2A> metody, jak pokazano w poniższej sekcji. To podejście zapewnia pewne informacje o typie danych, które <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> próbowano zwrócić przez właściwość.  
  
<a name="getresourcedata"></a>   
### <a name="retrieving-resources-by-name-with-getresourcedata"></a>Pobieranie zasobów według nazw z GetResourceData  
 Drugie podejście do wyliczania zasobów w pliku Resources również obejmuje przechodzenie przez zasoby w pliku przez wywołanie `IDictionaryEnumerator.MoveNext` metody. Dla każdego zasobu pobierana jest nazwa zasobu z <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> właściwości, która jest następnie przenoszona <xref:System.Resources.ResourceReader.GetResourceData%28System.String%2CSystem.String%40%2CSystem.Byte%5B%5D%40%29> do metody w celu pobrania danych zasobu. Ta wartość jest zwracana jako tablica bajtów w `resourceData` argumencie.  
  
 Takie podejście jest bardziej niewygodna niż pobranie nazwy zasobu i wartości z <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> właściwości i <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> , ponieważ zwraca rzeczywiste bajty, które tworzą wartość zasobu. Jeśli jednak próba pobrania zasobu zgłosi wyjątek, <xref:System.Resources.ResourceReader.GetResourceData%2A> Metoda może ułatwić zidentyfikowanie źródła wyjątku przez dostarczenie informacji o typie danych zasobu. Aby uzyskać więcej informacji na temat ciągu, który wskazuje typ danych zasobu, zobacz <xref:System.Resources.ResourceReader.GetResourceData%2A>.  
  
 Poniższy przykład ilustruje sposób użycia tej metody do pobierania zasobów i obsługi wszelkich zgłaszanych wyjątków. Program programowo tworzy plik binarny. resources zawierający cztery ciągi, jedną wartość logiczną, jedną liczbę całkowitą, jedną mapę bitową i jeden obiekt niestandardowy `DateTimeTZI` . Aby uruchomić przykład, wykonaj następujące czynności:  
  
1.  Utwórz zestaw o nazwie Library. dll, który zawiera `DateTimeTZI` strukturę. Poniżej znajduje się kod źródłowy zestawu.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/library.cs#4)]
     [!code-vb[System.Resources.ResourceReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/library.vb#4)]  
  
     Skompiluj kod źródłowy w programie C# przy użyciu następującego polecenia:  
  
    ```  
    csc /t:library library.cs  
    ```  
  
     Można też skompilować ją w Visual Basic przy użyciu następującego polecenia:  
  
    ```  
    vbc library.vb /t:library  
    ```  
  
2.  Skompiluj i wykonaj następujący kod źródłowy, który tworzy plik resources o nazwie ContactResources. resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/createresourceex1.cs#5)]
     [!code-vb[System.Resources.ResourceReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/createresourceex1.vb#5)]  
  
     Plik kodu źródłowego ma nazwę CreateResources.cs. Można ją C# skompilować przy użyciu następującego polecenia:  
  
    ```  
    csc CreateResources.cs /r:library.dll  
    ```  
  
     Można też skompilować ją w Visual Basic przy użyciu następującego polecenia:  
  
    ```  
    vbc CreateResources.vb /r:library.dll  
    ```  
  
3.  Skompiluj i uruchom następujący kod, aby wyliczyć zasoby w pliku ContactResources. resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/readresourceex1.cs#6)]
     [!code-vb[System.Resources.ResourceReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/readresourceex1.vb#6)]  
  
     Po zmodyfikowaniu kodu źródłowego (na przykład przez zamierzone Przerzucanie <xref:System.FormatException> na końcu `try` bloku) lub zmiana nazwy zestawu Library. dll tak, aby był niedostępny w czasie wykonywania, można uruchomić przykład, <xref:System.Resources.ResourceReader.GetResourceData%2A> aby zobaczyć, jak wywołania umożliwia pobranie lub ponowne utworzenie niektórych informacji o zasobach.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Resources.ResourceReader" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)].
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : System.IO.Stream -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień wejściowy służący do odczytywania zasobów.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Resources.ResourceReader" /> klasy dla określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor tworzy wystąpienie <xref:System.Resources.ResourceReader> obiektu pobierającego zasoby z autonomicznego pliku Resources lub z pliku Resources, który jest osadzony w zestawie. <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> Aby odczytywać z autonomicznego pliku Resources, <xref:System.IO.Stream> Utwórz wystąpienie obiektu i przekaż go <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> do konstruktora. Aby odczytywać dane z osadzonego pliku Resources <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> , należy wywołać metodę z nazwą uwzględniającą wielkość liter pliku Resources i przekazać zwracany <xref:System.IO.Stream> obiekt do <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> konstruktora.  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
## Examples  
 W przykładzie w tej sekcji jest używany następujący plik txt o nazwie `PatientForm.txt` do definiowania zasobów używanych przez aplikację.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Plik txt można skompilować do pliku Resources, wydając następujące polecenie:  
  
 **Resgen PatientForm. txt**  
  
 W poniższym przykładzie założono, że plik zasobów jest osadzony w zestawie, który zawiera kod wykonywalny aplikacji. Pobiera plik zasobów o nazwie `PatientForm.resources` z aktualnie wykonywanych zestawów i wyświetla nazwę i wartość każdego z zasobów.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream1.vb#1)]  
  
 Jeśli C# przykład ma nazwę `Example.cs`, można skompilować go za pomocą następującego polecenia:  
  
 **CSC Example.cs/res: PatientForm. resources**  
  
 Jeśli przykład Visual Basic ma nazwę `Example.vb`, można go skompilować przy użyciu następującego polecenia:  
  
 **Przykład VBC. vb/res: PatientForm. resources**  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie można odczytać parametru. <paramref name="stream" /></exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="stream" /></exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas uzyskiwania dostępu <paramref name="stream" />do programu.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu świadczenia usług serializacji. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : string -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Ścieżka i nazwa pliku zasobów, który ma zostać odczytany. w <c>nazwie pliku</c> nie jest rozróżniana wielkość liter.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Resources.ResourceReader" /> klasy dla określonego nazwanego pliku zasobu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor tworzy wystąpienie <xref:System.Resources.ResourceReader> obiektu pobierającego zasoby z autonomicznego pliku Resources. <xref:System.Resources.ResourceReader.%23ctor%28System.String%29> Aby pobrać zasoby z osadzonego pliku Resources, użyj <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> konstruktora.  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]

## Examples  
 W przykładzie w tej sekcji jest używany następujący plik txt o nazwie `PatientForm.txt` do definiowania zasobów używanych przez aplikację.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Plik. txt można skompilować do pliku Resources, wydając następujące polecenie:  
  
 **Resgen PatientForm. txt**  
  
 Poniższy przykład wylicza zasoby w `PatientForm.resources` i wyświetla nazwę i wartość każdego z nich.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="fileName" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.BadImageFormatException">Plik zasobu ma nieprawidłowy format. Na przykład długość pliku może wynosić zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="resourceReader.Close " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby systemu operacyjnego skojarzone z tym <see cref="T:System.Resources.ResourceReader" /> obiektem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.Close%2A>można bezpiecznie wywołać wiele razy.  
  
   
  
## Examples  
 Poniższy przykład przechodzi przez zasoby pliku i wyświetla wszystkie znalezione pary klucz/wartość. Następnie kod używa <xref:System.Resources.ResourceReader.Close%2A> metody do wyłączania <xref:System.Resources.ResourceReader> i wydawania wszystkich używanych przez nią zasobów.  
  
 [!code-cpp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CPP/getenumerator.cpp#1)]
 [!code-csharp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CS/getenumerator.cs#1)]
 [!code-vb[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="resourceReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Resources.ResourceReader" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu korzystania z tego wystąpienia programu <xref:System.Resources.ResourceReader>Wywołaj <xref:System.Resources.ResourceReader.Dispose%2A> wszystkie zasoby używane przez to wystąpienie. Należy wyeliminować dalsze odwołania do tego <xref:System.Resources.ResourceReader> wystąpienia, tak aby moduł wyrzucania elementów bezużytecznych mógł odzyskiwać pamięć wystąpienia, zamiast utrzymać go w celu sfinalizowania.  
  
 <xref:System.Resources.ResourceReader.Dispose%2A>wywołuje prywatną metodę Dispose (Boolean), która zawiera kod do zwolnienia zasobów zarządzanych i niezarządzanych. Aby uzyskać więcej informacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="resourceReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający dla <see cref="T:System.Resources.ResourceReader" /> tego obiektu.</summary>
        <returns>Moduł wyliczający dla <see cref="T:System.Resources.ResourceReader" /> tego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle wyliczane są <xref:System.Resources.ResourceReader.GetEnumerator%2A> zasoby przez wywołanie metody, a następnie wielokrotne <xref:System.Collections.IEnumerator.MoveNext%2A> wywołanie metody na zwracanym <xref:System.Collections.IDictionaryEnumerator> obiekcie do momentu zwrócenia `false`metody. Nazwa zasobu jest dostępna z <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> właściwości; jej wartość <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> właściwości. Przykład ilustruje sposób wyliczania zasobów w ten sposób.  
  
 Implementacja <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> właściwości<xref:System.Resources.ResourceReader> przez klasę może zgłosić następujące wyjątki:  
  
-   <xref:System.IO.FileNotFoundException>  
  
     Nie można odnaleźć zestawu, który zawiera typ, do którego należy dane.  
  
-   <xref:System.FormatException>  
  
     Dane mają nieoczekiwany format.  
  
-   <xref:System.TypeLoadException>  
  
     Typ, do którego należy dane, nie może zostać znaleziony.  
  
 Możesz obsłużyć wyjątek, wywołując <xref:System.Resources.ResourceReader.GetResourceData%2A> metodę w celu pobrania informacji o typie danych i tablicy bajtowej przypisanej do nazwanego zasobu. Aby uzyskać więcej informacji, zobacz sekcję "Pobieranie zasobów według nazwy z GetResourceData" w <xref:System.Resources.ResourceReader> temacie dotyczącym klas.  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceReader> Klasa obejmuje dwie metody, które zwracają moduł wyliczający. <xref:System.Resources.ResourceReader.GetEnumerator%2A> Metoda zwracaobiektinterfejsuijestzalecanąmetodąwywołania<xref:System.Collections.IDictionaryEnumerator> podczas wyliczania zasobów.  
  
   
  
## Examples  
 W przykładzie w tej sekcji jest używany następujący plik txt o nazwie `PatientForm.txt` do definiowania zasobów używanych przez aplikację.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Plik txt można skompilować do pliku Resources, wydając następujące polecenie:  
  
 **Resgen PatientForm. txt**  
  
 Poniższy przykład wylicza zasoby w `PatientForm.resources` i wyświetla nazwę i wartość każdego z nich.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Czytnik został zamknięty lub usunięty i nie można uzyskać do niego dostępu.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceData">
      <MemberSignature Language="C#" Value="public void GetResourceData (string resourceName, out string resourceType, out byte[] resourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetResourceData(string resourceName, [out] string&amp; resourceType, [out] unsigned int8[]&amp; resourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetResourceData(System.String,System.String@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetResourceData (resourceName As String, ByRef resourceType As String, ByRef resourceData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetResourceData(System::String ^ resourceName, [Runtime::InteropServices::Out] System::String ^ % resourceType, [Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % resourceData);" />
      <MemberSignature Language="F#" Value="member this.GetResourceData : string *  *  -&gt; unit" Usage="resourceReader.GetResourceData (resourceName, resourceType, resourceData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="resourceType" Type="System.String" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="resourceData" Type="System.Byte[]" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="resourceName">Nazwa zasobu.</param>
        <param name="resourceType">Gdy ta metoda zwraca, zawiera ciąg, który reprezentuje nazwę typu pobranego zasobu. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="resourceData">Gdy ta metoda zwraca, zawiera tablicę bajtową, która jest reprezentacją binarną pobranego typu. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Pobiera nazwę typu i dane nazwanego zasobu z otwartego pliku zasobów lub strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.GetResourceData%2A> Metoda pobiera wartość nazwanego zasobu jako tablicę bajtów. Jest zazwyczaj używany, <xref:System.Collections.IDictionaryEnumerator.Value%2A> gdy właściwość zgłasza wyjątek podczas próby pobrania wartości zasobu.  
  
 `resourceType`jest ciągiem, który reprezentuje typ danych zasobu. Może to być dowolna z następujących wartości:  
  
-   Ciąg reprezentujący `ResourceTypeCode` element członkowski wyliczenia, który wskazuje typ danych zasobu. `ResourceTypeCode`jest wyliczeniem prywatnym używanym przez., aby wskazać, że specjalny format binarny jest używany do przechowywania jednego z 19 wspólnych typów danych. Obejmują one typy danych pierwotnych .NET Framework (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char> <xref:System.Double> ,,<xref:System.Single>, <xref:System.Int16>, <xref:System.Int32> <xref:System.Int64> ,,,,<xref:System.SByte> <xref:System.Decimal> <xref:System.UInt16>, <xref:System.UInt32>, )<xref:System.UInt64>, <xref:System.String> aponadto`ResourceTypeCode` ,, i <xref:System.TimeSpan>, również Wyliczenie zawiera wartości pokazane w poniższej tabeli. <xref:System.DateTime>  
  
    |ResourceTypeCode wartość|Opis|  
    |----------------------------|-----------------|  
    |`ResourceTypeCode.ByteArray`|Dane są tablicą bajtów. Ten typ danych często wynika z wywołania <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Byte%5B%5D%29?displayProperty=nameWithType> metody.|  
    |`ResourceTypeCode.Null`|Dane to odwołanie o wartości null. Ten typ danych jest często wynikiem wywołania <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Object%29?displayProperty=nameWithType> metody z obiektem, którego wartość to. `null`|  
    |`ResourceTypeCode.Stream`|Dane są przechowywane w strumieniu. Ten typ danych jest często wynikiem wywołania <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%29?displayProperty=nameWithType> metody lub. <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%2CSystem.Boolean%29?displayProperty=nameWithType>|  
  
     Przy założeniu, że `resourceData` plik nie został uszkodzony, można go zwykle przekonwertować z tablicy bajtów z powrotem na oryginalną wartość przez <xref:System.BitConverter> wywołanie metody lub. <xref:System.IO.BinaryReader>  
  
-   Ciąg, który zawiera w pełni kwalifikowaną nazwę typu, którego serializowane dane są przypisane do `resourceData` argumentu (na `System.String`przykład). Ponadto dla typów, które nie są częścią biblioteki klas .NET Framework, ciąg zawiera nazwę, wersję, kulturę i klucz publiczny zestawu, który zawiera typ. Na przykład następujący ciąg wskazuje, że zserializowane dane reprezentują wystąpienie `Person` typu `Extensions` w przestrzeni nazw, które znajduje się w wersji 1,0 zestawu o nazwie Narzędzie, które nie ma klucza publicznego i nie wykryto kultury.  
  
     `Extensions.Person, Utility, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`  
  
     Przy założeniu, że `resourceData` nie została uszkodzona i że typ źródła jest dostępny, `resourceData` można go przekonwertować z tablicy bajtowej z powrotem na oryginalną wartość, konwertując tablicę <xref:System.IO.Stream> bajtów na obiekt i przekazując strumień do <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>Metoda.  
  
-   Ciąg używany do opisywania typu danych w <xref:System.Resources.ResourceWriter.AddResourceData%2A?displayProperty=nameWithType> wywołaniu metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceName" />nie istnieje.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="resourceName" />ma nieprawidłowy typ.</exception>
        <exception cref="T:System.FormatException">Pobrane dane zasobu są uszkodzone.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Resources.ResourceReader" /> obiekt nie został zainicjowany, prawdopodobnie dlatego, że jest zamknięty.</exception>
        <altmember cref="M:System.Resources.ResourceWriter.AddResourceData(System.String,System.String,System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający dla <see cref="T:System.Resources.ResourceReader" /> tego obiektu.</summary>
        <returns>Moduł wyliczający dla <see cref="T:System.Resources.ResourceReader" /> tego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.System%23Collections%23IEnumerable%23GetEnumerator%2A?displayProperty=nameWithType>jest jawną implementacją interfejsu. Może być używana tylko wtedy, <xref:System.Resources.ResourceReader> gdy wystąpienie jest rzutowane <xref:System.Collections.IEnumerable> do interfejsu. Zalecane podejście do wyliczania zasobów w pliku Resources polega na wywołaniu <xref:System.Collections.IEnumerator.MoveNext%2A> metody <xref:System.Collections.IDictionaryEnumerator> obiektu zwróconego przez <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Czytnik został już zamknięty i nie można uzyskać do niego dostępu.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Resources.ResourceReader" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Wywołanie metody Dispose pozwala na przydzielenie zasobów <xref:System.Resources.ResourceReader> używanych przez program do innych celów. Aby uzyskać więcej informacji na temat usuwania, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).

## Examples  
Poniższy przykład kodu przechodzi przez zasoby pliku i drukuje wszystkie znalezione pary klucz/wartość. Następnie kod używa metody theIDisposable. Dispose, aby zamknąć <xref:System.Resources.ResourceReader> i zwolnić wszystkie używane przez niego zasoby.

```vb
Imports System
Imports System.Resources
Imports System.Collections

Public Class ReadResources

    Public Shared Sub Main(args() As String)
        ' Create a resource reader for items.resources 
        ' and get an enumerator to iterate through the file. 
        Dim reader As IResourceReader = New ResourceReader("items.resources")
        Dim en As IDictionaryEnumerator = reader.GetEnumerator()

        ' Iterate through the file, printing the key and value pairs. 
        While en.MoveNext()
            Console.WriteLine()
            Console.WriteLine("Name: {0}", en.Key)
            Console.WriteLine("Value: {0}", en.Value)
        End While 

        ' Clean up all resources associated with the reader. 
        ' Calling Dispose is equivalent to calling Close.
        reader.Dispose()
    End Sub 

End Class
```

```csharp
using System;
using System.Resources;
using System.Collections;

public class ReadResources 
{
    public static void Main(string[] args) 
    {
        // Create a resource reader for items.resources 
        // and get an enumerator to iterate through the file.
        IResourceReader reader = new ResourceReader("items.resources");
        IDictionaryEnumerator en = reader.GetEnumerator();

        // Iterate through the file, printing the key/value pairs. 
        while (en.MoveNext()) 
        {
            Console.WriteLine();
            Console.WriteLine("Name: {0}", en.Key);
            Console.WriteLine("Value: {0}", en.Value);
        }

        // Clean up all resources associated with the reader. 
        // Calling Dispose is equivalent to calling Close.
        reader.Dispose();
    }
}
```

```cpp
using namespace System;
using namespace System::Resources;
using namespace System::Collections;
int main()
{
   array<String^>^args = Environment::GetCommandLineArgs();

   // Create a resource reader for items.resources 
   // and get an enumerator to iterate through the file.
   IResourceReader^ reader = gcnew ResourceReader( "items.resources" );
   IDictionaryEnumerator^ en = reader->GetEnumerator();

   // Iterate through the file, printing the key/value pairs. 
   while ( en->MoveNext() )
   {
      Console::WriteLine();
      Console::WriteLine( "Name: {0}", en->Key );
      Console::WriteLine( "Value: {0}", en->Value );
   }

   // Clean up all resources associated with the reader. 
   // Calling the destructor is equivalent to calling Close.
   reader->~IResourceReader();
}
```

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

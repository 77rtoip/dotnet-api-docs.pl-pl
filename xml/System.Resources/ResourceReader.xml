<Type Name="ResourceReader" FullName="System.Resources.ResourceReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="682738b4136d074223cbe025a9380b3cca9bc1d0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30564613" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ResourceReader : System.Resources.IResourceReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ResourceReader extends System.Object implements class System.Collections.IEnumerable, class System.IDisposable, class System.Resources.IResourceReader" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ResourceReader&#xA;Implements IResourceReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceReader sealed : System::Resources::IResourceReader" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.Reader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Resources.IResourceReader</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wylicza zasobów w pliku zasobów binarnych (.resources), odczytując sekwencyjnych zasobów pary nazwa/wartość.  
  
 **Uwaga dotycząca zabezpieczeń**: wywołanie metody tej klasy z niezaufanych danych stanowi zagrożenie bezpieczeństwa. Wywołanie metody w klasie tylko z zaufanych danych. Aby uzyskać więcej informacji, zobacz [niezaufanych zagrożenia bezpieczeństwa danych](https://docs.com/rick-anderson-1/8710/untrusted-data-security-risks).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader> Klasa udostępnia standardowej implementacji <xref:System.Resources.IResourceReader> interfejsu. A <xref:System.Resources.ResourceReader> wystąpienie reprezentuje autonomiczny plik .resources lub plik .resources, który jest osadzony w zestawie. Służy do wyliczenia zasobów w pliku .resources i pobierania jej pary nazwa/wartość. Różni się od <xref:System.Resources.ResourceManager> klasy, która służy do pobierania zasobów o nazwie określonej w pliku .resources jest osadzony w zestawie. <xref:System.Resources.ResourceManager> Klasa jest używana do pobrania zasobów, których nazwy są znane z wyprzedzeniem, podczas gdy <xref:System.Resources.ResourceReader> klasy jest przydatne w przypadku pobieranie zasobów, których numer lub dokładne nazwy nie są znane w czasie kompilacji. Na przykład aplikacja może użyć pliku zasobów do przechowywania informacji o konfiguracji, który jest podzielone na sekcje i elementów w sekcji, gdzie numer sekcji lub elementów w sekcji nie jest znany wcześniej. Zasoby mogą następnie objęty nazwę (takich jak `Section1`, `Section1Item1`, `Section1Item2`i tak dalej) i odczytywane za pomocą <xref:System.Resources.ResourceReader> obiektu.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 Aby uzyskać więcej informacji o używaniu <xref:System.Resources.ResourceReader> klasy, zobacz następujące sekcje:  
  
-   [Utworzenie wystąpienia obiektu ResourceReader](#instantiate)  
  
-   [Wyliczanie obiektu ResourceReader zasobów](#enumerate)  
  
    -   [Pobieranie zasobów za pomocą właściwości w obiekcie IDictionaryEnumerator](#idictionaryenumerator)  
  
    -   [Pobieranie zasobów według nazw z GetResourceData](#getresourcedata)  
  
<a name="instantiate"></a>   
## <a name="instantiating-a-resourcereader-object"></a>Utworzenie wystąpienia obiektu ResourceReader  
 Plik .resources jest plikiem binarnym, który został skompilowany z pliku tekstowego lub pliku .resx XML przez [Resgen.exe (Generator pliku zasobów)](~/docs/framework/tools/resgen-exe-resource-file-generator.md). A <xref:System.Resources.ResourceReader> object może reprezentować autonomiczny plik .resources lub plik .resources, które zostały osadzone w zestawie.  
  
 Można utworzyć wystąpienia <xref:System.Resources.ResourceReader> obiektów, że odczyty autonomiczny plik .resources, użyj <xref:System.Resources.ResourceReader> konstruktora klasy strumień wejściowy lub ciąg, który zawiera nazwę pliku .resources. Poniższy przykład przedstawia obu podejść. Tworzy wystąpienie pierwszy <xref:System.Resources.ResourceReader> obiekt, który reprezentuje plik .resources o nazwie `Resources1.resources` przy użyciu jego nazwa pliku. Tworzy drugi <xref:System.Resources.ResourceReader> obiekt, który reprezentuje plik .resources o nazwie `Resources2.resources` za pomocą strumienia utworzone na podstawie pliku.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#2)]  
  
 Aby utworzyć <xref:System.Resources.ResourceReader> tworzenia wystąpienia obiektu, który reprezentuje plik .resources osadzonych <xref:System.Reflection.Assembly> obiekt z zestawu, w której jest osadzony plik .resources. Jego <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> metoda zwraca <xref:System.IO.Stream> obiektów, które mogą zostać przekazane do <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> konstruktora. Poniższy przykład tworzy <xref:System.Resources.ResourceReader> obiekt, który reprezentuje plik .resources osadzonych.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#3)]
 [!code-vb[System.Resources.ResourceReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#3)]  
  
<a name="enumerate"></a>   
## <a name="enumerating-a-resourcereader-objects-resources"></a>Wyliczanie zasobów obiektu ResourceReader  
 Aby wyliczyć zasobów w pliku .resources, należy wywołać <xref:System.Resources.ResourceReader.GetEnumerator%2A> metody, która zwraca <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> obiektu. Należy wywołać `IDictionaryEnumerator.MoveNext` metodę, aby przejść z jednego zasobu do drugiego. Metoda zwraca `false` po wszystkich zasobów w pliku .resources zostały wyliczone.  
  
> [!NOTE]
>  Mimo że <xref:System.Resources.ResourceReader> klasa implementuje <xref:System.Collections.IEnumerable> interfejsu i <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> metody <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> nie ma metody <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> implementacji. Zamiast tego <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> metoda zwraca <xref:System.Collections.IDictionaryEnumerator> obiektu interfejsu, który zapewnia dostęp do każdego zasobu pary nazwa/wartość.  
  
 Można pobrać pojedynczych zasobów w kolekcji na dwa sposoby:  
  
-   Można wykonać iterację każdy zasób w <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> zbierania i używania <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> właściwości, aby pobrać nazwę zasobu i wartość. Ta technika firma Microsoft zaleca, gdy wszystkie zasoby są tego samego typu lub znany typ danych każdego zasobu.  
  
-   Możesz pobrać nazwę każdego zasobu podczas możesz przejść <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> kolekcji i wywołanie <xref:System.Resources.ResourceReader.GetResourceData%2A> metody do pobierania danych zasobu. Firma Microsoft zaleca takie podejście, gdy nie jest znany typ danych, każdego zasobu lub jeśli poprzednie podejście zgłasza wyjątki.  
  
<a name="idictionaryenumerator"></a>   
### <a name="retrieving-resources-by-using-idictionaryenumerator-properties"></a>Pobieranie zasobów za pomocą właściwości IDictionaryEnumerator  
 Pierwszy metody wyliczania zasobów w pliku .resources polega na bezpośrednie pobieranie pary nazwa/wartość każdego zasobu. Po wywołaniu metody `IDictionaryEnumerator.MoveNext` nazwę metody, aby przejść do każdego zasobu w kolekcji, można pobrać zasobu z <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> właściwości i dane zasobów z <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> właściwości.  
  
 Poniższy przykład przedstawia sposób pobrać nazwę i wartość każdego z zasobów w pliku .resources za pomocą <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> i <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> właściwości. Aby uruchomić przykład, należy utworzyć poniższy plik tekstowy o nazwie ApplicationResources.txt do definiowania zasobów ciągu.  
  
```  
Title="Contact Information"  
Label1="First Name:"  
Label2="Middle Name:"  
Label3="Last Name:"  
Label4="SSN:"  
Label5="Street Address:"  
Label6="City:"  
Label7="State:"  
Label8="Zip Code:"  
Label9="Home Phone:"  
Label10="Business Phone:"  
Label11="Mobile Phone:"  
Label12="Other Phone:"  
Label13="Fax:"  
Label14="Email Address:"  
Label15="Alternate Email Address:"  
```  
  
 Można następnie wykonać konwersję pliku zasobów tekstu do pliku binarnego o nazwie ApplicationResources.resources przy użyciu następującego polecenia:  
  
 **ApplicationResources.txt ResGen**  
  
 W poniższym przykładzie następnie użyto <xref:System.Resources.ResourceReader> klasy wyliczyć każdego zasobu w pliku .resources binarne autonomicznych i wyświetlić jej nazwę klucza i odpowiadającej jej wartości.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/class1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/class1.vb#1)]  
  
 Próba pobrania danych zasobu ze <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> właściwości może zgłosić następujące wyjątki:  
  
-   A <xref:System.FormatException> Jeśli dane nie ma oczekiwanego formatu.  
  
-   A <xref:System.IO.FileNotFoundException> Jeśli nie można odnaleźć zestawu zawierającego typ, do którego należy dane.  
  
-   A <xref:System.TypeLoadException> Jeśli nie może być typem, do którego należy danych nie można odnaleźć.  
  
 Zazwyczaj te wyjątki zostaną zgłoszone, jeżeli plik .resources została zmodyfikowana ręcznie, jeśli zestawu, w którym jest zdefiniowany typ ma albo nie został dołączony do aplikacji lub został przypadkowo usunięty lub jeśli zestaw jest w starszej wersji, która poprzedza Typ. Jeśli generowany jest jeden z tych wyjątków, można pobrać zasobów wyliczania każdego zasobu i wywoływania <xref:System.Resources.ResourceReader.GetResourceData%2A> metody, jak przedstawiono na poniższej sekcji. Metoda ta umożliwia niektóre informacje o danych wpisania który <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> właściwości podjęła próbę zwrócenia.  
  
<a name="getresourcedata"></a>   
### <a name="retrieving-resources-by-name-with-getresourcedata"></a>Pobieranie zasobów według nazw z GetResourceData  
 Drugim sposobem wyliczania zasobów w pliku .resources obejmuje również w nawigowaniu zasobów w pliku przez wywołanie metody `IDictionaryEnumerator.MoveNext` metody. Dla każdego zasobu, można pobrać nazwy zasobu z <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> właściwości, które są następnie przekazywane do <xref:System.Resources.ResourceReader.GetResourceData%28System.String%2CSystem.String%40%2CSystem.Byte%5B%5D%40%29> metody do pobierania danych zasobu. Ten błąd jest zwracany jako tablicę bajtów w `resourceData` argumentu.  
  
 Takie podejście jest bardziej nieodpowiednich niż podczas pobierania nazwy zasobów i wartość z zakresu od <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> i <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> właściwości, ponieważ zwraca ono wartość rzeczywista liczba bajtów, które tworzą wartość zasobu. Jednakże, jeśli próba pobrania zasobu zgłasza wyjątek, <xref:System.Resources.ResourceReader.GetResourceData%2A> metody może ułatwić identyfikację źródło wyjątku, podając informacje o typie danych zasobu. Aby uzyskać więcej informacji na temat ciąg, który wskazuje typ danych zasobów, zobacz <xref:System.Resources.ResourceReader.GetResourceData%2A>.  
  
 Poniższy przykład przedstawia sposób użycia tej metody można pobrać zasobów i wszelkie wyjątki, które są zgłaszane. Programowo tworzy plik .resources binarny, który zawiera cztery parametry, Boolean co jeden argument, jeden mapy bitowej i jeden niestandardowy `DateTimeTZI` obiektu. Aby uruchomić przykład, wykonaj następujące czynności:  
  
1.  Utwórz zestaw o nazwie Library.dll, który zawiera `DateTimeTZI` struktury. Poniżej znajduje się kod źródłowy zestawu.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/library.cs#4)]
     [!code-vb[System.Resources.ResourceReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/library.vb#4)]  
  
     Kompilowanie kodu źródłowego w języku C# za pomocą następującego polecenia:  
  
    ```  
    csc /t:library library.cs  
    ```  
  
     Lub skompilować w języku Visual Basic za pomocą następującego polecenia:  
  
    ```  
    vbc library.vb /t:library  
    ```  
  
2.  Skompiluj i wykonaj następujący kod źródłowy, który tworzy plik .resources o nazwie ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/createresourceex1.cs#5)]
     [!code-vb[System.Resources.ResourceReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/createresourceex1.vb#5)]  
  
     CreateResources.cs nosi nazwę pliku kodu źródłowego. Można go skompilować w języku C# za pomocą następującego polecenia:  
  
    ```  
    csc CreateResources.cs /r:library.dll  
    ```  
  
     Lub skompilować w języku Visual Basic za pomocą następującego polecenia:  
  
    ```  
    vbc CreateResources.vb /r:library.dll  
    ```  
  
3.  Skompiluj i uruchom następujący kod do wyliczenia zasobów w pliku ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/readresourceex1.cs#6)]
     [!code-vb[System.Resources.ResourceReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/readresourceex1.vb#6)]  
  
     Po zmodyfikowaniu kodu źródłowego (np. przez zgłaszanie celowo <xref:System.FormatException> na końcu `try` blok) lub zmiana nazwy zestawu Library.dll, dzięki czemu jest niedostępne w czasie wykonywania, możesz uruchomić przykład, aby zobaczyć, jak wywołań <xref:System.Resources.ResourceReader.GetResourceData%2A> umożliwiają pobieranie lub Utwórz ponownie niektóre informacje o zasobie.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Resources.ResourceReader" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Za pomocą wystąpienia tego obiektu z niezaufanych danych stanowi zagrożenie bezpieczeństwa. Ten obiekt jest używany tylko z zaufanych danych. Aby uzyskać więcej informacji, zobacz [sprawdzanie poprawności danych](https://www.owasp.org/index.php/Data_Validation).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::IO::Stream ^ stream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień wejściowy dla odczytu zasobów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Resources.ResourceReader" /> klasy dla określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> Tworzy konstruktora <xref:System.Resources.ResourceReader> obiekt, który pobiera z pliku .resources autonomicznej lub .resources pliku zasoby osadzone w zestawie. Do odczytu z pliku .resources autonomicznej, należy utworzyć wystąpienia <xref:System.IO.Stream> obiektu i przekaż go do <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> konstruktora. Aby odczytać z pliku .resources osadzone, należy wywołać <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> metodę z uwzględnieniem wielkości liter nazwy plików .resources i przebiegu zwróconego <xref:System.IO.Stream> do obiektu <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> konstruktora.  
  
> [!IMPORTANT]
>  Za pomocą wystąpienia tego obiektu z niezaufanych danych stanowi zagrożenie bezpieczeństwa. Ten obiekt jest używany tylko z zaufanych danych. Aby uzyskać więcej informacji, zobacz [sprawdzanie poprawności danych](https://www.owasp.org/index.php/Data_Validation).  
  
   
  
## Examples  
 W przykładzie w tej sekcji użyto następującego pliku txt, o nazwie `PatientForm.txt` do definiowania zasoby używane przez aplikację.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Plik .txt można kompilować w pliku .resources, wydając polecenie:  
  
 **resgen PatientForm.txt**  
  
 W poniższym przykładzie założono, że plik zasobu jest osadzony w zestawie, który zawiera kod wykonywalny aplikacji. Pobiera on plik zasobów o nazwie `PatientForm.resources` z aktualnie wykonywane zestawów i wyświetla nazwę i wartość każdego z jego zasobów.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream1.vb#1)]  
  
 Jeśli nosi nazwę przykład C# `Example.cs`, można go skompilować przy użyciu następującego polecenia:  
  
 **CSC Example.cs /res:PatientForm.resources**  
  
 Jeśli nosi nazwę przykład Visual Basic `Example.vb`, można go skompilować przy użyciu następującego polecenia:  
  
 **vbc — Example.vb /res:PatientForm.resources**  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> Parametr nie jest do odczytu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas uzyskiwania dostępu do <paramref name="stream" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu świadczenia usług serializacji. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::String ^ fileName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Ścieżka i nazwa pliku zasobu do odczytu. <c>Nazwa pliku</c> nie jest rozróżniana wielkość liter.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Resources.ResourceReader" /> klasy dla określonego o nazwie pliku zasobów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.%23ctor%28System.String%29> Tworzy konstruktora <xref:System.Resources.ResourceReader> obiekt, który pobiera zasoby z autonomiczny plik .resources. Można pobrać zasobów z pliku .resources osadzone, użyj <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> konstruktora.  
  
> [!IMPORTANT]
>  Za pomocą wystąpienia tego obiektu z niezaufanych danych stanowi zagrożenie bezpieczeństwa. Ten obiekt jest używany tylko z zaufanych danych. Aby uzyskać więcej informacji, zobacz [sprawdzanie poprawności danych](https://www.owasp.org/index.php/Data_Validation).  
  
   
  
## Examples  
 W przykładzie w tej sekcji użyto następującego pliku txt, o nazwie `PatientForm.txt` do definiowania zasoby używane przez aplikację.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Ten plik .txt można kompilować w pliku .resources, wydając polecenie:  
  
 **resgen PatientForm.txt**  
  
 Poniższy przykład wylicza zasobów w `PatientForm.resources` i wyświetla nazwę i wartość każdego z nich.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileName" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.BadImageFormatException">Plik zasobów ma nieprawidłowy format. Na przykład długość pliku może wynosić zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby systemu operacyjnego skojarzonego z tym <see cref="T:System.Resources.ResourceReader" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.Close%2A> można bezpiecznie wywoływać wielokrotnie.  
  
   
  
## Examples  
 W poniższym przykładzie przechodzi przez plik zasobów i wyświetla wszystkie znalezione pary klucz wartość. Następnie używa kod <xref:System.Resources.ResourceReader.Close%2A> metodę, aby zamknąć <xref:System.Resources.ResourceReader> i zwalnia wszelkie zasoby używane przez nią.  
  
 [!code-cpp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CPP/getenumerator.cpp#1)]
 [!code-csharp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CS/getenumerator.cs#1)]
 [!code-vb[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Resources.ResourceReader" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu korzystania z tego wystąpienia <xref:System.Resources.ResourceReader>, wywołaj <xref:System.Resources.ResourceReader.Dispose%2A> zwolnić wszystkie zasoby używane przez to wystąpienie. Należy usunąć dalsze odwołania do tego <xref:System.Resources.ResourceReader> , aby moduł zbierający elementy bezużyteczne można odzyskać pamięci zamiast jego regularne aktywności dla finalizację wystąpienia.  
  
 <xref:System.Resources.ResourceReader.Dispose%2A> wywołuje metodę Dispose(Boolean) prywatnej, która zawiera kod, aby zwolnić zasoby zarządzane i niezarządzane. Aby uzyskać więcej informacji, zobacz [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający dla tego <see cref="T:System.Resources.ResourceReader" /> obiektu.</summary>
        <returns>Moduł wyliczający dla tego <see cref="T:System.Resources.ResourceReader" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj wyliczyć zasobów przez wywołanie metody <xref:System.Resources.ResourceReader.GetEnumerator%2A> — metoda i następnie wielokrotnie wywoływać metodę <xref:System.Collections.IEnumerator.MoveNext%2A> metody w zwróconym <xref:System.Collections.IDictionaryEnumerator> obiekt do momentu metoda zwraca `false`. Nazwa zasobu jest dostępna z <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> właściwości; jego wartość z <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> właściwości. Wyliczyć zasobów w ten sposób, jak pokazano w przykładzie.  
  
 Implementacja <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> właściwości przez <xref:System.Resources.ResourceReader> klasy może zgłosić następujące wyjątki:  
  
-   <xref:System.IO.FileNotFoundException>  
  
     Nie można odnaleźć zestawu zawierającego typ, do którego należy dane.  
  
-   <xref:System.FormatException>  
  
     Dane nie jest w oczekiwanym formacie.  
  
-   <xref:System.TypeLoadException>  
  
     Nie można odnaleźć typu, do którego należy dane.  
  
 Może obsłużyć wyjątek, wywołując <xref:System.Resources.ResourceReader.GetResourceData%2A> metody można pobrać informacji o typie danych i przypisane do zasobów o nazwie tablicy bajtów. Aby uzyskać więcej informacji, zobacz sekcję "Pobieranie zasobów przez nazwę z GetResourceData" w <xref:System.Resources.ResourceReader> klasy tematu.  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceReader> Klasa zawiera dwie metody, które zwracają wyliczenia. <xref:System.Resources.ResourceReader.GetEnumerator%2A> Metoda zwraca <xref:System.Collections.IDictionaryEnumerator> interfejsu obiektu i jest zalecana metoda do wywołania, gdy wyliczania zasobów.  
  
   
  
## Examples  
 W przykładzie w tej sekcji użyto następującego pliku txt, o nazwie `PatientForm.txt` do definiowania zasoby używane przez aplikację.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Plik .txt można kompilować w pliku .resources, wydając polecenie:  
  
 **resgen PatientForm.txt**  
  
 Poniższy przykład wylicza zasobów w `PatientForm.resources` i wyświetla nazwę i wartość każdego z nich.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Czytnik został zamknięty lub usunięty i jest niedostępny.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceData">
      <MemberSignature Language="C#" Value="public void GetResourceData (string resourceName, out string resourceType, out byte[] resourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetResourceData(string resourceName, [out] string&amp; resourceType, [out] unsigned int8[]&amp; resourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetResourceData(System.String,System.String@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetResourceData (resourceName As String, ByRef resourceType As String, ByRef resourceData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetResourceData(System::String ^ resourceName, [Runtime::InteropServices::Out] System::String ^ % resourceType, [Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % resourceData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
        <Parameter Name="resourceType" Type="System.String&amp;" RefType="out" />
        <Parameter Name="resourceData" Type="System.Byte[]&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resourceName">Nazwa zasobu.</param>
        <param name="resourceType">Po powrocie z tej metody zawiera ciąg reprezentujący nazwę typu zasobu pobrane. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="resourceData">Po powrocie z tej metody zawiera tablicę bajtów, który jest binarna reprezentacja typu pobrane. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Pobiera nazwę typu i dane zasobów o nazwie z zasobów Otwieranie pliku lub strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.GetResourceData%2A> Metoda pobiera wartość nazwanego zasobu w postaci tablicy bajtów. Zwykle jest używana, gdy <xref:System.Collections.IDictionaryEnumerator.Value%2A> właściwości zgłasza wyjątek podczas próby pobrania wartości zasobu.  
  
 `resourceType` jest ciągiem, który reprezentuje typ danych zasobu. Może być jedną z następujących wartości:  
  
-   Reprezentacja ciągu `ResourceTypeCode` element członkowski wyliczenia wskazująca typ danych zasobu. `ResourceTypeCode` to wyliczenie prywatne, który jest używany przez aby wskazać, że specjalne format binarny jest używany do przechowywania jedną 19 typowe typów danych. Obejmują one typy pierwotne danych .NET Framework (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.Single>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, <xref:System.UInt64>), a także <xref:System.String>, <xref:System.DateTime>, i <xref:System.TimeSpan>, ponadto `ResourceTypeCode` wyliczenie zawiera wartości podanych w poniższej tabeli.  
  
    |ResourceTypeCode value|Opis|  
    |----------------------------|-----------------|  
    |`ResourceTypeCode.ByteArray`|Dane są tablicy bajtów. Typ danych to powszechnie wyników z wywołania <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Byte%5B%5D%29?displayProperty=nameWithType> metody.|  
    |`ResourceTypeCode.Null`|Dane to odwołanie o wartości null. Typ danych to powszechnie wyników z wywołania <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Object%29?displayProperty=nameWithType> metody z obiektem, którego wartość jest `null`.|  
    |`ResourceTypeCode.Stream`|Dane są przechowywane w strumieniu. Typ danych to powszechnie wyników z wywołania <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%29?displayProperty=nameWithType> lub <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%2CSystem.Boolean%29?displayProperty=nameWithType> metody.|  
  
     Przy założeniu, że `resourceData` nie został uszkodzony, jego zwykle można przekonwertować z tablicy bajtów do oryginalnej wartości przez wywołanie metody <xref:System.BitConverter> lub <xref:System.IO.BinaryReader> metody.  
  
-   Ciąg, który zawiera w pełni kwalifikowaną nazwę typu, których dane serializowane jest przypisany do `resourceData` argumentu (na przykład `System.String`). Ponadto dla typów, które nie są częścią bibliotece klas programu .NET Framework, ciąg zawiera nazwę, wersję, kulturę i klucz publiczny zestawu zawierającego typ. Na przykład następujący ciąg znaków oznacza, że dane serializowane reprezentuje wystąpienie `Person` wpisz `Extensions` przestrzeni nazw, w wersji 1.0 zestawu o nazwie narzędzie, które ma żadnego klucza publicznego i nie wyznaczonego kultury.  
  
     `Extensions.Person, Utility, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`  
  
     Przy założeniu, że `resourceData` nie został uszkodzony i że typ źródłowy jest dostępny, `resourceData` można przekonwertować z tablicy bajtów do oryginalnej wartości konwertując tablica bajtów do <xref:System.IO.Stream> obiekt i przekazywania strumienia do <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>metody.  
  
-   Ciąg używany do opisu typu danych w <xref:System.Resources.ResourceWriter.AddResourceData%2A?displayProperty=nameWithType> wywołania metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> nie istnieje.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="resourceName" /> Typ jest nieprawidłowy.</exception>
        <exception cref="T:System.FormatException">Dane pobrane zasobów jest uszkodzony.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Resources.ResourceReader" /> obiekt nie został zainicjowany, prawdopodobnie ponieważ jest ono zamknięte.</exception>
        <altmember cref="M:System.Resources.ResourceWriter.AddResourceData(System.String,System.String,System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający dla tego <see cref="T:System.Resources.ResourceReader" /> obiektu.</summary>
        <returns>Moduł wyliczający dla tego <see cref="T:System.Resources.ResourceReader" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.System%23Collections%23IEnumerable%23GetEnumerator%2A?displayProperty=nameWithType> jest jawnej implementacji interfejsu. Można go używać tylko wtedy, gdy <xref:System.Resources.ResourceReader> wystąpienia jest rzutowane na <xref:System.Collections.IEnumerable> interfejsu. Zalecane podejście do wyliczania zasobów w pliku .resources jest wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> metody <xref:System.Collections.IDictionaryEnumerator> obiektu zwróconego przez <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Czytnik został już zamknięty i nie są dostępne.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
  </Members>
</Type>
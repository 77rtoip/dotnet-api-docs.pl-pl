<Type Name="ResourceManager" FullName="System.Resources.ResourceManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a0604beca350dee3c9ad9f1eb2d9f351e0be0b67" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51907600" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ResourceManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ResourceManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceManager" />
  <TypeSignature Language="F#" Value="type ResourceManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje Menedżera zasobów, która zapewnia wygodny dostęp do zasobów dla kultury w czasie wykonywania.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 <xref:System.Resources.ResourceManager> Klasy pobiera zasoby z binarnego pliku Resources osadzonego w zestawie lub autonomiczny plik .resources. Jeśli aplikacja został zlokalizowany i zlokalizowane zasoby zostały wdrożone w [zestawy satelickie](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md), wyszukuje zasoby specyficzne dla kultury, zawiera zasób rezerwowy zlokalizowany zasób nie istnieje, gdy obsługuje zasobu serializacji.  
  
 Aby uzyskać więcej informacji na temat tworzenia i zarządzania zasobami w aplikacjach klasycznych i [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji, zobacz następujące sekcje:  
  
-   [Aplikacje klasyczne](#desktop)  
  
    -   [Tworzenie zasobów](#creating_resources)  
  
    -   [Utworzenie wystąpienia obiektu ResourceManager](#instantiating)  
  
    -   [ResourceManager i zasoby specyficzne dla kultury](#CultureSpecific)  
  
    -   [Pobieranie zasobów](#retrieving)  
  
    -   [Obsługa wyjątków MissingManifestResourceException i Missingsatelliteassemblyexception](#exception)  
  
    -   [Przechowywanie wersji zasobu](#versioning)  
  
    -   [\<satelliteassemblies > węzeł pliku konfiguracji](#config)  
  
-   [Aplikacje Windows Store](#ws)  
  
<a name="desktop"></a>   
## <a name="desktop-apps"></a>Aplikacje pulpitu  
 Dla aplikacji klasycznych <xref:System.Resources.ResourceManager> klasy pobiera zasoby z plików zasobów binarnych (.resources). Zazwyczaj kompilator języka lub [Assembly Linker (AL.exe)](~/docs/framework/tools/al-exe-assembly-linker.md) te pliki zasobów są osadzone w zestawie. Można również użyć <xref:System.Resources.ResourceManager> obiektu do pobrania zasobów bezpośrednio z pliku Resources, który nie jest zagnieżdżony w zestawie, wywołując <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> metody.  
  
> [!CAUTION]
>  Korzystanie z autonomicznego plików Resources w aplikacji platformy ASP.NET spowoduje przerwanie wdrażania XCOPY, ponieważ zasoby pozostać zablokowany, dopóki nie zostaną one jawnie wydane przez <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> metody. Jeśli chcesz wdrażać zasoby za pomocą programu ASP.NET, należy skompilować plików Resources do zestawów satelickich.  
  
 W zależności od zasobów aplikacji jeden plik Resources zawiera zasoby kultury domyślnej, którego zasoby są używane, jeśli można znaleźć żadnych zasobów dla kultury. Na przykład jeśli aplikacja domyślna kultura angielski (en), zasoby języka angielskiego są używane w każdym przypadku, gdy nie można znaleźć zlokalizowane zasoby dla określonej kultury, takich jak angielski (Stany Zjednoczone) (en US) lub francuski (Francja) (fr-FR). Zazwyczaj zasobów dla kultury domyślnej są osadzone w zestawie aplikacji głównej, a zasoby dla innych kultur zlokalizowane są osadzone w zestawach satelickich. Zestawy satelickie zawierają tylko zasoby. Mają one taką samą nazwę pliku głównego, jak zestawu głównego i rozszerzenie. resources.dll. W przypadku aplikacji, w których zestawy nie są zarejestrowane w globalnej pamięci podręcznej zestawy satelickie są przechowywane w podkatalogu aplikacji, którego nazwa odpowiada kultury zestawu.  
  
<a name="creating_resources"></a>   
### <a name="creating-resources"></a>Tworzenie zasobów  
 Podczas tworzenia aplikacji w języku zasobu są przechowywane informacje o zasobach w pliki tekstowe (pliki z rozszerzeniem txt lub restext) lub pliki XML (pliki z rozszerzeniem resx). Następnie skompilować tekst lub plikami XML zawierającymi [Resource File Generator (Resgen.exe)](~/docs/framework/tools/resgen-exe-resource-file-generator.md) można utworzyć pliku binarnego Resources. Następnie można osadzać wynikowy plik .resources w plik wykonywalny lub biblioteka przy użyciu opcji kompilatora, takich jak `/resources` dla Kompilatory języka C# i Visual Basic lub możesz osadzić go w zestawie satelickim przy użyciu. Jeśli dodasz plik resx w projekcie programu Visual Studio, Visual Studio obsługuje kompilacji i osadzanie domyślnego i zlokalizowane zasoby automatycznie jako część procesu kompilacji.  
  
 W idealnym przypadku należy utworzyć zasoby dla każdego języka aplikacji obsługuje, lub co najmniej o istotnych podzestawu każdego języka. Nazwy plików binarnych Resources przestrzegać konwencji nazewnictwa *basename*. *cultureName*Resources, gdzie *basename* to nazwa aplikacji lub nazwę klasy, w zależności od poziomu szczegółowości. <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType> Właściwość jest używana do określenia *cultureName*. Powinien zostać nazwany zasób dla kultury domyślnej aplikacji *basename*Resources.  
  
 Na przykład załóżmy, że zestaw zawiera kilka zasobów, w pliku zasobów o nazwie podstawowej MyResources. Te pliki zasobów powinny mieć nazwy kultury Japonia (japoński), MyResources.de.resources niemieckiego kultury MyResources.zh-CHS.resources dla uproszczonego kultury Chińskiej, takich jak MyResources.ja JP.resources i MyResources.fr-BE.resources dla kultury francuski (Belgia). Domyślny plik zasobów powinien zostać nazwany MyResources.resources. Pliki zasobów dla kultury często są spakowane w zestawach satelickich dla każdej kultury. Domyślny plik zasobów powinien być osadzony w głównym zestawie aplikacji.  
  
 Należy pamiętać, że umożliwiająca zasoby był oznaczony jako prywatny, ale należy zawsze oznaczyć je jako publiczne, dzięki czemu są one dostępne przez inne zestawy. (Ponieważ zestawu satelickiego nie zawiera kodu, zasoby, które są oznaczone jako prywatne są niedostępne dla aplikacji za pomocą dowolnego mechanizmu).  
  
 Aby uzyskać więcej informacji na temat tworzenia, pakowania i wdrażania zasobów, zobacz artykuły [Creating Resource Files](~/docs/framework/resources/creating-resource-files-for-desktop-apps.md), [tworzenie zestawów satelickich](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md), i [pakowanie i wdrażanie Zasoby](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
<a name="instantiating"></a>   
### <a name="instantiating-a-resourcemanager-object"></a>Utworzenie wystąpienia obiektu ResourceManager  
 Można utworzyć wystąpienia <xref:System.Resources.ResourceManager> obiekt, który pobiera zasoby z pliku Resources osadzonego przez wywołującego jeden z jej przeciążeń konstruktora klasy. To ściśle pozamałżeńskie <xref:System.Resources.ResourceManager> obiektu z pliku .resources określonej i wszelkie powiązane zlokalizowanych plików Resources w zestawach satelickich.  
  
 Dwa najczęściej wywoływane konstruktory są następujące:  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> odwołuje się do zasobów opartych na dwie części użytkownik poda informacje o: Nazwa podstawowa pliku Resources i zestawu, w której znajduje się domyślny plik .resources. Nazwa podstawowa zawiera nazwę przestrzeni nazw i głównego pliku Resources, bez jego kultury lub rozszerzenia. Należy pamiętać, że plików Resources, które są kompilowane z wiersza polecenia, zazwyczaj nie zawierają nazwę przestrzeni nazw, należy wykonać plików Resources, które są tworzone w środowisku Visual Studio. Na przykład, jeśli plik zasobów nosi nazwę MyCompany.StringResources.resources i <xref:System.Resources.ResourceManager> Konstruktor jest wywoływana z statyczną metodę o nazwie `Example.Main`, poniższy kod tworzy <xref:System.Resources.ResourceManager> obiekt, który można pobrać zasobów. Plik zasobów:  
  
     [!code-csharp[Conceptual.Resources.Retrieving#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#1)]
     [!code-vb[Conceptual.Resources.Retrieving#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#1)]  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> Wyszukuje zasobów w zestawach satelickich na podstawie informacji z typu obiektu. W pełni kwalifikowana nazwa typu odpowiada podstawowej nazwy pliku Resources, bez rozszerzenie nazwy pliku. W aplikacjach klasycznych, które są tworzone za pomocą projektanta zasobów usługi Visual Studio Visual Studio tworzy klasę otoki, w których w pełni kwalifikowana nazwa jest taka sama jak nazwa głównego pliku Resources. Na przykład, jeśli plik zasobów ma nazwę MyCompany.StringResources.resources i jest klasą otoki, o nazwie `MyCompany.StringResources`, poniższy kod tworzy <xref:System.Resources.ResourceManager> obiekt, który można pobrać zasoby z pliku .resources:  
  
     [!code-csharp[Conceptual.Resources.Retrieving#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#2)]
     [!code-vb[Conceptual.Resources.Retrieving#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#2)]  
  
 Jeśli nie można znaleźć odpowiednie zasoby, wywołanie konstruktora tworzy prawidłowy <xref:System.Resources.ResourceManager> obiektu. Jednak próba pobrania zasobu zgłasza <xref:System.Resources.MissingManifestResourceException> wyjątku. Aby uzyskać informacji o obsłudze wyjątków, zobacz [Obsługa wyjątków MissingManifestResourceException i wyjątki MissingSatelliteAssembly](#exception) sekcję w dalszej części tego artykułu.  
  
 Poniższy przykład pokazuje, jak utworzyć wystąpienie <xref:System.Resources.ResourceManager> obiektu. Zawiera kod źródłowy dla pliku wykonywalnego o nazwie ShowTime.exe. Obejmuje również Poniższy plik tekstowy o nazwie Strings.txt zawierający pojedynczy ciąg zasobu, `TimeHeader`:  
  
```  
TimeHeader=The current time is  
```  
  
 Plik wsadowy umożliwia generowanie pliku zasobów i osadzenie go do pliku wykonywalnego. Poniżej przedstawiono plik wsadowy, aby wygenerować plik wykonywalny, za pomocą kompilatora C#:  
  
```  
  
resgen strings.txt  
csc ShowTime.cs /resource:strings.resources  
  
```  
  
 Dla kompilatora języka Visual Basic można użyć następującego pliku wsadowym:  
  
```  
  
resgen strings.txt  
vbc ShowTime.vb /resource:strings.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showtime.cs#1)]
 [!code-vb[System.Resources.ResourceManager.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showtime.vb#1)]  
  
<a name="CultureSpecific"></a>   
### <a name="resourcemanager-and-culture-specific-resources"></a>ResourceManager i zasoby specyficzne dla kultury  
 Zlokalizowanych aplikacji wymaga zasobów, które mają być wdrożone, zgodnie z opisem w artykule [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md). Jeśli zestawy są prawidłowo skonfigurowane, usługi resource manager Określa, które zasoby do pobrania na podstawie dla bieżącego wątku <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> właściwości. (Ta właściwość zwraca również wartość Bieżący wątek kultury interfejsu użytkownika.) Na przykład, jeśli aplikacja została skompilowana z domyślnie zasoby języka angielskiego w głównym zestawie i za pomocą zasobów językowych francuska i Rosyjska w dwóch zestawach satelickich i <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> właściwość jest ustawiona na fr-FR, usługa resource manager pobiera francuskiej zasoby.  
  
 Możesz ustawić <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> właściwość jawnie lub niejawnie. Określa sposób, jest on ustawiany jak <xref:System.Resources.ResourceManager> obiektu pobiera zasoby, w oparciu o kulturę:  
  
-   Jeśli jawnie ustawić <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> właściwość do określonej kultury, zawsze usługi resource manager pobiera zasoby dla tej kultury, niezależnie od języka systemu operacyjnego lub przeglądarki przez użytkownika. Należy wziąć pod uwagę aplikację, która została skompilowana z zasoby domyślnego języka angielskiego i trzy zestawy satelickie, które zawierają zasoby dla języka angielskiego (Stany Zjednoczone), francuski (Francja) i rosyjski (Rosja). Jeśli <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> właściwość jest ustawiona na fr-FR, <xref:System.Resources.ResourceManager> obiekt zawsze pobiera zasoby francuski (Francja), nawet wtedy, gdy użytkownik obsługi języka systemu nie jest francuski. Upewnij się, że to żądane zachowanie przed jawnie ustawić właściwość.  
  
     W aplikacjach ASP.NET, należy ustawić <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> właściwość jawnie, ponieważ jest mało prawdopodobne, że ustawienia na serwerze będą zgodne przychodzące żądania klientów. Aplikacja platformy ASP.NET można ustawić <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> język, jaki akceptuje właściwość jawnie do przeglądarki użytkownika.  
  
     Jawne ustawianie <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> właściwość definiuje bieżącej kultury interfejsu użytkownika dla tego wątku. Nie ma wpływu na bieżącej kultury interfejsu użytkownika w dowolnych innych wątków w aplikacji.  
  
-   Kultura interfejsu użytkownika wszystkich wątków można ustawić w domenie aplikacji, przypisując <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje tę kulturę statycznej <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> właściwości.  
  
-   Jeśli nie zostanie jawnie ustawiona bieżącej kultury interfejsu użytkownika i domyślną kulturę używaną do bieżącej domeny aplikacji, nie zostaną zdefiniowane <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> zostaje ustalona niejawnie przez Windows `GetUserDefaultUILanguage` funkcji. Funkcja ta zapewnia przez wielojęzycznego interfejsu użytkownika (MUI), która pozwala użytkownikowi na ustawianie domyślnego języka. Jeśli język interfejsu użytkownika nie jest ustawiony przez użytkownika, domyślnie język zainstalowany system, który jest językiem zasobów systemu operacyjnego.  
  
 W poniższym przykładzie prostego "Hello world", które jawnie ustawia bieżącej kultury interfejsu użytkownika. Zawiera ona zasoby dla trzech kultur: angielski (Stany Zjednoczone) lub en US, francuski (Francja) lub fr-FR i rosyjski (Rosja) lub ru-RU. Zasoby en US znajdują się w pliku tekstowym o nazwie Greetings.txt:  
  
```  
HelloString=Hello world!  
```  
  
 Zasoby fr-FR znajdują się w pliku tekstowym o nazwie Greetings.fr-FR.txt:  
  
```  
HelloString=Salut tout le monde!  
```  
  
 Zasoby ru-RU, znajdują się w pliku tekstowym o nazwie Greetings.ru-RU.txt:  
  
```  
HelloString=Всем привет!  
```  
  
 Poniżej przedstawiono kod źródłowy, na przykład (Example.vb dla używanej wersji programu Visual Basic) lub Example.cs wersji języka C#:  
  
 [!code-csharp[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.currentculture/cs/example.cs#1)]
 [!code-vb[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.currentculture/vb/example.vb#1)]  
  
 Aby skompilować ten przykład, Utwórz plik wsadowy (.bat), który zawiera następujące polecenia i uruchom go w wierszu polecenia. Jeśli używasz języka C#, należy określić `csc` zamiast `vbc` i `Example.cs` zamiast `Example.vb`.  
  
```  
resgen Greetings.txt   
vbc Example.vb /resource:Greetings.resources  
  
resgen Greetings.fr-FR.txt  
Md fr-FR  
al /embed:Greetings.fr-FR.resources /culture:fr-FR /out:fr-FR\Example.resources.dll  
  
resgen Greetings.ru-RU.txt  
Md ru-RU  
al /embed:Greetings.ru-RU.resources /culture:ru-RU /out:ru-RU\Example.resources.dll  
```  
  
<a name="retrieving"></a>   
### <a name="retrieving-resources"></a>Pobieranie zasobów  
 Należy wywołać <xref:System.Resources.ResourceManager.GetObject%28System.String%29> i <xref:System.Resources.ResourceManager.GetString%28System.String%29> metody w celu uzyskania dostępu do określonego zasobu. Można również wywołać <xref:System.Resources.ResourceManager.GetStream%28System.String%29> metody do pobierania zasobów innych niż ciąg w postaci tablicy bajtów. Domyślnie w aplikacji, która zawiera zlokalizowane zasoby, te metody zwracają zasobów dla kultury ustalany na podstawie bieżącej kultury interfejsu użytkownika w wątku, który zgłosił wywołania. Zobacz poprzednią sekcję [ResourceManager i zasoby specyficzne dla kultury](#CultureSpecific), aby uzyskać więcej informacji na temat sposobu zdefiniowania bieżącej kultury interfejsu użytkownika w wątku. Jeśli Menedżera zasobów nie można odnaleźć zasobu dla bieżącego wątku interfejsu użytkownika kultury, używa procesu bazowego można pobrać określonego zasobu. Jeśli Menedżera zasobów nie może odnaleźć żadnych zlokalizowane zasoby, używa zasobów kultury domyślnej. Aby uzyskać więcej informacji na temat rezerwowego reguł zasobów, zobacz sekcję "Proces bazowy zasobu" w artykule [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  Jeśli określony plik .resources w <xref:System.Resources.ResourceManager> konstruktora klasy nie można odnaleźć, próba pobrania zasobu wyrzuca <xref:System.Resources.MissingManifestResourceException> lub <xref:System.Resources.MissingSatelliteAssemblyException> wyjątku. Aby uzyskać informacji o obsłudze wyjątków, zobacz [Obsługa wyjątków MissingManifestResourceException i Missingsatelliteassemblyexception](#exception) w dalszej części tego tematu.  
  
 W poniższym przykładzie użyto <xref:System.Resources.ResourceManager.GetString%2A> metodę, aby pobrać zasoby specyficzne dla kultury. Składa się z zasobami skompilowane z plików txt angielski (en), francuski (Francja) (fr-FR) i rosyjski (Rosja) (ru-RU) kultur. W przykładzie zmieniono bieżącą kulturę i bieżącej kultury interfejsu użytkownika języka angielskiego (Stany Zjednoczone), francuski (Francja), rosyjski (Rosja) i szwedzki (Szwecja). Następnie wywołuje <xref:System.Resources.ResourceManager.GetString%2A> metodę, która pobierze zlokalizowany ciąg, który wyświetla wraz z bieżącego dnia i miesiąca. Należy zauważyć, że dane wyjściowe wyświetla odpowiedni zlokalizowany ciąg z wyjątkiem sytuacji, gdy bieżąca kultura interfejsu użytkownika jest szwedzki (Szwecja). Ponieważ zasoby języka szwedzkiego są niedostępne, aplikacja zamiast tego używa zasobów domyślnej kultury, czyli w języku angielskim.  
  
 Przykład wymaga plików zasobów w formacie tekstowym, wymienione w poniższej tabeli. Każda z nich zawiera zasób w postaci pojedynczego ciągu o nazwie `DateStart`.  
  
|Kultury|Nazwa pliku|Nazwa zasobu|Wartość zasobu|  
|-------------|---------------|-------------------|--------------------|  
|pl pl|DateStrings.txt|`DateStart`|Dzisiaj jest|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|СЕГОДНЯ|  
  
 Poniżej przedstawiono kod źródłowy, na przykład (ShowDate.vb dla używanej wersji programu Visual Basic) lub ShowDate.cs dla wersji języka C# kodu.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 Aby skompilować ten przykład, Utwórz plik wsadowy, który zawiera następujące polecenia i uruchom go z poziomu wiersza polecenia. Jeśli używasz języka C#, należy określić `csc` zamiast `vbc` i `showdate.cs` zamiast `showdate.vb`.  
  
```  
  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
  
```  
  
 Istnieją dwa sposoby pobrania zasobów określonej kultury innej niż bieżąca kultura interfejsu użytkownika:  
  
-   Możesz wywołać <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>, <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>, lub <xref:System.Resources.ResourceManager.GetStream%28System.String%2CSystem.Globalization.CultureInfo%29> metody do pobierania zasobów dla określonej kultury. Jeśli nie można odnaleźć zlokalizowanych zasobów, Menedżer zasobów używa procesu bazowego zasobu zlokalizować odpowiedni zasób.  
  
-   Możesz wywołać <xref:System.Resources.ResourceManager.GetResourceSet%2A> metodę, aby uzyskać <xref:System.Resources.ResourceSet> obiekt, który reprezentuje zasoby dla określonej kultury. W wywołaniu metody należy określić, czy Menedżera zasobów sondy dla kultur nadrzędnego przypadku nie można znaleźć zlokalizowane zasoby lub tego, czy po prostu nastąpi powrót do zasobów kultury domyślnej. Następnie można użyć <xref:System.Resources.ResourceSet> metod dostępu do zasobów (zlokalizowany dla tej kultury) według nazwy lub można wyliczyć zasobów w zestawie.  
  
<a name="exception"></a>   
### <a name="handling-missingmanifestresourceexception-and-missingsatelliteassemblyexception-exceptions"></a>Obsługa wyjątków MissingManifestResourceException i MissingSatelliteAssemblyException  
 Jeśli spróbujesz pobrać określonego zasobu, ale Menedżera zasobów nie można odnaleźć, że został zdefiniowany zasób i nie kultury domyślnej lub zasobów kultury domyślnej nie można odnaleźć, zgłasza usługi resource manager <xref:System.Resources.MissingManifestResourceException> wyjątek Jeśli go spodziewa się znaleźć zasoby w głównym zestawie lub <xref:System.Resources.MissingSatelliteAssemblyException> Jeśli oczekuje znaleźć zasoby w zestawie satelickim. Należy pamiętać, że wyjątek jest zgłaszany po wywołaniu metody pobierania zasobów takich jak <xref:System.Resources.ResourceManager.GetString%2A> lub <xref:System.Resources.ResourceManager.GetObject%2A>, a nie podczas tworzenia wystąpienia <xref:System.Resources.ResourceManager> obiektu.  
  
 Wyjątek jest zazwyczaj zgłaszany w następujących warunkach:  
  
-   Zestaw plików lub satelitarnej odpowiedni zasób nie istnieje. Jeśli usługi resource manager oczekuje aplikacji domyślnych zasobów do osadzenia w zestawie aplikacji głównej, są nieobecne. Jeśli <xref:System.Resources.NeutralResourcesLanguageAttribute> atrybut wskazuje, że zasoby domyślne aplikacji znajdują się w zestawie satelickim, że nie można odnaleźć zestawu. Podczas kompilowania aplikacji, upewnij się, że zasoby są osadzone w głównym zestawie lub że zestawu satelickiego niezbędne jest generowany i nosi nazwę odpowiednio. Jego nazwa powinna mieć postać *appName*. resources.dll, a powinien znajdować się w katalogu o nazwie po kulturę, której zawarte w niej zasoby.  
  
-   Aplikacja nie ma domyślnego lub kultury neutralnej zdefiniowane. Dodaj <xref:System.Resources.NeutralResourcesLanguageAttribute> atrybutu do pliku kodu źródłowego lub plik projektu informacje o pliku (AssemblyInfo.vb dla aplikacji w języku Visual Basic) lub AssemblyInfo.cs dla aplikacji C#.  
  
-   `baseName` Parametru w <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> Konstruktor Określa nazwę pliku Resources. Nazwa powinna zawierać plik zasobów w pełni kwalifikowanych przestrzeni nazw, ale nie jego rozszerzenie nazwy pliku. Zazwyczaj pliki zasobów, które są tworzone w programie Visual Studio obejmują nazwy przestrzeni nazw, ale nie pliki zasobów, które są tworzone i kompilowane w wierszu polecenia. Można określić nazwy plików Resources osadzonego, kompilując i uruchamiając narzędzie następujące. Jest to aplikacja konsoli, który przyjmuje nazwę w głównym zestawie lub zestawu satelickiego jako parametr wiersza polecenia. Wyświetla ciągi, które należy podać jako `baseName` parametru, aby usługi resource manager może poprawnie zidentyfikować zasobu.  
  
     [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
     [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 Jawnie w przypadku zmiany bieżącej kultury aplikacji, należy również pamiętać, że usługa resource manager pobiera zestaw zasobów, w oparciu o wartość <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> właściwości, a nie <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> właściwości. Zwykle Jeśli zmienisz jedną wartość, należy również zmienić innych.  
  
<a name="versioning"></a>   
### <a name="resource-versioning"></a>Przechowywanie wersji zasobu  
 Ponieważ głównego zestawu, który zawiera zasoby domyślnego aplikacji jest oddzielony od zestawy satelickie aplikacji, możesz wydasz nową wersję zestawu głównego bez konieczności ponownego wdrażania zestawów satelickich. Możesz użyć <xref:System.Resources.SatelliteContractVersionAttribute> atrybutu, aby używać istniejących zestawów satelickich i poinstruowanie Menedżera zasobów nie można ponownie wdrożyć je do nowej wersji zestawu głównego,  
  
 Aby uzyskać więcej informacji na temat obsługi wersji zestawów satelickich, zobacz artykuł [podczas pobierania zasobów](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md).  
  
<a name="config"></a>   
### <a name="satelliteassemblies-configuration-file-node"></a>\<satelliteassemblies > węzeł pliku konfiguracji  
 Dla plików wykonywalnych, które są wdrażane i uruchamiane z witryny sieci Web (pliki .exe HREF) <xref:System.Resources.ResourceManager> obiektu mogą sondować zestawów satelickich w sieci web, która może obniżyć wydajność aplikacji. Aby wyeliminować problem z wydajnością, można ograniczyć, to sondowanie zestawów satelickich, wdrożone razem z aplikacją. Aby to zrobić, należy utworzyć `<satelliteassemblies>` węzła w pliku konfiguracyjnym aplikacji, aby określić, że został wdrożony określonych kultur dla aplikacji, które <xref:System.Resources.ResourceManager> obiekt nie należy próbować sondować żadnej kultury, który nie znajduje się w tym węźle.  
  
> [!NOTE]
>  Preferowana alternatywa dla tworzenia `<satelliteassemblies>` węzła jest użycie [Manifest wdrażania ClickOnce](https://msdn.microsoft.com/library/8457e615-e3b6-4990-8dcf-11bc590e4e9b) funkcji.  
  
 W pliku konfiguracji aplikacji należy utworzyć podobne do następujących sekcji:  
  
```  
<?xml version ="1.0"?>  
<configuration>  
    <satelliteassemblies>  
        <assembly name="MainAssemblyName, Version=versionNumber, Culture=neutral, PublicKeyToken=null|yourPublicKeyToken">  
            <culture>cultureName1</culture>  
            <culture>cultureName2</culture>  
            <culture>cultureName3</culture>  
        </assembly>  
    </satelliteassemblies>  
</configuration>  
```  
  
 Edytuj informacje o konfiguracji w następujący sposób:  
  
-   Określ co najmniej jedno `<assembly>` węzłów dla każdego zestawu głównego, który zostanie wdrożony, gdzie każdy węzeł określa w pełni kwalifikowanej nazwy zestawu. Określ nazwę swojego głównego zestawu, zamiast *MainAssemblyName*, a następnie określ `Version`, `PublicKeyToken`, i `Culture` atrybutu wartości, które odnoszą się do swojego zestawu głównego.  
  
     Aby uzyskać `Version` atrybutu, określ numer wersji zestawu. Na przykład pierwsza wersja zestawu może być numer wersji 1.0.0.0.  
  
     Aby uzyskać `PublicKeyToken` atrybucie należy określić słowo kluczowe `null` nie zarejestrował się zestaw silną nazwą, czy określić żeton klucza, jeśli zarejestrowano zestaw.  
  
     Dla `Culture` atrybucie należy określić słowo kluczowe `neutral` aby wyznaczyć głównego zestawu i spowodować <xref:System.Resources.ResourceManager> klasy sondowania tylko w przypadku kultur, na liście `<culture>` węzłów.  
  
     Aby uzyskać więcej informacji o w pełni kwalifikowane nazwy zestawów, zobacz artykuł [nazw zestawów](~/docs/framework/app-domains/assembly-names.md). Aby uzyskać więcej informacji na temat zestawów o silnych nazwach, zobacz artykuł [tworzenie i zestawy Using Strong-Named](~/docs/framework/app-domains/create-and-use-strong-named-assemblies.md).  
  
-   Określ co najmniej jedno `<culture>` węzłów przy użyciu nazwy określonej kultury, na przykład "fr-FR", lub nazwę kultury neutralnej, na przykład "fr".  
  
 Jeśli zasoby są potrzebne do dowolnego złożenia, które nie są wyświetlane w obszarze `<satelliteassemblies>` węzła <xref:System.Resources.ResourceManager> klasy sondy przy użyciu standardowych zasad sondowania wyjaśnionych kultur.  
  
<a name="ws"></a>   
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] Aplikacje  
  
> [!IMPORTANT]
>  Mimo że <xref:System.Resources.ResourceManager> klasy jest obsługiwana w [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji, nie zaleca się jej użycie. Klasa jest używana tylko wtedy, gdy tworzysz [!INCLUDE[net_portable](~/includes/net-portable-md.md)] projektów, które mogą być używane z [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji. Aby pobrać zasoby z [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] użyj [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) klasy zamiast tego.  
  
 Aby uzyskać [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji, <xref:System.Resources.ResourceManager> klasy pobiera zasoby z plików indeksu (PRI) zasobu pakietu. Jednego pliku PRI (plik PRI pakietu aplikacji) zawiera zasoby, które zarówno domyślnej kultury i zlokalizowane kultur. Narzędzie MakePRI do utworzenia pliku PRI z plików zasobów, które są w formacie XML, zasobów (.resw). Dla zasobów, które są zawarte w projekcie programu Visual Studio Visual Studio obsługuje proces tworzenia i automatycznie pakowanie pliku PRI. Następnie można użyć programu .NET Framework <xref:System.Resources.ResourceManager> klasy, aby uzyskać dostęp do zasobów aplikacji lub biblioteki.  
  
 Można utworzyć wystąpienie <xref:System.Resources.ResourceManager> dla obiektu [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji w taki sam sposób jak w przypadku aplikacji klasycznej.  
  
 Mogą uzyskiwać dostęp do zasobów dla danej kultury, przekazując nazwę zasobu, które mają zostać pobrane do <xref:System.Resources.ResourceManager.GetString%28System.String%29> metody. Domyślnie ta metoda zwraca zasobów dla kultury ustalany na podstawie bieżącej kultury interfejsu użytkownika w wątku, który zgłosił wywołania. Możesz również pobrać zasoby dla określonej kultury, przekazując nazwę zasobu i <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kulturę, w której zasób jest mają zostać pobrane do <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> metody. Jeśli nie można odnaleźć zasobu dla bieżącej kultury interfejsu użytkownika lub określonej kultury, usługi resource manager używa listy rezerwową język interfejsu użytkownika, aby zlokalizować odpowiedni zasób.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak użyć kultury jawne i niejawne bieżącej kultury interfejsu użytkownika w celu uzyskania zasoby w postaci ciągów w głównym zestawie i zestawem satelickim. Aby uzyskać więcej informacji, zobacz sekcję "Katalogu lokalizacji dla satelickich zestawów nie zainstalowane w globalnej pamięci podręcznej zestawów" [tworzenie zestawów satelickich](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) tematu.  
  
 Aby uruchomić ten przykład:  
  
1.  W katalogu aplikacji Utwórz plik o nazwie rmc.txt, który zawiera następujące ciągi zasobów:  
  
    ```  
  
    day=Friday  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
2.  Użyj [Resource File Generator](~/docs/framework/tools/resgen-exe-resource-file-generator.md) do generowania pliku zasobów rmc.resources z pliku wejściowego rmc.txt w następujący sposób:  
  
    ```  
    resgen rmc.txt  
    ```  
  
3.  Tworzenie podkatalogu katalogu aplikacji i nadaj mu "es-" MX". To jest nazwa kultury zestawu satelickiego, która zostanie utworzona w trzech kolejnych krokach.  
  
4.  Utwórz plik o nazwie rmc.es-MX.txt w katalogu es MX, który zawiera następujące ciągi zasobów:  
  
    ```  
  
    day=Viernes  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
5.  Użyj [Resource File Generator](~/docs/framework/tools/resgen-exe-resource-file-generator.md) do generowania pliku zasobów rmc.es MX.resources z pliku wejściowego rmc.es MX.txt w następujący sposób:  
  
    ```  
    resgen rmc.es-MX.txt  
    ```  
  
6.  Załóżmy, że nazwa pliku, w tym przykładzie jest rmc.vb lub rmc.cs. Skopiuj następujący kod źródłowy do pliku. Następnie skompilować go i osadzone zestawu głównego pliku zasobów, rmc.resources, zestawu pliku wykonywalnego. Jeśli używasz kompilator Visual Basic, składnia jest następująca:  
  
    ```  
    vbc rmc.vb /resource:rmc.resources  
    ```  
  
     Składnia odpowiednie dla kompilatora C# jest następująca:  
  
    ```  
    csc /resource:rmc.resources rmc.cs  
    ```  
  
7.  Użyj [Assembly Linker](~/docs/framework/tools/al-exe-assembly-linker.md) można utworzyć zestawu satelickiego. Jeśli podstawowa nazwa aplikacji jest rmc, nazwę zestawu satelickiego musi być rmc.resources.dll. Zestawu satelickiego powinny zostać utworzone w katalogu es MX. Jeśli es MX jest bieżący katalog, użyj tego polecenia:  
  
    ```  
    al /embed:rmc.es-MX.resources /c:es-MX /out:rmc.resources.dll   
    ```  
  
8.  Uruchom rmc.exe do wyświetlania ciągi zasobu osadzonego.  
  
 [!code-csharp[ResourceManager_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ResourceManager_Class/cs/rmc.cs#1)]
 [!code-vb[ResourceManager_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ResourceManager_Class/vb/rmc.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <altmember cref="T:System.Globalization.CultureInfo" />
    <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
    <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
    <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Zasoby w aplikacjach</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Resources.ResourceManager" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ResourceManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ResourceManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Resources.ResourceManager" /> klasy przy użyciu wartości domyślnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest przydatny tylko wtedy, gdy napisać własne klasy, która pochodzi od klasy <xref:System.Resources.ResourceManager> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (Type resourceSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type resourceSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resourceSource As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(Type ^ resourceSource);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager resourceSource" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="resourceSource" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="resourceSource">Typ, z której wywodzi się wszystkie informacje dotyczące znajdowania plików Resources usługi resource manager.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Resources.ResourceManager" /> klasę, która odwołuje się do zasobów w zestawach satelickich na podstawie informacji z obiektu określonego typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Aplikacje pulpitu  
 W aplikacjach klasycznych korzysta z usługi resource manager `resourceSource` parametru, aby załadować plik zasobów określonej w następujący sposób:  
  
-   Jeśli <xref:System.Resources.NeutralResourcesLanguageAttribute> atrybut nie jest używany do wskazania, że zasoby domyślną kulturę używaną znajdują się w zestawie satelickim, Menedżer zasobów przyjęto założenie, że pliku zasobów dla kultury domyślnej znajduje się w tym samym zestawie jako typu określonego przez `resourceSource` parametru.  
  
-   Menedżer zasobów przyjęto założenie, że domyślnego pliku zasobów ma taką samą nazwę jak typ określony przez `resourceSource` parametru.  
  
-   Menedżer zasobów używa domyślnego <xref:System.Resources.ResourceSet> klasy do manipulowania pliku zasobów.  
  
 Na przykład biorąc pod uwagę typ o nazwie MyCompany.MyProduct.MyType, Menedżer zasobów wyszukuje plik Resources o nazwie MyCompany.MyProduct.MyType.resources w zestawie, który definiuje MyType.  
  
 W programie Visual Studio, projektancie zasobów automatycznie generuje kod, który definiuje `internal` (w języku C#) lub `Friend` (w języku Visual Basic), klasy, których nazwa jest taka sama jak podstawowa nazwa pliku Resources dla kultury domyślnej. Dzięki temu można utworzyć wystąpienia <xref:System.Resources.ResourceManager> obiektu i ją połączyć z określonego zestawu zasobów, uzyskując obiekt tekstowy, którego nazwa odpowiada nazwa zasobu, ponieważ tak długo, jak klasa jest widoczna w kompilatorze, zasoby muszą znajdować się jako dobrze. Na przykład, jeśli plik .resources nosi nazwę zasób1, następująca instrukcja tworzy <xref:System.Resources.ResourceManager> obiektów do zarządzania pliku Resources o nazwie zasób1:  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/ctor1.cs#2)]  
  
 Jeśli nie używasz programu Visual Studio, należy utworzyć klasę, bez członków, w których przestrzeń nazw i nazwę są takie same jak w przypadku domyślnego pliku Resources. Przykład stanowi ilustrację.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] Aplikacje  
  
> [!IMPORTANT]
>  Mimo że <xref:System.Resources.ResourceManager> klasy jest obsługiwana w [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji, nie zaleca się jej użycie. Klasa jest używana tylko wtedy, gdy tworzysz [!INCLUDE[net_portable](~/includes/net-portable-md.md)] projektów, które mogą być używane z [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji. Aby pobrać zasoby z [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] użyj [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) klasy zamiast tego.  
  
 W [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji <xref:System.Resources.ResourceManager> używa `resourceSource` parametru, aby rozpoznać zestawu, nazwie podstawowej i przestrzeni nazw, gdzie elementy zasobu może znajdować się w pliku indeksu (PRI) zasobów pakietu aplikacji. Na przykład, biorąc pod uwagę typ o nazwie MyCompany.MyProduct.MyType, która jest zdefiniowana w `MyAssembly`, Menedżer zasobów wyszukuje zasób Ustaw identyfikator o nazwie MyAssembly i wyszukuje zakres MyCompany.MyProduct.MyType w tym zestaw zasobów. Menedżer zasobów wyszukuje elementy zasobu w kontekście domyślnej (bieżącej kultury, bieżące ustawienie wysokiego kontrastu itd.) w ramach tego zakresu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> Konstruktor do tworzenia wystąpienia <xref:System.Resources.ResourceManager> obiektu. Składa się z zasobami skompilowane z plików txt angielski (en), francuski (Francja) (fr-FR) i rosyjski (Rosja) (ru-RU) kultur. W przykładzie zmieniono bieżącą kulturę i bieżącej kultury interfejsu użytkownika języka angielskiego (Stany Zjednoczone), francuski (Francja), rosyjski (Rosja) i szwedzki (Szwecja). Następnie wywołuje <xref:System.Resources.ResourceManager.GetString%28System.String%29> metodę, która pobierze zlokalizowany ciąg, który wyświetla powitanie, które jest zależne od pory Dania z.  
  
 Przykład wymaga trzy pliki zasobów w formacie tekstowym, zgodnie z opisem w poniższej tabeli. Każdy plik zawiera zasoby w postaci ciągów o nazwie `Morning`, `Afternoon`, i `Evening`.  
  
|Kultury|Nazwa pliku|Nazwa zasobu|Wartość zasobu|  
|-------------|---------------|-------------------|--------------------|  
|pl pl|GreetingResources.txt|`Morning`|Dzień dobry|  
|pl pl|GreetingResources.txt|`Afternoon`|Dzień dobry|  
|pl pl|GreetingResources.txt|`Evening`|Dobry wieczór|  
|fr-FR|GreetingResources.fr-FR.txt|`Morning`|Bonjour|  
|fr-FR|GreetingResources.fr-FR.txt|`Afternoon`|Bonjour|  
|fr-FR|GreetingResources.fr-FR.txt|`Evening`|Bonsoir|  
|ru-RU|GreetingResources.ru-RU.txt|`Morning`|Доброе утро|  
|ru-RU|GreetingResources.ru-RU.txt|`Afternoon`|ДОБРЫЙ ДЕНЬ|  
|ru-RU|GreetingResources.ru-RU.txt|`Evening`|ДОБРЫЙ ВЕЧЕР|  
  
 Aby skompilować przykład Visual Basic i utworzyć plik wykonywalny o nazwie Greet.exe, można użyć następującego pliku wsadowego. Aby skompilować przy użyciu języka C#, należy zmienić nazwę kompilatora z `vbc` do `csc` i rozszerzenie pliku z `.vb` do `.cs`.  
  
```  
  
resgen GreetingResources.txt  
vbc Greet.vb /resource: GreetingResources.resources  
  
md fr-FR  
resgen GreetingResources.fr-FR.txt  
al /out:fr-FR\Greet.resources.dll /culture:fr-FR /embed: GreetingResources.fr-FR.resources   
  
md ru-RU  
resgen GreetingResources.ru-RU.txt  
al /out:ru-RU\Greet.resources.dll /culture:ru-RU /embed: GreetingResources.ru-RU.resources  
  
```  
  
 Poniżej przedstawiono kod źródłowy, na przykład (ShowDate.vb dla używanej wersji programu Visual Basic) lub ShowDate.cs dla wersji języka C# kodu.  
  
 [!code-csharp[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/greet.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/greet.vb#3)]  
  
 Oprócz definiowania aplikacji klasy o nazwie `Example`, kod źródłowy definiuje klasą wewnętrzną, którego nazwa `GreetingResources`, jest taka sama jak nazwa podstawowa plików zasobów. Dzięki temu można utworzyć wystąpienia pomyślnie <xref:System.Resources.ResourceManager> obiektu przez wywołanie metody <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> konstruktora.  
  
 Zwróć uwagę, że wyświetla dane wyjściowe, które odpowiedni zlokalizowany ciąg z wyjątkiem sytuacji, gdy bieżąca kultura interfejsu użytkownika jest szwedzki (Szwecja), w którym to przypadku go używa zasobów w języku angielskim. Ponieważ zasoby języka szwedzkiego są niedostępne, aplikacja używa zasobów kultury domyślnej, zgodnie z definicją <xref:System.Resources.NeutralResourcesLanguageAttribute> zamiast tego atrybutu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceSource" /> Parametr <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="baseName">Nazwa głównego pliku zasobów bez jego rozszerzenie, ale w tym wszelkie w pełni kwalifikowanej nazwy obszaru nazw. Na przykład nazwa głównego pliku zasobów o nazwie US.resources MyApplication.MyResource.en jest MyApplication.MyResource.</param>
        <param name="assembly">Główny zestaw zasobów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Resources.ResourceManager" /> klasę, która odwołuje się do zasobów znajdujących się w plikach o nazwie określonym katalogu głównym w danym zestawie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Aplikacje pulpitu  
 W aplikacjach klasycznych plików poszczególnych zasobów dla kultury powinny być zawarte w zestawy satelickie i plik zasobów kultury domyślnej powinny być zawarte w głównym zestawie. Zestawu satelickiego założono, że zawierają zasoby dla pojedynczej kultury określonej w manifeście tego zestawu, a także jest ładowany w razie potrzeby.  
  
> [!NOTE]
>  Aby pobrać zasoby z plików Resources bezpośrednio, zamiast pobierania ich z zestawów, należy wywołać <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> metody zamiast tego do utworzenia wystąpienia <xref:System.Resources.ResourceManager> obiektu.  
  
 Jeśli plik zasobów identyfikowane przez `baseName` nie można znaleźć w `assembly`, metoda tworzy wystąpienie <xref:System.Resources.ResourceManager> obiekt, ale próba pobrania określonego zasobu zgłasza wyjątek, zwykle <xref:System.Resources.MissingManifestResourceException>. Aby dowiedzieć się, jak zdiagnozowaniu przyczyny wyjątek, zobacz sekcję "Obsługa wyjątków missingmanifestresourceexception —" <xref:System.Resources.ResourceManager> temat poświęcony klasie.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] Aplikacje  
  
> [!IMPORTANT]
>  Mimo że <xref:System.Resources.ResourceManager> klasy jest obsługiwana w [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji, nie zaleca się jej użycie. Klasa jest używana tylko wtedy, gdy tworzysz [!INCLUDE[net_portable](~/includes/net-portable-md.md)] projektów, które mogą być używane z [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji. Aby pobrać zasoby z [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] użyj [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) klasy zamiast tego.  
  
 W [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] usługi resource manager korzysta z aplikacji, prostą nazwę `assembly` zestaw parametrów, aby wyszukać pasującego zasobu w pliku (PRI) indeksu zasobów pakietu aplikacji. `baseName` Parametr jest używany do wyszukiwania elementu zasobów w ramach zestawu zasobów. Na przykład nazwę główną dla PortableLibrary1.Resource1.de-DE.resources jest PortableLibrary1.Resource1.  
  
   
  
## Examples  
 W poniższym przykładzie użyto prostą aplikację "Hello World" niezlokalizowana, aby zilustrować <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> konstruktora. Poniżej przedstawiono zawartość pliku tekstowego o nazwie ExampleResources.txt. Po skompilowaniu aplikacji zasobu jest osadzony w zestawie głównej aplikacji.  
  
```  
Greeting=Hello  
```  
  
 Plik tekstowy, można przekonwertować na plik binarny zasobów za pomocą w wierszu polecenia monit w następujący sposób:  
  
```  
resgen ExampleResources.txt  
```  
  
 W poniższym przykładzie przedstawiono kod wykonywalny, który tworzy <xref:System.Resources.ResourceManager> obiektu monituje użytkownika o wprowadzenie nazwy i wyświetla pozdrowienia.  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/example.cs#1)]
 [!code-vb[System.Resources.ResourceManager.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/example.vb#1)]  
  
 Może być kompilowane przy użyciu następującego polecenia w języku Visual Basic:  
  
```  
vbc Example.vb /resource:ExampleResources.resources  
```  
  
 lub za pomocą następujących poleceń w języku C#:  
  
```  
csc Example.cs /resource:ExampleResources.resources  
```  
  
 Należy zauważyć, że przykład pobiera odwołanie do zestawu, który zawiera plik zasobów, przekazując typ zdefiniowany w tym zestawie, do `typeof` — funkcja (w języku C#) lub `GetType` funkcji (w języku Visual Basic) i pobieranie wartości jego <xref:System.Type.Assembly%2A?displayProperty=nameWithType>właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseName" /> Lub <paramref name="assembly" /> parametr <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Ten konstruktor korzysta z dostarczanych przez system <see cref="T:System.Resources.ResourceSet" /> implementacji. Aby użyć formatu pliku niestandardowego zasobu, powinien pochodzić od <see cref="T:System.Resources.ResourceSet" /> klasy, Zastąp <see cref="M:System.Resources.ResourceSet.GetDefaultReader" /> i <see cref="M:System.Resources.ResourceSet.GetDefaultWriter" /> metody i — dostęp próbny, że typ ma <see cref="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" /> konstruktora. Za pomocą niestandardowego <see cref="T:System.Resources.ResourceSet" /> może być przydatne do kontrolowania zasobów zasady buforowania i obsługi własnych format plików zasobów, ale zwykle nie jest konieczne.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly * Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly, usingResourceSet)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">Nazwa głównego pliku zasobów bez jego rozszerzenie, ale w tym wszelkie w pełni kwalifikowanej nazwy obszaru nazw. Na przykład nazwa głównego pliku zasobów o nazwie US.resources MyApplication.MyResource.en jest MyApplication.MyResource.</param>
        <param name="assembly">Główny zestaw zasobów.</param>
        <param name="usingResourceSet">Typ niestandardowy <see cref="T:System.Resources.ResourceSet" /> do użycia. Jeśli <see langword="null" />, domyślne środowisko uruchomieniowe <see cref="T:System.Resources.ResourceSet" /> obiekt jest używany.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Resources.ResourceManager" /> klasę, która korzysta z określonego <see cref="T:System.Resources.ResourceSet" /> klasy, aby wyszukać zasoby zawarte w plikach o nazwie określonym katalogu głównym w danym zestawie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pliki poszczególnych zasobów dla kultury powinny być zawarte w zestawy satelickie i plik zasobów kultury domyślnej powinny być zawarte w głównym zestawie. Zestawu satelickiego założono, że zawierają zasoby dla pojedynczej kultury określonej w manifeście tego zestawu, a także jest ładowany w razie potrzeby.  
  
> [!NOTE]
>  Aby pobrać zasoby z plików Resources bezpośrednio, zamiast pobierania ich z zestawów, należy wywołać <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> metody zamiast tego do utworzenia wystąpienia <xref:System.Resources.ResourceManager> obiektu.  
  
 Jeśli plik zasobów identyfikowane przez `baseName` nie można znaleźć w `assembly`, metoda tworzy wystąpienie <xref:System.Resources.ResourceManager> obiekt, ale próba pobrania określonego zasobu zgłasza wyjątek, zwykle <xref:System.Resources.MissingManifestResourceException>. Aby dowiedzieć się, jak zdiagnozowaniu przyczyny wyjątek, zobacz sekcję "Obsługa wyjątków missingmanifestresourceexception —" <xref:System.Resources.ResourceManager> temat poświęcony klasie.  
  
> [!NOTE]
>  `usingResourceSet` Parametr jest używany do obsługi formatu zasobów i będzie najczęściej `null`. To różni się od konstruktora, który przyjmuje <xref:System.Type> tylko.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="usingResourceset" /> Brak klasy pochodnej z <see cref="T:System.Resources.ResourceSet" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseName" /> Lub <paramref name="assembly" /> parametr <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Ten konstruktor pozwala na określenie <see cref="T:System.Resources.ResourceSet" /> implementacji. Jeśli nie ma określonego <see cref="T:System.Resources.ResourceSet" /> implementacji ale czy np. Aby użyć formatu pliku zasobów niestandardowych, powinien pochodzić od <see cref="T:System.Resources.ResourceSet" /> klasy, Zastąp <see cref="M:System.Resources.ResourceSet.GetDefaultReader" /> i <see cref="M:System.Resources.ResourceSet.GetDefaultWriter" /> metody i przekazać typ do tego konstruktora.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BaseName">
      <MemberSignature Language="C#" Value="public virtual string BaseName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseName" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.BaseName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseName : string" Usage="System.Resources.ResourceManager.BaseName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę katalogu głównego plików zasobów, które <see cref="T:System.Resources.ResourceManager" /> wyszukiwania dla zasobów.</summary>
        <value>Nazwa głównego zasobu pliki <see cref="T:System.Resources.ResourceManager" /> wyszukiwania dla zasobów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.BaseName%2A> Właściwość odzwierciedla w pełni kwalifikowanej nazwy obszaru nazw i nazwy zasobu głównego pliku zasobów, bez jego rozszerzenia nazwy pliku lub kultury. Na przykład, jeśli aplikacja domyślnego pliku zasobów ma nazwę `SampleApps.StringResources.resources`, wartość <xref:System.Resources.ResourceManager.BaseName%2A> właściwość jest "SampleApps.StringResources". Jeśli aplikacja domyślnego pliku zasobów ma nazwę `SampleApps.StringResources.en-US.resources` i jest osadzony w zestawie satelickim wartość <xref:System.Resources.ResourceManager.BaseName%2A> właściwość nadal jest "SampleApps.StringResources".  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager.BaseName%2A> Wartość właściwości pliku zasobów, które są kompilowane i osadzone w wierszu polecenia nie zawiera nazwy przestrzeni nazw, chyba że jawnie wstawieniu podczas kompilowania pliku. Z drugiej strony <xref:System.Resources.ResourceManager.BaseName%2A> wartość właściwości pliku zasobów, które są kompilowane i osadzone w środowisku Visual Studio zazwyczaj obejmują domyślną nazwę przestrzeni nazw.  
  
 <xref:System.Resources.ResourceManager.BaseName%2A> Wartość właściwości jest taka sama, jak ciąg przekazany do <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> lub <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29> Konstruktor podczas tworzenia wystąpienia <xref:System.Resources.ResourceManager> wystąpienia.  
  
   
  
## Examples  
 Można określić nazwy plików Resources osadzonego, kompilując i uruchamiając narzędzie następujące. Jest to aplikacja konsoli, który przyjmuje nazwę w głównym zestawie lub zestawu satelickiego jako parametr wiersza polecenia. Wyświetla ciągi, które należy podać jako `baseName` parametru <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> lub <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29> konstruktora, aby usługi resource manager może poprawnie zidentyfikować zasobu.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
 [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseNameField">
      <MemberSignature Language="C#" Value="protected string BaseNameField;" />
      <MemberSignature Language="ILAsm" Value=".field family string BaseNameField" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.BaseNameField" />
      <MemberSignature Language="VB.NET" Value="Protected BaseNameField As String " />
      <MemberSignature Language="C++ CLI" Value="protected: System::String ^ BaseNameField;" />
      <MemberSignature Language="F#" Value="val mutable BaseNameField : string" Usage="System.Resources.ResourceManager.BaseNameField" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa nazwę katalogu głównego zasobu pliki <see cref="T:System.Resources.ResourceManager" /> wyszukiwania dla zasobów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.BaseNameField> Pola przydaje się tylko wtedy, gdy napisać własne klasy, która pochodzi od klasy <xref:System.Resources.ResourceManager> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFileBasedResourceManager">
      <MemberSignature Language="C#" Value="public static System.Resources.ResourceManager CreateFileBasedResourceManager (string baseName, string resourceDir, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.CreateFileBasedResourceManager(System.String,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFileBasedResourceManager (baseName As String, resourceDir As String, usingResourceSet As Type) As ResourceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Resources::ResourceManager ^ CreateFileBasedResourceManager(System::String ^ baseName, System::String ^ resourceDir, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="static member CreateFileBasedResourceManager : string * string * Type -&gt; System.Resources.ResourceManager" Usage="System.Resources.ResourceManager.CreateFileBasedResourceManager (baseName, resourceDir, usingResourceSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="resourceDir" Type="System.String" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">Nazwa głównego zasobów. Na przykład nazwa głównego pliku zasobów o nazwie "US.resources MyResource.en" to "MyResource".</param>
        <param name="resourceDir">Nazwa katalogu, aby wyszukać zasoby. <c>resourceDir</c> może być ścieżką bezwzględną lub ścieżką względną z katalogu aplikacji.</param>
        <param name="usingResourceSet">Typ niestandardowy <see cref="T:System.Resources.ResourceSet" /> do użycia. Jeśli <see langword="null" />, domyślne środowisko uruchomieniowe <see cref="T:System.Resources.ResourceSet" /> obiekt jest używany.</param>
        <summary>Zwraca <see cref="T:System.Resources.ResourceManager" /> obiekt, który wyszukuje określonego katalogu, a nie dla zasobów w manifeście zestawu.</summary>
        <returns>Nowe wystąpienie usługi resource manager, wyszukująca określonego katalogu, a nie dla zasobów w manifeście zestawu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca Menedżera zasobów, które pobiera zasoby z pliku Resources, który nie jest zagnieżdżony w zestawie. Możesz użyć tej funkcji <xref:System.Resources.ResourceManager> obiektu można załadować zasobów dla strony ASP.NET i do testowania <xref:System.Resources.ResourceSet> implementacji.  Na przykład, która pobiera zasoby z autonomicznego pliku Resources, zobacz [podczas pobierania zasobów](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md) artykułu.  
  
 Ta metoda umożliwia określenie <xref:System.Resources.ResourceSet> implementacji. Jeśli nie ma określonego <xref:System.Resources.ResourceSet> implementacji, ale chcesz stosować format pliku zasobów niestandardowych, powinien pochodzić od <xref:System.Resources.ResourceSet> klasy, Zastąp <xref:System.Resources.ResourceSet.GetDefaultReader%2A> i <xref:System.Resources.ResourceSet.GetDefaultWriter%2A> metody i przekazać typ do tego konstruktora.  
  
> [!CAUTION]
>  Korzystanie z autonomicznego plików Resources w aplikacji platformy ASP.NET spowoduje przerwanie wdrażania XCOPY, ponieważ zasoby pozostać zablokowany, dopóki nie zostaną one jawnie wydane przez <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> metody. Jeśli chcesz wdrażać zasoby z aplikacjami ASP.NET kompilacji plików Resources do zestawów satelickich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseName" /> Lub <paramref name="resourceDir" /> parametr <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FallbackLocation">
      <MemberSignature Language="C#" Value="protected System.Resources.UltimateResourceFallbackLocation FallbackLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Resources.UltimateResourceFallbackLocation FallbackLocation" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.FallbackLocation" />
      <MemberSignature Language="VB.NET" Value="Protected Property FallbackLocation As UltimateResourceFallbackLocation" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Resources::UltimateResourceFallbackLocation FallbackLocation { System::Resources::UltimateResourceFallbackLocation get(); void set(System::Resources::UltimateResourceFallbackLocation value); };" />
      <MemberSignature Language="F#" Value="member this.FallbackLocation : System.Resources.UltimateResourceFallbackLocation with get, set" Usage="System.Resources.ResourceManager.FallbackLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.UltimateResourceFallbackLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia lokalizację, z której można pobrać zasoby rezerwowe domyślne.</summary>
        <value>Jedna z wartości wyliczenia, które określa, gdzie Menedżera zasobów można wyszukać zasoby rezerwowe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.FallbackLocation%2A> Właściwość jest przydatna tylko wtedy, gdy napisać własne klasy, która pochodzi od klasy <xref:System.Resources.ResourceManager> klasy.  
  
 Możesz użyć <xref:System.Resources.NeutralResourcesLanguageAttribute> atrybutu informują Menedżera zasobów, gdzie można znaleźć domyślnej kultury dla aplikacji: w głównym zestawie (ustawienie domyślne) lub w zestawie satelickim.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Resources.UltimateResourceFallbackLocation" />
        <altmember cref="T:System.Resources.NeutralResourcesLanguageAttribute" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Opakowanie i wdrażanie zasobów</related>
      </Docs>
    </Member>
    <Member MemberName="GetNeutralResourcesLanguage">
      <MemberSignature Language="C#" Value="protected static System.Globalization.CultureInfo GetNeutralResourcesLanguage (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Globalization.CultureInfo GetNeutralResourcesLanguage(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetNeutralResourcesLanguage(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetNeutralResourcesLanguage (a As Assembly) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Globalization::CultureInfo ^ GetNeutralResourcesLanguage(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetNeutralResourcesLanguage : System.Reflection.Assembly -&gt; System.Globalization.CultureInfo" Usage="System.Resources.ResourceManager.GetNeutralResourcesLanguage a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">Zestaw, dla którego ma zostać zwrócone informacje specyficzne dla kultury.</param>
        <summary>Zwraca informacje specyficzne dla kultury dla zestawu głównego domyślnych zasobów poprzez pobranie wartości <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> atrybutu w określonym zestawie.</summary>
        <returns>Kultura z <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> atrybut, jeśli je znaleziono; w przeciwnym razie, niezmienna kultura.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość określonego zasobu niebędących ciągami dla bieżącej kultury.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string -&gt; obj&#xA;override this.GetObject : string -&gt; obj" Usage="resourceManager.GetObject name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zasobu, który można pobrać.</param>
        <summary>Zwraca wartość określonego zasobu innych niż ciąg.</summary>
        <returns>Wartość zasobu zlokalizowane dla bieżących ustawień kultura obiektu wywołującego. Jeśli istnieje zestaw odpowiednich zasobów, ale <paramref name="name" /> nie zostanie znaleziony, metoda zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetObject%2A> Metoda służy do pobierania zasobów niebędących ciągami. Należą do nich wartości, które należą do pierwotne typy danych, takich jak <xref:System.Int32> lub <xref:System.Double>, mapy bitowe (takie jak <xref:System.Drawing.Bitmap?displayProperty=nameWithType> obiektu), lub niestandardowe serializacji obiektów. Zwykle zwracany obiekt musi rzutowania (w języku C#) lub przekonwertować (w języku Visual Basic) do obiektu odpowiedniego typu.  
  
 Zwrócone zasobów jest zlokalizowana dla kultury interfejsu użytkownika bieżącego wątku, która jest zdefiniowana przez <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> właściwości. Jeśli zasób nie jest zlokalizowana dla tej kultury, Menedżer zasobów używa reguł rezerwowego załadować odpowiedni zasób. Jeśli nie można używać zestawu zlokalizowanych zasobów zostanie znaleziony, <xref:System.Resources.ResourceManager> powraca zasobów kultury domyślnej. Jeśli nie można odnaleźć zasobu dla domyślnej kultury, metoda zgłasza <xref:System.Resources.MissingManifestResourceException> wyjątek lub, jeśli zestaw zasobów powinien znajdować się w zestawie satelickim <xref:System.Resources.MissingSatelliteAssemblyException> wyjątku. Jeśli Menedżera zasobów można załadować odpowiedni zasób zestawu, ale nie można odnaleźć zasób o nazwie `name`, metoda zwraca `null`.  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A> Właściwość określa, czy porównanie `name` za pomocą nazw zasobów jest rozróżniana wielkość liter (ustawienie domyślne) lub jest rozróżniana wielkość liter.  
  
> [!CAUTION]
>  Ta metoda może zgłaszać wyjątki więcej niż podano. Jednym z powodów taka sytuacja może wystąpić jest zgłasza wyjątek, jeśli metoda, która wywołuje tę metodę.  Na przykład <xref:System.IO.FileLoadException> może zostać wygenerowany wyjątek, jeśli błąd został utworzony, wdrażanie lub Instalowanie zestawu satelickiego, lub <xref:System.Runtime.Serialization.SerializationException> może być zgłaszany wyjątek, jeśli typ zdefiniowany przez użytkownika zgłasza wyjątek zdefiniowanych przez użytkownika, gdy typ jest przeprowadzona.  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Jeśli wywołasz <xref:System.Resources.ResourceManager.GetObject%2A> metoda wiele razy z takimi samymi `name` parametru nie są zależne od metoda zwraca odwołanie do tego samego obiektu za pomocą każdego wywołania. Jest to spowodowane <xref:System.Resources.ResourceManager.GetObject%2A> metoda może zwrócić odwołanie do istniejącego obiektu zasobu w pamięci podręcznej, lub można ponownie załadować zasobu i zwraca odwołanie do nowego obiektu zasobów.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Resources.ResourceManager.GetObject%28System.String%29> metodę deserializacji niestandardowych obiektów. Przykład zawiera plik kodu źródłowego o nazwie UIElements.cs (UIElements.vb, jeśli używasz języka Visual Basic) definiujący następującą strukturę o nazwie `PersonTable`. Ta struktura jest przeznaczona do użycia przez procedurę wyświetlana tabela ogólna, która wyświetla zlokalizowanych nazw kolumn tabeli. Należy pamiętać, że `PersonTable` struktury jest oznaczona za pomocą <xref:System.SerializableAttribute> atrybutu.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example.cs#6)]
 [!code-vb[Conceptual.Resources.Retrieving#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#6)]  
  
 Poniższy kod w pliku o nazwie CreateResources.cs (CreateResources.vb dla języka Visual Basic) tworzy XML pliku zasobu o nazwie UIResources.resx, która przechowuje tytuł tabeli i `PersonTable` obiekt, który zawiera informacje dotyczące aplikacji, który jest zlokalizowany na Język angielski.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example1.cs#7)]
 [!code-vb[Conceptual.Resources.Retrieving#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#7)]  
  
 Następujący kod w pliku kodu źródłowego o nazwie GetObject.cs (GetObject.vb), a następnie pobiera zasoby i wyświetla je w konsoli.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example2.cs#8)]
 [!code-vb[Conceptual.Resources.Retrieving#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example2.vb#8)]  
  
 Można tworzenie zasobów niezbędnych plików i zestawów i uruchomić aplikację, wykonując następujący plik wsadowy. Należy użyć `/r` opcję, aby podać Resgen.exe z odwołaniem do UIElements.dll, aby go mogą uzyskiwać dostęp do informacji o `PersonTable` struktury. Jeśli używasz języka C#, należy zastąpić `vbc` kompilatora nazwą `csc`i Zastąp `.vb` rozszerzenie `.cs`.  
  
```  
  
vbc /t:library UIElements.vb  
vbc CreateResources.vb /r:UIElements.dll  
CreateResources  
  
resgen UIResources.resx  /r:UIElements.dll  
vbc GetObject.vb /r:UIElements.dll /resource:UIResources.resources  
  
GetObject.exe  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Nie można używać zestawu zlokalizowanych zasobów wykryła, a nie ma żadnych zasobów kultury domyślnej. Aby uzyskać informacje o sposobie obsługi tego wyjątku, zobacz sekcję "Obsługa wyjątków MissingManifestResourceException i missingsatelliteassemblyexception — liczba wyjątków" w <see cref="T:System.Resources.ResourceManager" /> temat poświęcony klasie.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Zasobów kultury domyślnej znajdują się w zestawie satelickim, który nie został odnaleziony. Aby uzyskać informacje o sposobie obsługi tego wyjątku, zobacz sekcję "Obsługa wyjątków MissingManifestResourceException i missingsatelliteassemblyexception — liczba wyjątków" w <see cref="T:System.Resources.ResourceManager" /> temat poświęcony klasie.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String)" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Opakowanie i wdrażanie zasobów</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string * System.Globalization.CultureInfo -&gt; obj&#xA;override this.GetObject : string * System.Globalization.CultureInfo -&gt; obj" Usage="resourceManager.GetObject (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zasobu, który można pobrać.</param>
        <param name="culture">Kultura, dla której zasób jest zlokalizowana. Jeśli zasób nie jest zlokalizowana dla tej kultury, usługi resource manager używa reguł rezerwowy, aby zlokalizować odpowiedni zasób.  
  
Jeśli ta wartość jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> jest on uzyskiwany za pomocą <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" /> właściwości.</param>
        <summary>Pobiera wartość określonego zasobu niebędących ciągami zlokalizowane dla określonej kultury.</summary>
        <returns>Wartość zasobu zlokalizowane dla określonej kultury. Jeśli istnieje zestaw odpowiednich zasobów, ale <paramref name="name" /> nie zostanie znaleziony, metoda zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> Metoda służy do pobierania zasobów niebędących ciągami. Należą do nich wartości, które należą do pierwotne typy danych, takich jak <xref:System.Int32> lub <xref:System.Double>, mapy bitowe (takie jak <xref:System.Drawing.Bitmap?displayProperty=nameWithType> obiektu), lub niestandardowe serializacji obiektów. Zwykle zwracany obiekt musi rzutowania (w języku C#) lub przekonwertować (w języku Visual Basic) do obiektu odpowiedniego typu.  
  
 Zwrócone zasobów jest zlokalizowana dla kultury, który jest określony przez `culture`, lub dla kultury, który jest określony przez <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> właściwość Jeśli `culture` jest `null`. Jeśli zasób nie jest zlokalizowana dla tej kultury, Menedżer zasobów używa reguł rezerwowego załadować odpowiedni zasób. Jeśli nie można używać zestawu zlokalizowanych zasobów zostanie znaleziony, Menedżer zasobów powraca zasobów kultury domyślnej. Jeśli nie można odnaleźć zasobu dla domyślnej kultury, metoda zgłasza <xref:System.Resources.MissingManifestResourceException> wyjątek lub, jeśli zestaw zasobów powinien znajdować się w zestawie satelickim <xref:System.Resources.MissingSatelliteAssemblyException> wyjątku. Jeśli Menedżera zasobów można załadować odpowiedni zasób zestawu, ale nie można odnaleźć zasób o nazwie `name`, metoda zwraca `null`.  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A> Właściwość określa, czy porównanie `name` za pomocą nazw zasobów jest rozróżniana wielkość liter (ustawienie domyślne) lub jest rozróżniana wielkość liter.  
  
> [!CAUTION]
>  Ta metoda może zgłaszać wyjątki więcej niż podano. Jednym z powodów taka sytuacja może wystąpić jest zgłasza wyjątek, jeśli metoda, która wywołuje tę metodę.  Na przykład <xref:System.IO.FileLoadException> może zostać wygenerowany wyjątek, jeśli błąd został utworzony, wdrażanie lub Instalowanie zestawu satelickiego, lub <xref:System.Runtime.Serialization.SerializationException> może być zgłaszany wyjątek, jeśli typ zdefiniowany przez użytkownika zgłasza wyjątek zdefiniowanych przez użytkownika, gdy typ jest przeprowadzona.  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Jeśli wywołasz <xref:System.Resources.ResourceManager.GetObject%2A> metoda wiele razy z takimi samymi `name` parametru nie są zależne od metoda zwraca odwołanie do tego samego obiektu za pomocą każdego wywołania. Jest to spowodowane <xref:System.Resources.ResourceManager.GetObject%2A> metoda może zwrócić odwołanie do istniejącego obiektu zasobu w pamięci podręcznej, lub można ponownie załadować zasobu i zwraca odwołanie do nowego obiektu zasobów.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> metodę deserializacji niestandardowych obiektów. Przykład zawiera plik kodu źródłowego o nazwie NumberInfo.cs (NumberInfo.vb, jeśli używasz języka Visual Basic) definiujący następującą strukturę o nazwie `Numbers`. Ta struktura jest przeznaczona do użycia przez prosta aplikacja edukacyjnych, który innej niż angielska wypowiedzi zliczania do dziesięciu w języku angielskim. Należy pamiętać, że `Numbers` klasa jest oznaczona za pomocą <xref:System.SerializableAttribute> atrybutu.  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/numberinfo.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/numberinfo.vb#1)]  
  
 Poniższy kod źródłowy z pliku o nazwie CreateResources.cs (CreateResources.vb dla języka Visual Basic) tworzy pliki zasobów XML dla domyślnego języka angielskiego, a także dla języków, francuski i portugalski, rosyjski.  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/createresources.cs#2)]
 [!code-vb[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/createresources.vb#2)]  
  
 Zasoby są używane przez następujące aplikację, która ustawia bieżącej kultury interfejsu użytkownika na francuską (Francja), portugalski (Brazylia) i rosyjski (Rosja). Wywołuje <xref:System.Resources.ResourceManager.GetObject%28System.String%29> metodę, aby uzyskać `Numbers` obiekt, który zawiera numery zlokalizowane i <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> metodę, aby uzyskać `Numbers` obiekt, który zawiera numery w języku angielskim. Następnie wyświetla liczby nieparzyste przy użyciu bieżącej kultury interfejsu użytkownika i w języku angielskim. Plik kodu źródłowego nosi nazwę ShowNumbers.cs (ShowNumbers.vb).  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/shownumbers.cs#3)]
 [!code-vb[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/shownumbers.vb#3)]  
  
 Następujący plik wsadowy umożliwia tworzenie i wykonywanie wersja języka Visual Basic przykładu. Jeśli używasz języka C#, należy zastąpić `vbc` z `csc`i Zastąp `.vb` rozszerzenie `.cs`.  
  
```  
  
vbc /t:library NumberInfo.vb  
  
vbc CreateResources.vb /r:NumberInfo.dll  
CreateResources  
  
resgen NumberResources.resx /r:NumberInfo.dll  
  
resgen NumberResources.fr.resx /r:Numberinfo.dll  
Md fr  
al /embed:NumberResources.fr.resources /culture:fr /t:lib /out:fr\ShowNumbers.resources.dll  
  
resgen NumberResources.pt.resx  /r:Numberinfo.dll  
Md pt  
al /embed:NumberResources.pt.resources /culture:pt /t:lib /out:pt\ShowNumbers.resources.dll  
  
resgen NumberResources.ru.resx /r:Numberinfo.dll  
Md ru  
al /embed:NumberResources.ru.resources /culture:ru /t:lib /out:ru\ShowNumbers.resources.dll  
  
vbc ShowNumbers.vb /r:NumberInfo.dll /resource:NumberResources.resources  
ShowNumbers.exe  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Nie można używać zestawu zasobów zostały znalezione i nie ma żadnych zasobów kultury domyślnej. Aby uzyskać informacje o sposobie obsługi tego wyjątku, zobacz sekcję "Obsługa wyjątków MissingManifestResourceException i missingsatelliteassemblyexception — liczba wyjątków" w <see cref="T:System.Resources.ResourceManager" /> temat poświęcony klasie.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Zasobów kultury domyślnej znajdują się w zestawie satelickim, który nie został odnaleziony. Aby uzyskać informacje o sposobie obsługi tego wyjątku, zobacz sekcję "Obsługa wyjątków MissingManifestResourceException i missingsatelliteassemblyexception — liczba wyjątków" w <see cref="T:System.Resources.ResourceManager" /> temat poświęcony klasie.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <threadsafe>
          <see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" /> Metody jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Opakowanie i wdrażanie zasobów</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceFileName">
      <MemberSignature Language="C#" Value="protected virtual string GetResourceFileName (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetResourceFileName(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceFileName(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResourceFileName (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetResourceFileName(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceFileName : System.Globalization.CultureInfo -&gt; string&#xA;override this.GetResourceFileName : System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetResourceFileName culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Obiekt culture, dla którego jest tworzony nazwa pliku zasobu.</param>
        <summary>Generuje nazwę pliku zasobów dla danego <see cref="T:System.Globalization.CultureInfo" /> obiektu.</summary>
        <returns>Nazwę, która może służyć do pliku zasobów, dla danej <see cref="T:System.Globalization.CultureInfo" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetResourceFileName%2A> Metoda jest przydatna tylko wtedy, gdy napisać własne klasy, która pochodzi od klasy <xref:System.Resources.ResourceManager> klasy.  
  
 Ta metoda używa <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType> właściwości jako część nazwy pliku dla wszystkich języków innych niż niezmiennej kultury. Ta metoda nie znajduje się w manifeście zestawu lub touch dysku i służy tylko do konstruowania nazwy pliku zasobu (odpowiednie do przekazania do <xref:System.Resources.ResourceReader> konstruktora) lub nazwę zasobu manifestu obiektu blob.  
  
 Klasa pochodna mogą przesłaniać tę metodę, aby wyszukać inne rozszerzenie, takie jak ". Program ResX", lub zupełnie inny schemat nazewnictwa plików zasobów. Należy pamiętać, że metody mogą być używane, można dostosować nazwę pliku zasobu w zestawie satelickim, a nie dostosowania nazwy zestawu satelickiego, sam.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">Globalizacja i lokalizacja aplikacji .NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceSet">
      <MemberSignature Language="C#" Value="public virtual System.Resources.ResourceSet GetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Resources.ResourceSet GetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Resources::ResourceSet ^ GetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.GetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">Kultura, którego zasoby mają być pobierane.</param>
        <param name="createIfNotExists">
          <see langword="true" /> Aby załadować zasobu zestaw, jeśli nie został jeszcze; załadowany w przeciwnym razie <see langword="false" />.</param>
        <param name="tryParents">
          <see langword="true" /> na potrzeby zasób rezerwowy załadować odpowiedni zasób, jeśli zasób nie można odnaleźć; <see langword="false" /> pomijanie procesu bazowego zasobu.</param>
        <summary>Pobiera zasób dla określonej kultury.</summary>
        <returns>Zasób, ustaw dla określonej kultury.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw zasobów, która jest zwracana reprezentuje zasoby, które są zlokalizowane dla określonej kultury. Jeśli nie zostały zlokalizowane zasoby dla tej kultury i `tryParents` jest `true`, <xref:System.Resources.ResourceManager.GetResourceSet%2A> przy użyciu reguł rezerwowego zasobów można załadować odpowiedni zasób. Jeśli `tryParents` jest `false` i nie można znaleźć zestaw zasobów dla kultury, metoda zwraca `null`. Aby uzyskać więcej informacji na temat zasobów rezerwowych, zobacz sekcję "Proces bazowy zasobu" w [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) artykułu.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Resources.ResourceManager.GetResourceSet%2A> metodę, aby pobrać zasoby specyficzne dla kultury dla kultury francuski (Francja). Następnie wylicza wszystkie zasoby w zestawie zasobów. Zawiera kod źródłowy dla pliku wykonywalnego o nazwie ShowNumbers.exe. Zawiera on również następującego pliku dwóch tekst, który zawierają nazwy liczb. Pierwsza strona, NumberResources.txt, zawiera nazwy numery z jednego do dziesięciu w języku angielskim:  
  
```  
  
one=one  
two=two  
three=three  
four=four  
five=five  
six=six  
seven=seven  
eight=eight  
nine=nine  
ten=ten  
  
```  
  
 Drugi NumberResources.fr FR.txt, zawiera nazwy liczb od jednej do czterech w języku francuskim:  
  
```  
  
one=un  
two=deux  
three=trois  
four=quatre  
  
```  
  
 Aby wygenerować plików zasobów, Osadź plik zasobu języka angielskiego do pliku wykonywalnego i utworzyć zestaw satelicki dla zasobów języka francuskiego, można użyć pliku wsadowego. Poniżej przedstawiono plik wsadowy, aby wygenerować plik wykonywalny przy użyciu kompilatora Visual Basic:  
  
```  
  
resgen NumberResources.txt  
vbc shownumbers.vb /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
```  
  
 Dla kompilatora C# można używać następującego pliku wsadowym:  
  
```  
  
resgen NumberResources.txt  
csc shownumbers.cs /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/cs/shownumbers.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/vb/shownumbers.vb#1)]  
  
 Należy pamiętać, że jeśli zmienisz wartość `createIfNotExists` argument `false`, wywołanie metody zwraca `null`, ponieważ Menedżer zasobów nie został już załadowany zasobów języka francuskiego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">
          <paramref name="tryParents" /> jest <see langword="true" />wykryła nie można używać zestaw zasobów i nie ma żadnych zasobów kultury domyślnej.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">Globalizacja i lokalizacja aplikacji .NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteContractVersion">
      <MemberSignature Language="C#" Value="protected static Version GetSatelliteContractVersion (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Version GetSatelliteContractVersion(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetSatelliteContractVersion(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetSatelliteContractVersion (a As Assembly) As Version" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static Version ^ GetSatelliteContractVersion(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetSatelliteContractVersion : System.Reflection.Assembly -&gt; Version" Usage="System.Resources.ResourceManager.GetSatelliteContractVersion a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">Zestaw, aby wyszukać <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> atrybutu.</param>
        <summary>Zwraca informacje o wersji określonej przez <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> atrybutów w danym zestawie.</summary>
        <returns>Wersja kontraktu satelitarnej danego zestawu, lub <see langword="null" /> Jeśli wersja nie została odnaleziona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat przechowywanie wersji zestawu satelickiego zobacz <xref:System.Resources.SatelliteContractVersionAttribute> temat referencyjny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Version" /> Znaleziony w zestawie <paramref name="a" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="a" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca obiekt strumienia niezarządzanej pamięci z określonego zasobu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zasobu.</param>
        <summary>Zwraca obiekt strumienia niezarządzanej pamięci z określonego zasobu.</summary>
        <returns>Obiekt strumienia niezarządzanej pamięci, który reprezentuje zasobu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetStream%2A> Metoda przyjmuje nazwę zasobu, który jest przechowywany jako <xref:System.IO.MemoryStream> obiektów, pobiera wartość <xref:System.Object> zasobów i zwraca <xref:System.IO.UnmanagedMemoryStream> obiektu. Wymaga to, należy skontaktować się bezpośrednio z strumień bajtów, które następnie wykonać konwersję do obiektu. Ta metoda przydaje się głównie w celu zapewnienia optymalnej wydajności: pobierania zasobu jako strumień bajtów zamiast jawnego obiektu może poprawić wydajność.  
  
 Zwrócone zasobów jest zlokalizowana dla kultury interfejsu użytkownika bieżącego wątku, która jest zdefiniowana przez <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> właściwości. Jeśli zasób nie jest zlokalizowana dla tej kultury, Menedżer zasobów używa reguł rezerwowego załadować odpowiedni zasób. Jeśli nie można używać zestawu zlokalizowanych zasobów zostanie znaleziony, <xref:System.Resources.ResourceManager> powraca zasobów kultury domyślnej. Jeśli nie można odnaleźć zasobu dla domyślnej kultury, metoda zgłasza <xref:System.Resources.MissingManifestResourceException> wyjątek lub, jeśli zestaw zasobów powinien znajdować się w zestawie satelickim <xref:System.Resources.MissingSatelliteAssemblyException> wyjątku. Jeśli Menedżera zasobów można załadować odpowiedni zasób zestawu, ale nie można odnaleźć zasób o nazwie `name`, metoda zwraca `null`.  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A> Właściwość określa, czy porównanie `name` za pomocą nazw zasobów jest rozróżniana wielkość liter (ustawienie domyślne) lub jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Resources.ResourceManager.GetStream%28System.String%29> otwarcia oknie powitalnym metodę, która pobierze mapy bitowej, który jest używany w aplikacji. Następujące źródła kodu z pliku o nazwie CreateResources.cs (dla C#) lub CreateResources.vb (dla języka Visual Basic) generuje plik Resx o nazwie AppResources.resx, który zawiera Zserializowany obraz. W tym przypadku obraz, który jest ładowany z pliku o nazwie SplashScreen.jpg; można zmodyfikować nazwę pliku, aby zastąpić własnego obrazu.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/createresources.cs#4)]
 [!code-vb[Conceptual.Resources.Retrieving#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/createresources.vb#4)]  
  
 Poniższy kod z pliku o nazwie GetStream.cs (C#) lub GetStream.vb (dla języka Visual Basic), a następnie pobiera zasób i wyświetla obraz w <xref:System.Windows.Forms.PictureBox?displayProperty=nameWithType> kontroli.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/getstream.cs#5)]
 [!code-vb[Conceptual.Resources.Retrieving#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/getstream.vb#5)]  
  
 Następujący plik wsadowy można użyć, aby zbudować przykład C#. Dla języka Visual Basic należy zmienić `csc` do `vbc`i zmień rozszerzenie pliku z kodem źródłowym z `.cs` do `.vb`...  
  
```  
  
csc CreateResources.cs  
CreateResources  
  
resgen AppResources.resx  
  
csc GetStream.cs /resource:AppResources.resources  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wartość określonego zasobu nie jest <see cref="T:System.IO.MemoryStream" /> obiektu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Nie można używać zestawu zasobów zostanie znaleziony, a nie ma żadnych zasobów domyślne. Aby uzyskać informacje o sposobie obsługi tego wyjątku, zobacz sekcję "Obsługa wyjątków MissingManifestResourceException i missingsatelliteassemblyexception — liczba wyjątków" w <see cref="T:System.Resources.ResourceManager" /> temat poświęcony klasie.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Zasobów kultury domyślnej znajdują się w zestawie satelickim, który nie został odnaleziony. Aby uzyskać informacje o sposobie obsługi tego wyjątku, zobacz sekcję "Obsługa wyjątków MissingManifestResourceException i missingsatelliteassemblyexception — liczba wyjątków" w <see cref="T:System.Resources.ResourceManager" /> temat poświęcony klasie.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String, culture As CultureInfo) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string * System.Globalization.CultureInfo -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zasobu.</param>
        <param name="culture">Obiekt, który określa kulturę do użytku wyszukiwania zasobów. Jeśli <c>kultury</c> jest <see langword="null" />, jest używana kultura bieżącego wątku.</param>
        <summary>Zwraca obiekt strumienia niezarządzanej pamięci z określonego zasobu, używając określonej kultury.</summary>
        <returns>Obiekt strumienia niezarządzanej pamięci, który reprezentuje zasobu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetStream%2A> Metoda przyjmuje nazwę zasobu, który jest przechowywany jako <xref:System.IO.MemoryStream> obiektów, pobiera wartość <xref:System.Object> zasobów i zwraca <xref:System.IO.UnmanagedMemoryStream> obiektu. Wymaga to, należy skontaktować się bezpośrednio z strumień bajtów, które następnie wykonać konwersję do obiektu. Ta metoda przydaje się głównie w celu zapewnienia optymalnej wydajności: pobierania zasobu jako strumień bajtów zamiast jawnego obiektu może poprawić wydajność.  
  
 Zwrócone zasobów jest zlokalizowana dla kultury, który jest określony przez `culture`, lub dla kultury, który jest określony przez <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> właściwość Jeśli `culture` jest `null`. Jeśli zasób nie jest zlokalizowana dla tej kultury, Menedżer zasobów używa reguł rezerwowego załadować odpowiedni zasób. Jeśli nie można używać zestawu zlokalizowanych zasobów zostanie znaleziony, <xref:System.Resources.ResourceManager> powraca zasobów kultury domyślnej. Jeśli nie można odnaleźć zasobu dla domyślnej kultury, metoda zgłasza <xref:System.Resources.MissingManifestResourceException> wyjątek lub, jeśli zestaw zasobów powinien znajdować się w zestawie satelickim <xref:System.Resources.MissingSatelliteAssemblyException> wyjątku. Jeśli Menedżera zasobów można załadować odpowiedni zasób zestawu, ale nie można odnaleźć zasób o nazwie `name`, metoda zwraca `null`.  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A> Właściwość określa, czy porównanie `name` za pomocą nazw zasobów jest rozróżniana wielkość liter (ustawienie domyślne) lub jest rozróżniana wielkość liter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wartość określonego zasobu nie jest <see cref="T:System.IO.MemoryStream" /> obiektu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Nie można używać zestawu zasobów zostanie znaleziony, a nie ma żadnych zasobów domyślne. Aby uzyskać informacje o sposobie obsługi tego wyjątku, zobacz sekcję "Obsługa wyjątków MissingManifestResourceException i missingsatelliteassemblyexception — liczba wyjątków" w <see cref="T:System.Resources.ResourceManager" /> temat poświęcony klasie.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Zasobów kultury domyślnej znajdują się w zestawie satelickim, który nie został odnaleziony. Aby uzyskać informacje o sposobie obsługi tego wyjątku, zobacz sekcję "Obsługa wyjątków MissingManifestResourceException i missingsatelliteassemblyexception — liczba wyjątków" w <see cref="T:System.Resources.ResourceManager" /> temat poświęcony klasie.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość określonego ciągu zasobu dla bieżącej kultury interfejsu użytkownika lub określonej kultury.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetString : string -&gt; string&#xA;override this.GetString : string -&gt; string" Usage="resourceManager.GetString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zasobu do pobrania.</param>
        <summary>Zwraca wartość zasobu określonego ciągu.</summary>
        <returns>Wartość zasobu zlokalizowany dla bieżącej kultury interfejsu użytkownika obiektu wywołującego lub <see langword="null" /> Jeśli <paramref name="name" /> nie można odnaleźć w zestawie zasobów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Aplikacje pulpitu  
 W aplikacjach klasycznych zasobów, która jest zwracana jest zlokalizowana dla kultury interfejsu użytkownika bieżącego wątku, zgodnie z definicją <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> właściwości. Jeśli zasób nie został zlokalizowany dla tej kultury, Menedżer zasobów sondy dla zasobu, wykonując kroki opisane w sekcji "Zasobów rezerwowych procesu" [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) artykułu. Jeśli nie można używać zestawu zlokalizowanych zasobów zostanie znaleziony, Menedżer zasobów powraca zasobów kultury domyślnej. Jeśli Menedżera zasobów nie można załadować zestawu zasobów kultury domyślnej, metoda zgłasza <xref:System.Resources.MissingManifestResourceException> wyjątek lub, jeśli zestaw zasobów powinien znajdować się w zestawie satelickim <xref:System.Resources.MissingSatelliteAssemblyException> wyjątku. Jeśli Menedżera zasobów można załadować odpowiedni zasób zestawu, ale nie można odnaleźć zasób o nazwie `name`, metoda zwraca `null`.  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A> Właściwość określa, czy porównanie `name` za pomocą nazw zasobów jest rozróżniana wielkość liter (ustawienie domyślne) lub jest rozróżniana wielkość liter.  
  
> [!CAUTION]
>  Ta metoda może zgłaszać wyjątki więcej niż podano. Jednym z powodów taka sytuacja może wystąpić jest zgłasza wyjątek, jeśli metoda, która wywołuje tę metodę.  Na przykład <xref:System.IO.FileLoadException> może zostać wygenerowany wyjątek, jeśli błąd został utworzony, wdrażanie lub Instalowanie zestawu satelickiego, lub <xref:System.Runtime.Serialization.SerializationException> może być zgłaszany wyjątek, jeśli typ zdefiniowany przez użytkownika zgłasza wyjątek zdefiniowanych przez użytkownika, gdy typ jest przeprowadzona.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] Aplikacje  
  
> [!IMPORTANT]
>  Mimo że <xref:System.Resources.ResourceManager> klasy jest obsługiwana w [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji, nie zaleca się jej użycie. Klasa jest używana tylko wtedy, gdy tworzysz [!INCLUDE[net_portable](~/includes/net-portable-md.md)] projektów, które mogą być używane z [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji. Aby pobrać zasoby z [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] użyj [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) klasy zamiast tego.  
  
 W [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji <xref:System.Resources.ResourceManager.GetString%28System.String%29> metoda zwraca wartość `name` ciągu zasobu zlokalizowany dla bieżącego ustawienia kultury interfejsu użytkownika obiektu wywołującego. Lista kultur jest tworzony na podstawie listy język interfejsu użytkownika preferowanego systemu operacyjnego. Jeśli Menedżera zasobów nie może dopasować `name`, metoda zwraca `null`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Resources.ResourceManager.GetString%2A> metodę, aby pobrać zasoby specyficzne dla kultury. Składa się z zasobami skompilowane z plików txt angielski (en), francuski (Francja) (fr-FR) i rosyjski (Rosja) (ru-RU) kultur. W przykładzie zmieniono bieżącą kulturę i bieżącej kultury interfejsu użytkownika języka angielskiego (Stany Zjednoczone), francuski (Francja), rosyjski (Rosja) i szwedzki (Szwecja). Następnie wywołuje <xref:System.Resources.ResourceManager.GetString%2A> metodę, która pobierze zlokalizowany ciąg, który wyświetla wraz z bieżącego dnia i miesiąca. Należy zauważyć, że dane wyjściowe wyświetla odpowiedni zlokalizowany ciąg z wyjątkiem sytuacji, gdy bieżąca kultura interfejsu użytkownika jest szwedzki (Szwecja). Ponieważ zasoby języka szwedzkiego są niedostępne, aplikacja zamiast tego używa zasobów domyślnej kultury, czyli w języku angielskim. Przykład wymaga plików zasobów w formacie tekstowym, wymienione w poniższej tabeli. Każda z nich zawiera zasób w postaci pojedynczego ciągu o nazwie `DateStart`.  
  
|Kultury|Nazwa pliku|Nazwa zasobu|Wartość zasobu|  
|-------------|---------------|-------------------|--------------------|  
|pl pl|DateStrings.txt|`DateStart`|Dzisiaj jest|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|СЕГОДНЯ|  
  
 Aby skompilować przykład C#, można użyć następującego pliku wsadowego. Dla języka Visual Basic należy zmienić `csc` do `vbc`i zmień rozszerzenie pliku z kodem źródłowym z `.cs` do `.vb`.  
  
```  
resgen DateStrings.txt  
csc showdate.cs /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 Poniżej przedstawiono kod źródłowy, na przykład (ShowDate.vb dla używanej wersji programu Visual Basic) lub ShowDate.cs wersji języka C#.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Wartość określonego zasobu nie jest ciągiem.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Nie można używać zestawu zasobów wykryła, a nie ma żadnych zasobów dla kultury domyślnej. Aby uzyskać informacje o sposobie obsługi tego wyjątku, zobacz sekcję "Obsługa wyjątków MissingManifestResourceException i missingsatelliteassemblyexception — liczba wyjątków" w <see cref="T:System.Resources.ResourceManager" /> temat poświęcony klasie.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Zasobów kultury domyślnej znajdują się w zestawie satelickim, który nie został odnaleziony. Aby uzyskać informacje o sposobie obsługi tego wyjątku, zobacz sekcję "Obsługa wyjątków MissingManifestResourceException i missingsatelliteassemblyexception — liczba wyjątków" w <see cref="T:System.Resources.ResourceManager" /> temat poświęcony klasie.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <threadsafe>
          <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> Metody jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Opakowanie i wdrażanie zasobów</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eca16922-1c46-4f68-aefe-e7a12283641f">Pobieranie zasobów w zestawy satelickie</related>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetString : string * System.Globalization.CultureInfo -&gt; string&#xA;override this.GetString : string * System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetString (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zasobu do pobrania.</param>
        <param name="culture">Obiekt, który reprezentuje kulturę, dla której zasób jest zlokalizowana.</param>
        <summary>Zwraca wartość zasobu ciągu zlokalizowane dla określonej kultury.</summary>
        <returns>Wartość zasobu zlokalizowane dla określonej kultury lub <see langword="null" /> Jeśli <paramref name="name" /> nie można odnaleźć w zestawie zasobów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Aplikacje pulpitu  
 W aplikacjach klasycznych Jeśli `culture` jest `null`, <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> metoda używa bieżącej kultury interfejsu użytkownika, uzyskany z <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> właściwości.  
  
 Zasób, zwracany jest zlokalizowana dla kultury określonej parametrem `culture` parametru. Jeśli zasób nie został zlokalizowany `culture`, usługi resource manager sondy dla zasobu, wykonując kroki opisane w sekcji "Zasobów rezerwowych procesu" [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) tematu. Jeśli nie można używać zestawu zasobów zostanie znaleziony, Menedżer zasobów powraca zasobów kultury domyślnej. Jeśli Menedżera zasobów nie można załadować zestawu zasobów kultury domyślnej, metoda zgłasza <xref:System.Resources.MissingManifestResourceException> wyjątek lub, jeśli zestaw zasobów powinien znajdować się w zestawie satelickim <xref:System.Resources.MissingSatelliteAssemblyException> wyjątku. Jeśli Menedżera zasobów można załadować odpowiedni zasób zestawu, ale nie można odnaleźć zasób o nazwie `name`, metoda zwraca `null`.  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A> Właściwość określa, czy porównanie `name` za pomocą nazw zasobów jest rozróżniana wielkość liter (ustawienie domyślne) lub jest rozróżniana wielkość liter.  
  
> [!CAUTION]
>  Ta metoda może zgłaszać wyjątki więcej niż podano. Jednym z powodów taka sytuacja może wystąpić jest zgłasza wyjątek, jeśli metoda, która wywołuje tę metodę.  Na przykład <xref:System.IO.FileLoadException> może zostać wygenerowany wyjątek, jeśli błąd został utworzony, wdrażanie lub Instalowanie zestawu satelickiego, lub <xref:System.Runtime.Serialization.SerializationException> może być zgłaszany wyjątek, jeśli typ zdefiniowany przez użytkownika zgłasza wyjątek zdefiniowanych przez użytkownika, gdy typ jest przeprowadzona.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] Aplikacje  
  
> [!IMPORTANT]
>  Mimo że <xref:System.Resources.ResourceManager> klasy jest obsługiwana w [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji, nie zaleca się jej użycie. Klasa jest używana tylko wtedy, gdy tworzysz [!INCLUDE[net_portable](~/includes/net-portable-md.md)] projektów, które mogą być używane z [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji. Aby pobrać zasoby z [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] użyj [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) klasy zamiast tego.  
  
 W [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> metoda zwraca wartość `name` ciągu zasobu, zlokalizowane dla kultury określonej parametrem `culture` parametru. Jeśli zasób nie jest zlokalizowana dla `culture` kultury, wyszukiwanie używa całego [!INCLUDE[win8](~/includes/win8-md.md)] rezerwowego Lista języków i kończy działanie po wyszukiwania w kulturze domyślnej. Jeśli Menedżera zasobów nie może dopasować `name`, metoda zwraca `null`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> metodę, aby pobrać zasoby specyficzne dla kultury. Przykład domyślnej kultury jest angielski (en) i francuski (Francja) (fr-FR) i rosyjski (Rosja) (ru-RU) obejmuje zestawy satelickie kultur. W przykładzie zmieniono bieżącą kulturę i bieżącej kultury interfejsu użytkownika rosyjski (Rosja) przed wywołaniem <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>. Następnie wywołuje <xref:System.Resources.ResourceManager.GetString%2A> metody i <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody i przekazuje <xref:System.Globalization.CultureInfo> obiekty reprezentujące francuski (Francja) i kultury szwedzki (Szwecja) do każdej metody. W danych wyjściowych, miesiąc i dzień miesiąca, a także ciąg, który poprzedza ich są wyświetlane w języku francuskim, ponieważ <xref:System.Resources.ResourceManager.GetString%2A> metody jest możliwość pobrania zasobu języka francuskiego. Jednak w przypadku kultury szwedzki (Szwecja) miesiąc i dzień miesiąca są wyświetlane w szwedzki, mimo że ciąg, który poprzedza ich w języku angielskim. Jest to spowodowane Menedżera zasobów nie można odnaleźć zasoby zlokalizowane szwedzkim, tak aby zwracało poprawnie zasobu dla domyślnej kultury angielskiej zamiast tego.  
  
 Przykład wymaga plików zasobów w formacie tekstowym, wymienione w poniższej tabeli. Każda z nich zawiera zasób w postaci pojedynczego ciągu o nazwie `DateStart`.  
  
|Kultury|Nazwa pliku|Nazwa zasobu|Wartość zasobu|  
|-------------|---------------|-------------------|--------------------|  
|pl pl|DateStrings.txt|`DateStart`|Dzisiaj jest|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|СЕГОДНЯ|  
  
 Następujący plik wsadowy można użyć, aby skompilować przykład Visual Basic. Aby skompilować w języku C#, należy zmienić `vbc` do `csc`i zmień rozszerzenie pliku z kodem źródłowym z `.vb` do `.cs`.  
  
```  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 Poniżej przedstawiono kod źródłowy, na przykład (ShowDate.vb dla używanej wersji programu Visual Basic) lub ShowDate.cs wersji języka C#.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate2.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Wartość określonego zasobu nie jest ciągiem.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Nie można używać zestawu zasobów wykryła, a nie ma żadnych zasobów dla kultury domyślnej. Aby uzyskać informacje o sposobie obsługi tego wyjątku, zobacz sekcję "Obsługa wyjątków MissingManifestResourceException i missingsatelliteassemblyexception — liczba wyjątków" w <see cref="T:System.Resources.ResourceManager" /> temat poświęcony klasie.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Zasobów kultury domyślnej znajdują się w zestawie satelickim, który nie został odnaleziony. Aby uzyskać informacje o sposobie obsługi tego wyjątku, zobacz sekcję "Obsługa wyjątków MissingManifestResourceException i missingsatelliteassemblyexception — liczba wyjątków" w <see cref="T:System.Resources.ResourceManager" /> temat poświęcony klasie.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <threadsafe>
          <see cref="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" /> Metody jest bezpieczny dla wątków.</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Opakowanie i wdrażanie zasobów</related>
      </Docs>
    </Member>
    <Member MemberName="HeaderVersionNumber">
      <MemberSignature Language="C#" Value="public static readonly int HeaderVersionNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 HeaderVersionNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeaderVersionNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int HeaderVersionNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeaderVersionNumber : int" Usage="System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa wersję nagłówki plików zasobów, bieżąca implementacja parametru <see cref="T:System.Resources.ResourceManager" /> mogą być interpretowane i produkcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreCase">
      <MemberSignature Language="C#" Value="public virtual bool IgnoreCase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.IgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IgnoreCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IgnoreCase { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreCase : bool with get, set" Usage="System.Resources.ResourceManager.IgnoreCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługi resource manager umożliwia wyszukiwań zasobów bez uwzględniania wielkości liter w <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> i <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> metody.</summary>
        <value>
          <see langword="true" /> ignorowanie wielkości liter podczas wyszukiwania zasobów; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość <xref:System.Resources.ResourceManager.IgnoreCase%2A> właściwość `false`, zasób o nazwie "Resource" nie jest odpowiednikiem zasób o nazwie "resource". Jeśli <xref:System.Resources.ResourceManager.IgnoreCase%2A> jest `true`, zasób o nazwie "Resource" odpowiada zasób o nazwie "resource". Zauważ, że w przypadku <xref:System.Resources.ResourceManager.IgnoreCase%2A> jest `true`, <xref:System.Resources.ResourceManager.GetString%2A?displayProperty=nameWithType> i <xref:System.Resources.ResourceManager.GetObject%2A?displayProperty=nameWithType> metod wykonania porównania bez uwzględniania wielkości liter ciągu przy użyciu niezmiennej kultury. Zaletą jest to, że wyniki porównania bez uwzględniania wielkości liter ciągu wykonywane przez te metody są takie same na wszystkich komputerach, niezależnie od kultury. Wadą jest to, że wyniki nie są zgodne z reguł stosowania wielkości liter wszystkich kultur.  
  
 Na przykład turecki alfabetu ma dwie wersje znak I:, jeden z kropką i jedna bez pojedynczego znaku kropki. W języku tureckim znak (Unicode 0049) I jest uznawany za wielkie wersję innego znaku ı (Unicode 0131). Znak i (Unicode 0069) jest uznawana za małe wersję kolejny znak İ (Unicode 0130). Zgodnie z tych reguł stosowania wielkości liter porównania bez uwzględniania wielkości liter ciągu znaków i (Unicode 0069) i (Unicode 0049) powinna zakończyć się niepowodzeniem dla kultury "tr-TR" (turecki w Turcji). Jednak ponieważ porównanie odbywa się przy użyciu reguł stosowania wielkości liter kultury niezmiennej, jeśli <xref:System.Resources.ResourceManager.IgnoreCase%2A> jest `true`, to porównanie zakończy się pomyślnie.  
  
> [!NOTE]
>  Ze względu na wydajność najlepiej zawsze określać poprawną wielkość dla nazwy zasobu. Ustawienie <xref:System.Resources.ResourceManager.IgnoreCase%2A> do `true` może spowodować zauważalne zwiększenie w zestawie roboczym i znaczny spadek wydajności.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalGetResourceSet">
      <MemberSignature Language="C#" Value="protected virtual System.Resources.ResourceSet InternalGetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Resources.ResourceSet InternalGetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function InternalGetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Resources::ResourceSet ^ InternalGetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.InternalGetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">Kultura obiektu do wyszukania.</param>
        <param name="createIfNotExists">
          <see langword="true" /> Aby załadować zasobu zestaw, jeśli nie został jeszcze; załadowany w przeciwnym razie <see langword="false" />.</param>
        <param name="tryParents">
          <see langword="true" /> Aby sprawdzić nadrzędnego <see cref="T:System.Globalization.CultureInfo" /> obiektów, jeśli zestaw zasobów nie można załadować; w przeciwnym razie <see langword="false" />.</param>
        <summary>Udostępnia implementację służące do znajdowania zestawu zasobów.</summary>
        <returns>Zestaw określony zasób.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Główny zestaw nie zawiera pliku Resources, który jest wymagany, aby wyszukać zasób.</exception>
        <exception cref="T:System.ExecutionEngineException">Wystąpił błąd wewnętrzny w środowisku uruchomieniowym.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Skojarzone z zestawu satelickiego <paramref name="culture" /> nie można zlokalizować.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <block subset="none" type="overrides">
          <para>Ta metoda kończy pracę potrzebnego do znalezienia zasób zestawu i może być cykliczne i wielobieżna ConcurrencyMode. Innymi słowy, ta metoda może załadować zestawu i wyzwalacza <see cref="E:System.AppDomain.AssemblyLoad" /> zdarzenie, które następnie ponownie wywołuje <see cref="T:System.Resources.ResourceManager" /> obiekt, który nie został całkowicie zainicjowany. Aby uniknąć, biorąc dodatkowe blokady, ta metoda nie jest bezpieczny dla wątków. <see cref="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />, <see cref="M:System.Resources.ResourceManager.GetString(System.String)" />, I <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> metody wykonaj wszystkie niezbędne synchronizacji.</para>
        </block>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">Globalizacja i lokalizacja aplikacji .NET</related>
      </Docs>
    </Member>
    <Member MemberName="MagicNumber">
      <MemberSignature Language="C#" Value="public static readonly int MagicNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 MagicNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MagicNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MagicNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int MagicNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable MagicNumber : int" Usage="System.Resources.ResourceManager.MagicNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje numer używany do identyfikowania plików zasobów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość jest równa 0xBEEFCACE. Pierwsze cztery bajty domyślny format pliku systemu zawierają całkowita 32-bitowej w formacie little-endian (zobacz <xref:System.Text.Encoding>).  
  
 Jeśli <xref:System.Resources.ResourceManager.MagicNumber> zostanie znaleziony, bajty następujący będzie numer wersji <xref:System.Resources.ResourceManager> nagłówka, a następnie liczbę określającą liczbę bajtów ma być pomijana, aby pokonać ten nagłówek. Kolejny numer wskazuje wersję <xref:System.Resources.ResourceManager> które tworzone nagłówka, następuje określone informacje o wersji.  
  
 Numer wersji dla bieżącej implementacji jest jednym. Następne bajty są poprzedzone długość ciąg zawierający nazwę <xref:System.Resources.IResourceReader>, który może odczytać ten plik.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MainAssembly">
      <MemberSignature Language="C#" Value="protected System.Reflection.Assembly MainAssembly;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Reflection.Assembly MainAssembly" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MainAssembly" />
      <MemberSignature Language="VB.NET" Value="Protected MainAssembly As Assembly " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Reflection::Assembly ^ MainAssembly;" />
      <MemberSignature Language="F#" Value="val mutable MainAssembly : System.Reflection.Assembly" Usage="System.Resources.ResourceManager.MainAssembly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa główny zestaw, który zawiera zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.MainAssembly> Pola przydaje się tylko wtedy, gdy napisać własne klasy, która pochodzi od klasy <xref:System.Resources.ResourceManager> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllResources">
      <MemberSignature Language="C#" Value="public virtual void ReleaseAllResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseAllResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.ReleaseAllResources" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReleaseAllResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseAllResources();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseAllResources : unit -&gt; unit&#xA;override this.ReleaseAllResources : unit -&gt; unit" Usage="resourceManager.ReleaseAllResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Informuje Menedżera zasobów, aby wywołać <see cref="M:System.Resources.ResourceSet.Close" /> metody na wszystkich <see cref="T:System.Resources.ResourceSet" /> obiektów i zwolnić wszystkie zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda będzie się zmniejszać zestaw roboczy w uruchomionej aplikacji. Wszystkie odnośniki przyszłych zasobów, w tym <xref:System.Resources.ResourceManager> obiekt będzie jak kosztowne jako pierwszy wyszukiwania, ponieważ Menedżer zasobów będzie miał do wyszukiwania i załadować zasoby ponownie. Może to być przydatne w przypadku niektórych złożonych scenariuszy wątków, w przypadku, gdy tworzenie nowego <xref:System.Resources.ResourceManager> obiektu jest odpowiednie działanie.  
  
> [!NOTE]
>  Począwszy od programu .NET Framework w wersji 2.0, <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> metoda nie jest bezpieczny wątkowo w odniesieniu do <xref:System.Resources.ResourceManager.GetObject%2A>, <xref:System.Resources.ResourceManager.GetString%2A>, i <xref:System.Resources.ResourceManager.GetStream%2A> operacji. Zaletą tej zmiany jest zwiększenie wydajności dla wielu wątków, wymagające dostępu do zasobów. Jednak jeśli wywołasz <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> metody w jednym wątku podczas jednoczesnego pobierania zasobu w innym wątku, operacji pobierania może zgłosić <xref:System.ObjectDisposedException> wyjątku.  
  
 Umożliwia także tę metodę w sytuacjach, w których mają wystąpień zarządzanych zasobów, w ramach bieżącej usługi resource manager mogą być wprowadzane w sposób deterministyczny, bez konieczności oczekiwania na Menedżera zasobów całkowicie wykraczają poza zakres i się bezużyteczne.  
  
> [!NOTE]
>  Wywołanie tej metody nie spowoduje usunięcia zestawów satelickich. Aby zwolnić zestawów satelickich, należy użyć <xref:System.AppDomain.Unload%2A> metody.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ResourceSets">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable ResourceSets;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Collections.Hashtable ResourceSets" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.ResourceSets" />
      <MemberSignature Language="VB.NET" Value="Protected ResourceSets As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Collections::Hashtable ^ ResourceSets;" />
      <MemberSignature Language="F#" Value="val mutable ResourceSets : System.Collections.Hashtable" Usage="System.Resources.ResourceManager.ResourceSets" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("call InternalGetResourceSet instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera <see cref="T:System.Collections.Hashtable" /> zwracającego mapowanie z kultur, aby <see cref="T:System.Resources.ResourceSet" /> obiektów.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResourceSetType">
      <MemberSignature Language="C#" Value="public virtual Type ResourceSetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ResourceSetType" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.ResourceSetType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ResourceSetType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ResourceSetType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ResourceSetType : Type" Usage="System.Resources.ResourceManager.ResourceSetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ obiektu zestaw zasobów, korzystającą z usługi resource manager w celu utworzenia <see cref="T:System.Resources.ResourceSet" /> obiektu.</summary>
        <value>Typ zasobu zestawu obiekt, który korzysta z usługi resource manager do konstruowania <see cref="T:System.Resources.ResourceSet" /> obiektu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
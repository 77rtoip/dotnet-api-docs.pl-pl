<Type Name="SslStream" FullName="System.Net.Security.SslStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="595c8b079b56e602a81ac703884f6eee7a00231b" />
    <Meta Name="ms.sourcegitcommit" Value="b3480b6208c3cad466469e76294a96f5ab1ef04c" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/16/2018" />
    <Meta Name="ms.locfileid" Value="35691849" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SslStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SslStream extends System.Net.Security.AuthenticatedStream implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.SslStream" />
  <TypeSignature Language="VB.NET" Value="Public Class SslStream&#xA;Inherits AuthenticatedStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class SslStream : System::Net::Security::AuthenticatedStream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia strumień używany do komunikacji klient serwer, który korzysta z protokołu zabezpieczeń Secure Socket Layer (SSL) do uwierzytelniania serwera i opcjonalnie klienta.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły SSL pomoc, aby zagwarantować poufność i integralności sprawdzanie wiadomości przesyłane przy użyciu <xref:System.Net.Security.SslStream>. Połączenie SSL, takim jak udostępniany przez <xref:System.Net.Security.SslStream>, powinna być używana, jeśli komunikacji poufnych informacji między klientem serwerem. Przy użyciu <xref:System.Net.Security.SslStream> pomaga uniemożliwia odczytywanie i manipulowanie informacji podczas przesyłania w sieci.  
  
 <xref:System.Net.Security.SslStream> Wystąpienia przesyła dane przy użyciu wprowadzona podczas tworzenia strumienia <xref:System.Net.Security.SslStream>. Jeśli podasz to zasadniczy strumień masz możliwość określenia, czy zamknięcia <xref:System.Net.Security.SslStream> zamyka również odpowiedniego strumienia. Zazwyczaj <xref:System.Net.Security.SslStream> klasa jest używana z <xref:System.Net.Sockets.TcpClient> i <xref:System.Net.Sockets.TcpListener> klasy. <xref:System.Net.Sockets.TcpClient.GetStream%2A> Metoda zapewnia <xref:System.Net.Sockets.NetworkStream> odpowiednie do użycia z <xref:System.Net.Security.SslStream> klasy.  
  
 Po utworzeniu <xref:System.Net.Security.SslStream>, serwer i opcjonalnie, klient musi zostać uwierzytelniony. Serwer musi dostarczyć X509 certyfikatu, która określa dowodu tożsamości i mogą żądać, że klient także zrobić. Uwierzytelnianie odbywa się przed przesłaniem informacji za pomocą <xref:System.Net.Security.SslStream>. Klienci inicjują uwierzytelnianie przy użyciu synchronicznej <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> metod, które blokują dopiero po zakończeniu uwierzytelniania, lub asynchroniczną <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> metody, które nie blokują oczekiwanie na ukończenie uwierzytelniania. Serwery inicjującej uwierzytelnianie przy użyciu synchronicznej <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> lub asynchroniczne <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metody. Zarówno klient, jak i serwer muszą inicjować uwierzytelniania.  
  
 Uwierzytelnianie jest obsługiwane przez dostawcę kanałów dostawcy obsługi zabezpieczeń (SSPI). Klient jest możliwość kontrolowania weryfikacji certyfikatu serwera, określając <xref:System.Net.Security.RemoteCertificateValidationCallback> delegować podczas tworzenia <xref:System.Net.Security.SslStream>. Serwer można również sterować sprawdzania poprawności, podając <xref:System.Net.Security.RemoteCertificateValidationCallback> delegowanie. Metoda odwołuje się do delegata zawiera strona zdalna certyfikatu oraz wszelkie błędy podczas sprawdzania poprawności certyfikatu SSPI. Należy pamiętać, że jeśli serwer określa delegata, metoda obiektu delegowanego została wywołana niezależnie od tego, czy serwer zażądał uwierzytelnienia klienta. Jeśli serwer nie przedstawiano żądania uwierzytelniania klienta, metoda obiektu delegowanego serwera otrzymuje certyfikat null i pustą tablicę błędów certyfikatów.  
  
 Jeśli serwer wymaga uwierzytelnienia klienta, klient musi określić co najmniej jednego certyfikatu uwierzytelniania. Jeśli klient ma więcej niż jeden certyfikat, klient może dostarczyć <xref:System.Net.Security.LocalCertificateSelectionCallback> pełnomocnika, aby wybrać odpowiedni certyfikat dla serwera. Certyfikaty klienta muszą znajdować się w bieżącym "Mój" magazynu certyfikatów użytkownika. Uwierzytelnianie klienta przy użyciu certyfikatów nie jest obsługiwane dla <xref:System.Security.Authentication.SslProtocols.Ssl2> protokołu (SSL wersja 2).  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>i <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 Podczas procesu uwierzytelniania, znanej także jako uzgadniania protokołu SSL zakończy się powodzeniem, ustanawiane tożsamości serwera (i opcjonalnie klienta) i <xref:System.Net.Security.SslStream> mogą służyć przez klienta i serwera do wymiany wiadomości. Przed wysyłania i odbierania informacji, klient i serwer należy sprawdzić zabezpieczeń usług i poziomy podał <xref:System.Net.Security.SslStream> ustalenie, czy protokół, algorytmów i sile wybrane spełniają ich wymagania dotyczące integralności i poufności. Jeśli bieżące ustawienia nie są wystarczające, należy zamknąć strumienia. Można sprawdzić zabezpieczeń usługi świadczone przez <xref:System.Net.Security.SslStream> przy użyciu <xref:System.Net.Security.SslStream.IsEncrypted%2A> i <xref:System.Net.Security.SslStream.IsSigned%2A> właściwości. W poniższej tabeli przedstawiono elementy, które zgłosiły ustawienia kryptograficzne używane do uwierzytelniania, szyfrowania i podpisywania danych.  
  
|Element|Elementy członkowskie|  
|-------------|-------------|  
|Protokół zabezpieczeń używany do uwierzytelniania serwera i, opcjonalnie, klient.|<xref:System.Net.Security.SslStream.SslProtocol%2A> Właściwości oraz skojarzonych z nimi <xref:System.Security.Authentication.SslProtocols> wyliczenia.|  
|Określony algorytm wymiany kluczy.|<xref:System.Net.Security.SslStream.KeyExchangeAlgorithm%2A> Właściwości oraz skojarzonych z nimi <xref:System.Security.Authentication.ExchangeAlgorithmType> wyliczenia.|  
|Algorytm integralności komunikatu.|<xref:System.Net.Security.SslStream.HashAlgorithm%2A> Właściwości oraz skojarzonych z nimi <xref:System.Security.Authentication.HashAlgorithmType> wyliczenia.|  
|Algorytm poufności wiadomości.|<xref:System.Net.Security.SslStream.CipherAlgorithm%2A> Właściwości oraz skojarzonych z nimi <xref:System.Security.Authentication.CipherAlgorithmType> wyliczenia.|  
|Sile wybrane algorytmy.|<xref:System.Net.Security.SslStream.KeyExchangeStrength%2A>, <xref:System.Net.Security.SslStream.HashStrength%2A>, I <xref:System.Net.Security.SslStream.CipherStrength%2A> właściwości.|  
  
 Po pomyślnym uwierzytelnieniu można wysyłać dane przy użyciu synchronicznej <xref:System.Net.Security.SslStream.Write%2A> lub asynchroniczne <xref:System.Net.Security.SslStream.BeginWrite%2A> metody. Użytkownik może odbierać dane przy użyciu synchronicznej <xref:System.Net.Security.SslStream.Read%2A> lub asynchroniczne <xref:System.Net.Security.SslStream.BeginRead%2A> metody.  
  
 Jeśli określono, aby <xref:System.Net.Security.SslStream.%23ctor%2A> że zasadniczy strumień należy pozostawić otwarty, jest odpowiedzialny za strumieniu zamknięcia, gdy wszystko będzie gotowe przy jej użyciu.  
  
> [!NOTE]
>  Jeśli aplikacja tworzącą <xref:System.Net.Security.SslStream> obiektu jest uruchamiane przy użyciu poświadczeń zwykłego użytkownika, aplikacja nie będzie mieć możliwość dostępu certyfikaty zainstalowane w magazynie komputera lokalnego, chyba że uprawnienia jawnie przypisany do użytkownika w tym celu.  
  
 <xref:System.Net.Security.SslStream> zakłada się, że przekroczono limit wraz ze wszystkimi innymi <xref:System.IO.IOException> po generowany jest jeden ze strumienia wewnętrzny będzie traktowany jako krytyczny przez swojego obiektu wywołującego. Ponowne wykorzystywanie <xref:System.Net.Security.SslStream> wystąpienie po przekroczenie limitu czasu, którą będzie zwracać pamięci. Aplikacja powinna <xref:System.IO.Stream.Close%2A> <xref:System.Net.Security.SslStream> i zgłosić wyjątek w tych przypadkach.  
  
 .NET Framework 4.6 obejmuje nowa funkcja zabezpieczeń, która blokuje niezabezpieczonych szyfrowania i tworzenia skrótów algorytmów dla połączenia. Aplikacji przy użyciu protokołu TLS/SSL za pośrednictwem interfejsów API, takich jak HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream, itp. oraz przeznaczonych dla platformy .NET Framework 4.6 uzyskać bardziej bezpiecznych zachowanie domyślne.  
  
 Deweloperzy mogą chcesz zrezygnować z tego zachowania, aby zapewnić współdziałanie z ich istniejących SSL3 usług protokołu TLS lub z usługi szyfrowania RC4. [W tym artykule](https://support.microsoft.com/kb/3069494) wyjaśniono, jak zmodyfikować kod, tak aby nowe zachowanie jest wyłączona.  
  
 .NET Framework 4.7 dodaje nowe przeciążenia dla metod, które uwierzytelniają SslStreams, nie można określić wersji protokołu TLS, ale zamiast tego użyć TLS, wersja zdefiniowany jako domyślny system w [SCHANNEL](https://msdn.microsoft.com/library/windows/desktop/aa380123.aspx). Użyj tych metod w aplikacji w sposób, aby można było później zmodyfikować ustawienia domyślne jako zmiany najlepsze praktyki wersji protokołu TLS w czasie, bez konieczności ponowne skompilowanie i wdrożenie aplikacji.

 Zobacz też [zabezpieczeń TLS (Transport Layer) najlepsze rozwiązania w środowisku .NET Framework](~/docs/framework/network-programming/tls.md).
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano tworzenie <xref:System.Net.Sockets.TcpListener> używającą <xref:System.Net.Security.SslStream> klasy do komunikacji z klientami.  
  
 [!code-cpp[NclSslServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#0)]
 [!code-csharp[NclSslServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#0)]  
  
 W poniższym przykładzie kodu pokazano tworzenie <xref:System.Net.Sockets.TcpClient> używającą <xref:System.Net.Security.SslStream> klasy do komunikowania się z serwerem.  
  
 [!code-cpp[NclSslClientSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#0)]
 [!code-csharp[NclSslClientSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#0)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Security.NegotiateStream" />
    <altmember cref="T:System.Net.Security.AuthenticatedStream" />
    <altmember cref="T:System.IO.IOException" />
    <altmember cref="T:System.IO.Stream" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Security.SslStream" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapobiec <xref:System.Net.Security.SslStream> zamknięcie strumienia, który zostanie podana, użyj funkcji <xref:System.Net.Security.SslStream.%23ctor%2A> konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream">A <see cref="T:System.IO.Stream" /> obiekt używany przez <see cref="T:System.Net.Security.SslStream" /> do wysyłania i odbierania danych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Security.SslStream" /> przy użyciu określonego <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość nie jest określona w pliku konfiguracji encryptionpolicy, <xref:System.Net.Security.EncryptionPolicy> domyślnie <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> dla <xref:System.Net.Security.SslStream> wystąpienia, który jest tworzony.  
  
 Korzystanie z szyfrowania Null jest wymagane, gdy zasady szyfrowania jest ustawione na <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> nie jest do odczytu.  - lub - <paramref name="innerStream" /> nie jest zapisywalny.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> jest <see langword="null" />.  - lub - <paramref name="innerStream" /> jest równa <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream">A <see cref="T:System.IO.Stream" /> obiekt używany przez <see cref="T:System.Net.Security.SslStream" /> do wysyłania i odbierania danych.</param>
        <param name="leaveInnerStreamOpen">Wartość logiczna, która wskazuje zachowanie zamknięcia <see cref="T:System.IO.Stream" /> obiekt używany przez <see cref="T:System.Net.Security.SslStream" /> do wysyłania i odbierania danych. Ten parametr wskazuje, czy wewnętrzny strumienia pozostanie otwarte.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Security.SslStream" /> przy użyciu określonego <see cref="T:System.IO.Stream" /> i zachowanie zamknięcie strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu `true` dla `leaveStreamOpen` parametru zamknięcia <xref:System.Net.Security.SslStream> nie ma wpływu `innerStream` strumienia; należy jawnie zamknąć `innerStream` gdy nie jest już potrzebne.  
  
 Jeśli wartość nie jest określona w pliku konfiguracji encryptionpolicy, <xref:System.Net.Security.EncryptionPolicy> domyślnie <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> dla <xref:System.Net.Security.SslStream> wystąpienia, który jest tworzony.  
  
 Korzystanie z szyfrowania Null jest wymagane, gdy zasady szyfrowania jest ustawione na <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wywołanie tego konstruktora.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> nie jest do odczytu.  - lub - <paramref name="innerStream" /> nie jest zapisywalny.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> jest <see langword="null" />.  - lub - <paramref name="innerStream" /> jest równa <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean, userCertificateValidationCallback As RemoteCertificateValidationCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream">A <see cref="T:System.IO.Stream" /> obiekt używany przez <see cref="T:System.Net.Security.SslStream" /> do wysyłania i odbierania danych.</param>
        <param name="leaveInnerStreamOpen">Wartość logiczna, która wskazuje zachowanie zamknięcia <see cref="T:System.IO.Stream" /> obiekt używany przez <see cref="T:System.Net.Security.SslStream" /> do wysyłania i odbierania danych. Ten parametr wskazuje, czy wewnętrzny strumienia pozostanie otwarte.</param>
        <param name="userCertificateValidationCallback">A <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> delegata odpowiedzialne za zatwierdzanie certyfikat dostarczony przez komputer zdalny.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Security.SslStream" /> przy użyciu określonego <see cref="T:System.IO.Stream" />, strumienia zachowanie zamknięcia i delegata sprawdzania poprawności certyfikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu `true` dla `leaveStreamOpen` parametru zamknięcia <xref:System.Net.Security.SslStream> nie ma wpływu `innerStream` strumienia; należy jawnie zamknąć `innerStream` gdy nie jest już potrzebne.  
  
 `userCertificateValidationCallback` Pełnomocnika `certificateErrors` argument zawiera kody błędów systemu Windows, zwrócony przez kanał interfejsu dostawcy obsługi zabezpieczeń (SSPI). Zwracana wartość metody wywoływane przez `userCertificateValidationCallback` delegata Określa, czy uwierzytelnianie zakończy się pomyślnie.  
  
 Protokół zabezpieczeń i algorytmy kryptograficzne są już zaznaczone, gdy `userCertificateValidationCallback` delegata wywołania metody. Metoda służy do ustalenia, czy wybranego algorytmów kryptograficznych i sile są wystarczające dla aplikacji. Jeśli nie, metoda powinna zwrócić `false` zapobiegające <xref:System.Net.Security.SslStream> utworzenie.  
  
 Jeśli wartość nie jest określona w pliku konfiguracji encryptionpolicy, <xref:System.Net.Security.EncryptionPolicy> domyślnie <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> dla <xref:System.Net.Security.SslStream> wystąpienia, który jest tworzony.  
  
 Korzystanie z szyfrowania Null jest wymagane, gdy zasady szyfrowania jest ustawione na <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Platformę buforuje sesji SSL, tworzonych i podejmie próbę ponownego użycia pamięci podręcznej sesji dla nowego żądania, jeśli to możliwe. Podczas próby ponownego użycia sesji SSL, platformę używa pierwszego elementu obiektu <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (jeśli istnieje), lub spróbuje ponownie użyć sesji anonimowe, jeśli <xref:System.Net.HttpWebRequest.ClientCertificates%2A> jest pusta.  
  
> [!NOTE]
>  Certyfikaty klienta są nieobsługiwane w wersji 2 protokołu SSL.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.Security.SslStream> i inicjuje część kliencką uwierzytelniania.  
  
 [!code-cpp[NclSslClientSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#4)]
 [!code-csharp[NclSslClientSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> nie jest do odczytu.  - lub - <paramref name="innerStream" /> nie jest zapisywalny.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> jest <see langword="null" />.  - lub - <paramref name="innerStream" /> jest równa <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean, userCertificateValidationCallback As RemoteCertificateValidationCallback, userCertificateSelectionCallback As LocalCertificateSelectionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback, System::Net::Security::LocalCertificateSelectionCallback ^ userCertificateSelectionCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream">A <see cref="T:System.IO.Stream" /> obiekt używany przez <see cref="T:System.Net.Security.SslStream" /> do wysyłania i odbierania danych.</param>
        <param name="leaveInnerStreamOpen">Wartość logiczna, która wskazuje zachowanie zamknięcia <see cref="T:System.IO.Stream" /> obiekt używany przez <see cref="T:System.Net.Security.SslStream" /> do wysyłania i odbierania danych. Ten parametr wskazuje, czy wewnętrzny strumienia pozostanie otwarte.</param>
        <param name="userCertificateValidationCallback">A <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> delegata odpowiedzialne za zatwierdzanie certyfikat dostarczony przez komputer zdalny.</param>
        <param name="userCertificateSelectionCallback">A <see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> delegata odpowiedzialny za wybranie certyfikatu służącego do uwierzytelniania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Security.SslStream" /> przy użyciu określonego <see cref="T:System.IO.Stream" />, strumienia zachowanie zamknięcia, delegat weryfikacji certyfikatu a obiektem delegowanym wyboru certyfikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu `true` dla `leaveStreamOpen` parametru zamknięcia <xref:System.Net.Security.SslStream> nie ma wpływu `innerStream` strumienia; należy jawnie zamknąć `innerStream` gdy nie jest już potrzebne.  
  
 `userCertificateValidationCallback` Pełnomocnika `certificateErrors` argument zawiera kody błędów systemu Windows, zwrócony przez kanał interfejsu dostawcy obsługi zabezpieczeń (SSPI). Zwracana wartość metody wywoływane przez `userCertificateValidationCallback` delegata Określa, czy uwierzytelnianie zakończy się pomyślnie.  
  
 Protokół zabezpieczeń i algorytmy kryptograficzne są już zaznaczone, gdy `userCertificateValidationCallback` delegata wywołania metody. Metoda służy do ustalenia, czy wybranego algorytmów kryptograficznych i sile są wystarczające dla aplikacji. Jeśli nie, metoda powinna zwrócić `false` zapobiegające <xref:System.Net.Security.SslStream> utworzenie.  
  
 `userCertificateSelectionCallback` Delegata jest przydatne, gdy aplikacja ma wiele certyfikatów i dynamicznie musisz wybrać certyfikat. Certyfikaty w magazynie "MY" są przekazywane do metody wywoływane przez delegata.  
  
 Jeśli wartość nie jest określona w pliku konfiguracji encryptionpolicy, <xref:System.Net.Security.EncryptionPolicy> domyślnie <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> dla <xref:System.Net.Security.SslStream> wystąpienia, który jest tworzony.  
  
 Korzystanie z szyfrowania Null jest wymagane, gdy zasady szyfrowania jest ustawione na <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Platformę buforuje sesji SSL, tworzonych i podejmie próbę ponownego użycia pamięci podręcznej sesji dla nowego żądania, jeśli to możliwe. Podczas próby ponownego użycia sesji SSL, platformę używa pierwszego elementu obiektu P:System.Net.HttpWebRequest.ClientCertificates (jeśli istnieje) lub próbuje ponownie wykorzystać anonimowy sesji, jeśli P:System.Net.HttpWebRequest.ClientCertificates jest pusta.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wywołanie tego konstruktora. Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Net.Security.SslStream> klasy.  
  
 [!code-cpp[NclSslClientAsync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#6)]
 [!code-csharp[NclSslClientAsync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> nie jest do odczytu.  - lub - <paramref name="innerStream" /> nie jest zapisywalny.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> jest <see langword="null" />.  - lub - <paramref name="innerStream" /> jest równa <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, System.Net.Security.EncryptionPolicy encryptionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, valuetype System.Net.Security.EncryptionPolicy encryptionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback,System.Net.Security.EncryptionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback, System::Net::Security::LocalCertificateSelectionCallback ^ userCertificateSelectionCallback, System::Net::Security::EncryptionPolicy encryptionPolicy);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("encryptionPolicy is ignored")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" />
        <Parameter Name="encryptionPolicy" Type="System.Net.Security.EncryptionPolicy" />
      </Parameters>
      <Docs>
        <param name="innerStream">A <see cref="T:System.IO.Stream" /> obiekt używany przez <see cref="T:System.Net.Security.SslStream" /> do wysyłania i odbierania danych.</param>
        <param name="leaveInnerStreamOpen">Wartość logiczna, która wskazuje zachowanie zamknięcia <see cref="T:System.IO.Stream" /> obiekt używany przez <see cref="T:System.Net.Security.SslStream" /> do wysyłania i odbierania danych. Ten parametr wskazuje, czy wewnętrzny strumienia pozostanie otwarte.</param>
        <param name="userCertificateValidationCallback">A <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> delegata odpowiedzialne za zatwierdzanie certyfikat dostarczony przez komputer zdalny.</param>
        <param name="userCertificateSelectionCallback">A <see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> delegata odpowiedzialny za wybranie certyfikatu służącego do uwierzytelniania.</param>
        <param name="encryptionPolicy">
          <see cref="T:System.Net.Security.EncryptionPolicy" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Security.SslStream" /> przy użyciu określonego <see cref="T:System.IO.Stream" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystanie z szyfrowania Null, jest wymagany, gdy `encryptionPolicy` ustawiono parametr <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="innerStream" /> nie jest do odczytu.  - lub - <paramref name="innerStream" /> nie jest zapisywalny.  - lub - <paramref name="encryptionPolicy" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> jest <see langword="null" />.  - lub - <paramref name="innerStream" /> jest równa <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uwierzytelnianie po stronie klienta połączenia klient serwer.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClient(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, które współużytkują to <see cref="T:System.Net.Security.SslStream" />.</param>
        <summary>Metoda wywoływana przez klientów do uwierzytelniania serwera i opcjonalnie klienta w ramach połączenia klient serwer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Nie certyfikaty klienta są używane w uwierzytelniania. Lista odwołania certyfikatów nie jest sprawdzana podczas uwierzytelniania. Wartość określona dla `targetHost` musi być zgodna z nazwą w certyfikacie serwera.  
  
 Gdy uwierzytelnianie zakończy się powodzeniem, należy zaznaczyć <xref:System.Net.Security.SslStream.IsEncrypted%2A> i <xref:System.Net.Security.SslStream.IsSigned%2A> właściwości, aby ustalić, jakie usługi zabezpieczeń są używane przez <xref:System.Net.Security.SslStream>. Sprawdź <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> właściwości w celu określenia, czy wystąpiły wzajemnego uwierzytelniania.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Błąd już wystąpił uwierzytelniania.  - lub - uwierzytelniania serwera za pomocą tej <see cref="T:System.Net.Security.SslStream" /> została wcześniej zainstalowana.  - lub - uwierzytelniania jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String, clientCertificates As X509CertificateCollection, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, który będzie udostępniać to <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates">
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawiera certyfikaty klienta.</param>
        <param name="checkCertificateRevocation">A <see cref="T:System.Boolean" /> wartość, która określa, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Metoda wywoływana przez klientów do uwierzytelniania serwera i opcjonalnie klienta w ramach połączenia klient serwer. Proces uwierzytelniania używa kolekcja określonego certyfikatu i protokołu SSL domyślne systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Gdy uwierzytelnianie zakończy się powodzeniem, należy zaznaczyć <xref:System.Net.Security.SslStream.IsEncrypted%2A> i <xref:System.Net.Security.SslStream.IsSigned%2A> właściwości, aby ustalić, jakie usługi zabezpieczeń są używane przez <xref:System.Net.Security.SslStream>. Sprawdź <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> właściwości w celu określenia, czy wystąpiły wzajemnego uwierzytelniania.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
> [!NOTE]
>  Certyfikaty klienta są nieobsługiwane w wersji 2 protokołu SSL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String, clientCertificates As X509CertificateCollection, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, który będzie udostępniać to <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates">
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawiera certyfikaty klienta.</param>
        <param name="enabledSslProtocols">
          <see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</param>
        <param name="checkCertificateRevocation">A <see cref="T:System.Boolean" /> wartość, która określa, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Metoda wywoływana przez klientów do uwierzytelniania serwera i opcjonalnie klienta w ramach połączenia klient serwer. Proces uwierzytelniania używa certyfikatu określonej kolekcji i protokołu SSL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Gdy uwierzytelnianie zakończy się powodzeniem, należy zaznaczyć <xref:System.Net.Security.SslStream.IsEncrypted%2A> i <xref:System.Net.Security.SslStream.IsSigned%2A> właściwości, aby ustalić, jakie usługi zabezpieczeń są używane przez <xref:System.Net.Security.SslStream>. Sprawdź <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> właściwości w celu określenia, czy wystąpiły wzajemnego uwierzytelniania.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
> [!NOTE]
>  Certyfikaty klienta są nieobsługiwane w wersji 2 protokołu SSL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClientAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uwierzytelnianie po stronie klienta połączenia klient serwer jako operację asynchroniczną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClientAsync(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, które współużytkują to <see cref="T:System.Net.Security.SslStream" />.</param>
        <summary>Metoda wywoływana przez klientów do uwierzytelniania serwera i opcjonalnie klienta w przypadku połączenia klient serwer jako operację asynchroniczną.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task" /> obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Nie certyfikaty klienta są używane w uwierzytelniania. Lista odwołania certyfikatów nie jest sprawdzana podczas uwierzytelniania. Wartość określona dla `targetHost` musi być zgodna z nazwą w certyfikacie serwera.  
  
 Gdy uwierzytelnianie zakończy się powodzeniem, należy zaznaczyć <xref:System.Net.Security.SslStream.IsEncrypted%2A> i <xref:System.Net.Security.SslStream.IsSigned%2A> właściwości, aby ustalić, jakie usługi zabezpieczeń są używane przez <xref:System.Net.Security.SslStream>. Sprawdź <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> właściwości w celu określenia, czy wystąpiły wzajemnego uwierzytelniania.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Błąd już wystąpił uwierzytelniania.  - lub - uwierzytelniania serwera za pomocą tej <see cref="T:System.Net.Security.SslStream" /> została wcześniej zainstalowana.  - lub - uwierzytelniania jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.Security.SslClientAuthenticationOptions sslClientAuthenticationOptions, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.Security.SslClientAuthenticationOptions sslClientAuthenticationOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.Net.Security.SslClientAuthenticationOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::Security::SslClientAuthenticationOptions ^ sslClientAuthenticationOptions, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sslClientAuthenticationOptions" Type="System.Net.Security.SslClientAuthenticationOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="sslClientAuthenticationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String, clientCertificates As X509CertificateCollection, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, który będzie udostępniać to <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates">
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawiera certyfikaty klienta.</param>
        <param name="checkCertificateRevocation">A <see cref="T:System.Boolean" /> wartość, która określa, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Metoda wywoływana przez klientów do uwierzytelniania serwera i opcjonalnie klienta w przypadku połączenia klient serwer jako operację asynchroniczną. Proces uwierzytelniania używa kolekcja określonego certyfikatu i protokołu SSL domyślne systemu.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Gdy uwierzytelnianie zakończy się powodzeniem, należy zaznaczyć <xref:System.Net.Security.SslStream.IsEncrypted%2A> i <xref:System.Net.Security.SslStream.IsSigned%2A> właściwości, aby ustalić, jakie usługi zabezpieczeń są używane przez <xref:System.Net.Security.SslStream>. Sprawdź <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> właściwości w celu określenia, czy wystąpiły wzajemnego uwierzytelniania.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
> [!NOTE]
>  Certyfikaty klienta są nieobsługiwane w wersji 2 protokołu SSL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String, clientCertificates As X509CertificateCollection, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, który będzie udostępniać to <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates">
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawiera certyfikaty klienta.</param>
        <param name="enabledSslProtocols">
          <see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</param>
        <param name="checkCertificateRevocation">A <see cref="T:System.Boolean" /> wartość, która określa, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Metoda wywoływana przez klientów do uwierzytelniania serwera i opcjonalnie klienta w przypadku połączenia klient serwer jako operację asynchroniczną. Proces uwierzytelniania używa certyfikatu określonej kolekcji i protokołu SSL.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task" /> obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Gdy uwierzytelnianie zakończy się powodzeniem, należy zaznaczyć <xref:System.Net.Security.SslStream.IsEncrypted%2A> i <xref:System.Net.Security.SslStream.IsSigned%2A> właściwości, aby ustalić, jakie usługi zabezpieczeń są używane przez <xref:System.Net.Security.SslStream>. Sprawdź <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> właściwości w celu określenia, czy wystąpiły wzajemnego uwierzytelniania.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
> [!NOTE]
>  Certyfikaty klienta są nieobsługiwane w wersji 2 protokołu SSL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Metoda wywoływana przez serwery do uwierzytelniania serwera i opcjonalnie klienta w ramach połączenia klient serwer.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certyfikat używany do uwierzytelniania serwera.</param>
        <summary>Metoda wywoływana przez serwery do uwierzytelniania serwera i opcjonalnie klienta w przypadku połączenia klient serwer przy użyciu określonego certyfikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Lista odwołania certyfikatów nie jest sprawdzana podczas uwierzytelniania. Klient nie jest wymagane do zapewnienia certyfikatu uwierzytelniania.  
  
 Ta metoda umożliwia blokowanie przed zakończeniem operacji. Aby uniknąć zablokowania przed zakończeniem operacji, użyj jednej z <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> przeciążenia metody.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Błąd już wystąpił uwierzytelniania.  - lub - uwierzytelniania klienta za pomocą tej <see cref="T:System.Net.Security.SslStream" /> została wcześniej zainstalowana.  - lub - uwierzytelniania jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> Metoda nie jest obsługiwana w systemie Windows 95, Windows 98 lub Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certyfikacie x 509 używany do uwierzytelniania serwera.</param>
        <param name="clientCertificateRequired">A <see cref="T:System.Boolean" /> wartość, która określa, czy klient jest podanie certyfikatu dla uwierzytelniania. Należy pamiętać, że to tylko żądania — Jeśli żaden certyfikat nie jest podany serwer nadal akceptuje żądania połączenia.</param>
        <param name="checkCertificateRevocation">A <see cref="T:System.Boolean" /> wartość, która określa, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Metoda wywoływana przez serwery do uwierzytelniania serwera i opcjonalnie klienta w przypadku połączenia klient serwer przy użyciu określonych certyfikatów i wymagania i przy użyciu protokołu zabezpieczeń domyślny system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Ta metoda umożliwia blokowanie przed zakończeniem operacji. Aby uniknąć zablokowania przed zakończeniem operacji, użyj jednej z <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> przeciążenia metody.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Błąd już wystąpił uwierzytelniania.  - lub - uwierzytelniania klienta za pomocą tej <see cref="T:System.Net.Security.SslStream" /> została wcześniej zainstalowana.  - lub - uwierzytelniania jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> Metoda nie jest obsługiwana w systemie Windows 95, Windows 98 lub Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certyfikacie x 509 używany do uwierzytelniania serwera.</param>
        <param name="clientCertificateRequired">A <see cref="T:System.Boolean" /> wartość, która określa, czy klient jest podanie certyfikatu dla uwierzytelniania. Należy pamiętać, że to tylko żądania — Jeśli żaden certyfikat nie jest podany serwer nadal akceptuje żądania połączenia.</param>
        <param name="enabledSslProtocols">
          <see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</param>
        <param name="checkCertificateRevocation">A <see cref="T:System.Boolean" /> wartość, która określa, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Metoda wywoływana przez serwery do uwierzytelniania serwera i opcjonalnie klienta w przypadku połączenia klient serwer przy użyciu określonych certyfikatów, wymagania i protokół zabezpieczeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Ta metoda umożliwia blokowanie przed zakończeniem operacji. Aby uniknąć zablokowania przed zakończeniem operacji, użyj jednej z <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> przeciążenia metody.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> nie jest prawidłową <see cref="T:System.Security.Authentication.SslProtocols" /> wartość.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Błąd już wystąpił uwierzytelniania.  - lub - uwierzytelniania klienta za pomocą tej <see cref="T:System.Net.Security.SslStream" /> została wcześniej zainstalowana.  - lub - uwierzytelniania jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> Metoda nie jest obsługiwana w systemie Windows 95, Windows 98 lub Windows Millennium.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Metoda wywoływana przez serwery do uwierzytelniania serwera i opcjonalnie klienta w przypadku połączenia klient serwer jako operację asynchroniczną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certyfikat używany do uwierzytelniania serwera.</param>
        <summary>Metoda wywoływana przez serwery do uwierzytelniania serwera i opcjonalnie klienta w przypadku połączenia klient serwer przy użyciu określonego certyfikatu jako operację asynchroniczną.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task" /> obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Ta metoda jest uwierzytelniany przy użyciu <xref:System.Security.Authentication.SslProtocols.Default>. Lista odwołania certyfikatów nie jest sprawdzana podczas uwierzytelniania. Klient nie jest wymagane do zapewnienia certyfikatu uwierzytelniania.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Błąd już wystąpił uwierzytelniania.  - lub - uwierzytelniania klienta za pomocą tej <see cref="T:System.Net.Security.SslStream" /> została wcześniej zainstalowana.  - lub - uwierzytelniania jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServerAsync" /> Metoda nie jest obsługiwana w systemie Windows 95, Windows 98 lub Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.Security.SslServerAuthenticationOptions sslServerAuthenticationOptions, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.Security.SslServerAuthenticationOptions sslServerAuthenticationOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Net.Security.SslServerAuthenticationOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::Security::SslServerAuthenticationOptions ^ sslServerAuthenticationOptions, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sslServerAuthenticationOptions" Type="System.Net.Security.SslServerAuthenticationOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="sslServerAuthenticationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certyfikacie x 509 używany do uwierzytelniania serwera.</param>
        <param name="clientCertificateRequired">A <see cref="T:System.Boolean" /> wartość, która określa, czy klient jest podanie certyfikatu dla uwierzytelniania. Należy pamiętać, że to tylko żądania — Jeśli żaden certyfikat nie jest podany serwer nadal akceptuje żądania połączenia.</param>
        <param name="checkCertificateRevocation">A <see cref="T:System.Boolean" /> wartość, która określa, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Metoda wywoływana przez serwery do uwierzytelniania serwera i opcjonalnie klienta w przypadku połączenia klient serwer przy użyciu określonych certyfikatów, wymagania i protokół zabezpieczeń jako operację asynchroniczną.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certyfikacie x 509 używany do uwierzytelniania serwera.</param>
        <param name="clientCertificateRequired">A <see cref="T:System.Boolean" /> wartość, która określa, czy klient jest podanie certyfikatu dla uwierzytelniania. Należy pamiętać, że to tylko żądania — Jeśli żaden certyfikat nie jest podany serwer nadal akceptuje żądania połączenia.</param>
        <param name="enabledSslProtocols">
          <see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</param>
        <param name="checkCertificateRevocation">A <see cref="T:System.Boolean" /> wartość, która określa, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Metoda wywoływana przez serwery do uwierzytelniania serwera i opcjonalnie klienta w przypadku połączenia klient serwer przy użyciu określonych certyfikatów, wymagania i protokół zabezpieczeń jako operację asynchroniczną.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task" /> obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację do uwierzytelnienia po stronie klienta połączenia klient serwer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenie tej metody nie blokują w trakcie uwierzytelniania. Aby zablokować podczas oczekiwania na ukończenie uwierzytelniania, użyj jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, które współużytkują to <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="asyncCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Obiekt użytkownika, który zawiera informacje na temat operacji. Ten obiekt jest przekazywany do <c>asyncCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Metoda wywoływana przez klientów, aby rozpocząć operację asynchroniczną do uwierzytelniania serwera i opcjonalnie klienta.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Nie certyfikaty klienta są używane w uwierzytelniania. Lista odwołania certyfikatów nie jest sprawdzana podczas uwierzytelniania.  
  
 Wartość określona dla `targetHost` musi być zgodna z nazwą w certyfikacie serwera.  
  
 Należy ukończyć operację asynchroniczną uwierzytelniania przez wywołanie metody <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegowanie.  
  
 Ta metoda nie są blokowane podczas operacji. Aby zablokować przed zakończeniem operacji, użyj jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Błąd już wystąpił uwierzytelniania.  - lub - uwierzytelniania serwera za pomocą tej <see cref="T:System.Net.Security.SslStream" /> została wcześniej zainstalowana.  - lub - uwierzytelniania jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, które współużytkują to <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates">
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawierające certyfikaty klienta.</param>
        <param name="checkCertificateRevocation">A <see cref="T:System.Boolean" /> wartość, która określa, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <param name="asyncCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Obiekt użytkownika, który zawiera informacje na temat operacji. Ten obiekt jest przekazywany do <c>asyncCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Metoda wywoływana przez klientów, aby rozpocząć operację asynchroniczną do uwierzytelniania serwera i opcjonalnie klienta przy użyciu określonych certyfikatów i domyślnym protokołem zabezpieczeń systemu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Wartość określona dla `targetHost` musi być zgodna z nazwą w certyfikacie serwera.  
  
 Należy ukończyć operację asynchroniczną uwierzytelniania przez wywołanie metody <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegowanie.  
  
 Ta metoda nie są blokowane podczas operacji. Aby zablokować przed zakończeniem operacji, użyj jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
> [!NOTE]
>  Certyfikaty klienta są nieobsługiwane w wersji 2 protokołu SSL.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Błąd już wystąpił uwierzytelniania.  - lub - uwierzytelniania serwera za pomocą tej <see cref="T:System.Net.Security.SslStream" /> została wcześniej zainstalowana.  - lub - uwierzytelniania jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, które współużytkują to <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates">
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawierające certyfikaty klienta.</param>
        <param name="enabledSslProtocols">
          <see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</param>
        <param name="checkCertificateRevocation">A <see cref="T:System.Boolean" /> wartość, która określa, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <param name="asyncCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Obiekt użytkownika, który zawiera informacje na temat operacji. Ten obiekt jest przekazywany do <c>asyncCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Metoda wywoływana przez klientów, aby rozpocząć operację asynchroniczną do uwierzytelniania serwera i opcjonalnie klienta przy użyciu określonych certyfikatów i protokołu zabezpieczeń.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Wartość określona dla `targetHost` musi być zgodna z nazwą w certyfikacie serwera.  
  
 Należy ukończyć operację asynchroniczną uwierzytelniania przez wywołanie metody <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegowanie.  
  
 Ta metoda nie są blokowane podczas operacji. Aby zablokować przed zakończeniem operacji, użyj jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
> [!NOTE]
>  Certyfikaty klienta są nieobsługiwane w wersji 2 protokołu SSL.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetHost" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> nie jest prawidłową <see cref="T:System.Security.Authentication.SslProtocols" /> wartość.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Błąd już wystąpił uwierzytelniania.  - lub - uwierzytelniania serwera za pomocą tej <see cref="T:System.Net.Security.SslStream" /> została wcześniej zainstalowana.  - lub - uwierzytelniania jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację asynchroniczną do obsługi uwierzytelniania klient serwer połączenia po stronie serwera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenie tej metody nie blokują w trakcie uwierzytelniania. Aby zablokować podczas oczekiwania na ukończenie uwierzytelniania, użyj jednej z <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certyfikacie x 509 używany do uwierzytelniania serwera.</param>
        <param name="asyncCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Obiekt użytkownika, który zawiera informacje na temat operacji. Ten obiekt jest przekazywany do <c>asyncCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Metoda wywoływana przez serwery, aby rozpocząć operację asynchroniczną do uwierzytelniania klienta i opcjonalnie serwera w przypadku połączenia klient serwer.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Lista odwołania certyfikatów nie jest sprawdzana podczas uwierzytelniania. Klient nie jest wymagane do zapewnienia certyfikatu uwierzytelniania.  
  
 Należy ukończyć operację asynchroniczną uwierzytelniania przez wywołanie metody <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegowanie.  
  
 Ta metoda nie są blokowane podczas operacji. Aby zablokować przed zakończeniem operacji, użyj jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Błąd już wystąpił uwierzytelniania.  - lub - uwierzytelniania klienta za pomocą tej <see cref="T:System.Net.Security.SslStream" /> została wcześniej zainstalowana.  - lub - uwierzytelniania jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> Metoda nie jest obsługiwana w systemie Windows 95, Windows 98 lub Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certyfikacie x 509 używany do uwierzytelniania serwera.</param>
        <param name="clientCertificateRequired">A <see cref="T:System.Boolean" /> wartość, która określa, czy klient jest podanie certyfikatu dla uwierzytelniania. Należy pamiętać, że to tylko żądania — Jeśli żaden certyfikat nie jest podany serwer nadal akceptuje żądania połączenia.</param>
        <param name="checkCertificateRevocation">A <see cref="T:System.Boolean" /> wartość, która określa, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <param name="asyncCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Obiekt użytkownika, który zawiera informacje na temat operacji. Ten obiekt jest przekazywany do <c>asyncCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Metoda wywoływana przez serwery, aby rozpocząć operację asynchroniczną do uwierzytelniania serwera i opcjonalnie klienta przy użyciu określonych certyfikatów i wymagania i domyślnym protokołem zabezpieczeń systemu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Należy ukończyć operację asynchroniczną uwierzytelniania przez wywołanie metody <xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegowanie.  
  
 Ta metoda nie są blokowane podczas operacji. Aby zablokować przed zakończeniem operacji, użyj jednej z <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Błąd już wystąpił uwierzytelniania.  - lub - uwierzytelniania serwera za pomocą tej <see cref="T:System.Net.Security.SslStream" /> została wcześniej zainstalowana.  - lub - uwierzytelniania jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> Metoda nie jest obsługiwana w systemie Windows 95, Windows 98 lub Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certyfikacie x 509 używany do uwierzytelniania serwera.</param>
        <param name="clientCertificateRequired">A <see cref="T:System.Boolean" /> wartość, która określa, czy klient jest podanie certyfikatu dla uwierzytelniania. Należy pamiętać, że to tylko żądania — Jeśli żaden certyfikat nie jest podany serwer nadal akceptuje żądania połączenia.</param>
        <param name="enabledSslProtocols">
          <see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</param>
        <param name="checkCertificateRevocation">A <see cref="T:System.Boolean" /> wartość, która określa, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <param name="asyncCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Obiekt użytkownika, który zawiera informacje na temat operacji. Ten obiekt jest przekazywany do <c>asyncCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Metoda wywoływana przez serwery, aby rozpocząć operację asynchroniczną do uwierzytelniania serwera i opcjonalnie klienta przy użyciu określonych certyfikatów, wymagania i protokół zabezpieczeń.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Należy ukończyć operację asynchroniczną uwierzytelniania przez wywołanie metody <xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegowanie.  
  
 Ta metoda nie są blokowane podczas operacji. Aby zablokować przed zakończeniem operacji, użyj jednej z <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serverCertificate" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enabledSslProtocols" /> nie jest prawidłową <see cref="T:System.Security.Authentication.SslProtocols" /> wartość.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Błąd już wystąpił uwierzytelniania.  - lub - uwierzytelniania serwera za pomocą tej <see cref="T:System.Net.Security.SslStream" /> została wcześniej zainstalowana.  - lub - uwierzytelniania jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> Metoda nie jest obsługiwana w systemie Windows 95, Windows 98 lub Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">A <see cref="T:System.Byte" /> odczytać tablicy, która odbiera bajtów ze strumienia.</param>
        <param name="offset">Liczony od zera lokalizacja w <c>buforu</c> rozpoczęcia przechowywania danych przeczytanie tego strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania ze strumienia.</param>
        <param name="asyncCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji odczytu.</param>
        <param name="asyncState">Obiekt użytkownika, który zawiera informacje na temat operacji odczytu. Ten obiekt jest przekazywany do <c>asyncCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Rozpoczyna operację asynchroniczną odczytu, która odczytuje dane ze strumienia i zapisuje go w określonej tablicy.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po włączeniu szyfrowania i podpisywania operacja odczytu odczytuje dane z podstawowego strumienia, sprawdza integralność danych i/lub odszyfrowuje je. Operacja odczytu asynchronicznego musi wykonać wywołanie <xref:System.Net.Security.SslStream.EndRead%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegowanie.  
  
 Ta metoda nie są blokowane podczas operacji. Aby zablokować przed zakończeniem operacji, należy użyć <xref:System.Net.Security.SslStream.Read%2A> metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 <xref:System.Net.Security.SslStream> Klasa nie obsługuje wiele równoczesnych operacji odczytu.  
  
 Nie można wywołać tej metody, dopóki pomyślnym uwierzytelnieniu. Do uwierzytelnienia wywołania jedną <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, lub <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje uruchamiania asynchronicznych operacji odczytu.  
  
 [!code-cpp[NclSslClientAsync#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#8)]
 [!code-csharp[NclSslClientAsync#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#8)]  
  
 [!code-cpp[NclSslClientAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#4)]
 [!code-csharp[NclSslClientAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#4)]  
  
 Następująca metoda jest wywoływana po zakończeniu odczytu.  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; długość <paramref name="buffer" />.  - lub - <paramref name="offset" /> + liczba &gt; długość <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Operacja odczytu nie powiodła się.  - lub - szyfrowania jest używany, ale nie można odszyfrować danych.</exception>
        <exception cref="T:System.NotSupportedException">Istnieje już operacja odczytu w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie przeprowadzono uwierzytelniania.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">A <see cref="T:System.Byte" /> tablica, która dostarcza bajtów do zapisania w strumieniu.</param>
        <param name="offset">Liczony od zera lokalizacja w <c>buforu</c> w której ma zostać rozpoczęte odczytywanie bajtów do zapisania w strumieniu.</param>
        <param name="count">
          <see cref="T:System.Int32" /> Wartość, która określa liczbę bajtów do odczytu z <c>buforu</c>.</param>
        <param name="asyncCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po ukończeniu operacji zapisu.</param>
        <param name="asyncState">Obiekt użytkownika, który zawiera informacje na temat operacji zapisu. Ten obiekt jest przekazywany do <c>asyncCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Rozpoczyna operację asynchronicznego zapisu, która zapisuje <see cref="T:System.Byte" />s z określonego bufora do strumienia.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje wywołanie tej metody.  
  
 [!code-cpp[NclSslServerAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#5)]
 [!code-csharp[NclSslServerAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; długość <paramref name="buffer" />.  - lub - <paramref name="offset" /> + liczba &gt; długość <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Operacja zapisu nie powiodła się.</exception>
        <exception cref="T:System.NotSupportedException">Istnieje już w toku operacji zapisu.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie przeprowadzono uwierzytelniania.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanRead</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy zasadniczy strumień jest możliwy do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli podczas uwierzytelniania i zasadniczy strumień jest możliwy do odczytu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku pomyślnego uwierzytelnienia, ta właściwość zwraca wartość zwrócona przez wywołanie <xref:System.IO.Stream.CanRead%2A> w strumieniu podstawowym.  
  
 Zasadniczy strumień został określony podczas tworzenia wystąpienia <xref:System.Net.Security.SslStream> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wyświetlania wartości tej właściwości.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy wyszukiwać źródłowego strumienia.</summary>
        <value>Ta właściwość zawsze zwraca <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy próbować ustawiać pozycja <xref:System.Net.Security.SslStream> obiektu lub jego źródłowego strumienia.  
  
 Zasadniczy strumień został określony podczas tworzenia wystąpienia <xref:System.Net.Security.SslStream> klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.CanSeek" />
        <altmember cref="P:System.Net.Security.SslStream.Position" />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy zasadniczy strumień obsługuje limity czasu.</summary>
        <value>
          <see langword="true" /> Jeśli zasadniczy strumień obsługuje limity czasu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwrócona przez wywołanie <xref:System.IO.Stream.CanTimeout%2A> w strumieniu podstawowym.  
  
 Zasadniczy strumień został określony podczas tworzenia wystąpienia <xref:System.Net.Security.SslStream> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wyświetlania wartości tej właściwości.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanWrite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy zasadniczy strumień jest zapisywalna.</summary>
        <value>
          <see langword="true" /> Jeśli podczas uwierzytelniania i zasadniczy strumień jest zapisywalny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku pomyślnego uwierzytelnienia, ta właściwość zwraca wartość zwrócona przez wywołanie <xref:System.IO.Stream.CanWrite%2A> w strumieniu podstawowym.  
  
 Zasadniczy strumień został określony podczas tworzenia wystąpienia <xref:System.Net.Security.SslStream> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wyświetlania wartości tej właściwości.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckCertRevocationStatus">
      <MemberSignature Language="C#" Value="public virtual bool CheckCertRevocationStatus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CheckCertRevocationStatus" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CheckCertRevocationStatus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CheckCertRevocationStatus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CheckCertRevocationStatus { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CheckCertRevocationStatus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy lista odwołania certyfikatów jest sprawdzana w procesie weryfikacji certyfikatu.</summary>
        <value>
          <see langword="true" /> Jeśli lista odwołania certyfikatów jest sprawdzana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Listy odwołania certyfikatów zawiera certyfikaty, które zostały odwołane przez wystawcę. Sprawdzanie listy negatywnie wpływa na wydajność, ale zwiększa bezpieczeństwo aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wyświetlania wartości tej właściwości.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CipherAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.CipherAlgorithmType CipherAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.CipherAlgorithmType CipherAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CipherAlgorithm As CipherAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::CipherAlgorithmType CipherAlgorithm { System::Security::Authentication::CipherAlgorithmType get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CipherAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.CipherAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która identyfikuje algorytm szyfrowania zbiorczego używanych przez to <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>A <see cref="T:System.Security.Authentication.CipherAlgorithmType" /> wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Security.Authentication.CipherAlgorithmType.Null> jest wymagany dla <xref:System.Net.Security.SslStream.CipherAlgorithm%2A> właściwości podczas <xref:System.Net.Security.EncryptionPolicy.NoEncryption> wartość wyliczenia jest używany do tworzenia <xref:System.Net.Security.SslStream> wystąpienia.  
  
 [!INCLUDE[winxpsvr](~/includes/winxpsvr-md.md)] i [!INCLUDE[winxp](~/includes/winxp-md.md)] nie obsługują <xref:System.Security.Authentication.CipherAlgorithmType.Null> wartość. Nawet jeśli <xref:System.Security.Authentication.CipherAlgorithmType.Null> wartość jest używana do konstruowania <xref:System.Net.Security.SslStream> wystąpienia, <xref:System.Net.Security.EncryptionPolicy> właściwość będzie <xref:System.Security.Authentication.CipherAlgorithmType.None>. <xref:System.Security.Authentication.CipherAlgorithmType.Null> Zwracana jest wartość tylko w systemie Windows Vista lub nowszy.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia ustawienia szyfrowania dla określonego strumienia.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.Security.SslStream.CipherAlgorithm" /> Właściwość uzyskano przed ukończenia procesu uwierzytelniania lub proces uwierzytelniania nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="CipherStrength">
      <MemberSignature Language="C#" Value="public virtual int CipherStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CipherStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CipherStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CipherStrength { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CipherStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która identyfikuje siła algorytmu szyfrowania używanych przez to <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>
          <see cref="T:System.Int32" /> Wartość, która określa siła algorytmu, w bitach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości wynosi zero, dopóki nie wystąpi uwierzytelniania.  
  
 Ta właściwość zwraca jedną z następujących wartości:  
  
-   0  
  
-   40  
  
-   56  
  
-   80  
  
-   128  
  
-   168  
  
-   192  
  
-   256  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia ustawienia szyfrowania dla określonego strumienia.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Net.Security.SslStream" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` — metoda i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr ma wartość true, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Net.Security.SslStream> odwołania. Ta metoda wywołuje `Dispose()` metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see langword="Dispose(Boolean)" /> należy uważać, aby nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see langword="Dispose(Boolean)" />, zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenia Resources](~/docs/standard/garbage-collection/unmanaged.md) niezarządzane i [zastąpienie metody Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsClient (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsClient(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndAuthenticateAsClient(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Zwrócony przez wywołanie do wystąpienia <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />.</param>
        <summary>Kończy operację uwierzytelniania oczekujących asynchronicznych serwera pracę z poprzedniego wywołania <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli działanie nie zostało ukończone, ta metoda blokuje, dopóki nie robi. Gdy uwierzytelnienie zakończy się powodzeniem, należy zaznaczyć <xref:System.Net.Security.SslStream.IsEncrypted%2A> i <xref:System.Net.Security.SslStream.IsSigned%2A> właściwości, aby ustalić, jakie usługi zabezpieczeń są używane przez <xref:System.Net.Security.SslStream>. Sprawdź <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> właściwości w celu określenia, czy wystąpiły wzajemnego uwierzytelniania.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 Aby wykonać tę operację synchronicznie, użyj jednej z <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została utworzona przez wywołanie do <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie nie jest oczekujący serwera do wykonania.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsServer (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsServer(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndAuthenticateAsServer(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Zwrócony przez wywołanie do wystąpienia <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</param>
        <summary>Kończy operację uwierzytelniania oczekujących asynchronicznych klienta pracę z poprzedniego wywołania <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli działanie nie zostało ukończone, ta metoda blokuje, dopóki nie robi. Gdy uwierzytelnienie zakończy się powodzeniem, należy zaznaczyć <xref:System.Net.Security.SslStream.IsEncrypted%2A> i <xref:System.Net.Security.SslStream.IsSigned%2A> właściwości, aby ustalić, jakie usługi zabezpieczeń są używane przez <xref:System.Net.Security.SslStream>. Sprawdź <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> właściwości w celu określenia, czy wystąpiły wzajemnego uwierzytelniania.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException>, a to <xref:System.Net.Security.SslStream> nie jest już niemożliwe. Należy zamknąć ten obiekt i usunąć wszystkie odwołania do niego, dzięki czemu mogą być zbierane przez moduł garbage collector.  
  
 Aby wykonać tę operację synchronicznie, użyj jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została utworzona przez wywołanie do <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostanie w stanie uniemożliwiającym jego używanie tego obiektu.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie nie jest oczekujący klienta do wykonania.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndRead(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Zwrócony przez wywołanie do wystąpienia <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Kończy operację asynchroniczną odczytu pracę z poprzedniego wywołania <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <returns>A <see cref="T:System.Int32" /> wartość, która określa liczbę bajtów do odczytu strumienia podstawowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli działanie nie zostało ukończone, ta metoda blokuje, dopóki nie robi.  
  
 Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Security.SslStream.Read%2A> metody.  
  
 Nie można wywołać tej metody, dopóki pomyślnym uwierzytelnieniu. Do uwierzytelnienia wywołania jedną <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, lub <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, że końcowa asynchronicznych operacji odczytu.  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została utworzona przez wywołanie do <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie przeprowadzono uwierzytelniania.</exception>
        <exception cref="T:System.IO.IOException">Operacja odczytu nie powiodła się.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndWrite(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Zwrócony przez wywołanie do wystąpienia <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Kończy operację asynchronicznego zapisu pracę z poprzedniego wywołania <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli działanie nie zostało ukończone, ta metoda blokuje, dopóki nie robi.  
  
 Aplikacji nie można wywołać tej metody do momentu pomyślnym uwierzytelnieniu. W celu uwierzytelnienia wywoływanie jednego z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, lub <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metody.  
  
 Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Security.SslStream.Write%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje kończące operację asynchronicznego zapisu.  
  
 [!code-cpp[NclSslServerAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#4)]
 [!code-csharp[NclSslServerAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została utworzona przez wywołanie do <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie przeprowadzono uwierzytelniania.</exception>
        <exception cref="T:System.IO.IOException">Operacja zapisu nie powiodła się.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że wszystkie buforowane dane są zapisywane w podstawowej urządzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.IO.Stream.Flush%2A> w strumieniu podstawowym.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wywołanie tej metody.  
  
 [!code-cpp[NclSslClientSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#5)]
 [!code-csharp[NclSslClientSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.HashAlgorithmType HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.HashAlgorithmType HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashAlgorithm As HashAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::HashAlgorithmType HashAlgorithm { System::Security::Authentication::HashAlgorithmType get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.HashAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.HashAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera algorytm używany do generowania kodów uwierzytelniania wiadomości (Mac).</summary>
        <value>A <see cref="T:System.Security.Authentication.HashAlgorithmType" /> wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algorytmy uwierzytelniania wiadomości generują wartości skrótu wiadomości i podpisy wykrywać naruszeniu i sfałszowaniem.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia ustawienia szyfrowania dla określonego strumienia.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.Security.SslStream.HashAlgorithm" /> Właściwość uzyskano przed ukończenia procesu uwierzytelniania lub proces uwierzytelniania nie powiodło się.</exception>
      </Docs>
    </Member>
    <Member MemberName="HashStrength">
      <MemberSignature Language="C#" Value="public virtual int HashStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HashStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int HashStrength { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.HashStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która identyfikuje siła algorytmu wyznaczania wartości skrótu używanego przez to wystąpienie.</summary>
        <value>
          <see cref="T:System.Int32" /> Wartość, która określa siłę <see cref="T:System.Security.Authentication.HashAlgorithmType" /> algorytmu w bitach. Prawidłowe wartości to 128 lub 160.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości wynosi zero, dopóki nie wystąpi uwierzytelniania.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia ustawienia szyfrowania dla określonego strumienia.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsAuthenticated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy uwierzytelnianie zakończyło się pomyślnie.</summary>
        <value>
          <see langword="true" /> Jeśli wystąpiły pomyślne uwierzytelnienie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie klientów przez wywołanie metody <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> lub <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> metody. Serwery uwierzytelniania przez wywołanie metody <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> lub <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wyświetlania wartości tej właściwości.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEncrypted { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsEncrypted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość wskazującą, czy to <see cref="T:System.Net.Security.SslStream" /> używa szyfrowania danych.</summary>
        <value>
          <see langword="true" /> Jeśli dane są szyfrowane przed przesyłanych za pośrednictwem sieci i odszyfrować po osiągnięciu zdalny punkt końcowy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Szyfrowanie pomaga chronić prywatność danych, czyli pomaga upewnij się, że gdy dane są przesyłane, go nie może być odszyfrowywane przez osoby trzecie.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wyświetlania wartości tej właściwości.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsMutuallyAuthenticated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy zarówno serwera i klienta zostały uwierzytelnione.</summary>
        <value>
          <see langword="true" /> Jeśli serwer został uwierzytelniony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas serwer wymaga od klienta zapewnienia certyfikatu dla uwierzytelniania wzajemnego uwierzytelniania jest określona przez serwer.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wyświetlania wartości tej właściwości.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" />
        <altmember cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsServer { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsServer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy lokalny strony połączenia używane przez to <see cref="T:System.Net.Security.SslStream" /> został uwierzytelniony jako serwer.</summary>
        <value>
          <see langword="true" /> Jeśli lokalny punkt końcowy został pomyślnie uwierzytelniony jako po stronie serwera uwierzytelnionego połączenia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli uwierzytelnianie nie powiodło się lub nie zostało przeprowadzone, ta właściwość zwraca `false`.  
  
 Na potrzeby uwierzytelniania, co serwer, wywołaj <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> lub <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wyświetlania wartości tej właściwości.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSigned { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsSigned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Boolean" /> wartość, która wskazuje, czy dane wysyłane przy użyciu tego strumienia jest podpisany.</summary>
        <value>
          <see langword="true" /> Jeśli dane podpisu przed przesyłanych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podpisywania danych, pomaga w ochronie integralności danych, czyli pomaga odbiorcy określić, czy dane została naruszona przesyłane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wyświetlania wartości tej właściwości.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyExchangeAlgorithm As ExchangeAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::ExchangeAlgorithmType KeyExchangeAlgorithm { System::Security::Authentication::ExchangeAlgorithmType get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.KeyExchangeAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExchangeAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera określony algorytm wymiany kluczy używanych przez to <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>
          <see cref="T:System.Security.Authentication.ExchangeAlgorithmType" /> Wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości jest <xref:System.Security.Authentication.ExchangeAlgorithmType.None> dopóki nie wystąpi uwierzytelniania.  
  
 Określony algorytm wymiany kluczy chroni informacje używane do generowania kluczy współużytkowanych.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia ustawienia szyfrowania dla określonego strumienia.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeStrength">
      <MemberSignature Language="C#" Value="public virtual int KeyExchangeStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeyExchangeStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyExchangeStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int KeyExchangeStrength { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.KeyExchangeStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która identyfikuje siła algorytmu wymiany kluczy używanych przez to wystąpienie.</summary>
        <value>
          <see cref="T:System.Int32" /> Wartość, która określa siłę <see cref="T:System.Security.Authentication.ExchangeAlgorithmType" /> algorytmu w bitach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości wynosi zero, dopóki nie wystąpi uwierzytelniania.  
  
 W typowych scenariuszy wartość tej właściwości jest jedną z następujących czynności:  
  
-   512  
  
-   768  
  
-   1024  
  
-   2048  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia ustawienia szyfrowania dla określonego strumienia.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość strumienia podstawowego.</summary>
        <value>A <see cref="T:System.Int64" />.  Długość strumienia podstawowego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwrócona przez wywołanie <xref:System.IO.Stream.Length%2A> w strumieniu podstawowym. Jeśli nie można wyszukać zasadniczy strumień, tej metody zwykle zgłasza wyjątek. Typ środowiska wykonawczego zasadniczy strumień określa typu run-time wyjątku, który jest generowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Pobieranie wartości tej właściwości nie jest obsługiwane, gdy strumień podstawowy <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.LocalCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LocalCertificate As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::X509Certificates::X509Certificate ^ LocalCertificate { System::Security::Cryptography::X509Certificates::X509Certificate ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.LocalCertificate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera certyfikat używany do uwierzytelniania lokalnego punktu końcowego.</summary>
        <value>Obiekt w certyfikacie x 509, który reprezentuje certyfikatu dla uwierzytelniania lub <see langword="null" /> Jeśli żaden certyfikat nie został dostarczony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, wyświetlanie certyfikat zwrócony przez tę właściwość.  
  
 [!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
 [!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie nie powiodło się lub nie przeprowadzono.</exception>
      </Docs>
    </Member>
    <Member MemberName="NegotiatedApplicationProtocol">
      <MemberSignature Language="C#" Value="public System.Net.Security.SslApplicationProtocol NegotiatedApplicationProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.SslApplicationProtocol NegotiatedApplicationProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.NegotiatedApplicationProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NegotiatedApplicationProtocol As SslApplicationProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::SslApplicationProtocol NegotiatedApplicationProtocol { System::Net::Security::SslApplicationProtocol get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.SslApplicationProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżącą pozycję w strumieniu podstawowym.</summary>
        <value>A <see cref="T:System.Int64" />.  Bieżąca pozycja w strumieniu podstawowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwrócona przez wywołanie <xref:System.IO.Stream.Position%2A> w strumieniu podstawowym. Jeśli nie można wyszukać zasadniczy strumień, tej metody zwykle zgłasza wyjątek. Typ środowiska wykonawczego zasadniczy strumień określa typu run-time wyjątku, który jest generowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ustawienie tej właściwości nie jest obsługiwane.  Pobieranie wartości tej właściwości nie jest obsługiwane, gdy strumień podstawowy - lub - <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Read(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">A <see cref="T:System.Byte" /> tablicy, która odbiera bajty odczytywać tego strumienia.</param>
        <param name="offset">A <see cref="T:System.Int32" /> zawierający liczony od zera lokalizacja w <c>buforu</c> rozpoczęcia przechowywania danych przeczytanie tego strumienia.</param>
        <param name="count">A <see cref="T:System.Int32" /> zawiera maksymalną liczbę bajtów do odczytania tego strumienia.</param>
        <summary>Odczytuje dane z tego strumienia i zapisuje go w określonej tablicy.</summary>
        <returns>A <see cref="T:System.Int32" /> wartość, która określa liczbę bajtów do odczytu. Jeśli nie ma więcej danych do odczytu, zwraca wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda odczytuje maksymalnie `count` bajtów ze strumienia i zapisuje je w `buffer` począwszy od `offset`. Nie można wykonywać wiele równoczesnych operacji odczytu.  
  
 Nie można wywołać tej metody, dopóki pomyślnym uwierzytelnieniu. Do uwierzytelnienia wywołania jedną <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, lub <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metody.  
  
 Aby wykonać tę operację asynchronicznie, użyj <xref:System.Net.Security.SslStream.BeginRead%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje odczytu z <xref:System.Net.Security.SslStream>.  
  
 [!code-cpp[NclSslClientSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#6)]
 [!code-csharp[NclSslClientSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; długość <paramref name="buffer" />.  - lub - <paramref name="offset" /> + liczba &gt; długość <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Operacja odczytu nie powiodła się. Jeśli jest obecny, aby ustalić przyczynę niepowodzenia, sprawdź wyjątek wewnętrzny.</exception>
        <exception cref="T:System.NotSupportedException">Istnieje już operacja odczytu w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie przeprowadzono uwierzytelniania.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.ReadTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czas operacji odczytu blokuje oczekiwanie na dane.</summary>
        <value>A <see cref="T:System.Int32" /> , który określa czas, jaki upływa zanim synchronicznego odczytać operacja kończy się niepowodzeniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwrócona przez wywołanie <xref:System.IO.Stream.ReadTimeout%2A> w strumieniu podstawowym. W przypadku ustawienia tej właściwości <xref:System.IO.Stream.ReadTimeout%2A> wartość w podstawowym strumieniu jest równa określonej wartości.  
  
 Jeśli strumień podstawowy <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.SslStream.ReadTimeout%2A> jest (w milisekundach) i ma ustawioną wartość <xref:System.Threading.Timeout.Infinite> domyślnie, który odczytywać operacji, czy nie limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje ustawienie dla tej właściwości wartości.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.RemoteCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoteCertificate As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::X509Certificates::X509Certificate ^ RemoteCertificate { System::Security::Cryptography::X509Certificates::X509Certificate ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.RemoteCertificate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera certyfikat używany do uwierzytelniania zdalny punkt końcowy.</summary>
        <value>Obiekt w certyfikacie x 509, który reprezentuje certyfikatu dla uwierzytelniania lub <see langword="null" /> Jeśli żaden certyfikat nie został dostarczony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, wyświetlanie certyfikat zwrócony przez tę właściwość.  
  
 [!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
 [!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie nie powiodło się lub nie przeprowadzono.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Ta wartość jest ignorowana.</param>
        <param name="origin">Ta wartość jest ignorowana.</param>
        <summary>Zgłasza wyjątek <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Zawsze zwraca <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody. Jest dziedziczone, ale nie jest obsługiwana przez <xref:System.Net.Security.SslStream> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wyszukiwanie nie jest obsługiwana przez <see cref="T:System.Net.Security.SslStream" /> obiektów.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.SetLength(System.Int64)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Int64" /> Wartość określająca długość strumienia.</param>
        <summary>Ustawia długość strumienia podstawowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.IO.Stream.SetLength%2A?displayProperty=nameWithType> na zasadniczy strumień określone, jeśli to <xref:System.Net.Security.SslStream> został utworzony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task ShutdownAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task ShutdownAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.ShutdownAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ShutdownAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ ShutdownAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamknięcie tego SslStream.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SslProtocol">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.SslProtocols SslProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.SslProtocols SslProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.SslProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SslProtocol As SslProtocols" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::SslProtocols SslProtocol { System::Security::Authentication::SslProtocols get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.SslProtocol</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.SslProtocols</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, protokół zabezpieczeń używany do uwierzytelniania tego połączenia.</summary>
        <value>
          <see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły zabezpieczeń obsługiwane są określone podczas <xref:System.Net.Security.SslStream> jest tworzony. Jeśli żaden protokół zabezpieczeń został przekazany do konstruktora, wystąpienie jest tworzony przy użyciu <xref:System.Security.Authentication.SslProtocols.Default>. Rzeczywiste protokół używany do uwierzytelniania jest zaznaczone, oparte na protokoły obsługiwane przez klienta i serwera.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono właściwości zabezpieczeń określonego strumienia.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransportContext">
      <MemberSignature Language="C#" Value="public System.Net.TransportContext TransportContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.TransportContext TransportContext" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.TransportContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransportContext As TransportContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::TransportContext ^ TransportContext { System::Net::TransportContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.TransportContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.TransportContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Net.TransportContext" /> używany do uwierzytelniania przy użyciu ochrony rozszerzonej.</summary>
        <value>
          <see cref="T:System.Net.TransportContext" /> Obiekt, który zawiera token wiązania kanałów (CBT) używane do ochrony rozszerzonej.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje dane do tego strumienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Write(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">A <see cref="T:System.Byte" /> tablica, która dostarcza zapisanych w strumieniu bajtów.</param>
        <summary>Zapisuje określone dane do tego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie zakończy działanie. Aby zapobiec blokowanie zakończy działanie, należy użyć <xref:System.Net.Security.SslStream.BeginWrite%2A> metody.  
  
 Nie można wywołać tej metody, dopóki pomyślnym uwierzytelnieniu. Do uwierzytelnienia wywołania jedną <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, lub <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metody.  
  
 <xref:System.Net.Security.SslStream> Klasa nie obsługuje wiele równoczesnych zapisu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zapisywanie uwierzytelnionego <xref:System.Net.Security.SslStream>.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Operacja zapisu nie powiodła się.</exception>
        <exception cref="T:System.NotSupportedException">Istnieje już w toku operacji zapisu.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie przeprowadzono uwierzytelniania.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Write(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">A <see cref="T:System.Byte" /> tablica, która dostarcza zapisanych w strumieniu bajtów.</param>
        <param name="offset">A <see cref="T:System.Int32" /> zawierający liczony od zera lokalizacja w <c>buforu</c> w której ma zostać rozpoczęte odczytywanie bajtów do zapisania w strumieniu.</param>
        <param name="count">A <see cref="T:System.Int32" /> zawiera liczbę bajtów do odczytu z <c>buforu</c>.</param>
        <summary>Zapis do określonej liczby miejsc <see cref="T:System.Byte" />s do źródłowego strumienia, używając określonego bufora i przesunięcie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia blokowanie zakończy działanie. Aby zapobiec, blokowanie operacji zakończy działanie zakończy, użyj <xref:System.Net.Security.SslStream.BeginWrite%2A> metody.  
  
 Nie można wywołać tej metody, dopóki pomyślnym uwierzytelnieniu. Do uwierzytelnienia wywołania jedną <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, lub <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metody.  
  
 <xref:System.Net.Security.SslStream> Klasa nie obsługuje wiele równoczesnych zapisu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; długość <paramref name="buffer" />.  - lub - <paramref name="offset" /> + liczba &gt; długość <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Operacja zapisu nie powiodła się.</exception>
        <exception cref="T:System.NotSupportedException">Istnieje już w toku operacji zapisu.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie przeprowadzono uwierzytelniania.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.WriteTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czas operacji zapisu blokuje oczekiwanie na dane.</summary>
        <value>A <see cref="T:System.Int32" /> , który określa czas, jaki musi upłynąć, zanim operacja zapisu synchronicznego kończy się niepowodzeniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwrócona przez wywołanie <xref:System.IO.Stream.WriteTimeout%2A> w strumieniu podstawowym. Operacje na zestawie określona wartość Określa <xref:System.IO.Stream.WriteTimeout%2A> wartość w strumieniu podstawowym.  
  
 Jeśli strumień podstawowy <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.SslStream.WriteTimeout%2A> jest (w milisekundach) i ma ustawioną wartość <xref:System.Threading.Timeout.Infinite> domyślnie, które zapisują operacji, czy nie limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje ustawienie dla tej właściwości wartości.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
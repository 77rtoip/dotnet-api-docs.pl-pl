<Type Name="SslStream" FullName="System.Net.Security.SslStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a63456513b88006fb76703ed7b56449985013d83" /><Meta Name="ms.sourcegitcommit" Value="0807ab0a64414edc9b4d09d3877857e83cb7f7a4" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/13/2019" /><Meta Name="ms.locfileid" Value="68972642" /></Metadata><TypeSignature Language="C#" Value="public class SslStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SslStream extends System.Net.Security.AuthenticatedStream implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.SslStream" />
  <TypeSignature Language="VB.NET" Value="Public Class SslStream&#xA;Inherits AuthenticatedStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class SslStream : System::Net::Security::AuthenticatedStream" />
  <TypeSignature Language="F#" Value="type SslStream = class&#xA;    inherit AuthenticatedStream&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zapewnia strumień używany do komunikacji klient-serwer, który używa protokołu zabezpieczeń Secure Socket Layer (SSL) do uwierzytelniania serwera i opcjonalnie klienta.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protokoły SSL pomagają zapewnić poufność i sprawdzanie integralności komunikatów przesyłanych przy użyciu <xref:System.Net.Security.SslStream>. Połączenie SSL, takie jak dostarczone przez <xref:System.Net.Security.SslStream>, powinno być używane podczas komunikowania poufnych informacji między klientem a serwerem. Korzystanie z <xref:System.Net.Security.SslStream> pomaga zapobiegać odczytywaniu i manipulowaniu informacjami podczas przesyłania ich w sieci.  
  
 Wystąpienie przesyła dane przy użyciu strumienia dostarczanego podczas <xref:System.Net.Security.SslStream>tworzenia. <xref:System.Net.Security.SslStream> Po dostarczeniu tego strumienia bazowego można określić, czy zamknięcie <xref:System.Net.Security.SslStream> tego strumienia spowoduje również zamknięcie źródłowego. Zazwyczaj Klasa jest używana <xref:System.Net.Sockets.TcpClient> z klasami i <xref:System.Net.Sockets.TcpListener>. <xref:System.Net.Security.SslStream> <xref:System.Net.Sockets.TcpClient.GetStream%2A> Metoda zapewnia<xref:System.Net.Sockets.NetworkStream> odpowiednie do użycia z klasą <xref:System.Net.Security.SslStream> .  
  
 Po utworzeniu <xref:System.Net.Security.SslStream>serwera, serwerze i opcjonalnie należy uwierzytelnić klienta. Serwer musi dostarczyć certyfikat x509, który ustanowi potwierdzenie tożsamości i może zażądać tego klienta. Przed przesłaniem informacji przy użyciu <xref:System.Net.Security.SslStream>usługi należy przeprowadzić uwierzytelnianie. Klienci inicjują uwierzytelnianie przy użyciu <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> metod synchronicznych, które blokują do momentu zakończenia uwierzytelniania <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> lub metod asynchronicznych, które nie blokują oczekiwania na ukończenie uwierzytelniania. Serwery inicjują uwierzytelnianie przy użyciu <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> metod synchronicznych lub asynchronicznych. <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> Zarówno klient, jak i serwer muszą inicjować uwierzytelnianie.  
  
 Uwierzytelnianie jest obsługiwane przez dostawcę kanału obsługi zabezpieczeń (SSPI). Klient uzyskuje możliwość kontroli poprawności certyfikatu serwera przez określenie <xref:System.Net.Security.RemoteCertificateValidationCallback> delegata podczas <xref:System.Net.Security.SslStream>tworzenia. Serwer może również kontrolować walidację, dostarczając <xref:System.Net.Security.RemoteCertificateValidationCallback> delegata. Metoda, do której odwołuje się delegat, obejmuje certyfikat strony zdalnej oraz wszystkie błędy, które zostały wykryte podczas weryfikacji certyfikatu. Należy pamiętać, że jeśli serwer określa delegata, metoda obiektu delegowanego jest wywoływana niezależnie od tego, czy serwer zażądał uwierzytelnienia klienta. Jeśli serwer nie zażądał uwierzytelnienia klienta, Metoda delegowania serwera odbiera certyfikat o wartości null i pustą tablicę błędów certyfikatów.  
  
 Jeśli serwer wymaga uwierzytelniania klienta, klient musi określić co najmniej jeden certyfikat do uwierzytelnienia. Jeśli klient ma więcej niż jeden certyfikat, klient może dostarczyć <xref:System.Net.Security.LocalCertificateSelectionCallback> delegata, aby wybrać poprawny certyfikat dla serwera. Certyfikaty klienta muszą znajdować się w magazynie certyfikatów bieżącego użytkownika. Uwierzytelnianie klienta za pośrednictwem certyfikatów nie jest obsługiwane <xref:System.Security.Authentication.SslProtocols.Ssl2> w przypadku protokołu SSL w wersji 2.  
  
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException> <xref:System.Net.Security.SslStream> i nie jest już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 Gdy proces uwierzytelniania, znany również jako uzgadnianie SSL, powiedzie się, tożsamość serwera (i opcjonalnie klient) jest ustanawiana i <xref:System.Net.Security.SslStream> może być używana przez klienta i serwer do wymiany komunikatów. Przed wysłaniem lub odebraniem informacji, klient i serwer powinny sprawdzić usługi zabezpieczeń i poziomy udostępnione przez <xref:System.Net.Security.SslStream> program, aby określić, czy wybrany protokół, algorytmy i siły spełniają wymagania dotyczące integralności i poufne. Jeśli bieżące ustawienia nie są wystarczające, strumień powinien zostać zamknięty. Możesz sprawdzić usługi zabezpieczeń podane przez <xref:System.Net.Security.SslStream> <xref:System.Net.Security.SslStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.SslStream.IsSigned%2A> . W poniższej tabeli przedstawiono elementy, które raportują ustawienia kryptograficzne używane do uwierzytelniania, szyfrowania i podpisywania danych.  
  
|Element|Elementy członkowskie|  
|-------------|-------------|  
|Protokół zabezpieczeń używany do uwierzytelniania serwera i, opcjonalnie, klienta.|Właściwość i skojarzone <xref:System.Security.Authentication.SslProtocols>Wyliczenie. <xref:System.Net.Security.SslStream.SslProtocol%2A>|  
|Algorytm wymiany kluczy.|Właściwość i skojarzone <xref:System.Security.Authentication.ExchangeAlgorithmType>Wyliczenie. <xref:System.Net.Security.SslStream.KeyExchangeAlgorithm%2A>|  
|Algorytm integralności komunikatów.|Właściwość i skojarzone <xref:System.Security.Authentication.HashAlgorithmType>Wyliczenie. <xref:System.Net.Security.SslStream.HashAlgorithm%2A>|  
|Algorytm poufności komunikatów.|Właściwość i skojarzone <xref:System.Security.Authentication.CipherAlgorithmType>Wyliczenie. <xref:System.Net.Security.SslStream.CipherAlgorithm%2A>|  
|Siły wybranych algorytmów.|Właściwości <xref:System.Net.Security.SslStream.KeyExchangeStrength%2A>, <xref:System.Net.Security.SslStream.HashStrength%2A>i .<xref:System.Net.Security.SslStream.CipherStrength%2A>|  
  
 Po pomyślnym uwierzytelnieniu można wysyłać dane przy użyciu metod <xref:System.Net.Security.SslStream.Write%2A> synchronicznych <xref:System.Net.Security.SslStream.BeginWrite%2A> lub asynchronicznych. Dane można odbierać przy użyciu metod synchronicznych <xref:System.Net.Security.SslStream.Read%2A> lub asynchronicznych. <xref:System.Net.Security.SslStream.BeginRead%2A>  
  
 Jeśli określisz, że źródłowy strumień powinien pozostać otwarty, użytkownik jest odpowiedzialny za zamknięcie tego strumienia po zakończeniu korzystania z niego. <xref:System.Net.Security.SslStream.%23ctor%2A>  
  
> [!NOTE]
>  Jeśli aplikacja, która tworzy <xref:System.Net.Security.SslStream> obiekt, jest uruchamiana z poświadczeniami normalnego użytkownika, aplikacja nie będzie mogła uzyskać dostępu do certyfikatów zainstalowanych w lokalnym magazynie komputerowym, chyba że uprawnienie zostało jawnie przekazane Użytkownikowi.  
  
 <xref:System.Net.Security.SslStream>przyjęto założenie, że przekroczenie limitu czasu wraz z innymi <xref:System.IO.IOException> , gdy jeden z nich zostanie wygenerowany ze strumienia wewnętrznego będzie traktowany jako krytyczny przez jego obiekt wywołujący. Ponownie użycie <xref:System.Net.Security.SslStream> wystąpienia po upływie limitu czasu spowoduje zwrócenie elementów bezużytecznych. W takich przypadkach <xref:System.IO.Stream.Close%2A> aplikacja <xref:System.Net.Security.SslStream> powinna być i zgłosić wyjątek.  
  
 .NET Framework 4,6 obejmuje nową funkcję zabezpieczeń, która blokuje niebezpieczne algorytmy szyfrowania i wyznaczania wartości skrótu dla połączeń. Aplikacje korzystające z protokołu TLS/SSL za pośrednictwem interfejsów API, takich jak HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream itp. i przeznaczonych dla .NET Framework 4,6, domyślnie uzyskają bezpieczniejsze zachowanie.  
  
 Deweloperzy mogą chcieć zrezygnować z tego zachowania, aby zachować współdziałanie z istniejącymi usługami SSL3 Services lub TLS/RC4. W [tym artykule](https://support.microsoft.com/kb/3069494) wyjaśniono, jak zmodyfikować kod w taki sposób, aby nowe zachowanie zostało wyłączone.  
  
 .NET Framework 4,7 dodaje nowe przeciążenia dla metod, które uwierzytelniają SslStreams, które nie określają wersji protokołu TLS, ale zamiast tego używają wersji protokołu TLS zdefiniowanej jako domyślny system w [Schannel](https://msdn.microsoft.com/library/windows/desktop/aa380123.aspx). Użyj tych metod w aplikacji jako sposobu, aby można było później zmodyfikować wartości domyślne jako najlepszych rozwiązań w zakresie protokołu TLS z upływem czasu, bez konieczności ponownego kompilowania i wdrażania aplikacji.

 Zobacz również [najlepsze rozwiązania Transport Layer Security (TLS) z .NET Framework](~/docs/framework/network-programming/tls.md).
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje tworzenie <xref:System.Net.Sockets.TcpListener> , które <xref:System.Net.Security.SslStream> używa klasy do komunikowania się z klientami.  
  
[!code-cpp[NclSslServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#0)]
[!code-csharp[NclSslServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#0)]  
[!code-vb[NclSslServerSync#0](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#0)]
  
 Poniższy przykład kodu demonstruje tworzenie <xref:System.Net.Sockets.TcpClient> , które <xref:System.Net.Security.SslStream> używa klasy do komunikowania się z serwerem.  
  
 [!code-cpp[NclSslClientSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#0)]
 [!code-csharp[NclSslClientSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#0)]  
 [!code-vb[NclSslClientSync#0](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslClientSync/VB/clientsync.vb#0)]

 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Security.NegotiateStream" />
    <altmember cref="T:System.Net.Security.AuthenticatedStream" />
    <altmember cref="T:System.IO.IOException" />
    <altmember cref="T:System.IO.Stream" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Security.SslStream" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapobiec <xref:System.Net.Security.SslStream> zamykaniu przez użytkownika strumienia, <xref:System.Net.Security.SslStream.%23ctor%2A> Użyj konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream innerStream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream"><see cref="T:System.IO.Stream" /> Obiekt używany <see cref="T:System.Net.Security.SslStream" /> przez program do wysyłania i otrzymywania danych.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Security.SslStream" /> klasy przy użyciu określonego <see cref="T:System.IO.Stream" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość nie jest określona w pliku konfiguracji dla EncryptionPolicy, <xref:System.Net.Security.EncryptionPolicy> <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> domyślnie dla <xref:System.Net.Security.SslStream> wystąpienia, które jest skonstruowane.  
  
 Użycie szyfru wartości null jest wymagane, gdy zasady szyfrowania są ustawione na <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="innerStream" />nie można odczytać.  
  
—lub— 
 <paramref name="innerStream" />nie jest zapisywalny.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="innerStream" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="innerStream" />jest równe <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream * bool -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream (innerStream, leaveInnerStreamOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream"><see cref="T:System.IO.Stream" /> Obiekt używany <see cref="T:System.Net.Security.SslStream" /> przez program do wysyłania i otrzymywania danych.</param>
        <param name="leaveInnerStreamOpen">Wartość logiczna wskazująca zachowanie <see cref="T:System.IO.Stream" /> zamknięcia obiektu używanego <see cref="T:System.Net.Security.SslStream" /> przez program do wysyłania i otrzymywania danych. Ten parametr wskazuje, czy strumień wewnętrzny został otwarty.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Security.SslStream" /> klasy przy użyciu określonego <see cref="T:System.IO.Stream" /> i zamknięcia strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu `true` `leaveStreamOpen` dla parametru, zamknięcie <xref:System.Net.Security.SslStream> nie ma wpływu na `innerStream` strumień; należy jawnie zamknąć `innerStream` , gdy nie jest już potrzebne.  
  
 Jeśli wartość nie jest określona w pliku konfiguracji dla EncryptionPolicy, <xref:System.Net.Security.EncryptionPolicy> <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> domyślnie dla <xref:System.Net.Security.SslStream> wystąpienia, które jest skonstruowane.  
  
 Użycie szyfru wartości null jest wymagane, gdy zasady szyfrowania są ustawione na <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie tego konstruktora.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
 [!code-vb[NclSslServerSync#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#1)] 
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="innerStream" />nie można odczytać.  
  
—lub— 
 <paramref name="innerStream" />nie jest zapisywalny.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="innerStream" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="innerStream" />jest równe <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean, userCertificateValidationCallback As RemoteCertificateValidationCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream * bool * System.Net.Security.RemoteCertificateValidationCallback -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream (innerStream, leaveInnerStreamOpen, userCertificateValidationCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream"><see cref="T:System.IO.Stream" /> Obiekt używany <see cref="T:System.Net.Security.SslStream" /> przez program do wysyłania i otrzymywania danych.</param>
        <param name="leaveInnerStreamOpen">Wartość logiczna wskazująca zachowanie <see cref="T:System.IO.Stream" /> zamknięcia obiektu używanego <see cref="T:System.Net.Security.SslStream" /> przez program do wysyłania i otrzymywania danych. Ten parametr wskazuje, czy strumień wewnętrzny został otwarty.</param>
        <param name="userCertificateValidationCallback"><see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> Delegat odpowiedzialny za Weryfikowanie certyfikatu dostarczonego przez stronę zdalną.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Security.SslStream" /> klasy przy użyciu określonego <see cref="T:System.IO.Stream" />zachowania zamknięcia strumienia i delegata walidacji certyfikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu `true` `leaveStreamOpen` dla parametru, zamknięcie <xref:System.Net.Security.SslStream> nie ma wpływu na `innerStream` strumień; należy jawnie zamknąć `innerStream` , gdy nie jest już potrzebne.  
  
 Argument`certificateErrors`delegata zawiera wszystkie kody błędów systemu Windows zwracane przez interfejs dostawcy obsługi zabezpieczeń (SSPI) kanału. `userCertificateValidationCallback` Zwracana wartość metody wywoływanej przez delegata określa `userCertificateValidationCallback` , czy uwierzytelnianie powiedzie się.  
  
 Protokół zabezpieczeń i algorytmy kryptograficzne są już wybrane, gdy `userCertificateValidationCallback` wywoływana jest metoda obiektu delegowanego. Można użyć metody, aby określić, czy wybrane algorytmy i siły kryptograficzne są wystarczające dla aplikacji. W przeciwnym razie metoda powinna zostać zwrócona `false` , aby <xref:System.Net.Security.SslStream> zapobiec tworzeniu.  
  
 Jeśli wartość nie jest określona w pliku konfiguracji dla EncryptionPolicy, <xref:System.Net.Security.EncryptionPolicy> <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> domyślnie dla <xref:System.Net.Security.SslStream> wystąpienia, które jest skonstruowane.  
  
 Użycie szyfru wartości null jest wymagane, gdy zasady szyfrowania są ustawione na <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Struktura buforuje sesje SSL w miarę ich tworzenia i próbuje ponownie użyć buforowanej sesji dla nowego żądania, jeśli jest to możliwe. Przy próbie ponownego użycia sesji SSL w strukturze jest używany pierwszy element <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (jeśli istnieje) lub próba ponownego użycia sesji anonimowych, jeśli <xref:System.Net.HttpWebRequest.ClientCertificates%2A> jest ona pusta.  
  
> [!NOTE]
>  Certyfikaty klienta nie są obsługiwane w protokole SSL w wersji 2.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.Security.SslStream> i inicjuje część klienta uwierzytelniania.  
  
 [!code-cpp[NclSslClientSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#4)]
 [!code-csharp[NclSslClientSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#4)]  
 [!code-vb[NclSslClientSync#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslClientSync/VB/clientsync.vb#4)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="innerStream" />nie można odczytać.  
  
—lub— 
 <paramref name="innerStream" />nie jest zapisywalny.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="innerStream" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="innerStream" />jest równe <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean, userCertificateValidationCallback As RemoteCertificateValidationCallback, userCertificateSelectionCallback As LocalCertificateSelectionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback, System::Net::Security::LocalCertificateSelectionCallback ^ userCertificateSelectionCallback);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream * bool * System.Net.Security.RemoteCertificateValidationCallback * System.Net.Security.LocalCertificateSelectionCallback -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream (innerStream, leaveInnerStreamOpen, userCertificateValidationCallback, userCertificateSelectionCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream"><see cref="T:System.IO.Stream" /> Obiekt używany <see cref="T:System.Net.Security.SslStream" /> przez program do wysyłania i otrzymywania danych.</param>
        <param name="leaveInnerStreamOpen">Wartość logiczna wskazująca zachowanie <see cref="T:System.IO.Stream" /> zamknięcia obiektu używanego <see cref="T:System.Net.Security.SslStream" /> przez program do wysyłania i otrzymywania danych. Ten parametr wskazuje, czy strumień wewnętrzny został otwarty.</param>
        <param name="userCertificateValidationCallback"><see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> Delegat odpowiedzialny za Weryfikowanie certyfikatu dostarczonego przez stronę zdalną.</param>
        <param name="userCertificateSelectionCallback"><see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> Delegat odpowiedzialny za wybór certyfikatu używanego do uwierzytelniania.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Security.SslStream" /> klasy przy użyciu określonego <see cref="T:System.IO.Stream" />zachowania zamykania strumienia, delegata walidacji certyfikatu i delegata wyboru certyfikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu `true` `leaveStreamOpen` dla parametru, zamknięcie <xref:System.Net.Security.SslStream> nie ma wpływu na `innerStream` strumień; należy jawnie zamknąć `innerStream` , gdy nie jest już potrzebne.  
  
 Argument`certificateErrors`delegata zawiera wszystkie kody błędów systemu Windows zwracane przez interfejs dostawcy obsługi zabezpieczeń (SSPI) kanału. `userCertificateValidationCallback` Zwracana wartość metody wywoływanej przez delegata określa `userCertificateValidationCallback` , czy uwierzytelnianie powiedzie się.  
  
 Protokół zabezpieczeń i algorytmy kryptograficzne są już wybrane, gdy `userCertificateValidationCallback` wywoływana jest metoda obiektu delegowanego. Można użyć metody, aby określić, czy wybrane algorytmy i siły kryptograficzne są wystarczające dla aplikacji. W przeciwnym razie metoda powinna zostać zwrócona `false` , aby <xref:System.Net.Security.SslStream> zapobiec tworzeniu.  
  
 Delegat `userCertificateSelectionCallback` jest przydatny, gdy aplikacja ma wiele certyfikatów i musi dynamicznie wybrać certyfikat. Certyfikaty w sklepie "MY" są przesyłane do metody wywoływanej przez delegata.  
  
 Jeśli wartość nie jest określona w pliku konfiguracji dla EncryptionPolicy, <xref:System.Net.Security.EncryptionPolicy> <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> domyślnie dla <xref:System.Net.Security.SslStream> wystąpienia, które jest skonstruowane.  
  
 Użycie szyfru wartości null jest wymagane, gdy zasady szyfrowania są ustawione na <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Struktura buforuje sesje SSL w miarę ich tworzenia i próbuje ponownie użyć buforowanej sesji dla nowego żądania, jeśli jest to możliwe. Przy próbie ponownego użycia sesji SSL, struktura używa pierwszego elementu P:System.Net.HttpWebRequest.ClientCertificates (jeśli istnieje) lub próbuje ponownie użyć sesji anonimowych, jeśli P:System.Net.HttpWebRequest.ClientCertificates jest pusty.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie tego konstruktora. Ten przykład jest częścią większego przykładu dostarczonego dla <xref:System.Net.Security.SslStream> klasy.  
  
 [!code-cpp[NclSslClientAsync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#6)]
 [!code-csharp[NclSslClientAsync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#6)]  
 [!code-vb[NclSslClientAsync#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslClientAsync/VB/clientasync.vb#6)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="innerStream" />nie można odczytać.  
  
—lub— 
 <paramref name="innerStream" />nie jest zapisywalny.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="innerStream" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="innerStream" />jest równe <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, System.Net.Security.EncryptionPolicy encryptionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, valuetype System.Net.Security.EncryptionPolicy encryptionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback,System.Net.Security.EncryptionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback, System::Net::Security::LocalCertificateSelectionCallback ^ userCertificateSelectionCallback, System::Net::Security::EncryptionPolicy encryptionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream * bool * System.Net.Security.RemoteCertificateValidationCallback * System.Net.Security.LocalCertificateSelectionCallback * System.Net.Security.EncryptionPolicy -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream (innerStream, leaveInnerStreamOpen, userCertificateValidationCallback, userCertificateSelectionCallback, encryptionPolicy)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("encryptionPolicy is ignored")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encryptionPolicy" Type="System.Net.Security.EncryptionPolicy" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="innerStream"><see cref="T:System.IO.Stream" /> Obiekt używany <see cref="T:System.Net.Security.SslStream" /> przez program do wysyłania i otrzymywania danych.</param>
        <param name="leaveInnerStreamOpen">Wartość logiczna wskazująca zachowanie <see cref="T:System.IO.Stream" /> zamknięcia obiektu używanego <see cref="T:System.Net.Security.SslStream" /> przez program do wysyłania i otrzymywania danych. Ten parametr wskazuje, czy strumień wewnętrzny został otwarty.</param>
        <param name="userCertificateValidationCallback"><see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> Delegat odpowiedzialny za Weryfikowanie certyfikatu dostarczonego przez stronę zdalną.</param>
        <param name="userCertificateSelectionCallback"><see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> Delegat odpowiedzialny za wybór certyfikatu używanego do uwierzytelniania.</param>
        <param name="encryptionPolicy"><see cref="T:System.Net.Security.EncryptionPolicy" /> Do użycia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Security.SslStream" /> klasy przy użyciu określonego<see cref="T:System.IO.Stream" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie szyfru wartości null jest wymagane, gdy `encryptionPolicy` parametr jest ustawiony na. <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="innerStream" />nie można odczytać.  
  
—lub— 
 <paramref name="innerStream" />nie jest zapisywalny.  
  
—lub— 
 <paramref name="encryptionPolicy" />jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="innerStream" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="innerStream" />jest równe <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uwierzytelnianie po stronie klienta połączenia klienta z serwerem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : string -&gt; unit&#xA;override this.AuthenticateAsClient : string -&gt; unit" Usage="sslStream.AuthenticateAsClient targetHost" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClient(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, na którym jest udostępniana <see cref="T:System.Net.Security.SslStream" />.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia serwera i opcjonalnie klienta w połączeniach klienta z serwerem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]W uwierzytelnianiu nie są używane żadne certyfikaty klienta. Lista odwołania certyfikatów nie jest sprawdzana podczas uwierzytelniania. Określona `targetHost` wartość musi być zgodna z nazwą w certyfikacie serwera.  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.SslStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.SslStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.SslStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetHost" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub— 
Wcześniej podjęto próbę uwierzytelnienia <see cref="T:System.Net.Security.SslStream" /> serwera.  
  
—lub— 
Uwierzytelnianie jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String, clientCertificates As X509CertificateCollection, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool -&gt; unit&#xA;override this.AuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool -&gt; unit" Usage="sslStream.AuthenticateAsClient (targetHost, clientCertificates, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, który będzie go <see cref="T:System.Net.Security.SslStream" />udostępniać.</param>
        <param name="clientCertificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawiera certyfikaty klienta.</param>
        <param name="checkCertificateRevocation"><see cref="T:System.Boolean" /> Wartość określająca, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia serwera i opcjonalnie klienta w połączeniach klienta z serwerem. Proces uwierzytelniania używa określonej kolekcji certyfikatów i domyślnego protokołu SSL systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.SslStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.SslStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.SslStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
> [!NOTE]
>  Certyfikaty klienta nie są obsługiwane w protokole SSL w wersji 2.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String, clientCertificates As X509CertificateCollection, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool -&gt; unit&#xA;override this.AuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool -&gt; unit" Usage="sslStream.AuthenticateAsClient (targetHost, clientCertificates, enabledSslProtocols, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, który będzie go <see cref="T:System.Net.Security.SslStream" />udostępniać.</param>
        <param name="clientCertificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawiera certyfikaty klienta.</param>
        <param name="enabledSslProtocols"><see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</param>
        <param name="checkCertificateRevocation"><see cref="T:System.Boolean" /> Wartość określająca, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia serwera i opcjonalnie klienta w połączeniach klienta z serwerem. Proces uwierzytelniania używa określonej kolekcji certyfikatów i protokołu SSL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.SslStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.SslStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.SslStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
> [!NOTE]
>  Certyfikaty klienta nie są obsługiwane w protokole SSL w wersji 2.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClientAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uwierzytelnianie po stronie klienta połączenia klienta z serwerem jako operacji asynchronicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : string -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsClientAsync targetHost" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClientAsync(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, na którym jest udostępniana <see cref="T:System.Net.Security.SslStream" />.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia serwera i opcjonalnie klienta w połączeniach klienta z serwerem jako operacji asynchronicznej.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]W uwierzytelnianiu nie są używane żadne certyfikaty klienta. Lista odwołania certyfikatów nie jest sprawdzana podczas uwierzytelniania. Określona `targetHost` wartość musi być zgodna z nazwą w certyfikacie serwera.  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.SslStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.SslStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.SslStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetHost" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub— 
Wcześniej podjęto próbę uwierzytelnienia <see cref="T:System.Net.Security.SslStream" /> serwera.  
  
—lub— 
Uwierzytelnianie jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.Security.SslClientAuthenticationOptions sslClientAuthenticationOptions, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.Security.SslClientAuthenticationOptions sslClientAuthenticationOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.Net.Security.SslClientAuthenticationOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::Security::SslClientAuthenticationOptions ^ sslClientAuthenticationOptions, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.AuthenticateAsClientAsync : System.Net.Security.SslClientAuthenticationOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsClientAsync (sslClientAuthenticationOptions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sslClientAuthenticationOptions" Type="System.Net.Security.SslClientAuthenticationOptions" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sslClientAuthenticationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String, clientCertificates As X509CertificateCollection, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsClientAsync (targetHost, clientCertificates, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, który będzie go <see cref="T:System.Net.Security.SslStream" />udostępniać.</param>
        <param name="clientCertificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawiera certyfikaty klienta.</param>
        <param name="checkCertificateRevocation"><see cref="T:System.Boolean" /> Wartość określająca, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia serwera i opcjonalnie klienta w połączeniach klienta z serwerem jako operacji asynchronicznej. Proces uwierzytelniania używa określonej kolekcji certyfikatów i domyślnego protokołu SSL systemu.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.SslStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.SslStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.SslStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
> [!NOTE]
>  Certyfikaty klienta nie są obsługiwane w protokole SSL w wersji 2.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String, clientCertificates As X509CertificateCollection, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsClientAsync (targetHost, clientCertificates, enabledSslProtocols, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, który będzie go <see cref="T:System.Net.Security.SslStream" />udostępniać.</param>
        <param name="clientCertificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawiera certyfikaty klienta.</param>
        <param name="enabledSslProtocols"><see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</param>
        <param name="checkCertificateRevocation"><see cref="T:System.Boolean" /> Wartość określająca, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia serwera i opcjonalnie klienta w połączeniach klienta z serwerem jako operacji asynchronicznej. Proces uwierzytelniania używa określonej kolekcji certyfikatów i protokołu SSL.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.SslStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.SslStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.SslStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
> [!NOTE]
>  Certyfikaty klienta nie są obsługiwane w protokole SSL w wersji 2.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywoływane przez serwery do uwierzytelniania serwera i opcjonalnie klienta w połączeniach klienta z serwerem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; unit" Usage="sslStream.AuthenticateAsServer serverCertificate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certyfikat używany do uwierzytelniania serwera.</param>
        <summary>Wywoływane przez serwery do uwierzytelniania serwera i opcjonalnie klienta w połączeniach klienta z serwerem przy użyciu podanego certyfikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]Lista odwołania certyfikatów nie jest sprawdzana podczas uwierzytelniania. Klient nie musi podawać certyfikatu w celu uwierzytelnienia.  
  
 Ta metoda jest blokowana do momentu zakończenia operacji. Aby zapobiec blokowaniu do momentu zakończenia operacji, użyj jednego <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> z przeciążeń metody.  
  
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub— 
Uwierzytelnianie klienta przy użyciu <see cref="T:System.Net.Security.SslStream" /> tego programu było wypróbowane wcześniej.  
  
—lub— 
Uwierzytelnianie jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> Metoda nie jest obsługiwana w systemach Windows 95, Windows 98 i Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool -&gt; unit" Usage="sslStream.AuthenticateAsServer (serverCertificate, clientCertificateRequired, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">X509 używany do uwierzytelniania serwera.</param>
        <param name="clientCertificateRequired"><see cref="T:System.Boolean" /> Wartość określająca, czy klient jest monitowany o certyfikat w celu uwierzytelnienia. Należy zauważyć, że jest to tylko żądanie — Jeśli certyfikat nie jest dostarczany, serwer nadal akceptuje żądanie połączenia.</param>
        <param name="checkCertificateRevocation"><see cref="T:System.Boolean" /> Wartość określająca, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Wywoływane przez serwery do uwierzytelniania serwera i opcjonalnie klienta w połączeniach klienta z serwerem przy użyciu określonych certyfikatów i wymagań oraz przy użyciu domyślnego protokołu zabezpieczeń systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Ta metoda jest blokowana do momentu zakończenia operacji. Aby zapobiec blokowaniu do momentu zakończenia operacji, użyj jednego <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> z przeciążeń metody.  
  
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub— 
Uwierzytelnianie klienta przy użyciu <see cref="T:System.Net.Security.SslStream" /> tego programu było wypróbowane wcześniej.  
  
—lub— 
Uwierzytelnianie jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> Metoda nie jest obsługiwana w systemach Windows 95, Windows 98 i Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool -&gt; unit" Usage="sslStream.AuthenticateAsServer (serverCertificate, clientCertificateRequired, enabledSslProtocols, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">X509 używany do uwierzytelniania serwera.</param>
        <param name="clientCertificateRequired"><see cref="T:System.Boolean" /> Wartość określająca, czy klient jest monitowany o certyfikat w celu uwierzytelnienia. Należy zauważyć, że jest to tylko żądanie — Jeśli certyfikat nie jest dostarczany, serwer nadal akceptuje żądanie połączenia.</param>
        <param name="enabledSslProtocols"><see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</param>
        <param name="checkCertificateRevocation"><see cref="T:System.Boolean" /> Wartość określająca, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Wywoływane przez serwery do uwierzytelniania serwera i opcjonalnie klienta w połączeniach klienta z serwerem przy użyciu określonych certyfikatów, wymagań i protokołu zabezpieczeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Ta metoda jest blokowana do momentu zakończenia operacji. Aby zapobiec blokowaniu do momentu zakończenia operacji, użyj jednego <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> z przeciążeń metody.  
  
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enabledSslProtocols" />nie jest prawidłową <see cref="T:System.Security.Authentication.SslProtocols" /> wartością.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub— 
Uwierzytelnianie klienta przy użyciu <see cref="T:System.Net.Security.SslStream" /> tego programu było wypróbowane wcześniej.  
  
—lub— 
Uwierzytelnianie jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> Metoda nie jest obsługiwana w systemach Windows 95, Windows 98 i Windows Millennium.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywoływane przez serwery do uwierzytelniania serwera i opcjonalnie klienta w połączeniach klienta z serwerem jako operacji asynchronicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsServerAsync serverCertificate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certyfikat używany do uwierzytelniania serwera.</param>
        <summary>Wywoływane przez serwery do uwierzytelniania serwera i opcjonalnie klienta w połączeniach klienta z serwerem przy użyciu określonego certyfikatu jako operacji asynchronicznej.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Ta metoda służy do uwierzytelniania <xref:System.Security.Authentication.SslProtocols.Default>za pomocą. Lista odwołania certyfikatów nie jest sprawdzana podczas uwierzytelniania. Klient nie musi podawać certyfikatu w celu uwierzytelnienia.  
  
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub— 
Uwierzytelnianie klienta przy użyciu <see cref="T:System.Net.Security.SslStream" /> tego programu było wypróbowane wcześniej.  
  
—lub— 
Uwierzytelnianie jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServerAsync" /> Metoda nie jest obsługiwana w systemach Windows 95, Windows 98 i Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.Security.SslServerAuthenticationOptions sslServerAuthenticationOptions, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.Security.SslServerAuthenticationOptions sslServerAuthenticationOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Net.Security.SslServerAuthenticationOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::Security::SslServerAuthenticationOptions ^ sslServerAuthenticationOptions, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.AuthenticateAsServerAsync : System.Net.Security.SslServerAuthenticationOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsServerAsync (sslServerAuthenticationOptions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sslServerAuthenticationOptions" Type="System.Net.Security.SslServerAuthenticationOptions" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sslServerAuthenticationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsServerAsync (serverCertificate, clientCertificateRequired, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">X509 używany do uwierzytelniania serwera.</param>
        <param name="clientCertificateRequired"><see cref="T:System.Boolean" /> Wartość określająca, czy klient jest monitowany o certyfikat w celu uwierzytelnienia. Należy zauważyć, że jest to tylko żądanie — Jeśli certyfikat nie jest dostarczany, serwer nadal akceptuje żądanie połączenia.</param>
        <param name="checkCertificateRevocation"><see cref="T:System.Boolean" /> Wartość określająca, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Wywoływane przez serwery do uwierzytelniania serwera i opcjonalnie klienta w połączeniach klienta z serwerem przy użyciu określonych certyfikatów, wymagań i protokołu zabezpieczeń jako operacji asynchronicznej.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsServerAsync (serverCertificate, clientCertificateRequired, enabledSslProtocols, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">X509 używany do uwierzytelniania serwera.</param>
        <param name="clientCertificateRequired"><see cref="T:System.Boolean" /> Wartość określająca, czy klient jest monitowany o certyfikat w celu uwierzytelnienia. Należy zauważyć, że jest to tylko żądanie — Jeśli certyfikat nie jest dostarczany, serwer nadal akceptuje żądanie połączenia.</param>
        <param name="enabledSslProtocols"><see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</param>
        <param name="checkCertificateRevocation"><see cref="T:System.Boolean" /> Wartość określająca, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <summary>Wywoływane przez serwery do uwierzytelniania serwera i opcjonalnie klienta w połączeniach klienta z serwerem przy użyciu określonych certyfikatów, wymagań i protokołu zabezpieczeń jako operacji asynchronicznej.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację uwierzytelniania po stronie klienta połączenia z serwerem klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia tej metody nie są blokowane, gdy uwierzytelnianie jest w toku. Aby zablokować podczas oczekiwania na ukończenie uwierzytelniania, należy użyć jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> metod.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsClient (targetHost, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, na którym jest udostępniana <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez klientów, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia serwera i opcjonalnie klienta.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]W uwierzytelnianiu nie są używane żadne certyfikaty klienta. Lista odwołania certyfikatów nie jest sprawdzana podczas uwierzytelniania.  
  
 Określona `targetHost` wartość musi być zgodna z nazwą w certyfikacie serwera.  
  
 Asynchroniczne operacje uwierzytelniania muszą zostać wykonane przez wywołanie <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata.  
  
 Ta metoda nie jest blokowana, gdy operacja zostanie ukończona. Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> przeciążeń metody.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>, nie <xref:System.Net.Security.SslStream> jest on już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetHost" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub— 
Wcześniej podjęto próbę uwierzytelnienia <see cref="T:System.Net.Security.SslStream" /> serwera.  
  
—lub— 
Uwierzytelnianie jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsClient (targetHost, clientCertificates, checkCertificateRevocation, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, na którym jest udostępniana <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawierające certyfikaty klienta.</param>
        <param name="checkCertificateRevocation"><see cref="T:System.Boolean" /> Wartość określająca, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez klientów, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia serwera i opcjonalnie klienta przy użyciu określonych certyfikatów i domyślnego protokołu zabezpieczeń systemu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Określona `targetHost` wartość musi być zgodna z nazwą w certyfikacie serwera.  
  
 Asynchroniczne operacje uwierzytelniania muszą zostać wykonane przez wywołanie <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata.  
  
 Ta metoda nie jest blokowana, gdy operacja zostanie ukończona. Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> przeciążeń metody.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>, nie <xref:System.Net.Security.SslStream> jest on już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
> [!NOTE]
>  Certyfikaty klienta nie są obsługiwane w protokole SSL w wersji 2.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetHost" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub— 
Wcześniej podjęto próbę uwierzytelnienia <see cref="T:System.Net.Security.SslStream" /> serwera.  
  
—lub— 
Uwierzytelnianie jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsClient (targetHost, clientCertificates, enabledSslProtocols, checkCertificateRevocation, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetHost">Nazwa serwera, na którym jest udostępniana <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> Zawierające certyfikaty klienta.</param>
        <param name="enabledSslProtocols"><see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</param>
        <param name="checkCertificateRevocation"><see cref="T:System.Boolean" /> Wartość określająca, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez klientów, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia serwera i opcjonalnie klienta przy użyciu określonych certyfikatów i protokołu zabezpieczeń.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Określona `targetHost` wartość musi być zgodna z nazwą w certyfikacie serwera.  
  
 Asynchroniczne operacje uwierzytelniania muszą zostać wykonane przez wywołanie <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata.  
  
 Ta metoda nie jest blokowana, gdy operacja zostanie ukończona. Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> przeciążeń metody.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>, nie <xref:System.Net.Security.SslStream> jest on już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
> [!NOTE]
>  Certyfikaty klienta nie są obsługiwane w protokole SSL w wersji 2.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetHost" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enabledSslProtocols" />nie jest prawidłową <see cref="T:System.Security.Authentication.SslProtocols" /> wartością.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub— 
Wcześniej podjęto próbę uwierzytelnienia <see cref="T:System.Net.Security.SslStream" /> serwera.  
  
—lub— 
Uwierzytelnianie jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację asynchroniczną w celu obsłużenia po stronie serwera uwierzytelniania połączenia klienta z serwerem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia tej metody nie są blokowane, gdy uwierzytelnianie jest w toku. Aby zablokować podczas oczekiwania na ukończenie uwierzytelniania, należy użyć jednej z <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> metod.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsServer (serverCertificate, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">X509 używany do uwierzytelniania serwera.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez serwery, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]Lista odwołania certyfikatów nie jest sprawdzana podczas uwierzytelniania. Klient nie musi podawać certyfikatu w celu uwierzytelnienia.  
  
 Asynchroniczne operacje uwierzytelniania muszą zostać wykonane przez wywołanie <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata.  
  
 Ta metoda nie jest blokowana, gdy operacja zostanie ukończona. Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> przeciążeń metody.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>, nie <xref:System.Net.Security.SslStream> jest on już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub— 
Uwierzytelnianie klienta przy użyciu <see cref="T:System.Net.Security.SslStream" /> tego programu było wypróbowane wcześniej.  
  
—lub— 
Uwierzytelnianie jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> Metoda nie jest obsługiwana w systemach Windows 95, Windows 98 i Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsServer (serverCertificate, clientCertificateRequired, checkCertificateRevocation, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">X509 używany do uwierzytelniania serwera.</param>
        <param name="clientCertificateRequired"><see cref="T:System.Boolean" /> Wartość określająca, czy klient jest monitowany o certyfikat w celu uwierzytelnienia. Należy zauważyć, że jest to tylko żądanie — Jeśli certyfikat nie jest dostarczany, serwer nadal akceptuje żądanie połączenia.</param>
        <param name="checkCertificateRevocation"><see cref="T:System.Boolean" /> Wartość określająca, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez serwery, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia serwera i opcjonalnie klienta przy użyciu określonych certyfikatów i wymagań oraz domyślnego protokołu zabezpieczeń systemu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Asynchroniczne operacje uwierzytelniania muszą zostać wykonane przez wywołanie <xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata.  
  
 Ta metoda nie jest blokowana, gdy operacja zostanie ukończona. Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> przeciążeń metody.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>, nie <xref:System.Net.Security.SslStream> jest on już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub— 
Wcześniej podjęto próbę uwierzytelnienia <see cref="T:System.Net.Security.SslStream" /> serwera.  
  
—lub— 
Uwierzytelnianie jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> Metoda nie jest obsługiwana w systemach Windows 95, Windows 98 i Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsServer (serverCertificate, clientCertificateRequired, enabledSslProtocols, checkCertificateRevocation, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">X509 używany do uwierzytelniania serwera.</param>
        <param name="clientCertificateRequired"><see cref="T:System.Boolean" /> Wartość określająca, czy klient jest monitowany o certyfikat w celu uwierzytelnienia. Należy zauważyć, że jest to tylko żądanie — Jeśli certyfikat nie jest dostarczany, serwer nadal akceptuje żądanie połączenia.</param>
        <param name="enabledSslProtocols"><see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</param>
        <param name="checkCertificateRevocation"><see cref="T:System.Boolean" /> Wartość określająca, czy lista odwołania certyfikatów jest sprawdzana podczas uwierzytelniania.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez serwery, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia serwera i opcjonalnie klienta przy użyciu określonych certyfikatów, wymagań i protokołu zabezpieczeń.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Asynchroniczne operacje uwierzytelniania muszą zostać wykonane przez wywołanie <xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata.  
  
 Ta metoda nie jest blokowana, gdy operacja zostanie ukończona. Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> przeciążeń metody.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>, nie <xref:System.Net.Security.SslStream> jest on już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enabledSslProtocols" />nie jest prawidłową <see cref="T:System.Security.Authentication.SslProtocols" /> wartością.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub— 
Wcześniej podjęto próbę uwierzytelnienia <see cref="T:System.Net.Security.SslStream" /> serwera.  
  
—lub— 
Uwierzytelnianie jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> Metoda nie jest obsługiwana w systemach Windows 95, Windows 98 i Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginRead (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> Tablica, która odbiera Bajty odczytane ze strumienia.</param>
        <param name="offset">Lokalizacja, w <paramref name="buffer" /> której ma zostać rozpoczęte przechowywanie danych odczytanych z tego strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania ze strumienia.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody wywoływanej po zakończeniu operacji odczytu.</param>
        <param name="asyncState">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji odczytu. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchroniczne operacje odczytu, które odczytuje dane ze strumienia i zapisuje je w określonej tablicy.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który wskazuje stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli szyfrowanie i podpisywanie są włączone, operacja odczytu odczytuje dane ze strumienia źródłowego, sprawdza integralność danych i/lub odszyfrowuje je. Asynchroniczna operacja odczytu musi zostać zakończona przez wywołanie <xref:System.Net.Security.SslStream.EndRead%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata.  
  
 Ta metoda nie jest blokowana, gdy operacja zostanie ukończona. Aby zablokować do momentu zakończenia operacji, użyj <xref:System.Net.Security.SslStream.Read%2A> metody.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 <xref:System.Net.Security.SslStream> Klasa nie obsługuje wielu jednoczesnych operacji odczytu.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia. Aby uwierzytelnić wywołanie jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metod, <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>lub,.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje uruchomienie asynchronicznej operacji odczytu.  
  
 [!code-cpp[NclSslClientAsync#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#8)]
 [!code-csharp[NclSslClientAsync#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#8)]  
 [!code-vb[NclSslClientAsync#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslClientAsync/VB/clientasync.vb#8)]  

 [!code-cpp[NclSslClientAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#4)]
 [!code-csharp[NclSslClientAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#4)] 
 [!code-vb[NclSslClientAsync#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslClientAsync/VB/clientasync.vb#4)]  

  
 Następująca metoda jest wywoływana po zakończeniu operacji odczytu.  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
 [!code-vb[NclSslClientAsync#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslClientAsync/VB/clientasync.vb#5)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" />&gt; długość .<paramref name="buffer" />  
  
—lub— 
 <paramref name="offset" />+ Zlicz &gt; <paramref name="buffer" />długość.</exception>
        <exception cref="T:System.IO.IOException">Operacja odczytu nie powiodła się.  
  
 —lub—  
  
 Szyfrowanie jest w użyciu, ale nie można odszyfrować danych.</exception>
        <exception cref="T:System.NotSupportedException">Operacja odczytu jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginWrite (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> Tablica dostarczająca bajty, które mają być zapisywane w strumieniu.</param>
        <param name="offset">Lokalizacja, w <paramref name="buffer" /> której ma zostać rozpoczęte odczytywanie bajtów do zapisu w strumieniu.</param>
        <param name="count">Wartość określająca liczbę bajtów, z <paramref name="buffer" />których ma zostać odczytany. <see cref="T:System.Int32" /></param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody wywoływanej po zakończeniu operacji zapisu.</param>
        <param name="asyncState">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji zapisu. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchroniczne operacje zapisu, które zapisują <see cref="T:System.Byte" />elementy s z określonego buforu do strumienia.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie tej metody.  
  
 [!code-cpp[NclSslServerAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#5)]
 [!code-csharp[NclSslServerAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" />&gt; długość .<paramref name="buffer" />  
  
—lub— 
 <paramref name="offset" />+ Zlicz &gt; <paramref name="buffer" />długość.</exception>
        <exception cref="T:System.IO.IOException">Operacja zapisu nie powiodła się.</exception>
        <exception cref="T:System.NotSupportedException">Operacja zapisu jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Net.Security.SslStream.CanRead" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanRead</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy źródłowy strumień jest możliwy do odczytu.</summary>
        <value><see langword="true" />Jeśli nastąpiło uwierzytelnianie i źródłowy strumień jest możliwy do odczytu; w <see langword="false" />przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nastąpiło pomyślne uwierzytelnienie, ta właściwość zwraca wartość zwróconą przez <xref:System.IO.Stream.CanRead%2A> wywołanie na źródłowym strumieniu.  
  
 Strumień źródłowy jest określany podczas tworzenia wystąpienia <xref:System.Net.Security.SslStream> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
[!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
[!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
[!code-vb[NclSslServerSync#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Net.Security.SslStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy źródłowy strumień jest możliwy do przeszukania.</summary>
        <value>Ta właściwość zawsze zwraca <see langword="false" />wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy podejmować próby ustawienia pozycji <xref:System.Net.Security.SslStream> obiektu ani jego strumienia podstawowego.  
  
 Strumień źródłowy jest określany podczas tworzenia wystąpienia <xref:System.Net.Security.SslStream> klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.CanSeek" />
        <altmember cref="P:System.Net.Security.SslStream.Position" />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Net.Security.SslStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy źródłowy strumień obsługuje limity czasu.</summary>
        <value><see langword="true" />Jeśli źródłowy strumień obsługuje limity czasu; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwróconą przez wywołanie <xref:System.IO.Stream.CanTimeout%2A> na źródłowym strumieniu.  
  
 Strumień źródłowy jest określany podczas tworzenia wystąpienia <xref:System.Net.Security.SslStream> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
[!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
[!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
[!code-vb[NclSslServerSync#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#5)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Net.Security.SslStream.CanWrite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanWrite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy źródłowy strumień jest zapisywalny.</summary>
        <value><see langword="true" />Jeśli nastąpiło uwierzytelnianie i źródłowy strumień jest zapisywalny; w <see langword="false" />przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nastąpiło pomyślne uwierzytelnienie, ta właściwość zwraca wartość zwróconą przez <xref:System.IO.Stream.CanWrite%2A> wywołanie na źródłowym strumieniu.  
  
 Strumień źródłowy jest określany podczas tworzenia wystąpienia <xref:System.Net.Security.SslStream> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
[!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
[!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
[!code-vb[NclSslServerSync#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#5)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckCertRevocationStatus">
      <MemberSignature Language="C#" Value="public virtual bool CheckCertRevocationStatus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CheckCertRevocationStatus" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CheckCertRevocationStatus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CheckCertRevocationStatus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CheckCertRevocationStatus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CheckCertRevocationStatus : bool" Usage="System.Net.Security.SslStream.CheckCertRevocationStatus" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CheckCertRevocationStatus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy lista odwołania certyfikatów jest sprawdzana podczas procesu walidacji certyfikatu.</summary>
        <value><see langword="true" />Jeśli lista odwołania certyfikatów jest zaznaczona; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lista odwołania certyfikatów zawiera certyfikaty, które zostały odwołane przez wystawcy. Sprawdzanie, czy lista ma negatywny wpływ na wydajność, ale usprawnia zabezpieczenia aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
[!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
[!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
[!code-vb[NclSslServerSync#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#5)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CipherAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.CipherAlgorithmType CipherAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.CipherAlgorithmType CipherAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CipherAlgorithm As CipherAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::CipherAlgorithmType CipherAlgorithm { System::Security::Authentication::CipherAlgorithmType get(); };" />
      <MemberSignature Language="F#" Value="member this.CipherAlgorithm : System.Security.Authentication.CipherAlgorithmType" Usage="System.Net.Security.SslStream.CipherAlgorithm" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CipherAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.CipherAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która identyfikuje algorytm szyfrowania zbiorczego używany przez ten <see cref="T:System.Net.Security.SslStream" />element.</summary>
        <value>Wartość, która identyfikuje algorytm szyfrowania zbiorczego używany w tym <see cref="T:System.Net.Security.SslStream" />programie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Security.Authentication.CipherAlgorithmType.Null> jest wymagana dla właściwości, <xref:System.Net.Security.SslStream.CipherAlgorithm%2A> gdy <xref:System.Net.Security.EncryptionPolicy.NoEncryption> wartość wyliczenia jest używana do konstruowania <xref:System.Net.Security.SslStream> wystąpienia.  
  
 [!INCLUDE[winxpsvr](~/includes/winxpsvr-md.md)]i [!INCLUDE[winxp](~/includes/winxp-md.md)] nie obsługują tej <xref:System.Security.Authentication.CipherAlgorithmType.Null> wartości. Dlatego nawet jeśli <xref:System.Security.Authentication.CipherAlgorithmType.Null> wartość jest używana do <xref:System.Net.Security.SslStream> konstruowania wystąpienia <xref:System.Security.Authentication.CipherAlgorithmType.None>, <xref:System.Net.Security.EncryptionPolicy> właściwość będzie. <xref:System.Security.Authentication.CipherAlgorithmType.Null> Wartość jest zwracana tylko w systemie Windows Vista i nowszych.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla ustawienia kryptografii określonego strumienia.  
  
[!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
[!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
[!code-vb[NclSslServerSync#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#3)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Uzyskano dostęp do właściwości przed ukończeniem procesu uwierzytelniania lub proces uwierzytelniania nie powiódł się. <see cref="P:System.Net.Security.SslStream.CipherAlgorithm" /></exception>
      </Docs>
    </Member>
    <Member MemberName="CipherStrength">
      <MemberSignature Language="C#" Value="public virtual int CipherStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CipherStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CipherStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CipherStrength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CipherStrength : int" Usage="System.Net.Security.SslStream.CipherStrength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CipherStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która identyfikuje siłę algorytmu szyfrowania używanego przez ten <see cref="T:System.Net.Security.SslStream" />element.</summary>
        <value><see cref="T:System.Int32" /> Wartość, która określa siłę algorytmu w bitach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości jest równa zero, dopóki nie nastąpi uwierzytelnienie.  
  
 Ta właściwość zwraca jedną z następujących wartości:  
  
-   0  
  
-   40  
  
-   56  
  
-   80  
  
-   128  
  
-   168  
  
-   192  
  
-   256  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla ustawienia kryptografii określonego strumienia.  
  
[!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
[!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
[!code-vb[NclSslServerSync#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#3)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="sslStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez <see cref="T:System.Net.Security.SslStream" /> program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` <xref:System.Object.Finalize%2A> i metodę. `Dispose()`wywołuje metodę chronioną `Dispose(Boolean)` `disposing` z parametrem ustawionym `true`na. <xref:System.Object.Finalize%2A>wywołuje `Dispose` `false`z `disposing` ustawionym na.  
  
 Gdy parametr ma wartość true, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.Net.Security.SslStream> których odwołują się te odwołania. `disposing` Ta metoda wywołuje `Dispose()` metodę każdego przywoływanego obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" />może być wywoływana wiele razy przez inne obiekty. W przypadku <see langword="Dispose(Boolean)" /> przesłaniania należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały <see langword="Dispose" />wcześniej usunięte w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see langword="Dispose(Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see langword="Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [Zastępowanie metody Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="sslStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie zwalnia niezarządzane i zarządzane zasoby używane przez <see cref="T:System.Net.Security.SslStream" />.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację Dispose.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia wykonywanie operacji Dispose intensywnie korzystających z zasobów bez blokowania wątku głównego. 

 Ta metoda również usuwa strumień wewnętrzny, gdy <xref:System.Net.Security.AuthenticatedStream.LeaveInnerStreamOpen> jest `false`; w przeciwnym razie strumień wewnętrzny jest właśnie opróżniany.
 
 Wywołanie `DisposeAsync` zezwala na przydzielenie zasobów używanych <xref:System.Net.Security.SslStream> przez program do innych celów. Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsClient (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsClient : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsClient : IAsyncResult -&gt; unit" Usage="sslStream.EndAuthenticateAsClient asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndAuthenticateAsClient(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Wystąpienie zwrócone przez <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />wywołanie metody. <see cref="T:System.IAsyncResult" /></param>
        <summary>Zakończenie oczekującej operacji asynchronicznego uwierzytelniania serwera rozpoczętej z poprzednim wywołaniem <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />do.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja nie została ukończona, ta metoda jest blokowana, dopóki nie zostanie wykonana. Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.SslStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.SslStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.SslStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 Aby wykonać tę operację synchronicznie, użyj jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> metod.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został utworzony przez wywołanie metody <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Nie ma oczekującego uwierzytelniania na serwerze.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsServer (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsServer(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsServer : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsServer : IAsyncResult -&gt; unit" Usage="sslStream.EndAuthenticateAsServer asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndAuthenticateAsServer(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Wystąpienie zwrócone przez <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />wywołanie metody. <see cref="T:System.IAsyncResult" /></param>
        <summary>Zakończenie oczekującej asynchronicznej operacji uwierzytelniania klienta rozpoczętej z poprzednim wywołaniem do <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja nie została ukończona, ta metoda jest blokowana, dopóki nie zostanie wykonana. Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.SslStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.SslStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.SslStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, otrzymasz komunikat <xref:System.Security.Authentication.AuthenticationException>i nie będzie on <xref:System.Net.Security.SslStream> już użyteczny. Należy zamknąć ten obiekt i usunąć z niego wszystkie odwołania, aby można było go zebrać przez moduł wyrzucania elementów bezużytecznych.  
  
 Aby wykonać tę operację synchronicznie, użyj jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> metod.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został utworzony przez wywołanie metody <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się i pozostawiono ten obiekt w stanie niezdatnym do użytku.</exception>
        <exception cref="T:System.InvalidOperationException">Nie ma oczekującego uwierzytelniania klienta do ukończenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="sslStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndRead(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Wystąpienie zwrócone przez wywołanie elementu<see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Zakończenie asynchronicznej operacji odczytu rozpoczętej z poprzednim wywołaniem <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />do.</summary>
        <returns><see cref="T:System.Int32" /> Wartość określająca liczbę bajtów odczytanych ze strumienia źródłowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja nie została ukończona, ta metoda jest blokowana, dopóki nie zostanie wykonana.  
  
 Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Security.SslStream.Read%2A> metody.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia. Aby uwierzytelnić wywołanie jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metod, <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>lub,.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zakończenie asynchronicznej operacji odczytu.  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
 [!code-vb[NclSslClientAsync#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslClientAsync/VB/clientasync.vb#5)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został utworzony przez wywołanie metody <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak oczekującej operacji odczytu do wykonania.

—lub—

Nie nastąpiło uwierzytelnianie.</exception>
        <exception cref="T:System.IO.IOException">Operacja odczytu nie powiodła się.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="sslStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndWrite(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Wystąpienie zwrócone przez wywołanie elementu<see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Zakończenie asynchronicznej operacji zapisu rozpoczętej z poprzednim wywołaniem <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />do.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja nie została ukończona, ta metoda jest blokowana, dopóki nie zostanie wykonana.  
  
 Aplikacja nie może wywołać tej metody do momentu pomyślnego uwierzytelnienia. Aby przeprowadzić uwierzytelnianie, wywołaj jedną <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>z <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metod <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>lub,.  
  
 Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Security.SslStream.Write%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zakończenie asynchronicznej operacji zapisu.  
  
 [!code-cpp[NclSslServerAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#4)]
 [!code-csharp[NclSslServerAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został utworzony przez wywołanie metody <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak oczekującej operacji zapisu do wykonania.

—lub—

Nie nastąpiło uwierzytelnianie.</exception>
        <exception cref="T:System.IO.IOException">Operacja zapisu nie powiodła się.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="sslStream.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że wszystkie buforowane dane są zapisywane na podstawowym urządzeniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.IO.Stream.Flush%2A> na źródłowym strumieniu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie tej metody.  
  
 [!code-cpp[NclSslClientSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#5)]
 [!code-csharp[NclSslClientSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#5)]  
 [!code-vb[NclSslClientSync#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslClientSync/VB/clientsync.vb#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="sslStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.HashAlgorithmType HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.HashAlgorithmType HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashAlgorithm As HashAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::HashAlgorithmType HashAlgorithm { System::Security::Authentication::HashAlgorithmType get(); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Security.Authentication.HashAlgorithmType" Usage="System.Net.Security.SslStream.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.HashAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.HashAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera algorytm używany do generowania kodów uwierzytelniania wiadomości (Mac).</summary>
        <value>Algorytm używany do generowania kodów uwierzytelniania wiadomości (Mac).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algorytmy uwierzytelniania wiadomości generują wartości skrótu wiadomości i podpisy używane do wykrywania naruszenia i fałszowania.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla ustawienia kryptografii określonego strumienia.  
  
[!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
[!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
[!code-vb[NclSslServerSync#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#3)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Uzyskano dostęp do właściwości przed ukończeniem procesu uwierzytelniania lub proces uwierzytelniania nie powiódł się. <see cref="P:System.Net.Security.SslStream.HashAlgorithm" /></exception>
      </Docs>
    </Member>
    <Member MemberName="HashStrength">
      <MemberSignature Language="C#" Value="public virtual int HashStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HashStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int HashStrength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HashStrength : int" Usage="System.Net.Security.SslStream.HashStrength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.HashStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która identyfikuje siłę algorytmu wyznaczania wartości skrótu używanego przez to wystąpienie.</summary>
        <value>Wartość, która określa siłę <see cref="T:System.Security.Authentication.HashAlgorithmType" /> algorytmu w bitach. <see cref="T:System.Int32" /> Prawidłowe wartości to 128 lub 160.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości jest równa zero, dopóki nie nastąpi uwierzytelnienie.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla ustawienia kryptografii określonego strumienia.  
  
[!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
[!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
[!code-vb[NclSslServerSync#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#3)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Net.Security.SslStream.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsAuthenticated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy uwierzytelnianie zakończyło się pomyślnie.</summary>
        <value><see langword="true" />Jeśli nastąpiło pomyślne uwierzytelnienie; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klienci są <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> uwierzytelniani przez wywoływanie metod lub <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> . Serwery są uwierzytelniane przez <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> wywołanie <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metod lub.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
[!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
[!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
[!code-vb[NclSslServerSync#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#4)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEncrypted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEncrypted : bool" Usage="System.Net.Security.SslStream.IsEncrypted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsEncrypted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest <see cref="T:System.Net.Security.SslStream" /> używane szyfrowanie danych. <see cref="T:System.Boolean" /></summary>
        <value><see langword="true" />Jeśli dane są szyfrowane przed przesłaniem przez sieć i odszyfrowywane po osiągnięciu zdalnego punktu końcowego; w <see langword="false" />przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Szyfrowanie pomaga chronić prywatność danych, co pomaga zapewnić, że podczas przesyłania danych nie można go odszyfrować od stron trzecich.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
[!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
[!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
[!code-vb[NclSslServerSync#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#4)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMutuallyAuthenticated : bool" Usage="System.Net.Security.SslStream.IsMutuallyAuthenticated" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsMutuallyAuthenticated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy zarówno serwer, jak i klient został uwierzytelniony.</summary>
        <value><see langword="true" />Jeśli serwer został uwierzytelniony; w <see langword="false" />przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie wzajemne jest określane przez serwer, gdy serwer chce, aby klient zapewniał certyfikat do uwierzytelniania.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
[!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
[!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
[!code-vb[NclSslServerSync#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#4)]
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" />
        <altmember cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsServer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsServer : bool" Usage="System.Net.Security.SslStream.IsServer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsServer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy lokalna strona połączenia używana przez ten <see cref="T:System.Net.Security.SslStream" /> program została uwierzytelniona jako serwer. <see cref="T:System.Boolean" /></summary>
        <value><see langword="true" />Jeśli lokalny punkt końcowy został pomyślnie uwierzytelniony jako Strona serwera uwierzytelnionego połączenia; w <see langword="false" />przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli uwierzytelnianie nie powiodło się lub nie nastąpiło `false`, ta właściwość zwraca wartość.  
  
 Aby uwierzytelnić się jako serwer, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> Wywołaj <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metody lub.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
[!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
[!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
[!code-vb[NclSslServerSync#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#4)]
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSigned { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSigned : bool" Usage="System.Net.Security.SslStream.IsSigned" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsSigned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy dane wysyłane przy użyciu tego strumienia są podpisane.</summary>
        <value><see langword="true" />Jeśli dane są podpisane przed przesłaniem; w <see langword="false" />przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podpisywanie danych pomaga chronić integralność danych, a mianowicie pomaga odbiorcom określić, czy dane zostały naruszone podczas przesyłania.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
[!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
[!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
[!code-vb[NclSslServerSync#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#4)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyExchangeAlgorithm As ExchangeAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::ExchangeAlgorithmType KeyExchangeAlgorithm { System::Security::Authentication::ExchangeAlgorithmType get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeAlgorithm : System.Security.Authentication.ExchangeAlgorithmType" Usage="System.Net.Security.SslStream.KeyExchangeAlgorithm" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.KeyExchangeAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExchangeAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera algorytm wymiany kluczy używany przez ten <see cref="T:System.Net.Security.SslStream" />program.</summary>
        <value><see cref="T:System.Security.Authentication.ExchangeAlgorithmType" /> Wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości jest <xref:System.Security.Authentication.ExchangeAlgorithmType.None> do momentu wystąpienia uwierzytelnienia.  
  
 Algorytm wymiany kluczy chroni informacje używane do generowania kluczy współużytkowanych.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla ustawienia kryptografii określonego strumienia.  
  
[!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
[!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
[!code-vb[NclSslServerSync#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#3)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeStrength">
      <MemberSignature Language="C#" Value="public virtual int KeyExchangeStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeyExchangeStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyExchangeStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int KeyExchangeStrength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeStrength : int" Usage="System.Net.Security.SslStream.KeyExchangeStrength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.KeyExchangeStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą siłę algorytmu wymiany kluczy używanego przez to wystąpienie.</summary>
        <value>Wartość, która określa siłę <see cref="T:System.Security.Authentication.ExchangeAlgorithmType" /> algorytmu w bitach. <see cref="T:System.Int32" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości jest równa zero, dopóki nie nastąpi uwierzytelnienie.  
  
 W typowych scenariuszach wartość tej właściwości jest jedną z następujących wartości:  
  
-   512  
  
-   768  
  
-   1024  
  
-   2048  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla ustawienia kryptografii określonego strumienia.  
  
[!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
[!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
[!code-vb[NclSslServerSync#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#3)]  

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Net.Security.SslStream.Length" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość źródłowego strumienia.</summary>
        <value>Długość źródłowego strumienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwróconą przez wywołanie <xref:System.IO.Stream.Length%2A> na źródłowym strumieniu. Jeśli źródłowy strumień nie jest możliwy do przeszukiwania, ta metoda zwykle zgłasza wyjątek. Typ czasu wykonywania źródłowego strumienia określa typ czasu wykonywania wygenerowanego wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Pobieranie wartości tej właściwości nie jest obsługiwane, gdy źródłowy strumień jest <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.LocalCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LocalCertificate As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::X509Certificates::X509Certificate ^ LocalCertificate { System::Security::Cryptography::X509Certificates::X509Certificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalCertificate : System.Security.Cryptography.X509Certificates.X509Certificate" Usage="System.Net.Security.SslStream.LocalCertificate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.LocalCertificate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera certyfikat używany do uwierzytelniania lokalnego punktu końcowego.</summary>
        <value>Obiekt x509 reprezentujący certyfikat dostarczony na potrzeby uwierzytelniania lub <see langword="null" /> Jeśli nie podano żadnego certyfikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie certyfikatu zwróconego przez tę właściwość.  
  
[!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
[!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
[!code-vb[NclSslServerSync#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#6)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie nie powiodło się lub nie nastąpiło.</exception>
      </Docs>
    </Member>
    <Member MemberName="NegotiatedApplicationProtocol">
      <MemberSignature Language="C#" Value="public System.Net.Security.SslApplicationProtocol NegotiatedApplicationProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.SslApplicationProtocol NegotiatedApplicationProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.NegotiatedApplicationProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NegotiatedApplicationProtocol As SslApplicationProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::SslApplicationProtocol NegotiatedApplicationProtocol { System::Net::Security::SslApplicationProtocol get(); };" />
      <MemberSignature Language="F#" Value="member this.NegotiatedApplicationProtocol : System.Net.Security.SslApplicationProtocol" Usage="System.Net.Security.SslStream.NegotiatedApplicationProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.SslApplicationProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NegotiatedCipherSuite">
      <MemberSignature Language="C#" Value="public virtual System.Net.Security.TlsCipherSuite NegotiatedCipherSuite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.TlsCipherSuite NegotiatedCipherSuite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.NegotiatedCipherSuite" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NegotiatedCipherSuite As TlsCipherSuite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::Security::TlsCipherSuite NegotiatedCipherSuite { System::Net::Security::TlsCipherSuite get(); };" />
      <MemberSignature Language="F#" Value="member this.NegotiatedCipherSuite : System.Net.Security.TlsCipherSuite" Usage="System.Net.Security.SslStream.NegotiatedCipherSuite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.TlsCipherSuite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pakiet szyfrowania, który został wynegocjowany dla tego połączenia.</summary>
        <value>Jedna z wartości wyliczenia, które identyfikują mechanizm szyfrowania, który został wynegocjowany dla tego połączenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Ta właściwość pobiera pakiet szyfrowania, który będzie używany w komunikacji między klientem a serwerem przez podstawową implementację protokołu SSL/TLS. Jest on dostępny tylko po pomyślnym wywołaniu <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> lub <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Uzyskano dostęp do właściwości przed ukończeniem procesu uwierzytelniania lub proces uwierzytelniania nie powiódł się.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Net.Security.SslStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżącą pozycję w źródłowym strumieniu.</summary>
        <value>Bieżąca pozycja w strumieniu źródłowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwróconą przez wywołanie <xref:System.IO.Stream.Position%2A> na źródłowym strumieniu. Jeśli źródłowy strumień nie jest możliwy do przeszukiwania, ta metoda zwykle zgłasza wyjątek. Typ czasu wykonywania źródłowego strumienia określa typ czasu wykonywania wygenerowanego wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ustawienie tej właściwości nie jest obsługiwane.  
  
—lub— 
Pobieranie wartości tej właściwości nie jest obsługiwane, gdy źródłowy strumień jest <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="sslStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Read(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> Tablica, która odbiera Bajty odczytane z tego strumienia.</param>
        <param name="offset">A <see cref="T:System.Int32" /> , który zawiera lokalizację, w <paramref name="buffer" /> której ma zostać rozpoczęte przechowywanie danych odczytanych z tego strumienia.</param>
        <param name="count">A <see cref="T:System.Int32" /> , który zawiera maksymalną liczbę bajtów odczytywanych z tego strumienia.</param>
        <summary>Odczytuje dane z tego strumienia i zapisuje je w określonej tablicy.</summary>
        <returns><see cref="T:System.Int32" /> Wartość określająca liczbę odczytanych bajtów. Gdy nie ma więcej danych do odczytu, zwraca wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda odczytuje maksymalnie `count` bajty ze strumienia i zapisuje je w `buffer` czasie `offset`od. Nie można wykonać wielu jednoczesnych operacji odczytu.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia. Aby uwierzytelnić wywołanie jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metod, <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>lub,.  
  
 Aby wykonać tę operację asynchronicznie, użyj <xref:System.Net.Security.SslStream.BeginRead%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje odczyt z <xref:System.Net.Security.SslStream>.  
  
 [!code-cpp[NclSslClientSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#6)]
 [!code-csharp[NclSslClientSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#6)]  
 [!code-vb[NclSslClientSync#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslClientSync/VB/clientsync.vb#6)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" />&gt; długość .<paramref name="buffer" />  
  
—lub— 
 <paramref name="offset" />+ Zlicz &gt; <paramref name="buffer" />długość.</exception>
        <exception cref="T:System.IO.IOException">Operacja odczytu nie powiodła się. Sprawdź wewnętrzny wyjątek, jeśli jest obecny, aby określić przyczynę niepowodzenia.</exception>
        <exception cref="T:System.NotSupportedException">Operacja odczytu jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="sslStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, który odbiera Bajty odczytane z tego strumienia.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie odczytuje dane z tego strumienia i zapisuje je w określonym zakresie pamięci.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu. Wartość <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> właściwości zawiera łączną liczbę <paramref name="buffer" />odczytanych bajtów. Gdy nie ma więcej danych do odczytu, zwraca wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odczytuje tyle danych, ile jest dostępnych w `buffer`. 
 
 Nie można wykonać wielu jednoczesnych operacji odczytu.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
        <exception cref="T:System.IO.IOException">Operacja odczytu nie powiodła się. Sprawdź wewnętrzny wyjątek, jeśli jest obecny, aby określić przyczynę niepowodzenia.</exception>
        <exception cref="T:System.NotSupportedException">Operacja odczytu jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="sslStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, który odbiera Bajty odczytane z tego strumienia.</param>
        <param name="offset">Lokalizacja, w <paramref name="buffer" /> której ma zostać rozpoczęte przechowywanie danych odczytanych z tego strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania z tego strumienia.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie odczytuje dane z tego strumienia i zapisuje je w określonym zakresie tablicy bajtów.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu. Wartość <see cref="P:System.Threading.Tasks.Task`1.Result" /> właściwości zawiera łączną liczbę <paramref name="buffer" />odczytanych bajtów. Gdy nie ma więcej danych do odczytu, zwraca wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda odczytuje maksymalnie `count` bajty ze strumienia i zapisuje je w `buffer` czasie `offset`od. 
 
 Nie można wykonać wielu jednoczesnych operacji odczytu.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" />jest mniejsza niż 0.
  
—lub— 
 <paramref name="count" />jest większa niż długość <paramref name="buffer" /> znaku minus. <paramref name="offset" /></exception>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
        <exception cref="T:System.IO.IOException">Operacja odczytu nie powiodła się. Sprawdź wewnętrzny wyjątek, jeśli jest obecny, aby określić przyczynę niepowodzenia.</exception>
        <exception cref="T:System.NotSupportedException">Operacja odczytu jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="sslStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bajt z <see cref="T:System.Net.Security.SslStream" /> i przesuwa pozycję w strumieniu o jeden bajt lub zwraca-1, jeśli na końcu strumienia.</summary>
        <returns>Bajty bez znaku rzutowanie <see langword="Int32" />na lub-1, jeśli na końcu strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks   
 Nie można wykonać wielu jednoczesnych operacji odczytu.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
        <exception cref="T:System.IO.IOException">Operacja odczytu nie powiodła się. Sprawdź wewnętrzny wyjątek, jeśli jest obecny, aby określić przyczynę niepowodzenia.</exception>
        <exception cref="T:System.NotSupportedException">Operacja odczytu jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Net.Security.SslStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.ReadTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ilość czasu wyrażoną w milisekundach bloki operacji odczytu czekające na dane.</summary>
        <value>Czas (w milisekundach), który upłynął przed wykonaniem synchronicznej operacji odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwróconą przez wywołanie <xref:System.IO.Stream.ReadTimeout%2A> na źródłowym strumieniu. Po ustawieniu tej właściwości <xref:System.IO.Stream.ReadTimeout%2A> wartość w strumieniu źródłowym jest ustawiana na określoną wartość.  
  
 Jeśli źródłowy strumień jest <xref:System.Net.Sockets.NetworkStream> <xref:System.Net.Security.SslStream.ReadTimeout%2A> w milisekundach i jest domyślnie ustawiony na <xref:System.Threading.Timeout.Infinite> wartość, tak aby operacje odczytu nie przekroczyły limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje ustawienie wartości tej właściwości.  
  
[!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
[!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
[!code-vb[NclSslServerSync#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.RemoteCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoteCertificate As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::X509Certificates::X509Certificate ^ RemoteCertificate { System::Security::Cryptography::X509Certificates::X509Certificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteCertificate : System.Security.Cryptography.X509Certificates.X509Certificate" Usage="System.Net.Security.SslStream.RemoteCertificate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.RemoteCertificate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera certyfikat używany do uwierzytelniania zdalnego punktu końcowego.</summary>
        <value>Obiekt x509 reprezentujący certyfikat dostarczony na potrzeby uwierzytelniania lub <see langword="null" /> Jeśli nie podano żadnego certyfikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie certyfikatu zwróconego przez tę właściwość.  
  
[!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
[!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
[!code-vb[NclSslServerSync#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#6)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie nie powiodło się lub nie nastąpiło.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="sslStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Ta wartość jest ignorowana.</param>
        <param name="origin">Ta wartość jest ignorowana.</param>
        <summary><see cref="T:System.NotSupportedException" />Zgłasza.</summary>
        <returns>Zawsze zgłasza <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody. Jest on Dziedziczony, ale nie jest obsługiwany przez <xref:System.Net.Security.SslStream> klasę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wyszukiwanie nie jest obsługiwane przez <see cref="T:System.Net.Security.SslStream" /> obiekty.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="sslStream.SetLength value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.SetLength(System.Int64)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Int64" /> Wartość, która określa długość strumienia.</param>
        <summary>Ustawia długość źródłowego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.IO.Stream.SetLength%2A?displayProperty=nameWithType> źródłowy strumień określony <xref:System.Net.Security.SslStream> podczas tworzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task ShutdownAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task ShutdownAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.ShutdownAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ShutdownAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ ShutdownAsync();" />
      <MemberSignature Language="F#" Value="abstract member ShutdownAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.ShutdownAsync : unit -&gt; System.Threading.Tasks.Task" Usage="sslStream.ShutdownAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka ten SslStream.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SslProtocol">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.SslProtocols SslProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.SslProtocols SslProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.SslProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SslProtocol As SslProtocols" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::SslProtocols SslProtocol { System::Security::Authentication::SslProtocols get(); };" />
      <MemberSignature Language="F#" Value="member this.SslProtocol : System.Security.Authentication.SslProtocols" Usage="System.Net.Security.SslStream.SslProtocol" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.SslProtocol</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.SslProtocols</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą protokół zabezpieczeń używany do uwierzytelniania tego połączenia.</summary>
        <value><see cref="T:System.Security.Authentication.SslProtocols" /> Wartość, która reprezentuje protokół używany do uwierzytelniania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługiwane protokoły zabezpieczeń są określane podczas <xref:System.Net.Security.SslStream> tworzenia. Jeśli do konstruktora nie przekazano żadnego protokołu zabezpieczeń, wystąpienie jest tworzone przy użyciu <xref:System.Security.Authentication.SslProtocols.Default>. W oparciu o protokoły obsługiwane przez klienta i serwer wybierany jest rzeczywisty protokół używany do uwierzytelniania.  
  
   
  
## Examples  
 Poniższy przykład wyświetla właściwości zabezpieczeń określonego strumienia.  
  
[!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
[!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
[!code-vb[NclSslServerSync#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#3)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransportContext">
      <MemberSignature Language="C#" Value="public System.Net.TransportContext TransportContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.TransportContext TransportContext" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.TransportContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransportContext As TransportContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::TransportContext ^ TransportContext { System::Net::TransportContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransportContext : System.Net.TransportContext" Usage="System.Net.Security.SslStream.TransportContext" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.TransportContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.TransportContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.TransportContext" /> Pobiera używany do uwierzytelniania przy użyciu ochrony rozszerzonej.</summary>
        <value><see cref="T:System.Net.TransportContext" /> Obiekt, który zawiera token powiązania kanału (CBT) używany do ochrony rozszerzonej.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje dane w tym strumieniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] -&gt; unit" Usage="sslStream.Write buffer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Write(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> Tablica, która dostarcza bajty zapisywane w strumieniu.</param>
        <summary>Zapisuje określone dane w tym strumieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana, gdy operacja zostanie ukończona. Aby zapobiec blokowaniu podczas kończenia operacji, użyj <xref:System.Net.Security.SslStream.BeginWrite%2A> metody.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia. Aby uwierzytelnić wywołanie jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metod, <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>lub,.  
  
 <xref:System.Net.Security.SslStream> Klasa nie obsługuje wielu równoczesnych operacji zapisu.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje zapis do uwierzytelnienia <xref:System.Net.Security.SslStream>.  
  
[!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
[!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
[!code-vb[NclSslServerSync#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Operacja zapisu nie powiodła się.</exception>
        <exception cref="T:System.NotSupportedException">Operacja zapisu jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="sslStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Write(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> Tablica, która dostarcza bajty zapisywane w strumieniu.</param>
        <param name="offset">A <see cref="T:System.Int32" /> , który zawiera lokalizację, w <paramref name="buffer" /> której ma zacząć odczytywanie bajtów do zapisania w strumieniu.</param>
        <param name="count">A <see cref="T:System.Int32" /> , który zawiera liczbę bajtów, z <paramref name="buffer" />których ma zostać odczytany.</param>
        <summary>Napisz określoną liczbę <see cref="T:System.Byte" />s do źródłowego strumienia przy użyciu określonego buforu i przesunięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana, gdy operacja zostanie ukończona. Aby zapobiec blokowaniu, gdy operacja kończy działanie, użyj <xref:System.Net.Security.SslStream.BeginWrite%2A> metody.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia. Aby uwierzytelnić wywołanie jednej z <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> metod, <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>lub,.  
  
 <xref:System.Net.Security.SslStream> Klasa nie obsługuje wielu równoczesnych operacji zapisu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" />&gt; długość .<paramref name="buffer" />  
  
—lub— 
 <paramref name="offset" />+ Zlicz &gt; <paramref name="buffer" />długość.</exception>
        <exception cref="T:System.IO.IOException">Operacja zapisu nie powiodła się.</exception>
        <exception cref="T:System.NotSupportedException">Operacja zapisu jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="sslStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Dane do zapisu w źródłowym strumieniu.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie zapisuje dane do strumienia źródłowego z zakresu pamięci bajtów tylko do odczytu.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia. 

<xref:System.Net.Security.SslStream> Klasa nie obsługuje wielu równoczesnych operacji zapisu.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
        <exception cref="T:System.IO.IOException">Operacja zapisu nie powiodła się.</exception>
        <exception cref="T:System.NotSupportedException">Operacja zapisu jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="sslStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Dane do zapisu w źródłowym strumieniu.</param>
        <param name="offset">Lokalizacja <paramref name="buffer" /> , z której ma zostać rozpoczęte zapisywanie danych.</param>
        <param name="count">Liczba bajtów do zapisu w źródłowym strumieniu.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania.</param>
        <summary>Asynchronicznie zapisuje dane do strumienia źródłowego z określonego zakresu tablicy bajtów.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia. 

<xref:System.Net.Security.SslStream> Klasa nie obsługuje wielu równoczesnych operacji zapisu.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" />jest mniejsza niż 0.
  
—lub— 
 <paramref name="count" />jest większa niż długość <paramref name="buffer" /> znaku minus. <paramref name="offset" /></exception>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
        <exception cref="T:System.IO.IOException">Operacja zapisu nie powiodła się.</exception>
        <exception cref="T:System.NotSupportedException">Operacja zapisu jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Net.Security.SslStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.WriteTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ilość czasu, w którym bloki operacji zapisu oczekują na dane.</summary>
        <value>Czas, jaki upływa przed operacją zapisu synchronicznego, kończy się niepowodzeniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwróconą przez wywołanie <xref:System.IO.Stream.WriteTimeout%2A> na źródłowym strumieniu. W przypadku operacji ustawiania określona wartość ustawia <xref:System.IO.Stream.WriteTimeout%2A> wartość w strumieniu źródłowym.  
  
 Jeśli źródłowy strumień jest <xref:System.Net.Sockets.NetworkStream> <xref:System.Net.Security.SslStream.WriteTimeout%2A> w milisekundach i jest domyślnie ustawiony na <xref:System.Threading.Timeout.Infinite> wartość, tak aby operacje zapisu nie przekroczyły limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje ustawienie wartości tej właściwości.  
  
[!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
[!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
[!code-vb[NclSslServerSync#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclSslServerSync/VB/serversync.vb#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

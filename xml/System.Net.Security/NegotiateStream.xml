<Type Name="NegotiateStream" FullName="System.Net.Security.NegotiateStream">
  <TypeSignature Language="C#" Value="public class NegotiateStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NegotiateStream extends System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.NegotiateStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NegotiateStream&#xA;Inherits AuthenticatedStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NegotiateStream : System::Net::Security::AuthenticatedStream" />
  <TypeSignature Language="F#" Value="type NegotiateStream = class&#xA;    inherit AuthenticatedStream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia strumień, który używa protokołu zabezpieczeń Negocjuj do uwierzytelniania klienta i opcjonalnie serwera w komunikacji klient-serwer.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Security.NegotiateStream> Użyj klasy do uwierzytelniania i zabezpieczania informacji przesyłanych między klientem a serwerem. Korzystając <xref:System.Net.Security.NegotiateStream>z programu, można wykonać następujące czynności.  
  
-   Wyślij poświadczenia klienta na serwer pod kątem personifikacji lub delegowania.  
  
-   Żądaj uwierzytelniania serwera.  
  
-   Szyfruj i/lub podpisz dane przed ich przesłaniem.  
  
 Przed przesłaniem informacji należy przeprowadzić uwierzytelnianie. Klienci żądają uwierzytelniania przy użyciu <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> metod synchronicznych, które blokują do momentu zakończenia uwierzytelniania <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> lub metod asynchronicznych, które nie są blokowane podczas oczekiwania na ukończenie uwierzytelniania. Serwery żądają uwierzytelniania przy użyciu <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> metod synchronicznych lub asynchronicznych. <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> Klient i opcjonalnie serwer programu są uwierzytelniani przy użyciu protokołu zabezpieczeń Negocjuj. W systemach Windows 95/98 system Windows NT LAN Manager (NTLM) to protokół używany do uwierzytelniania. Na innych platformach protokół Kerberos jest używany do uwierzytelniania, jeśli obsługuje go klient i serwer; w przeciwnym razie jest używany protokół NTLM. Aby uzyskać szczegółowe opisy tych protokołów, zobacz dokumentację zestawu SDK platformy w witrynie MSDN, pod adresem msdn.microsoft.com/library/. <xref:System.Net.Security.NegotiateStream> Klasa wykonuje uwierzytelnianie przy użyciu interfejsu dostawcy obsługi zabezpieczeń (SSPI).  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które usługi zabezpieczeń będą używane przez program, aby pomóc w <xref:System.Net.Security.NegotiateStream> zabezpieczeniu danych podczas przesyłania. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie. Możesz uzyskać informacje o kliencie zdalnym lub serwerze przy użyciu <xref:System.Net.Security.NegotiateStream.RemoteIdentity%2A> właściwości.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie wyświetlony <xref:System.Security.Authentication.AuthenticationException> komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 Dane są wysyłane przy użyciu metod <xref:System.Net.Security.NegotiateStream.Write%2A> synchronicznych <xref:System.Net.Security.NegotiateStream.BeginWrite%2A> lub asynchronicznych. Dane są odbierane przy użyciu <xref:System.Net.Security.NegotiateStream.Read%2A> metod synchronicznych lub asynchronicznych. <xref:System.Net.Security.NegotiateStream.BeginRead%2A> Jeśli są włączone usługi zabezpieczeń, takie jak szyfrowanie lub podpisywanie, są one automatycznie stosowane do danych <xref:System.Net.Security.NegotiateStream>przez.  
  
 Przesyła dane przy użyciu strumienia dostarczanego podczas <xref:System.Net.Security.NegotiateStream>tworzenia. <xref:System.Net.Security.NegotiateStream> Po dostarczeniu tego strumienia bazowego można określić, czy zamknięcie <xref:System.Net.Security.NegotiateStream> tego strumienia spowoduje również zamknięcie źródłowego.  
  
   
  
## Examples  
Poniższy przykład demonstruje po stronie klienta połączenia klient-serwer, które używa programu <xref:System.Net.Security.NegotiateStream>. Klient uwierzytelnia i wysyła komunikat do serwera asynchronicznie.  
  
[!code-cpp[NclNegoAsyncClient#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#0)]
[!code-csharp[NclNegoAsyncClient#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#0)]  
[!code-vb[NclNegoAsyncClient#0](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#0)] 

Poniższy przykład kodu demonstruje po stronie serwera połączenia klient-serwer, które korzysta z programu, <xref:System.Net.Security.NegotiateStream> aby uwierzytelnić klienta i odczytać komunikat Wysłany przez klienta.  
  
[!code-cpp[NclNegoAsyncServer#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#0)]
[!code-csharp[NclNegoAsyncServer#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#0)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Zmiany w uwierzytelnianiu NTLM dla HTTPWebRequest w wersji 3,5 SP1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Security.NegotiateStream" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapobiec <xref:System.Net.Security.NegotiateStream> zamykaniu przez użytkownika strumienia, <xref:System.Net.Security.NegotiateStream.%23ctor%28System.IO.Stream%2CSystem.Boolean%29> Użyj konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateStream : System.IO.Stream -&gt; System.Net.Security.NegotiateStream" Usage="new System.Net.Security.NegotiateStream innerStream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream"><see cref="T:System.IO.Stream" /> Obiekt używany <see cref="T:System.Net.Security.NegotiateStream" /> przez program do wysyłania i otrzymywania danych.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Security.NegotiateStream" /> klasy przy użyciu określonego <see cref="T:System.IO.Stream" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie tego konstruktora.  
  
 [!code-cpp[NclNegoSyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#3)]
 [!code-csharp[NclNegoSyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateStream : System.IO.Stream * bool -&gt; System.Net.Security.NegotiateStream" Usage="new System.Net.Security.NegotiateStream (innerStream, leaveInnerStreamOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream"><see cref="T:System.IO.Stream" /> Obiekt używany <see cref="T:System.Net.Security.NegotiateStream" /> przez program do wysyłania i otrzymywania danych.</param>
        <param name="leaveInnerStreamOpen"><see langword="true" />Aby wskazać, że zamknięcie <see cref="T:System.Net.Security.NegotiateStream" /> nie ma wpływu na <paramref name="innerStream" />; , aby wskazać, że <see cref="T:System.Net.Security.NegotiateStream" /> zamknięcie jest również zamykane <paramref name="innerStream" />. <see langword="false" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Security.NegotiateStream" /> klasy przy użyciu określonego <see cref="T:System.IO.Stream" /> i zamknięcia strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu `true` `leaveStreamOpen` dla parametru, zamknięcie <xref:System.Net.Security.NegotiateStream> nie ma wpływu na `innerStream` strumień; należy jawnie zamknąć `innerStream` , gdy nie jest już potrzebne.  
  
   
  
## Examples  
Poniższy przykład demonstruje wywołanie tego konstruktora. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Net.Security.NegotiateStream> klasy.  
  
[!code-cpp[NclNegoAsyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#1)]
[!code-csharp[NclNegoAsyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#1)]  
[!code-vb[NclNegoAsyncClient#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#1)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="innerStream" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="innerStream" />jest równe <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : unit -&gt; unit&#xA;override this.AuthenticateAsClient : unit -&gt; unit" Usage="negotiateStream.AuthenticateAsClient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie używa klienta <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Nie określono głównej nazwy usługi (SPN) dla serwera. Poziom personifikacji to <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, poziom zabezpieczeń jest <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, a żądanie wzajemnego uwierzytelniania. <xref:System.Net.Security.NegotiateStream> Klasa będzie konstruować nazwę SPN używaną do uwierzytelniania wzajemnego.  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * string -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * string -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="targetName">Nazwa główna usługi (SPN), która jednoznacznie identyfikuje serwer do uwierzytelnienia.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonego poświadczenia klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom personifikacji to <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, poziom zabezpieczeń jest <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, a żądanie wzajemnego uwierzytelniania. <xref:System.Net.Security.NegotiateStream> Klasa będzie konstruować nazwę SPN używaną do uwierzytelniania wzajemnego.  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, binding, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="binding"><see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> Jest używany do ochrony rozszerzonej.</param>
        <param name="targetName">Nazwa główna usługi (SPN), która jednoznacznie identyfikuje serwer do uwierzytelnienia.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonego poświadczenia klienta i powiązania kanału.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom personifikacji to <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, poziom zabezpieczeń jest <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, a żądanie wzajemnego uwierzytelniania. <xref:System.Net.Security.NegotiateStream> Klasa będzie konstruować nazwę SPN używaną do uwierzytelniania wzajemnego.  
  
 Używana do ochrony rozszerzonej, która jest przenoszona do tej metody `binding` w parametrze, zostanie pobrana <xref:System.Net.Security.SslStream.TransportContext%2A> przez aplikację z właściwości <xref:System.Net.Security.SslStream>skojarzonej. <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="credential" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="targetName">Nazwa główna usługi (SPN), która jednoznacznie identyfikuje serwer do uwierzytelnienia.</param>
        <param name="requiredProtectionLevel">Jedna z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości, wskazująca usługi zabezpieczeń dla strumienia.</param>
        <param name="allowedImpersonationLevel">Jedna z <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> wartości wskazująca, w jaki sposób serwer może używać poświadczeń klienta w celu uzyskania dostępu do zasobów.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonych poświadczeń i opcji uwierzytelniania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `requiredProtectionLevel` , aby zażądać usług zabezpieczeń dla danych przesyłanych przy użyciu uwierzytelnionego strumienia. Na przykład, aby dane były szyfrowane i podpisane, określ <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> wartość. Pomyślne uwierzytelnienie nie gwarantuje, że żądanie <xref:System.Net.Security.ProtectionLevel> zostało udzielone. Należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="allowedImpersonationLevel" />nie jest prawidłową wartością.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" />ma wartość null.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="binding"><see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> Jest używany do ochrony rozszerzonej.</param>
        <param name="targetName">Nazwa główna usługi (SPN), która jednoznacznie identyfikuje serwer do uwierzytelnienia.</param>
        <param name="requiredProtectionLevel">Jedna z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości, wskazująca usługi zabezpieczeń dla strumienia.</param>
        <param name="allowedImpersonationLevel">Jedna z <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> wartości wskazująca, w jaki sposób serwer może używać poświadczeń klienta w celu uzyskania dostępu do zasobów.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonych poświadczeń, opcji uwierzytelniania i powiązania kanałów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `requiredProtectionLevel` , aby zażądać usług zabezpieczeń dla danych przesyłanych przy użyciu uwierzytelnionego strumienia. Na przykład, aby dane były szyfrowane i podpisane, określ <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> wartość. Pomyślne uwierzytelnienie nie gwarantuje, że żądanie <xref:System.Net.Security.ProtectionLevel> zostało udzielone. Należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program.  
  
 Używana do ochrony rozszerzonej, która jest przenoszona do tej metody `binding` w parametrze, zostanie pobrana <xref:System.Net.Security.SslStream.TransportContext%2A> przez aplikację z właściwości <xref:System.Net.Security.SslStream>skojarzonej. <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="credential" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="allowedImpersonationLevel" />nie jest prawidłową wartością.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClientAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia klienta i opcjonalnie serwera w ramach połączenia klienta z serwerem jako operacji asynchronicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : unit -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia klienta i opcjonalnie serwera w ramach połączenia klienta z serwerem jako operacji asynchronicznej.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie używa klienta <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Nie określono głównej nazwy usługi (SPN) dla serwera. Poziom personifikacji to <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, poziom zabezpieczeń jest <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, a żądanie wzajemnego uwierzytelniania. <xref:System.Net.Security.NegotiateStream> Klasa będzie konstruować nazwę SPN używaną do uwierzytelniania wzajemnego.  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * string -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="targetName">Nazwa główna usługi (SPN), która jednoznacznie identyfikuje serwer do uwierzytelnienia.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia klienta i opcjonalnie serwera w ramach połączenia klienta z serwerem jako operacji asynchronicznej. Proces uwierzytelniania używa określonego poświadczenia klienta.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom personifikacji to <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, poziom zabezpieczeń jest <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, a żądanie wzajemnego uwierzytelniania. <xref:System.Net.Security.NegotiateStream> Klasa będzie konstruować nazwę SPN używaną do uwierzytelniania wzajemnego.  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, binding, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="binding"><see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> Jest używany do ochrony rozszerzonej.</param>
        <param name="targetName">Nazwa główna usługi (SPN), która jednoznacznie identyfikuje serwer do uwierzytelnienia.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia klienta i opcjonalnie serwera w ramach połączenia klienta z serwerem jako operacji asynchronicznej. Proces uwierzytelniania używa określonego poświadczenia klienta i powiązania kanału.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom personifikacji to <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, poziom zabezpieczeń jest <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, a żądanie wzajemnego uwierzytelniania. <xref:System.Net.Security.NegotiateStream> Klasa będzie konstruować nazwę SPN używaną do uwierzytelniania wzajemnego.  
  
 Używana do ochrony rozszerzonej, która jest przenoszona do tej metody `binding` w parametrze, zostanie pobrana <xref:System.Net.Security.SslStream.TransportContext%2A> przez aplikację z właściwości <xref:System.Net.Security.SslStream>skojarzonej. <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="credential" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="targetName">Nazwa główna usługi (SPN), która jednoznacznie identyfikuje serwer do uwierzytelnienia.</param>
        <param name="requiredProtectionLevel">Jedna z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości, wskazująca usługi zabezpieczeń dla strumienia.</param>
        <param name="allowedImpersonationLevel">Jedna z <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> wartości wskazująca, w jaki sposób serwer może używać poświadczeń klienta w celu uzyskania dostępu do zasobów.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia klienta i opcjonalnie serwera w ramach połączenia klienta z serwerem jako operacji asynchronicznej. Proces uwierzytelniania używa określonych poświadczeń i opcji uwierzytelniania.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `requiredProtectionLevel` , aby zażądać usług zabezpieczeń dla danych przesyłanych przy użyciu uwierzytelnionego strumienia. Na przykład, aby dane były szyfrowane i podpisane, określ <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> wartość. Pomyślne uwierzytelnienie nie gwarantuje, że żądanie <xref:System.Net.Security.ProtectionLevel> zostało udzielone. Należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="allowedImpersonationLevel" />nie jest prawidłową wartością.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" />ma wartość null.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="binding"><see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> Jest używany do ochrony rozszerzonej.</param>
        <param name="targetName">Nazwa główna usługi (SPN), która jednoznacznie identyfikuje serwer do uwierzytelnienia.</param>
        <param name="requiredProtectionLevel">Jedna z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości, wskazująca usługi zabezpieczeń dla strumienia.</param>
        <param name="allowedImpersonationLevel">Jedna z <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> wartości wskazująca, w jaki sposób serwer może używać poświadczeń klienta w celu uzyskania dostępu do zasobów.</param>
        <summary>Wywoływane przez klientów w celu uwierzytelnienia klienta i opcjonalnie serwera w ramach połączenia klienta z serwerem jako operacji asynchronicznej. Proces uwierzytelniania używa określonych poświadczeń, opcji uwierzytelniania i powiązania kanałów.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `requiredProtectionLevel` , aby zażądać usług zabezpieczeń dla danych przesyłanych przy użyciu uwierzytelnionego strumienia. Na przykład, aby dane były szyfrowane i podpisane, określ <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> wartość. Pomyślne uwierzytelnienie nie gwarantuje, że żądanie <xref:System.Net.Security.ProtectionLevel> zostało udzielone. Należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program.  
  
 Używana do ochrony rozszerzonej, która jest przenoszona do tej metody `binding` w parametrze, zostanie pobrana <xref:System.Net.Security.SslStream.TransportContext%2A> przez aplikację z właściwości <xref:System.Net.Security.SslStream>skojarzonej. <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding>  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="credential" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="allowedImpersonationLevel" />nie jest prawidłową wartością.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obsługuje po stronie serwera uwierzytelniania dla połączenia klient-serwer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te metody blokują, gdy uwierzytelnianie jest w toku. Aby zapobiec blokowaniu aplikacji podczas oczekiwania na ukończenie uwierzytelniania, należy użyć <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : unit -&gt; unit&#xA;override this.AuthenticateAsServer : unit -&gt; unit" Usage="negotiateStream.AuthenticateAsServer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływane przez serwery w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie używa serwera <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Nie określono głównej nazwy usługi (SPN) dla serwera. Poziom personifikacji to <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, a poziom zabezpieczeń to. <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Ta metoda jest blokowana do momentu zakończenia operacji. Aby zapobiec blokowaniu do momentu zakończenia operacji, użyj jednego <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> z przeciążeń metody.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Systemy Windows 95 i Windows 98 nie są obsługiwane.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (policy As ExtendedProtectionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; unit" Usage="negotiateStream.AuthenticateAsServer policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="policy"><see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> Jest używany do ochrony rozszerzonej.</param>
        <summary>Wywoływane przez serwery w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonych zasad ochrony rozszerzonej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie używa serwera <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Nie określono głównej nazwy usługi (SPN) dla serwera. Poziom personifikacji to <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, a poziom zabezpieczeń to. <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>  
  
 Jeśli parametr ma `null`wartość, zostanie <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>użyta rozszerzona zasada ochrony, która ma ustawioną opcję. `policy`  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Ta metoda jest blokowana do momentu zakończenia operacji. Aby zapobiec blokowaniu do momentu zakończenia operacji, użyj jednego <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> z przeciążeń metody.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametry i <see langword="null" />zasady ochrony rozszerzonej przekazaną w parametrze są jednocześnie. <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> <paramref name="policy" /></exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.NotSupportedException">Systemy Windows 95 i Windows 98 nie są obsługiwane.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><paramref name="policy" /> Parametr został <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> ustawiony na na platformie, która nie obsługuje ochrony rozszerzonej.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsServer (credential, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustalenia tożsamości serwera.</param>
        <param name="requiredProtectionLevel">Jedna z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości, wskazująca usługi zabezpieczeń dla strumienia.</param>
        <param name="requiredImpersonationLevel">Jedna z <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> wartości wskazująca, w jaki sposób serwer może używać poświadczeń klienta w celu uzyskania dostępu do zasobów.</param>
        <summary>Wywoływane przez serwery w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonych poświadczeń serwera i opcji uwierzytelniania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Ta metoda jest blokowana do momentu zakończenia operacji. Aby zapobiec blokowaniu do momentu zakończenia operacji, użyj jednego <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> z przeciążeń metody.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" />musi być <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, lub <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby spróbować do uwierzytelniania za pomocą języka r.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako klient. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako serwer.</exception>
        <exception cref="T:System.NotSupportedException">Systemy Windows 95 i Windows 98 nie są obsługiwane.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsServer (credential, policy, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="policy"><see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> Jest używany do ochrony rozszerzonej.</param>
        <param name="requiredProtectionLevel">Jedna z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości, wskazująca usługi zabezpieczeń dla strumienia.</param>
        <param name="requiredImpersonationLevel">Jedna z <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> wartości wskazująca, w jaki sposób serwer może używać poświadczeń klienta w celu uzyskania dostępu do zasobów.</param>
        <summary>Wywoływane przez serwery w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonych poświadczeń serwera, opcji uwierzytelniania i zasad ochrony rozszerzonej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli parametr ma `null`wartość, zostanie <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>użyta rozszerzona zasada ochrony, która ma ustawioną opcję. `policy`  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Ta metoda jest blokowana do momentu zakończenia operacji. Aby zapobiec blokowaniu do momentu zakończenia operacji, użyj jednego <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> z przeciążeń metody.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametry i <see langword="null" />zasady ochrony rozszerzonej przekazaną w parametrze są jednocześnie. <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> <paramref name="policy" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" />musi być <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, lub <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby spróbować do uwierzytelniania za pomocą języka r.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako klient. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako serwer.</exception>
        <exception cref="T:System.NotSupportedException">Systemy Windows 95 i Windows 98 nie są obsługiwane.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><paramref name="policy" /> Parametr został <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> ustawiony na na platformie, która nie obsługuje ochrony rozszerzonej.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obsługuje po stronie serwera uwierzytelniania dla połączenia klienta z serwerem jako operacji asynchronicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : unit -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływane przez serwery w celu uwierzytelnienia klienta i opcjonalnie serwera, w połączeniu klienta z serwerem jako operacji asynchronicznej.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie używa serwera <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Nie określono głównej nazwy usługi (SPN) dla serwera. Poziom personifikacji to <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, a poziom zabezpieczeń to. <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Systemy Windows 95 i Windows 98 nie są obsługiwane.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (policy As ExtendedProtectionPolicy) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="policy"><see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> Jest używany do ochrony rozszerzonej.</param>
        <summary>Wywoływane przez serwery w celu uwierzytelnienia klienta i opcjonalnie serwera, w połączeniu klienta z serwerem jako operacji asynchronicznej. Proces uwierzytelniania używa określonych zasad ochrony rozszerzonej.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie używa serwera <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Nie określono głównej nazwy usługi (SPN) dla serwera. Poziom personifikacji to <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, a poziom zabezpieczeń to. <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>  
  
 Jeśli parametr ma `null`wartość, zostanie <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>użyta rozszerzona zasada ochrony, która ma ustawioną opcję. `policy`  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametry i <see langword="null" />zasady ochrony rozszerzonej przekazaną w parametrze są jednocześnie. <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> <paramref name="policy" /></exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.NotSupportedException">Systemy Windows 95 i Windows 98 nie są obsługiwane.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><paramref name="policy" /> Parametr został <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> ustawiony na na platformie, która nie obsługuje ochrony rozszerzonej.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync (credential, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustalenia tożsamości serwera.</param>
        <param name="requiredProtectionLevel">Jedna z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości, wskazująca usługi zabezpieczeń dla strumienia.</param>
        <param name="requiredImpersonationLevel">Jedna z <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> wartości wskazująca, w jaki sposób serwer może używać poświadczeń klienta w celu uzyskania dostępu do zasobów.</param>
        <summary>Wywoływane przez serwery w celu uwierzytelnienia klienta i opcjonalnie serwera, w połączeniu klienta z serwerem jako operacji asynchronicznej. Proces uwierzytelniania używa określonych poświadczeń serwera i opcji uwierzytelniania.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" />musi być <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, lub <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby spróbować do uwierzytelniania za pomocą języka r.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako klient. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako serwer.</exception>
        <exception cref="T:System.NotSupportedException">Systemy Windows 95 i Windows 98 nie są obsługiwane.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync (credential, policy, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="policy"><see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> Jest używany do ochrony rozszerzonej.</param>
        <param name="requiredProtectionLevel">Jedna z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości, wskazująca usługi zabezpieczeń dla strumienia.</param>
        <param name="requiredImpersonationLevel">Jedna z <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> wartości wskazująca, w jaki sposób serwer może używać poświadczeń klienta w celu uzyskania dostępu do zasobów.</param>
        <summary>Wywoływane przez serwery w celu uwierzytelnienia klienta i opcjonalnie serwera, w połączeniu klienta z serwerem jako operacji asynchronicznej. Proces uwierzytelniania używa określonych poświadczeń serwera, opcji uwierzytelniania i zasad ochrony rozszerzonej.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli parametr ma `null`wartość, zostanie <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>użyta rozszerzona zasada ochrony, która ma ustawioną opcję. `policy`  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametry i <see langword="null" />zasady ochrony rozszerzonej przekazaną w parametrze są jednocześnie. <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> <paramref name="policy" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" />musi być <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, lub <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby spróbować do uwierzytelniania za pomocą języka r.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako klient. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako serwer.</exception>
        <exception cref="T:System.NotSupportedException">Systemy Windows 95 i Windows 98 nie są obsługiwane.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><paramref name="policy" /> Parametr został <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> ustawiony na na platformie, która nie obsługuje ochrony rozszerzonej.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację asynchroniczną w celu uwierzytelnienia po stronie klienta połączenia klient-serwer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia tej metody nie są blokowane, gdy uwierzytelnianie jest w toku. Aby zablokować podczas oczekiwania na ukończenie uwierzytelniania, należy użyć jednej z <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> metod.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Zdefiniowany przez użytkownika obiekt zawierający informacje o operacji. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez klientów, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Ta metoda nie jest blokowana.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie używa klienta <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Nie określono głównej nazwy usługi (SPN) dla serwera. Poziom personifikacji to <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, a poziom zabezpieczeń to. <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> <xref:System.Net.Security.NegotiateStream> Klasa będzie konstruować nazwę SPN używaną do uwierzytelniania wzajemnego.  
  
 Ta metoda jest asynchroniczna i nie jest blokowana podczas kończenia operacji. Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> przeciążeń metody.  
  
 Asynchroniczne operacje uwierzytelniania muszą zostać wykonane przez wywołanie <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata. Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
   
  
## Examples  
Poniższy przykład demonstruje wywołanie tej metody, aby rozpocząć uwierzytelnianie asynchroniczne dla klienta.  
  
[!code-cpp[NclNegoAsyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#2)]
[!code-csharp[NclNegoAsyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#2)]  
[!code-vb[NclNegoAsyncClient#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#2)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * string * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, targetName, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="targetName">Nazwa główna usługi (SPN), która jednoznacznie identyfikuje serwer do uwierzytelnienia.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Zdefiniowany przez użytkownika obiekt zawierający informacje o operacji zapisu. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez klientów, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonych poświadczeń. Ta metoda nie jest blokowana.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest asynchroniczna i nie jest blokowana podczas kończenia operacji. Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> przeciążeń metody.  
  
 Asynchroniczne operacje uwierzytelniania muszą zostać wykonane przez wywołanie <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata. Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="targetName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, binding, targetName, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="binding"><see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> Jest używany do ochrony rozszerzonej.</param>
        <param name="targetName">Nazwa główna usługi (SPN), która jednoznacznie identyfikuje serwer do uwierzytelnienia.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Zdefiniowany przez użytkownika obiekt zawierający informacje o operacji zapisu. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez klientów, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonych poświadczeń i powiązania kanałów. Ta metoda nie jest blokowana.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest asynchroniczna i nie jest blokowana podczas kończenia operacji. Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> przeciążeń metody.  
  
 Asynchroniczne operacje uwierzytelniania muszą zostać wykonane przez wywołanie <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata. Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="targetName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="targetName">Nazwa główna usługi (SPN), która jednoznacznie identyfikuje serwer do uwierzytelnienia.</param>
        <param name="requiredProtectionLevel">Jedna z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości, wskazująca usługi zabezpieczeń dla strumienia.</param>
        <param name="allowedImpersonationLevel">Jedna z <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> wartości wskazująca, w jaki sposób serwer może używać poświadczeń klienta w celu uzyskania dostępu do zasobów.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Zdefiniowany przez użytkownika obiekt zawierający informacje o operacji zapisu. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez klientów, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonych poświadczeń i opcji uwierzytelniania. Ta metoda nie jest blokowana.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `requiredProtectionLevel` , aby zażądać usług zabezpieczeń dla danych przesyłanych przy użyciu uwierzytelnionego strumienia. Na przykład, aby dane były szyfrowane i podpisane, określ <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> wartość. Pomyślne uwierzytelnienie nie gwarantuje, że żądanie <xref:System.Net.Security.ProtectionLevel> zostało udzielone. Należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program.  
  
 Ta metoda jest asynchroniczna i nie jest blokowana podczas kończenia operacji. Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> przeciążeń metody.  
  
 Asynchroniczne operacje uwierzytelniania muszą zostać wykonane przez wywołanie <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata. Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="targetName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="binding"><see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> Jest używany do ochrony rozszerzonej.</param>
        <param name="targetName">Nazwa główna usługi (SPN), która jednoznacznie identyfikuje serwer do uwierzytelnienia.</param>
        <param name="requiredProtectionLevel">Jedna z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości, wskazująca usługi zabezpieczeń dla strumienia.</param>
        <param name="allowedImpersonationLevel">Jedna z <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> wartości wskazująca, w jaki sposób serwer może używać poświadczeń klienta w celu uzyskania dostępu do zasobów.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Zdefiniowany przez użytkownika obiekt zawierający informacje o operacji zapisu. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez klientów, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonych poświadczeń, opcji uwierzytelniania i powiązania kanałów. Ta metoda nie jest blokowana.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `requiredProtectionLevel` , aby zażądać usług zabezpieczeń dla danych przesyłanych przy użyciu uwierzytelnionego strumienia. Na przykład, aby dane były szyfrowane i podpisane, określ <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> wartość. Pomyślne uwierzytelnienie nie gwarantuje, że żądanie <xref:System.Net.Security.ProtectionLevel> zostało udzielone. Należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program.  
  
 Ta metoda jest asynchroniczna i nie jest blokowana podczas kończenia operacji. Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> przeciążeń metody.  
  
 Asynchroniczne operacje uwierzytelniania muszą zostać wykonane przez wywołanie <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata. Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="targetName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako serwer. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako klient.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna operację asynchroniczną w celu obsłużenia po stronie serwera uwierzytelniania połączenia klienta z serwerem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia tej metody nie są blokowane, gdy trwa uwierzytelnianie. Aby zablokować podczas oczekiwania na ukończenie uwierzytelniania, należy użyć <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Zdefiniowany przez użytkownika obiekt zawierający informacje o operacji. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez serwery, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Ta metoda nie jest blokowana.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie używa serwera <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Nie określono głównej nazwy usługi (SPN) dla serwera. Poziomem personifikacji jest <xref:System.Security.Principal.TokenImpersonationLevel.Identification>poziom zabezpieczeń. <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> przeciążeń metody.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Systemy Windows 95 i Windows 98 nie są obsługiwane.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (policy, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="policy"><see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> Jest używany do ochrony rozszerzonej.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Zdefiniowany przez użytkownika obiekt zawierający informacje o operacji zapisu. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez serwery, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonych zasad ochrony rozszerzonej. Ta metoda nie jest blokowana.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie używa serwera <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Nie określono głównej nazwy usługi (SPN) dla serwera. Poziomem personifikacji jest <xref:System.Security.Principal.TokenImpersonationLevel.Identification>poziom zabezpieczeń. <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>  
  
 Jeśli parametr ma `null`wartość, zostanie <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>użyta rozszerzona zasada ochrony, która ma ustawioną opcję. `policy`  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> przeciążeń metody.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametry i <see langword="null" />zasady ochrony rozszerzonej przekazaną w parametrze są jednocześnie. <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> <paramref name="policy" /></exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.NotSupportedException">Systemy Windows 95 i Windows 98 nie są obsługiwane.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><paramref name="policy" /> Parametr został <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> ustawiony na na platformie, która nie obsługuje ochrony rozszerzonej.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (credential, requiredProtectionLevel, requiredImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="requiredProtectionLevel">Jedna z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości, wskazująca usługi zabezpieczeń dla strumienia.</param>
        <param name="requiredImpersonationLevel">Jedna z <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> wartości wskazująca, w jaki sposób serwer może używać poświadczeń klienta w celu uzyskania dostępu do zasobów.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Zdefiniowany przez użytkownika obiekt zawierający informacje o operacji. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez serwery, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonych poświadczeń serwera i opcji uwierzytelniania. Ta metoda nie jest blokowana.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `requiredProtectionLevel` , aby zażądać usług zabezpieczeń dla danych przesyłanych przy użyciu uwierzytelnionego strumienia. Na przykład, aby dane były szyfrowane i podpisane, określ <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> wartość. Pomyślne uwierzytelnienie nie gwarantuje, że żądanie <xref:System.Net.Security.ProtectionLevel> zostało udzielone. Należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program.  
  
 Ta metoda jest asynchroniczna i nie jest blokowana podczas kończenia operacji. Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> przeciążeń metody.  
  
 Asynchroniczne operacje uwierzytelniania muszą zostać wykonane przez wywołanie <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata. Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" />musi być <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, lub <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako klient. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako serwer.</exception>
        <exception cref="T:System.NotSupportedException">Systemy Windows 95 i Windows 98 nie są obsługiwane.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć jawnie <see cref="T:System.Net.NetworkCredential" />. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (credential, policy, requiredProtectionLevel, requiredImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential"><see cref="T:System.Net.NetworkCredential" /> Służy do ustanowienia tożsamości klienta.</param>
        <param name="policy"><see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> Jest używany do ochrony rozszerzonej.</param>
        <param name="requiredProtectionLevel">Jedna z <see cref="T:System.Net.Security.ProtectionLevel" /> wartości, wskazująca usługi zabezpieczeń dla strumienia.</param>
        <param name="requiredImpersonationLevel">Jedna z <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> wartości wskazująca, w jaki sposób serwer może używać poświadczeń klienta w celu uzyskania dostępu do zasobów.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody, która ma zostać wywołana po zakończeniu uwierzytelniania.</param>
        <param name="asyncState">Zdefiniowany przez użytkownika obiekt zawierający informacje o operacji zapisu. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Wywoływane przez serwery, aby rozpocząć operację asynchroniczną w celu uwierzytelnienia klienta i opcjonalnie serwera w połączeniu klienta z serwerem. Proces uwierzytelniania używa określonych poświadczeń serwera, opcji uwierzytelniania i zasad ochrony rozszerzonej. Ta metoda nie jest blokowana.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj parametru `requiredProtectionLevel` , aby zażądać usług zabezpieczeń dla danych przesyłanych przy użyciu uwierzytelnionego strumienia. Na przykład, aby dane były szyfrowane i podpisane, określ <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> wartość. Pomyślne uwierzytelnienie nie gwarantuje, że żądanie <xref:System.Net.Security.ProtectionLevel> zostało udzielone. Należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program.  
  
 Jeśli parametr ma `null`wartość, zostanie <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>użyta rozszerzona zasada ochrony, która ma ustawioną opcję. `policy`  
  
 Ta metoda jest asynchroniczna i nie jest blokowana podczas kończenia operacji. Aby zablokować do momentu zakończenia operacji, użyj jednego z <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> przeciążeń metody.  
  
 Asynchroniczne operacje uwierzytelniania muszą zostać wykonane przez wywołanie <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata. Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametry i <see langword="null" />zasady ochrony rozszerzonej przekazaną w parametrze są jednocześnie. <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> <paramref name="policy" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" />musi być <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, lub <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie już się nie poszło.  
  
—lub—
  
 Ten strumień był wcześniej używany do próby uwierzytelniania jako klient. Nie można użyć strumienia, aby ponowić próbę uwierzytelnienia jako serwer.</exception>
        <exception cref="T:System.NotSupportedException">Systemy Windows 95 i Windows 98 nie są obsługiwane.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException"><paramref name="policy" /> Parametr został <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> ustawiony na na platformie, która nie obsługuje ochrony rozszerzonej.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Zintegrowane uwierzytelnianie systemu Windows z ochroną rozszerzoną</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginRead (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> Tablica, która odbiera Bajty odczytane ze strumienia.</param>
        <param name="offset">Lokalizacja, w <paramref name="buffer" /> której ma zostać rozpoczęte przechowywanie danych odczytanych z tego strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania ze strumienia.</param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody wywoływanej po zakończeniu operacji odczytu.</param>
        <param name="asyncState">Zdefiniowany przez użytkownika obiekt zawierający informacje o operacji odczytu. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchroniczne operacje odczytu, które odczytuje dane ze strumienia i zapisuje je w określonej tablicy.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli szyfrowanie, podpisywanie lub szyfrowanie i podpisywanie są włączone, operacja odczytu odczytuje dane ze strumienia źródłowego, sprawdza integralność danych i odszyfrowuje je. Jeśli nie są używane żadne usługi zabezpieczeń, takie jak szyfrowanie lub podpisywanie danych, ta metoda uruchamia asynchroniczną operację odczytu na źródłowym strumieniu.  
  
 Ta metoda jest asynchroniczna i nie jest blokowana podczas kończenia operacji. Aby zablokować do momentu zakończenia operacji, użyj <xref:System.Net.Security.NegotiateStream.Read%2A> metody.  
  
 Asynchroniczna operacja odczytu musi zostać zakończona przez wywołanie <xref:System.Net.Security.NegotiateStream.EndRead%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata. Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 <xref:System.Net.Security.NegotiateStream> Klasa nie obsługuje wielu jednoczesnych operacji odczytu. Jeśli podjęto próbę uruchomienia operacji odczytu, podczas gdy inna operacja odczytu jest już wykonywana w tym samym strumieniu, <xref:System.NotSupportedException> zostanie zgłoszony wyjątek.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia. Aby przeprowadzić uwierzytelnianie, wywołaj jedną <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>z <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>metod <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>,, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> , lub.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje uruchomienie asynchronicznej operacji odczytu. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Net.Security.NegotiateStream> klasy.  
  
 [!code-cpp[NclNegoAsyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#1)]
 [!code-csharp[NclNegoAsyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="offset" />znak <paramref name="count" /> Plus jest większy niż <paramref name="buffer" />długość.</exception>
        <exception cref="T:System.IO.IOException">Operacja odczytu nie powiodła się.  
  
—lub—
  
 Szyfrowanie jest w użyciu, ale nie można odszyfrować danych.</exception>
        <exception cref="T:System.NotSupportedException">Operacja odczytu jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginWrite (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> Tablica dostarczająca bajty, które mają być zapisywane w strumieniu.</param>
        <param name="offset">Lokalizacja, w <paramref name="buffer" /> której ma zostać rozpoczęte odczytywanie bajtów do zapisu w strumieniu.</param>
        <param name="count">Wartość określająca liczbę bajtów, z <paramref name="buffer" />których ma zostać odczytany. <see cref="T:System.Int32" /></param>
        <param name="asyncCallback"><see cref="T:System.AsyncCallback" /> Delegat odwołujący się do metody wywoływanej po zakończeniu operacji zapisu.</param>
        <param name="asyncState">Zdefiniowany przez użytkownika obiekt zawierający informacje o operacji zapisu. Ten obiekt jest przesyłany do <paramref name="asyncCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Rozpoczyna asynchroniczne operacje zapisu, które zapisują <see cref="T:System.Byte" />elementy s z określonego buforu do strumienia.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt wskazujący stan operacji asynchronicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli włączono szyfrowanie, podpisywanie lub szyfrowanie i podpisywanie, ta metoda odczytuje dane z bufora, szyfruje, podpisuje lub szyfruje i podpisuje je, a następnie przesyła je za pomocą źródłowego strumienia. Jeśli nie są używane żadne usługi zabezpieczeń, takie jak szyfrowanie lub podpisywanie danych, ta metoda uruchamia asynchroniczną operację zapisu na źródłowym strumieniu.  
  
 Ta metoda jest asynchroniczna i nie jest blokowana podczas kończenia operacji. Aby zablokować do momentu zakończenia operacji, użyj <xref:System.Net.Security.NegotiateStream.Read%2A> metody.  
  
 Asynchroniczna operacja odczytu musi zostać zakończona przez wywołanie <xref:System.Net.Security.NegotiateStream.EndWrite%2A> metody. Zazwyczaj Metoda jest wywoływana przez `asyncCallback` delegata. Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [wywoływanie metod synchronicznych asynchronicznie](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 <xref:System.Net.Security.NegotiateStream> Klasa nie obsługuje wielu równoczesnych operacji zapisu. Jeśli podjęto próbę uruchomienia operacji zapisu, podczas gdy inna operacja zapisu jest już wykonywana w tym samym strumieniu, <xref:System.NotSupportedException> zostanie zgłoszony wyjątek.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia. Aby przeprowadzić uwierzytelnianie, wywołaj jedną <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>z <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>metod <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>,, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> , lub.  
  
   
  
## Examples  
Poniższy przykład ilustruje rozpoczęcie asynchronicznej operacji zapisu.  
  
[!code-cpp[NclNegoAsyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#3)]
[!code-csharp[NclNegoAsyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#3)]  
[!code-vb[NclNegoAsyncClient#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#3)] 

Następująca metoda jest wywoływana, gdy operacja zostanie ukończona.  
  
[!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
[!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
[!code-vb[NclNegoAsyncClient#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#4)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset is less than 0" />.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="offset" />Liczba plusów jest większa niż długość <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Operacja zapisu nie powiodła się.  
  
—lub—
  
 Szyfrowanie jest w użyciu, ale nie można zaszyfrować danych.</exception>
        <exception cref="T:System.NotSupportedException">Operacja zapisu jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Net.Security.NegotiateStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy źródłowy strumień jest możliwy do odczytu.</summary>
        <value><see langword="true" />Jeśli nastąpiło uwierzytelnianie i źródłowy strumień jest możliwy do odczytu; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nastąpiło pomyślne uwierzytelnienie, ta właściwość zwraca wartość zwróconą przez wywołanie <xref:System.IO.Stream.CanRead%2A> właściwości na źródłowym strumieniu. Strumień źródłowy jest określany podczas tworzenia wystąpienia <xref:System.Net.Security.NegotiateStream> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Net.Security.NegotiateStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy źródłowy strumień jest możliwy do przeszukania.</summary>
        <value>Ta właściwość zawsze zwraca <see langword="false" />wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy podejmować próby ustawienia pozycji <xref:System.Net.Security.NegotiateStream> obiektu ani jego strumienia podstawowego. Strumień źródłowy jest określany podczas tworzenia wystąpienia <xref:System.Net.Security.NegotiateStream> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Security.NegotiateStream.Position" />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy źródłowy strumień obsługuje limity czasu.</summary>
        <value><see langword="true" />Jeśli źródłowy strumień obsługuje limity czasu; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwróconą przez wywołanie <xref:System.IO.Stream.CanTimeout%2A> właściwości w strumieniu źródłowym. Strumień źródłowy jest określany podczas tworzenia wystąpienia <xref:System.Net.Security.NegotiateStream> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Net.Security.NegotiateStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy źródłowy strumień jest zapisywalny.</summary>
        <value><see langword="true" />Jeśli nastąpiło uwierzytelnianie i źródłowy strumień jest zapisywalny; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nastąpiło pomyślne uwierzytelnienie, ta właściwość zwraca wartość zwróconą przez wywołanie <xref:System.IO.Stream.CanWrite%2A> właściwości na źródłowym strumieniu. Strumień źródłowy jest określany podczas tworzenia wystąpienia <xref:System.Net.Security.NegotiateStream> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="negotiateStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez <see cref="T:System.Net.Security.NegotiateStream" /> program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` <xref:System.Object.Finalize%2A> i metodę. `Dispose()`wywołuje metodę chronioną `Dispose(Boolean)` `disposing` z parametrem ustawionym `true`na. <xref:System.Object.Finalize%2A>wywołuje `Dispose` `false`z `disposing` ustawionym na.  
  
 Gdy parametr ma wartość true, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.Net.Security.NegotiateStream> których odwołują się te odwołania. `disposing` Ta metoda wywołuje `Dispose()` metodę każdego przywoływanego obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" />może być wywoływana wiele razy przez inne obiekty. W przypadku <see langword="Dispose(Boolean)" /> przesłaniania należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały <see langword="Dispose" />wcześniej usunięte w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see langword="Dispose(Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see langword="Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [Zastępowanie metody Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="negotiateStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie zwalnia niezarządzane i zarządzane zasoby używane przez <see cref="T:System.Net.Security.NegotiateStream" />.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację Dispose.</returns>
        <remarks>
          <format type="text/markdown">
  <![CDA  
  
## Remarks  
 Ta metoda umożliwia wykonywanie operacji Dispose intensywnie korzystających z zasobów bez blokowania wątku głównego. 

 Ta metoda również usuwa strumień wewnętrzny, gdy <xref:System.Net.Security.AuthenticatedStream.LeaveInnerStreamOpen> jest `false`; w przeciwnym razie strumień wewnętrzny jest właśnie opróżniany.
 
 Wywołanie `DisposeAsync` zezwala na przydzielenie zasobów używanych <xref:System.Net.Security.NegotiateStream> przez program do innych celów. Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsClient (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsClient : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsClient : IAsyncResult -&gt; unit" Usage="negotiateStream.EndAuthenticateAsClient asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Wystąpienie zwrócone przez <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />wywołanie metody. <see cref="T:System.IAsyncResult" /></param>
        <summary>Zakończenie oczekującej asynchronicznej operacji uwierzytelniania klienta, która została uruchomiona z wywołaniem do <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja nie została ukończona, ta metoda jest blokowana, dopóki nie zostanie wykonana. Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 Aby wykonać tę operację synchronicznie, użyj jednej z <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> metod.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został utworzony przez wywołanie metody <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.InvalidOperationException">Nie ma oczekującego uwierzytelniania klienta do ukończenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsServer (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsServer(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsServer : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsServer : IAsyncResult -&gt; unit" Usage="negotiateStream.EndAuthenticateAsServer asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Wystąpienie zwrócone przez <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />wywołanie metody. <see cref="T:System.IAsyncResult" /></param>
        <summary>Zakończenie oczekującej asynchronicznej operacji uwierzytelniania klienta, która została uruchomiona z wywołaniem do <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja nie została ukończona, ta metoda jest blokowana, dopóki nie zostanie wykonana.  
  
 Po pomyślnym uwierzytelnieniu należy sprawdzić <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> właściwości i <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , aby określić, które <xref:System.Net.Security.NegotiateStream>usługi zabezpieczeń są używane przez program. Sprawdź Właściwość <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> , aby określić, czy nastąpiło wzajemne uwierzytelnianie.  
  
 Jeśli uwierzytelnianie nie powiedzie się, zostanie <xref:System.Security.Authentication.AuthenticationException> wyświetlony komunikat <xref:System.Security.Authentication.InvalidCredentialException>lub. W takim przypadku można ponowić próbę uwierzytelnienia przy użyciu innego poświadczenia.  
  
 Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został utworzony przez wywołanie metody <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Uwierzytelnianie nie powiodło się. Możesz użyć tego obiektu, aby ponowić próbę uwierzytelnienia.</exception>
        <exception cref="T:System.InvalidOperationException">Nie ma oczekującego uwierzytelniania do ukończenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="negotiateStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Wystąpienie zwrócone przez wywołanie elementu<see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Zamyka asynchroniczną operację odczytu, która została rozpoczęta z wywołaniem do <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <returns><see cref="T:System.Int32" /> Wartość określająca liczbę bajtów odczytanych ze strumienia źródłowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja nie została ukończona, ta metoda jest blokowana, dopóki nie zostanie wykonana.  
  
 Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Security.NegotiateStream.Read%2A> metody.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia. Aby przeprowadzić uwierzytelnianie, wywołaj jedną <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>z <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>metod <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>,, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> , lub.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zakończenie asynchronicznej operacji odczytu. Przykład demonstrujący uruchomienie operacji można znaleźć w temacie <xref:System.Net.Security.NegotiateStream.BeginRead%2A>.  
  
 [!code-cpp[NclNegoAsyncServer#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#3)]
 [!code-csharp[NclNegoAsyncServer#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Obiekt asyncResult nie został utworzony przez wywołanie metody <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak oczekującej operacji odczytu do wykonania.

—lub—

Nie nastąpiło uwierzytelnianie.</exception>
        <exception cref="T:System.IO.IOException">Operacja odczytu nie powiodła się.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="negotiateStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Wystąpienie zwrócone przez wywołanie elementu<see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Zamyka asynchroniczną operację zapisu, która została uruchomiona z wywołaniem <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />do.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja nie została ukończona, ta metoda jest blokowana, dopóki nie zostanie wykonana.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia. Aby przeprowadzić uwierzytelnianie, wywołaj jedną <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>z <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>metod <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>,, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> , lub.  
  
 Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Security.NegotiateStream.Write%2A> metody.  
  
   
  
## Examples  
Poniższy przykład ilustruje metodę, która jest wywoływana w celu ukończenia asynchronicznej operacji zapisu. Przykład demonstrujący uruchomienie operacji można znaleźć w temacie <xref:System.Net.Security.NegotiateStream.BeginWrite%2A>.  
  
[!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
[!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
[!code-vb[NclNegoAsyncClient#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#4)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Obiekt asyncResult nie został utworzony przez wywołanie metody <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak oczekującej operacji zapisu do wykonania.

—lub—

Nie nastąpiło uwierzytelnianie.</exception>
        <exception cref="T:System.IO.IOException">Operacja zapisu nie powiodła się.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="negotiateStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że wszystkie buforowane dane są zapisywane na podstawowym urządzeniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.IO.Stream.Flush%2A> na źródłowym strumieniu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje opróżnianie strumienia.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel" Usage="System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, w jaki sposób serwer może używać poświadczeń klienta.</summary>
        <value>Jedna z <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed wywołaniem tej metody należy pomyślnie uwierzytelnić. Klienci określają poziom personifikacji, gdy żądają uwierzytelniania przez wywołanie jednej z <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> metod <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> lub. <xref:System.Security.Principal.TokenImpersonationLevel> W<xref:System.Security.Principal.TokenImpersonationLevel.Identification> przypadku uwierzytelniania bez określenia elementu jest używany.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie nie powiodło się lub nie nastąpiło.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy uwierzytelnianie zakończyło się pomyślnie.</summary>
        <value><see langword="true" />Jeśli nastąpiło pomyślne uwierzytelnienie; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klienci są <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> uwierzytelniani przez wywoływanie metod lub <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> . Serwery są uwierzytelniane przez <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> wywołanie <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> metod lub.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEncrypted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEncrypted : bool" Usage="System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest <see cref="T:System.Net.Security.NegotiateStream" /> używane szyfrowanie danych. <see cref="T:System.Boolean" /></summary>
        <value><see langword="true" />Jeśli dane są szyfrowane przed przesłaniem przez sieć i odszyfrowywane po osiągnięciu zdalnego punktu końcowego; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Szyfrowanie pomaga chronić prywatność danych. a mianowicie pomaga zapewnić, że podczas przesyłania danych nie może zostać oddzielone przez inne osoby.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Security.ProtectionLevel" />
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMutuallyAuthenticated : bool" Usage="System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy zarówno serwer, jak i klient został uwierzytelniony.</summary>
        <value><see langword="true" />Jeśli serwer został uwierzytelniony; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie wzajemne jest określane przez klienta, gdy klient chce, aby serwer dostarczał poświadczenia na potrzeby uwierzytelniania. Domyślnie klienci żądają uwierzytelniania wzajemnego.  
  
 Protokół Negotiate wybiera uwierzytelnianie NTLM lub Kerberos w zależności od protokołów zabezpieczeń obsługiwanych przez klienta i serwer. Protokół NTLM nie obsługuje wzajemnego uwierzytelniania.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsServer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsServer : bool" Usage="System.Net.Security.NegotiateStream.IsServer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy lokalna strona połączenia używana przez ten <see cref="T:System.Net.Security.NegotiateStream" /> program została uwierzytelniona jako serwer. <see cref="T:System.Boolean" /></summary>
        <value><see langword="true" />Jeśli lokalny punkt końcowy został pomyślnie uwierzytelniony jako Strona serwera uwierzytelnionego połączenia; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli uwierzytelnianie nie powiodło się lub nie nastąpiło `false`, ta właściwość zwraca wartość.  
  
 Aby uwierzytelnić się jako serwer, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> Wywołaj <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> metody lub.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSigned { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSigned : bool" Usage="System.Net.Security.NegotiateStream.IsSigned" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> Pobiera wartość wskazującą, czy dane wysyłane przy użyciu tego strumienia są podpisane.</summary>
        <value><see langword="true" />Jeśli dane są podpisane przed przesłaniem; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podpisywanie danych pomaga chronić integralność danych; oznacza to, że pomaga odbiorcom w ustaleniu, czy dane zostały naruszone podczas przesyłania.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Net.Security.NegotiateStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość źródłowego strumienia.</summary>
        <value>A <see cref="T:System.Int64" /> określa długość źródłowego strumienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwróconą przez wywołanie <xref:System.IO.Stream.Length%2A> właściwości w strumieniu źródłowym. Jeśli źródłowy strumień nie jest możliwy do przeszukiwania, ta właściwość zwykle zgłosi wyjątek. Typ czasu wykonywania źródłowego strumienia określa typ czasu wykonywania wygenerowanego wyjątku.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Pobieranie wartości tej właściwości nie jest obsługiwane, gdy źródłowy strumień jest <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Net.Security.NegotiateStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżącą pozycję w źródłowym strumieniu.</summary>
        <value>Element <see cref="T:System.Int64" /> określający bieżącą pozycję w strumieniu źródłowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwróconą przez wywołanie <xref:System.IO.Stream.Position%2A> właściwości w strumieniu źródłowym. Jeśli źródłowy strumień nie jest możliwy do przeszukiwania, ta właściwość zwykle zgłosi wyjątek. Typ czasu wykonywania źródłowego strumienia określa typ czasu wykonywania wygenerowanego wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ustawienie tej właściwości nie jest obsługiwane.  
  
—lub— 
Pobieranie wartości tej właściwości nie jest obsługiwane, gdy źródłowy strumień jest <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="negotiateStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> Tablica, która odbiera Bajty odczytane ze strumienia.</param>
        <param name="offset">A <see cref="T:System.Int32" /> zawierają lokalizację, w <paramref name="buffer" /> której ma zostać rozpoczęte przechowywanie danych odczytanych z tego strumienia.</param>
        <param name="count">A <see cref="T:System.Int32" /> zawiera maksymalną liczbę bajtów odczytywanych ze strumienia.</param>
        <summary>Odczytuje dane z tego strumienia i zapisuje je w określonej tablicy.</summary>
        <returns><see cref="T:System.Int32" /> Wartość określająca liczbę bajtów odczytanych ze strumienia źródłowego. Gdy nie ma więcej danych do odczytu, zwraca wartość 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda odczytuje maksymalnie `count` bajtów z bieżącego strumienia i zapisuje je w `buffer` czasie `offset`od.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia. Aby przeprowadzić uwierzytelnianie, wywołaj jedną <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>z <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>metod <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>,, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> , lub.  
  
 Aby wykonać tę operację asynchronicznie, użyj <xref:System.Net.Security.NegotiateStream.BeginRead%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje odczyt z <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncServer/CPP/NclNegoSyncServer.cpp#1)]
 [!code-csharp[NclNegoSyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Operacja odczytu nie powiodła się.</exception>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" /> Operacja jest już w toku.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ilość czasu, przez który bloki operacji odczytu oczekują na dane.</summary>
        <value>A <see cref="T:System.Int32" /> określa ilość czasu, który upłynie przed zakończeniem operacji odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwróconą przez wywołanie <xref:System.IO.Stream.ReadTimeout%2A> właściwości w strumieniu źródłowym. Po ustawieniu tej właściwości <xref:System.IO.Stream.ReadTimeout%2A> wartość w strumieniu źródłowym jest ustawiana na określoną wartość.  
  
 Jeśli źródłowy strumień jest <xref:System.Net.Sockets.NetworkStream> <xref:System.Net.Security.NegotiateStream.ReadTimeout%2A> w milisekundach i jest domyślnie ustawiony na <xref:System.Threading.Timeout.Infinite> wartość tak, aby operacje odczytu nie przekroczyły limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteIdentity">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.IIdentity RemoteIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity RemoteIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoteIdentity As IIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ RemoteIdentity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteIdentity : System.Security.Principal.IIdentity" Usage="System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o tożsamości strony zdalnej udostępniającej ten uwierzytelniony strumień.</summary>
        <value><see cref="T:System.Security.Principal.IIdentity" /> Obiekt, który opisuje tożsamość zdalnego punktu końcowego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy dostęp jest uzyskiwany przez klienta, ta właściwość <xref:System.Security.Principal.GenericIdentity> zwraca wartość zawierającą główną nazwę usługi (SPN) serwera oraz używany protokół uwierzytelniania. Po uzyskaniu dostępu do serwera ta właściwość zwraca <xref:System.Security.Principal.WindowsIdentity> opis klienta. Jeśli element<xref:System.Security.Principal.GenericIdentity>nie jest dostępny, informacje o kliencie są zwracane do serwera w programie. <xref:System.Security.Principal.WindowsIdentity>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoAsyncServer#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#2)]
 [!code-csharp[NclNegoAsyncServer#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Uwierzytelnianie nie powiodło się lub nie nastąpiło.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="negotiateStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Ta wartość jest ignorowana.</param>
        <param name="origin">Ta wartość jest ignorowana.</param>
        <summary>Zgłasza <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Zawsze zgłasza <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody. Jest on Dziedziczony, ale nie jest obsługiwany przez <xref:System.Net.Security.NegotiateStream>program.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wyszukiwanie nie jest obsługiwane w <see cref="T:System.Net.Security.NegotiateStream" />programie.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="negotiateStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Int64" /> Wartość, która określa długość strumienia.</param>
        <summary>Ustawia długość źródłowego strumienia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="negotiateStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> Tablica, która dostarcza bajty zapisywane w strumieniu.</param>
        <param name="offset">Zawierająca lokalizację rozpoczynającą się od zera <paramref name="buffer" /> , w której rozpocznie się odczytywanie bajtów do zapisania w strumieniu. <see cref="T:System.Int32" /></param>
        <param name="count">Zawierający liczbę bajtów, z <paramref name="buffer" />których ma zostać odczytany. <see cref="T:System.Int32" /></param>
        <summary>Napisz określoną liczbę <see cref="T:System.Byte" />s do źródłowego strumienia przy użyciu określonego buforu i przesunięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli włączono szyfrowanie, podpisywanie lub szyfrowanie i podpisywanie, ta metoda odczytuje dane z bufora, szyfruje, podpisuje lub szyfruje i podpisuje je, a następnie przesyła je za pomocą źródłowego strumienia. Jeśli nie są używane żadne usługi zabezpieczeń, takie jak szyfrowanie lub podpisywanie danych, <xref:System.IO.Stream.Write%2A> Metoda ta wywołuje na źródłowym strumieniu.  
  
 Ta metoda jest blokowana podczas kończenia operacji zapisu. Aby zapobiec blokowaniu podczas kończenia operacji, użyj <xref:System.Net.Security.NegotiateStream.Write%2A> metody.  
  
 Nie można wywołać tej metody do momentu pomyślnego uwierzytelnienia. Aby przeprowadzić uwierzytelnianie, wywołaj jedną <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>z <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>metod <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>,, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> , lub.  
  
 <xref:System.Net.Security.NegotiateStream> Klasa nie obsługuje wielu równoczesnych operacji zapisu. Jeśli podjęto próbę uruchomienia operacji zapisu, podczas gdy inna operacja zapisu jest już wykonywana w tym samym strumieniu, <xref:System.NotSupportedException> zostanie zgłoszony wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje zapis w <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset is less than 0" />.  
  
—lub— 
 <paramref name="offset" />jest większa niż długość <paramref name="buffer" />.  
  
—lub— 
 <paramref name="offset" />Liczba plusów jest większa niż długość <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Operacja zapisu nie powiodła się.  
  
—lub—
  
 Szyfrowanie jest w użyciu, ale nie można zaszyfrować danych.</exception>
        <exception cref="T:System.NotSupportedException">Operacja zapisu jest już w toku.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten obiekt został zamknięty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie nastąpiło uwierzytelnianie.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ilość czasu, w którym bloki operacji zapisu oczekują na dane.</summary>
        <value>A <see cref="T:System.Int32" /> , który określa czas, który upłynie, zanim operacja zapisu nie powiedzie się.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca wartość zwróconą przez wywołanie <xref:System.IO.Stream.WriteTimeout%2A> właściwości w strumieniu źródłowym. W przypadku operacji ustawiania określona wartość ustawia <xref:System.IO.Stream.WriteTimeout%2A> wartość w strumieniu źródłowym.  
  
 Jeśli źródłowy strumień jest <xref:System.Net.Sockets.NetworkStream> <xref:System.Net.Security.NegotiateStream.WriteTimeout%2A> w milisekundach i jest domyślnie ustawiony na <xref:System.Threading.Timeout.Infinite> tak, aby operacje zapisu nie przekroczyły limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Wyświetlanie wartości tej właściwości.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

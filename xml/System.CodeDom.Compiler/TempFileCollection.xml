<Type Name="TempFileCollection" FullName="System.CodeDom.Compiler.TempFileCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ae18bcefe30047f6df6286b4808f89ca4b0d15ce" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39835991" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TempFileCollection : IDisposable, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit TempFileCollection extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.TempFileCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class TempFileCollection&#xA;Implements ICollection, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TempFileCollection : IDisposable, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type TempFileCollection = class&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje kolekcję plików tymczasowych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.TempFileCollection> może służyć do generowania unikatowych nazw plików i do śledzenia listę plików. Może to być przydatne do <xref:System.CodeDom.Compiler.ICodeCompiler> implementacje związane z zarządzaniem listę generowanych przez kompilator pośredni pliki, które czasami są usuwane po użyciu.  
  
 Aby określić na potrzeby generowania nazw unikatowych pliku tymczasowego w katalogu, użyj odpowiednio przeciążonego konstruktora. Umożliwia także przeciążenia konstruktora, aby wskazać, czy pliki dodawane do kolekcji powinien, jeśli nie określono inaczej w przypadku korzystania z <xref:System.CodeDom.Compiler.TempFileCollection.AddFile%2A> lub <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> metody, można usunąć, jeśli kolekcja zostanie usunięty lub <xref:System.CodeDom.Compiler.TempFileCollection.Delete%2A> metoda jest wywoływana.  
  
 Plik w dowolnym katalogu można dodać do wystąpienia <xref:System.CodeDom.Compiler.TempFileCollection> przy użyciu <xref:System.CodeDom.Compiler.TempFileCollection.AddFile%2A> metody.  
  
 Aby wygenerować unikatową nazwę pliku tymczasowego konkretnego rozszerzenia pliku, należy wywołać <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> i określ rozszerzenie nazwy pliku do wygenerowania. <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> Metoda zwraca ciąg składający się z pełną ścieżkę do pliku o nazwie określonego rozszerzenia w katalogu określonym przez <xref:System.CodeDom.Compiler.TempFileCollection.TempDir%2A> właściwości. <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> Metoda zwróci tylko jedną unikatową nazwę pliku dla rozszerzenia nazwy pliku.  
  
 Zarówno <xref:System.CodeDom.Compiler.TempFileCollection.AddFile%2A> i <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> metody mają przeciążenia, które pozwalają na określenie, czy pliki powinny zostać usunięty po usunięciu kolekcji lub <xref:System.CodeDom.Compiler.TempFileCollection.Delete%2A> metoda jest wywoływana.  
  
 <xref:System.CodeDom.Compiler.TempFileCollection.Delete%2A> Metoda spowoduje usunięcie wszystkich plików w kolekcji, z wyjątkiem tych, które są oznaczone mają być przechowywane.  
  
 <xref:System.CodeDom.Compiler.TempFileCollection.BasePath%2A> Właściwość wskazuje pełną ścieżkę do nazwy pliku podstawowego bez rozszerzenia nazwy pliku, używany do generowania nazwy pliku zwrócone przez <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> metody.  
  
> [!NOTE]
>  Ta klasa zawiera żądanie łącza i dziedziczenia na poziomie klasy stosowane do wszystkich składowych. Element <xref:System.Security.SecurityException> jest generowany, gdy bezpośredniego obiektu wywołującego lub Klasa pochodna nie mają uprawnień pełnego zaufania. Aby uzyskać szczegółowe informacje na temat wymaganych zabezpieczeń, zobacz [zapotrzebowania na łącza](~/docs/framework/misc/link-demands.md) i [Inheritancedemand](http://msdn.microsoft.com/library/28b9adbb-8f08-4f10-b856-dbf59eb932d9).  
  
   
  
## Examples  
 Poniższy przykład pokazuje użycie <xref:System.CodeDom.Compiler.TempFileCollection> klasy i <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> i <xref:System.CodeDom.Compiler.TempFileCollection.AddFile%2A> metody.  
  
 [!code-csharp[System.CodeDom.Compiler.TempFileCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CodeDom.Compiler.TempFileCollection/CS/program.cs#1)]
 [!code-vb[System.CodeDom.Compiler.TempFileCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CodeDom.Compiler.TempFileCollection/VB/program.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">dla elementu pochodnego dla <see cref="T:System.CodeDom.Compiler.TempFileCollection" /> klasy. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; <see cref="T:System.Security.PermissionSet" />: <see langword="FullTrust" />.</permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Nie można użyć tej klasy w kodzie częściowo zaufanym.</permission>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.CodeDom.Compiler.TempFileCollection" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TempFileCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TempFileCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.CodeDom.Compiler.TempFileCollection" /> klasy przy użyciu wartości domyślnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest konstruktor domyślny, który inicjuje kolekcji przy użyciu ustawień domyślnych. Domyślnie ta kolekcja plików tymczasowych będą przechowywane pliki w katalogu tymczasowym domyślne i spowoduje usunięcie plików tymczasowych po wygenerowaniu i używane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TempFileCollection (string tempDir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tempDir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tempDir As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TempFileCollection(System::String ^ tempDir);" />
      <MemberSignature Language="F#" Value="new System.CodeDom.Compiler.TempFileCollection : string -&gt; System.CodeDom.Compiler.TempFileCollection" Usage="new System.CodeDom.Compiler.TempFileCollection tempDir" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="tempDir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tempDir">Ścieżka do katalogu tymczasowego na potrzeby przechowywania plików tymczasowych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.CodeDom.Compiler.TempFileCollection" /> przy użyciu określony katalog tymczasowy, który jest ustawiony na usuwanie plików tymczasowych po ich generowania i użytkowania, domyślnie.</summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Nie można użyć tej klasy w kodzie częściowo zaufanym.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TempFileCollection (string tempDir, bool keepFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tempDir, bool keepFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tempDir As String, keepFiles As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TempFileCollection(System::String ^ tempDir, bool keepFiles);" />
      <MemberSignature Language="F#" Value="new System.CodeDom.Compiler.TempFileCollection : string * bool -&gt; System.CodeDom.Compiler.TempFileCollection" Usage="new System.CodeDom.Compiler.TempFileCollection (tempDir, keepFiles)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tempDir" Type="System.String" />
        <Parameter Name="keepFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="tempDir">Ścieżka do katalogu tymczasowego na potrzeby przechowywania plików tymczasowych.</param>
        <param name="keepFiles">
          <see langword="true" /> Jeśli pliki tymczasowe powinny być umieszczone po użyciu; <see langword="false" /> się usunięcie plików tymczasowych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.CodeDom.Compiler.TempFileCollection" /> klasy przy użyciu określony katalog tymczasowy i określoną wartość wskazującą, czy zachować lub usunąć plików tymczasowych po ich generowania i użytkowania, domyślnie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `keepFiles` służy do ustawiania <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> parametru. Pliki tymczasowe w kolekcji są przechowywane lub usuwane po zakończeniu działania kompilatora na podstawie wartości z <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> właściwości w kolekcji. Każdy plik jest dodawany do kolekcji, bieżąca wartość <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> jest skojarzony z nim, chyba że został dodany za pomocą metody, która ma `keepFile` parametru, w którym to przypadku stosowanie wartości dla tego określonego pliku. Gdy <xref:System.CodeDom.Compiler.TempFileCollection.Delete%2A> metoda jest wywoływana, jeśli <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> jest `true`, wszystkie pliki zostaną usunięte, łącznie z tymi dodany z <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> wartość `true`. Dzięki temu określonych plików, te identyfikowany jako przechowywania plików, można tymczasowo przechowywane po kompilacji do celów takich jak raportowanie błędów, a następnie usuwane, gdy nie są już potrzebne.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Nie można użyć tej klasy w kodzie częściowo zaufanym.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddExtension">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje nazwę pliku z rozszerzeniem nazwy pliku określonej kolekcji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddExtension">
      <MemberSignature Language="C#" Value="public string AddExtension (string fileExtension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string AddExtension(string fileExtension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.AddExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddExtension (fileExtension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ AddExtension(System::String ^ fileExtension);" />
      <MemberSignature Language="F#" Value="member this.AddExtension : string -&gt; string" Usage="tempFileCollection.AddExtension fileExtension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileExtension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileExtension">Rozszerzenie nazwy pliku nazwa wygenerowany automatycznie plik tymczasowy do dodania do kolekcji.</param>
        <summary>Dodaje nazwę pliku z rozszerzeniem nazwy pliku określonej kolekcji.</summary>
        <returns>Nazwa pliku z określonym rozszerzeniem, który właśnie został dodany do kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca nazwę pliku z określonym rozszerzeniem, który został dodany do kolekcji plików tymczasowych. Inny kod nadal należy utworzyć plik, zanim będzie można jej używać.  
  
 Tę metodę można wywołać tylko raz dla każdego rozszerzenia nazwy pliku, ponieważ będzie zwracać tej samej nazwie, jeśli jest to samo rozszerzenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddExtension">
      <MemberSignature Language="C#" Value="public string AddExtension (string fileExtension, bool keepFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string AddExtension(string fileExtension, bool keepFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.AddExtension(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddExtension (fileExtension As String, keepFile As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ AddExtension(System::String ^ fileExtension, bool keepFile);" />
      <MemberSignature Language="F#" Value="member this.AddExtension : string * bool -&gt; string" Usage="tempFileCollection.AddExtension (fileExtension, keepFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileExtension" Type="System.String" />
        <Parameter Name="keepFile" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileExtension">Rozszerzenie nazwy pliku nazwa wygenerowany automatycznie plik tymczasowy do dodania do kolekcji.</param>
        <param name="keepFile">
          <see langword="true" /> Jeśli plik powinien znajdować się po użyciu; <see langword="false" /> Jeśli można usunąć pliku.</param>
        <summary>Dodaje nazwę pliku z rozszerzeniem nazwy pliku określonej w kolekcji przy użyciu określoną wartość wskazującą, czy usunięto lub przechowywane pliku.</summary>
        <returns>Nazwa pliku z określonym rozszerzeniem, który właśnie został dodany do kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca nazwę pliku z określonym rozszerzeniem, który został dodany do kolekcji plików tymczasowych. Inny kod nadal należy utworzyć plik, zanim będzie można jej używać.  
  
 Tę metodę można wywołać tylko raz dla każdego rozszerzenia nazwy pliku, ponieważ będzie zwracać tej samej nazwie, jeśli jest to samo rozszerzenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fileExtension" /> jest <see langword="null" /> ani być pustym ciągiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddFile">
      <MemberSignature Language="C#" Value="public void AddFile (string fileName, bool keepFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFile(string fileName, bool keepFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.AddFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFile (fileName As String, keepFile As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFile(System::String ^ fileName, bool keepFile);" />
      <MemberSignature Language="F#" Value="member this.AddFile : string * bool -&gt; unit" Usage="tempFileCollection.AddFile (fileName, keepFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="keepFile" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku do dodania do kolekcji.</param>
        <param name="keepFile">
          <see langword="true" /> Jeśli plik powinien znajdować się po użyciu; <see langword="false" /> Jeśli można usunąć pliku.</param>
        <summary>Dodaje określony plik do kolekcji przy użyciu określonej wartości, oznaczająca, czy zachować plik po usunięciu kolekcji lub gdy <see cref="M:System.CodeDom.Compiler.TempFileCollection.Delete" /> metoda jest wywoływana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje użycie <xref:System.CodeDom.Compiler.TempFileCollection.AddFile%28System.String%2CSystem.Boolean%29> metodę, aby dodać plik, który ma być przechowywany w kolekcji. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.CodeDom.Compiler.TempFileCollection> klasy.  
  
 [!code-csharp[System.CodeDom.Compiler.TempFileCollection#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.CodeDom.Compiler.TempFileCollection/CS/program.cs#2)]
 [!code-vb[System.CodeDom.Compiler.TempFileCollection#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.CodeDom.Compiler.TempFileCollection/VB/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fileName" /> jest <see langword="null" /> ani być pustym ciągiem.  - lub - <paramref name="fileName" /> jest duplikatem.</exception>
      </Docs>
    </Member>
    <Member MemberName="BasePath">
      <MemberSignature Language="C#" Value="public string BasePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BasePath" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.BasePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BasePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePath : string" Usage="System.CodeDom.Compiler.TempFileCollection.BasePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pełną ścieżkę do nazwy pliku podstawowego bez rozszerzenia nazwy pliku w ścieżce katalogu tymczasowego, który jest używany do generowania nazwy pliku tymczasowego dla kolekcji.</summary>
        <value>Pełna ścieżka do nazwy pliku podstawowego bez rozszerzenia nazwy pliku, w ścieżce katalogu tymczasowego, który jest używany do generowania nazwy pliku tymczasowego dla kolekcji.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Jeśli <see cref="P:System.CodeDom.Compiler.TempFileCollection.BasePath" /> właściwości nie została ustawiona lub została ustawiona na <see langword="null" />, i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.AllAccess" /> nie ma przyznanego dla katalogu tymczasowego, wskazywanym przez <see cref="P:System.CodeDom.Compiler.TempFileCollection.TempDir" /> właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (string[] fileNames, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(string[] fileNames, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.CopyTo(System.String[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (fileNames As String(), start As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::String ^&gt; ^ fileNames, int start);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : string[] * int -&gt; unit" Usage="tempFileCollection.CopyTo (fileNames, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileNames" Type="System.String[]" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="fileNames">Tablica ciągów, które można skopiować do.</param>
        <param name="start">Indeks tablicy, aby rozpocząć kopiowanie.</param>
        <summary>Kopiuje elementy członkowskie kolekcji do określonego ciągu znaków, zaczynając od określonego indeksu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.CodeDom.Compiler.TempFileCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczba plików w kolekcji.</summary>
        <value>Liczba plików w kolekcji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete();" />
      <MemberSignature Language="F#" Value="member this.Delete : unit -&gt; unit" Usage="tempFileCollection.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa pliki tymczasowe w tej kolekcji, które nie zostały oznaczone jako ma być przechowywana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.TempFileCollection.Delete%2A> Metoda sprawdza, czy każdy plik w kolekcji, aby ustalić, indywidualnie, czy plik ma być przechowywany lub usunięta. Pliki mogą być jawnie oznaczone jako ma być przechowywana w przypadku dodania do kolekcji przy użyciu Dodaj metody, które przyjmują `keepFile` parametru. Podczas dodawania pliku do kolekcji przy użyciu <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> przeciążenia, które nie ma `keepFile` parametru wartość z <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> właściwość jest używana jako wskaźnik pliku Zachowaj domyślne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="tempFileCollection.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.CodeDom.Compiler.TempFileCollection" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez publiczną `Dispose()` metody i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` równa `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane że <xref:System.CodeDom.Compiler.TempFileCollection> odwołania. Ta metoda wywołuje `Dispose()` metoda każdego obiektu, do którego istnieje odwołanie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see langword="Dispose(Boolean)" />, nie należy odwoływać się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do <see langword="Dispose" />. Aby uzyskać więcej informacji o sposobie wdrażania <see langword="Dispose(Boolean)" />, zobacz [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Overriding the Finalize Method](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TempFileCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TempFileCollection ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="tempFileCollection.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Próbuje usunąć plików tymczasowych, zanim ten obiekt jest odzyskiwane przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Object.Finalize%2A?displayProperty=nameWithType> i czyści zasoby, wywołując `Dispose(false)`. Zastąp `Dispose(Boolean)` dostosować czyszczenia.  
  
 Kod aplikacji nie powinna wywołać tę metodę; obiekt `Finalize` metoda jest wywoływana automatycznie podczas wyrzucania elementów bezużytecznych, chyba że finalizacja przez moduł garbage collector została wyłączona przez wywołanie <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać więcej informacji, zobacz [Finalize metody i destruktory](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70), [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md), i [Overriding the Finalize Method](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="tempFileCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera moduł wyliczający, który można wyliczyć elementy członkowskie kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Zawiera członków kolekcji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepFiles">
      <MemberSignature Language="C#" Value="public bool KeepFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepFiles" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.KeepFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepFiles { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepFiles : bool with get, set" Usage="System.CodeDom.Compiler.TempFileCollection.KeepFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zachowywać pliki, domyślnie, gdy <see cref="M:System.CodeDom.Compiler.TempFileCollection.Delete" /> metoda jest wywoływana lub kolekcji zostanie usunięty.</summary>
        <value>
          <see langword="true" /> Jeśli powinny być przechowywane pliki; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> właściwość jest używana jako domyślna wartość przy <xref:System.CodeDom.Compiler.TempFileCollection.AddExtension%2A> przeciążenia, które nie ma `keepFile` parametru jest wywoływana, aby dodać plik tymczasowy do kolekcji. Każdy plik tymczasowy w kolekcji ma Zachowaj skojarzone pliku flagę określającą, na podstawie każdego pliku, czy ten plik ma być przechowywany lub usunięta. Pliki są automatycznie przechowywany lub usuwane po zakończeniu kompilacji, na podstawie ich wartości plików skojarzone Zachowaj. Jednak po ukończeniu kompilacji plików, które zostały zachowane może być zwolnione, ustawiając <xref:System.CodeDom.Compiler.TempFileCollection.KeepFiles%2A> FAŁSZ i wywoływania <xref:System.CodeDom.Compiler.TempFileCollection.Delete%2A> metody.  Spowoduje to wszystkie pliki są usuwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int start);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int start) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> czyli miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> Musi mieć Indeksowanie oparte na zerze.</param>
        <param name="start">Rozpoczyna się od zera indeks w tablicy, od których kopiowanie.</param>
        <summary>Kopiuje elementy kolekcji do tablicy, zaczynając od określonego indeksu tablicy docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.CodeDom.Compiler.TempFileCollection> wystąpienia jest rzutowany na <xref:System.Collections.ICollection> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów znajdujących się w kolekcji.</summary>
        <value>Liczba elementów zawartych w słowniku <see cref="T:System.Collections.ICollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.CodeDom.Compiler.TempFileCollection> wystąpienia jest rzutowany na <xref:System.Collections.ICollection> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.Count" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest zsynchronizowany dostęp do kolekcji (wątkowo).</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wątkowo); w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.CodeDom.Compiler.TempFileCollection> wystąpienia jest rzutowany na <xref:System.Collections.ICollection> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do kolekcji.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.CodeDom.Compiler.TempFileCollection> wystąpienia jest rzutowany na <xref:System.Collections.ICollection> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.CodeDom.Compiler.TempFileCollection> wystąpienia jest rzutowany na <xref:System.Collections.IEnumerable> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.IEnumerable.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.TempFileCollection.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wykonuje zadania zdefiniowane przez aplikację skojarzone z uwalnianiem, zwalnianiem lub resetowaniem niezarządzanych zasobów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.CodeDom.Compiler.TempFileCollection> wystąpienia jest rzutowany na <xref:System.IDisposable> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IDisposable.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="TempDir">
      <MemberSignature Language="C#" Value="public string TempDir { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TempDir" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.TempFileCollection.TempDir" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TempDir As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TempDir { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TempDir : string" Usage="System.CodeDom.Compiler.TempFileCollection.TempDir" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera katalog tymczasowy do przechowywania plików tymczasowych w.</summary>
        <value>Katalog tymczasowy do przechowywania plików tymczasowych w.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
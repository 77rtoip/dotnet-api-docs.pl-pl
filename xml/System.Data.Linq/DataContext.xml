<Type Name="DataContext" FullName="System.Data.Linq.DataContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="614bf8b628b9e044f43fb12a554abe74af90df70" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174265" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.DataContext" />
  <TypeSignature Language="VB.NET" Value="Public Class DataContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataContext : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje główny punkt wejścia dla LINQ do SQL struktury.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Linq.DataContext> Jest źródłem wszystkich jednostek mapowane za pośrednictwem połączenia z bazą danych. Śledzi zmiany wprowadzone do wszystkich jednostek pobrane i obsługuje "tożsamości pamięć podręczną", który gwarantuje, że jednostek pobrać więcej niż jeden raz są reprezentowane przez przy użyciu tego samego wystąpienia obiektu.  
  
 Ogólnie rzecz biorąc <xref:System.Data.Linq.DataContext> wystąpienia jest przeznaczona do ostatniego dla jednej "jednostka pracy", jednak aplikacja definiuje czas. A <xref:System.Data.Linq.DataContext> jest lekki, a nie kosztowne. Typowe [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] aplikacja tworzy <xref:System.Data.Linq.DataContext> wystąpień w zakresie metody lub jako członek tej klasy, które reprezentują logiczne zestaw związane z operacji w bazie danych.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Linq.DataContext" /> klasy. Parametry połączenia, którego używasz, może być ciągiem połączenia ADO.NET. Można również określić nazwę pliku do pliku programu SQL Server Express lub SQL Server Compact.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
      </Parameters>
      <Docs>
        <param name="connection">Połączenie używane przez [! INCLUDE[dnprdnshort](~/includes/dnprdnshort-MD.MD)].</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Linq.DataContext" /> klasy odwołując połączenie używane przez [! INCLUDE[dnprdnshort](~/includes/dnprdnshort-MD.MD)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.Linq.DataContext> otwiera i zamyka połączenie z bazą danych, zgodnie z potrzebami, jeśli zostaną podane połączenie zamknięte lub parametry połączenia. Ogólnie rzecz biorąc, nie trzeba wywołać `Dispose` na <xref:System.Data.Linq.DataContext>. Jeśli podasz otwartego połączenia, <xref:System.Data.Linq.DataContext> nie zostanie zamknięte. W związku z tym tworzy wystąpienia <xref:System.Data.Linq.DataContext> z otwartego połączenia, chyba że masz powód, dla to zrobić. W <xref:System.Transactions> transakcji, <xref:System.Data.Linq.DataContext> nie spowoduje otwarcie lub zamknięcie połączenia, aby uniknąć podwyższania poziomu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="connection">Połączenie używane przez program .NET Framework.</param>
        <param name="mapping">Źródło mapowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Linq.DataContext" /> klasy za pomocą odwołań do połączenia ze źródłem danych mapowania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">Ten argument może być jednym z następujących czynności: Nazwa pliku, w którym znajduje się baza danych programu SQL Server Express.  Nazwa serwera, na którym baza danych jest obecny. W takim przypadku dostawca używa domyślnej bazy danych dla użytkownika.  Ciąg połączenia ukończone. [! INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-MD.MD)] po prostu przekazuje ciąg do dostawcy bez żadnych modyfikacji.</param>
        <param name="mapping">Źródło mapowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Linq.DataContext" /> klasy za pomocą odwołań do źródła plików oraz źródła mapowania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String)" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public DataContext (string connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="connectionString" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">To be added.</param>
        <param name="connectionString">To be added.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Linq.DataContext" /> klasy za pomocą odwołań do źródłowego pliku.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeConflicts">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeConflictCollection ChangeConflicts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.ChangeConflictCollection ChangeConflicts" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChangeConflicts As ChangeConflictCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::ChangeConflictCollection ^ ChangeConflicts { System::Data::Linq::ChangeConflictCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeConflictCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję obiektów, które spowodowały konfliktom współbieżności podczas <see cref="M:System.Data.Linq.DataContext.SubmitChanges" /> została wywołana.</summary>
        <value>Kolekcja obiektów, które spowodowały konfliktom współbieżności.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższym przykładzie pokazano, jak można powtórzyć kolekcji za pośrednictwem można pobrać informacji o konflikt.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.objectchangeconflict/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.objectchangeconflict/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public int CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CommandTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która zwiększa wartość limitu czasu dla zapytań, które mogłyby w przeciwnym razie upłynął limit czasu podczas domyślny limit czasu.</summary>
        <value>Wartość całkowitą, która zwiększa wartość limitu czasu dla zapytań, które mogłyby w przeciwnym razie upłynął limit czasu podczas domyślny limit czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość pobiera lub ustawia limit czasu polecenia używane do wykonywania poleceń wygenerowanego (`IDbCommands`). Aby uzyskać więcej informacji, zobacz <xref:System.Data.IDbCommand.CommandTimeout%2A>.  
  
 Gdy ta właściwość nie jest ustawiona, wartość domyślna <xref:System.Data.IDbCommand.CommandTimeout%2A> służy do wykonywania polecenia zapytania. Ta wartość domyślna jest ustawiana przez dostawcę magazynu. Należy pamiętać, że niektóre dostawców może zgłaszają wyjątki, jeśli ta wartość jest ustawiona na wartość inną niż zero.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera połączenie używane przez platformę.</summary>
        <value>Połączenie używane przez platformę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia współdziałanie z kodem ADO.NET relacyjne.  
  
 Zwrócony połączenie zostanie zamknięte, jeśli nie został jawnie otwarty przez użytkownika.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy bazę danych na serwerze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa bazy danych jest uzyskiwany przy użyciu następującego algorytmu:  
  
1. Jeśli bazy danych zostanie zidentyfikowana w parametrach połączenia, jego nazwa jest używana.  
1. Jeśli <xref:System.Data.Linq.Mapping.DatabaseAttribute> jest obecny, atrybut jego <xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> właściwość jest używana jako nazwa bazy danych.  
1. Jeśli w parametrach połączenia i silnie typizowaną tag bazy danych nie istnieje <xref:System.Data.Linq.DataContext> jest używana, bazy danych, który ma taką samą nazwę jak <xref:System.Data.Linq.DataContext> dziedziczenia klasy jest tworzone.  
1. Jeśli słabą <xref:System.Data.Linq.DataContext> jest używana, jest zgłaszany wyjątek.  
1. Jeśli <xref:System.Data.Linq.DataContext> został utworzony przy użyciu nazwy pliku, zostanie utworzona baza danych, odpowiadającego tej nazwy pliku.  
     
  
## Examples  
 Poniższy kod przedstawia sposób konfigurowania tymczasowej bazy danych, a następnie usuń go.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMethodCallQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryable&lt;TResult&gt; CreateMethodCallQuery&lt;TResult&gt; (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Linq.IQueryable`1&lt;!!TResult&gt; CreateMethodCallQuery&lt;TResult&gt;(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Linq::IQueryable&lt;TResult&gt; ^ CreateMethodCallQuery(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ elementów w zwracanej kolekcji.</typeparam>
        <param name="instance">Wystąpienie wywołania metody (bieżącego obiektu).</param>
        <param name="methodInfo">
          <see cref="T:System.Reflection.MethodInfo" /> Który identyfikuje metodę CLR, które odpowiada metoda bazy danych.</param>
        <param name="parameters">Tablica parametrów do przekazania do polecenia.</param>
        <summary>Wykonuje funkcję przechowywanymi w tabeli bazy danych skojarzony z określonej metody CLR.</summary>
        <returns>Kolekcja wartości wynikowych zwróconych przez kwerendę bazy danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A> — Metoda jest używana w kodzie automatycznie generowanych i działa jako serwer proxy do funkcji bazy danych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy można otworzyć skojarzonej bazy danych.</summary>
        <returns>
          <see langword="true" /> Jeśli określona baza danych może zostać otwarta. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda korzysta z połączenia w <xref:System.Data.Linq.DataContext.Connection%2A> właściwość, aby podjąć próbę otwarcia skojarzonej bazie danych.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej metody, aby określić, czy baza danych już istnieje.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferredLoadingEnabled">
      <MemberSignature Language="C#" Value="public bool DeferredLoadingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DeferredLoadingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferredLoadingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DeferredLoadingEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy relacje jeden do wielu lub jeden do jednego załadować z opóźnieniem.</summary>
        <value>
          <see langword="true" /> Jeśli włączono ładowanie odłożone; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy uzyskuje dostęp do jednej z tych relacji null przez innych kod jest zwracany, gdy relacja jest jeden do jednego, a pustą kolekcję, gdy jest jeden do wielu. Relacje nadal można podać, ustawiając <xref:System.Data.Linq.DataContext.LoadOptions%2A> właściwości.  
  
 Scenariusz głównego dla tej właściwości jest umożliwienie wyodrębnić fragment modelu obiektów i wysłać go (na przykład, aby usługi sieci Web).  
  
> [!NOTE]
>  Jeśli ta właściwość jest ustawiona na `false` po wykonaniu zapytania, jest zgłaszany wyjątek. Zobacz **prawidłowe tryby** sekcji poniżej, aby uzyskać więcej informacji.  
  
## <a name="valid-modes"></a>Prawidłowe tryby  
 Ładowanie odłożone wymaga śledzenie obiektów. Następujące trzy tryby są prawidłowe:  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `false`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> jest ignorowany i wywnioskować jako `false`. To zachowanie odnosi się tylko do odczytu <xref:System.Data.Linq.DataContext>.  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> = `false`. Ta sytuacja odpowiada <xref:System.Data.Linq.DataContext> umożliwia użytkownikom załadować wykresu obiektów przy użyciu <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> dyrektywy, ale nie umożliwia ładowanie odłożone.  
  
-   Ustawiona jest opcja `true`. Domyślnie włączone.  
  
 Nie można zmienić flagi, po wykonaniu zapytania. Każda zmiana po wykonaniu pierwszego zapytania, który używa, który <xref:System.Data.Linq.DataContext> zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa skojarzonej bazie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda korzysta z połączenia w <xref:System.Data.Linq.DataContext.Connection%2A> właściwości, aby zidentyfikować bazy danych do usunięcia.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak usunąć bazę danych, tymczasowo utworzony.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.Linq.DataContext.Dispose" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Data.Linq.DataContext" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Data.Linq.DataContext" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Data.Linq.DataContext" /> i opcjonalnie zwalnia zasobów zarządzanych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteCommand">
      <MemberSignature Language="C#" Value="public int ExecuteCommand (string command, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteCommand(string command, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteCommand (command As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteCommand(System::String ^ command, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="command">Polecenie SQL do wykonania.</param>
        <param name="parameters">Tablica parametrów do przekazania do polecenia. Należy pamiętać o następujących zasadach: liczba obiektów w tablicy jest mniejsza niż największa liczba określone w parametrach polecenia, jest zgłaszany wyjątek.  Jeśli tablica zawiera obiekty, które nie są wywoływane w parametrach polecenia, nie wyjątku.  Jeśli jeden z parametrów ma wartość null, jest konwertowana na <see langword="DBNull.Value" />.</param>
        <summary>Wykonuje polecenia SQL bezpośrednio w bazie danych.</summary>
        <returns>Liczba wierszy zmodyfikowane przez wykonanego polecenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przekazywane mechanizm przypadków gdzie [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] nie ma odpowiedniej dla danego scenariusza.  
  
 Składnia polecenia jest niemal taki sam, jak składni pozwala utworzyć ADO.NET `DataCommand`. Jedyną różnicą jest w sposób parametry są określone. W szczególności należy określić parametry ujęte w nawiasy klamrowe ({}...), a wyliczenia począwszy od 0. Parametr jest skojarzony z obiektem jednakowo numerowane w tablicy parametrów.  
  
 `ExecuteQuery` i `ExecuteCommand` umożliwiają określenie zmienna liczba argumentów dla parametru podstawiania. Na przykład można określić parametrów podczas wywoływania polecenia ExecuteQuery\<TResult >:  
  
```  
db.ExecuteQuery<Customer>("select * from dbo.Customers where City = {0}", "London");  
```  
  
 I inny przykład:  
  
```  
db.ExecuteCommand("UPDATE Products SET QuantityPerUnit = {0} WHERE ProductID = {1}", "24 boxes", 5);  
```  
  
 Otwiera połączenie, przekazuje SQL w następującym przykładzie `UPDATE` polecenia do aparatu SQL.  
  
   
  
## Examples  
 [!code-csharp[DLinqCommunicatingWithDatabase#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqCommunicatingWithDatabase/cs/Program.cs#3)]
 [!code-vb[DLinqCommunicatingWithDatabase#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqCommunicatingWithDatabase/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicDelete">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicDelete (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicDelete(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicDelete (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicDelete(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka do usunięcia.</param>
        <summary>Wykonuje wewnątrz delete metody zastąpienie, redelegate do [! INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-MD.MD)] zadanie generowania i wykonywania dynamicznego kodu SQL dla operacji delete.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicInsert">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicInsert (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicInsert(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicInsert (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicInsert(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka do wstawienia.</param>
        <summary>Wykonuje wewnątrz insert metody zastąpienie, redelegate do [! INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-MD.MD)] zadanie generowania i wykonywania dynamicznego kodu SQL dla operacji insert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy uwzględnić następujące kwestie:  
  
-   Ponieważ metoda zawiera modyfikator chronionego, jego użycie wymaga podklasy <xref:System.Data.Linq.DataContext>.  
  
-   Wyjątek jest generowany, gdy ta operacja nie została wywołana wewnątrz <xref:System.Data.Linq.DataContext.SubmitChanges%2A> operacji. Nie jest przeznaczona do wywoływania jako autonomiczny operacji poza zakresem <xref:System.Data.Linq.DataContext.SubmitChanges%2A> operacji. <xref:System.Data.Linq.DataContext.SubmitChanges%2A> sam wywołania Przesłaniaj metody wcześniejszych metod jest przeznaczona do wywoływania wewnątrz metody zastąpienie, jeśli są one wykonywane.  
  
-   Jest odpowiedzialny za deweloperowi Przekaż prawidłowe jednostki. Implementacja sprawdza śledzenia jednostki przekazany w. Jednak jest obowiązkiem deweloperowi zachować kolejność lub Przekaż tego samego obiektu dwa razy.  
  
-   Jest odpowiedzialny za developer do wywołania poprawne dynamicznego interfejsu API. Na przykład w `Update` zastąpić metodę tylko <xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A> można wywołać metody. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] nie wykrywa ani nie Sprawdź, czy wywoływanej metody dynamicznej zgodna odpowiednich operacji. Wyniki są niezdefiniowane, gdy została wywołana metoda nie ma zastosowania (na przykład wywołanie elementu <xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A> dla obiekt aktualizacji).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicUpdate">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicUpdate (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicUpdate(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicUpdate (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicUpdate(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka do zaktualizowania.</param>
        <summary>Wykonuje wewnątrz metody zastąpienie aktualizacji, aby redelegate do [! INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-MD.MD)] zadanie generowania i wykonywania dynamicznego kodu SQL dla operacji update.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMethodCall">
      <MemberSignature Language="C#" Value="protected System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Data.Linq.IExecuteResult ExecuteMethodCall(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::Linq::IExecuteResult ^ ExecuteMethodCall(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IExecuteResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Wystąpienie wywołania metody (bieżącego obiektu).</param>
        <param name="methodInfo">Określa metodę CLR, która odpowiada metoda bazy danych.</param>
        <param name="parameters">Tablica parametrów do przekazania do polecenia.</param>
        <summary>Wykonuje procedurę składowaną bazy danych lub funkcja skalarna skojarzone z określonej metody CLR.</summary>
        <returns>Wynik (zwracanej wartości i parametry wyjściowe) wykonania określonej metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A> — Metoda jest używana w kodzie automatycznie generowanych i działa jako serwer proxy do funkcji bazy danych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ExecuteQuery (Type elementType, string query, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable ExecuteQuery(class System.Type elementType, string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery (elementType As Type, query As String, ParamArray parameters As Object()) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ ExecuteQuery(Type ^ elementType, System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Typ <see cref="T:System.Collections.Generic.IEnumerable`1" /> ma zostać zwrócona.  Algorytm dopasowania kolumny w wyniku zapytania do pola lub właściwości w obiekcie działa w następujący sposób: Jeśli pole lub właściwość jest zamapowana na nazwę konkretnej kolumny, Oczekiwano nazwy tej kolumny w zestawie wyników.  Jeśli pole lub właściwość nie jest zamapowany, kolumnę z taką samą nazwę jak pole lub właściwość jest oczekiwany w zestawie wyników.  Porównanie jest wykonywane przez wyszukiwanie z uwzględnieniem wielkości liter dopasowanie najpierw. Jeśli nie ma tego dopasowania, kolejne wyszukiwania występuje pod kątem dopasowania bez uwzględniania wielkości liter.  Zapytanie musi zwracać wszystkie śledzone pola i właściwości obiektu (z wyjątkiem tych, które są ładowane na podstawie odroczonego) gdy są spełnione wszystkie następujące warunki: <c>T</c> jest jednostką jawnie śledzony przez <see cref="T:System.Data.Linq.DataContext" />.  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> jest <see langword="true" />.  Jednostka ma klucz podstawowy.  W przeciwnym razie jest zwracany wyjątek.</param>
        <param name="query">Zapytanie SQL do wykonania.</param>
        <param name="parameters">Tablica parametrów do przekazania do polecenia. Należy pamiętać o następujących zasadach: liczba obiektów w tablicy jest mniejsza niż największa liczba określone w parametrach polecenia, jest zgłaszany wyjątek.  Jeśli tablica zawiera obiekty, które nie są wywoływane w parametrach polecenia, nie wyjątku.  Jeśli parametr jest <see langword="null" />, jest konwertowana na <see langword="DBNull.Value" />.</param>
        <summary>Wykonuje zapytania SQL bezpośrednio w bazie danych.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Kolekcji obiektów zwróconych przez kwerendę.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; ExecuteQuery&lt;TResult&gt; (string query, params object[] parameters) where TResult : new();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; ExecuteQuery&lt;.ctor TResult&gt;(string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery(Of TResult As New) (query As String, ParamArray parameters As Object()) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; where TResult : gcnew() System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ ExecuteQuery(System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ elementów w zwracanej kolekcji.</typeparam>
        <param name="query">Zapytanie SQL do wykonania.</param>
        <param name="parameters">Tablica parametrów do przekazania do polecenia. Należy pamiętać o następujących zasadach: liczba obiektów w tablicy jest mniejsza niż największa liczba określone w parametrach polecenia, jest zgłaszany wyjątek.  Jeśli tablica zawiera obiekty, które nie są wywoływane w parametrach polecenia, nie wyjątku.  Jeśli parametr ma wartość null, jest konwertowana na <see langword="DBNull.Value" />.</param>
        <summary>Wykonuje zapytania SQL bezpośrednio w bazie danych i zwraca obiekty.</summary>
        <returns>Kolekcja obiektów zwróconych przez kwerendę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przekazywane mechanizm przypadków gdzie [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] nie dostarcza dla danego scenariusza.  
  
 Algorytm pasujące kolumny w wyniku zapytania do pól i właściwości w obiekcie działa w następujący sposób:  
  
-   Jeśli pole lub właściwość jest zamapowana na nazwę konkretnej kolumny, Oczekiwano nazwy tej kolumny w zestawie wyników.  
  
-   Jeśli pole lub właściwość nie jest zamapowany, kolumnę z taką samą nazwę jak pole lub właściwość jest oczekiwany w zestawie wyników.  
  
-   Porównanie jest wykonywane przez wyszukiwanie z uwzględnieniem wielkości liter dopasowanie. Jeśli nie zostanie znaleziony taki dopasowania, kolejne wyszukiwania występuje pod kątem dopasowania bez uwzględniania wielkości liter.  
  
-   Zapytanie musi zwracać wszystkie śledzone pola i właściwości obiektu (oprócz podlegające ładowanie odłożone) kiedy spełnione są następujące:  
  
    -   Jeśli `<T>` jest jednostką jawnie śledzony przez <xref:System.Data.Linq.DataContext>.  
  
    -   ObjectTrackingEnabled ma wartość true.  
  
    -   Jednostka ma klucz podstawowy.  
  
     W przeciwnym razie jest zwracany wyjątek.  
  
-   We wszystkich innych przypadkach zapytanie może pobierać tylko ich podzbiór śledzonych pola i właściwości dla obiektu.  
  
 Poniższy fragment kodu C# zawiera jedno użycie tej metody:  
  
```  
var customers = db.ExecuteQuery<Customer>(@"SELECT CustomerID, CompanyName, ContactName, ContactTitle,   
   Address, City, Region, PostalCode, Country, Phone, Fax  
   FROM   dbo.Customers  
   WHERE  City = {0}", "London");  
  
foreach (Customer c in customers)  
   Console.WriteLine(c.ContactName);  
```  
  
 W języku Visual Basic  
  
```  
Dim customers = db.ExecuteQuery(Of Customer)("SELECT CustomerID, _    CompanyName, ContactName, ContactTitle, _  
   Address, City, Region, PostalCode, Country, Phone, Fax _  
   FROM dbo.Customers _  
WHERE City = {0}", "London")  
  
For Each c As Customer In customers  
    Console.WriteLine(c.ContactName)  
Next  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeSet">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeSet GetChangeSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ChangeSet GetChangeSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetChangeSet" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChangeSet () As ChangeSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ChangeSet ^ GetChangeSet();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekty zmodyfikowane śledzone przez <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <returns>Zestaw obiektów jest zwracana jako trzy kolekcji tylko do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy uwzględnić następujące kwestie:  
  
-   <xref:System.Data.Linq.DataContext.GetChangeSet%2A> może mieć efekty uboczne, takich jak wnioskowania INSERT i usuwanie operacji, które zwykle są wykonywane w czasie <xref:System.Data.Linq.DataContext.SubmitChanges%2A>. Na przykład obiekty, które są używane w następujące operacje można utworzyć odpowiednie operacje wykrywany na poniższej liście:  
  
    -   <xref:System.Data.Linq.EntitySet%601.Add%2A> Aby <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.  
  
    -   <xref:System.Data.Linq.EntityRef%601> Przypisanie wartości null (prawdopodobnie z powodu <xref:System.Data.Linq.EntitySet%601.Remove%2A> do <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.  
  
-   Zestaw nie może zostać określona zgodnie z ograniczeń klucza obcego.  
  
-   Baza danych wygenerowała wartości (na przykład podstawowe i obce wartości klucza, sygnatury czasowe i tak dalej) nie są dostępne. Takie informacje wymaga wykonania polecenia bazy danych i prawdopodobnie propagacji pobrane informacje (na przykład klucz obcy z klucza podstawowego).  
  
-   Zestaw obiektów zmienionych jest obliczana w momencie wywołania. Kolejne wywołania <xref:System.Data.Linq.DataContext.SubmitChanges%2A> może utworzyć inny zestaw w przypadku wprowadzenia dodatkowych zmian.  
  
 Dane wyjściowe, gdy żadne zmiany nie zostały wprowadzone wygląda następująco:  
  
 `{Added: 0, Removed: 0, Modified: 0}`  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#2](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#2)]
 [!code-vb[DLinqDebuggingSupport#2](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand GetCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Common.DbCommand GetCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCommand (query As IQueryable) As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Common::DbCommand ^ GetCommand(System::Linq::IQueryable ^ query);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">Zapytanie, którego informacje polecenia SQL ma być pobrana.</param>
        <summary>Pobiera informacje o poleceniach SQL generowane przez [! INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-MD.MD)].</summary>
        <returns>Żądane polecenie Obiekt informacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest tylko metody pobierającej i nie ma wpływu na <xref:System.Data.Linq.DataContext> stanu.  
  
 Należy uwzględnić następujące kwestie:  
  
-   Argument musi być inne niż null. W przeciwnym razie jest zgłaszany wyjątek argumentu o wartości null.  
  
-   Wyjątki tłumaczenia normalne zapytania zgłoszony podczas [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] zastosować wykonywanie zapytania dla zapytania, którego nie można przetłumaczyć.  
  
-   Zwracany jest tylko pierwsze polecenie zapytania. W szczególności dodatkowych poleceń, które są używane do ładowania wczesny (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>) nie są uwzględniane.  
  
-   <xref:System.Data.Linq.DataContext> nie śledzi użytkownik wykona przy użyciu polecenia. Na przykład wyniki z wykonanie polecenia zwracane nie są śledzone i nie wpływają na <xref:System.Data.Linq.DataContext> stanu.  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#3)]
 [!code-vb[DLinqDebuggingSupport#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIDbCommand">
      <MemberSignature Language="C#" Value="public System.Data.IDbCommand GetIDbCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.IDbCommand GetIDbCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetIDbCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIDbCommand (query As IQueryable) As IDbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::IDbCommand ^ GetIDbCommand(System::Linq::IQueryable ^ query);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ITable GetTable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ITable GetTable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ITable ^ GetTable(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ITable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektów, które ma zostać zwrócona.</param>
        <summary>Zwraca kolekcję obiektów określonego typu, których typ jest zdefiniowany przez <paramref name="type" /> parametru.</summary>
        <returns>Kolekcja obiektów zdefiniowanych przez <paramref name="type" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest wersja lekko typu <xref:System.Data.Linq.DataContext.GetTable%2A>. Należy mieć lekko typizowaną wersję, ponieważ jest stosunkowo popularną praktyką dynamicznie tworzyć zapytania. Jest niedogodne wymusić stosowanie na potrzeby wywołania poprawna metoda ogólna odbicia.  
  
 Jeśli nie ma żadnych kolekcji dla określonego typu, jest zwracany wyjątek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Table&lt;TEntity&gt; GetTable&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.Table`1&lt;!!TEntity&gt; GetTable&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTable(Of TEntity As Class) () As Table(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Linq::Table&lt;TEntity&gt; ^ GetTable();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Table&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Typ obiektów, które ma zostać zwrócona.</typeparam>
        <summary>Zwraca kolekcję obiektów określonego typu, których typ jest zdefiniowany przez <paramref name="TEntity" /> parametru.</summary>
        <returns>Kolekcja obiektów zdefiniowanych przez <paramref name="TEntity" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest główny punkt wejścia dla wykonywania zapytania. Gdy silnie typizowaną <xref:System.Data.Linq.DataContext> jest utworzony, nowe właściwości wygenerowanego Hermetyzowanie wywołania tej metody. Na przykład `Customers` wygenerować właściwości zwraca `GetTable<Customer>`.  
  
 Jeśli nie ma żadnych kolekcji dla określonego typu, jest zwracany wyjątek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadOptions">
      <MemberSignature Language="C#" Value="public System.Data.Linq.DataLoadOptions LoadOptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.DataLoadOptions LoadOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.LoadOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadOptions As DataLoadOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::DataLoadOptions ^ LoadOptions { System::Data::Linq::DataLoadOptions ^ get(); void set(System::Data::Linq::DataLoadOptions ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.DataLoadOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Data.Linq.DataLoadOptions" /> skojarzony z tym <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <value>Pobieranie z wyprzedzeniem załadować opcje powiązanych danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość pobiera lub ustawia opcje, które są używane do definiowania zachowania pobierania z wyprzedzeniem dla odroczone załadowanych elementów członkowskich i członkostwa w kolekcji powiązanych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Log" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Log { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia lokalizację docelową, aby napisać zapytanie SQL lub polecenie.</summary>
        <value>
          <see cref="T:System.IO.TextReader" /> Do użycia przy zapisie polecenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest ustawiana `null` wyłączyć rejestrowanie polecenia.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wygenerowanego SQL w oknie konsoli, zanim wyświetli wyniki zapytania.  
  
 [!code-csharp[System.Data.Linq.DataContext#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#2)]
 [!code-vb[System.Data.Linq.DataContext#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mapping">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Mapping.MetaModel Mapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.Mapping.MetaModel Mapping" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Mapping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mapping As MetaModel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::Mapping::MetaModel ^ Mapping { System::Data::Linq::Mapping::MetaModel ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Mapping.MetaModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Data.Linq.Mapping.MetaModel" /> na podstawie mapowania.</summary>
        <value>Mapowanie między obiektami bazy danych i domeny.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool ObjectTrackingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ObjectTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ObjectTrackingEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy jest włączone śledzenie obiektów.</summary>
        <value>
          <see langword="true" /> Jeśli jest włączone śledzenie obiektów; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości na `false` zwiększa wydajność w czasie pobierania, ponieważ brak mniejszą liczbę elementów do śledzenia.  
  
 Wyjątek:  
  
-   Jeśli ustawiono właściwość `false` po wykonaniu zapytania.  
  
     Aby uzyskać więcej informacji, zobacz sekcję prawidłowe tryby w <xref:System.Data.Linq.DataContext>.  
  
-   Jeśli ustawiono właściwość `false` i <xref:System.Data.Linq.DataContext.SubmitChanges%2A> jest wywoływana.  
  
 Jeśli <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> jest `false`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> jest ignorowany i traktowany `false`. W takim przypadku <xref:System.Data.Linq.DataContext> jest tylko do odczytu.  
  
 Jeśli <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> jest `true`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> jest `false`. W takim przypadku <xref:System.Data.Linq.DataContext> umożliwia ładowanie wykres obiektu przy użyciu <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> dyrektyw, ale nie umożliwia ładowanie odłożone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCacheEnabled">
      <MemberSignature Language="C#" Value="public bool QueryCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool QueryCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property QueryCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool QueryCacheEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odświeża stan obiektu przy użyciu danych w bazie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przydatna po wystąpieniu błędu optymistycznej współbieżności do dostosowania elementy do stanu do kolejnej próby. Aktualizuje stan pierwotnych pola i właściwości obiektów.  
  
> [!NOTE]
>  Jeśli obiekt znajduje się na *wiele* zostanie ustawiona w relacji jeden do wielu, klucz obcy dla obiektu i wskaźnika obiektu na drugiej stronie relacji zostanie ustawiona do nowej wartości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entities As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Collections::IEnumerable ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="mode">Wartość, która określa sposób optymistycznej współbieżności konflikty są obsługiwane.</param>
        <param name="entities">Kolekcja obiektów do odświeżenia.</param>
        <summary>Odświeża kolekcję obiektów jednostki zgodnie z określonym trybie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mode">Wartość, która określa sposób optymistycznej współbieżności konflikty są obsługiwane.</param>
        <param name="entity">Obiekt do odświeżenia.</param>
        <summary>Odświeża do obiektu jednostki, zgodnie z określonym trybie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, params object[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, ParamArray entities As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, ... cli::array &lt;System::Object ^&gt; ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="mode">Wartość, która określa sposób optymistycznej współbieżności konflikty są obsługiwane.</param>
        <param name="entities">Tablica obiekty obiektów do odświeżenia.</param>
        <summary>Odświeża tablicę obiektów jednostki zgodnie z określonym trybie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubmitChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza zestaw zmodyfikowanych obiektów do wstawienia, zaktualizować lub usunąć i wykonuje odpowiednich poleceń do implementowania zmian w bazie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zastąpienie metody dla insert, update lub delete, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> wykonuje te metody zamiast domyślnej [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] poleceń.  
  
 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> rozpoczyna transakcją i nastąpi przeniesienie, jeśli wystąpi wyjątek podczas <xref:System.Data.Linq.DataContext.SubmitChanges%2A> jest wykonywany. Jednak to wycofanie zmian w pamięci lub śledzona przez <xref:System.Data.Linq.DataContext>; te zmiany, należy go z powrotem obniżyć ręcznie. Można uruchomić z nowe wystąpienie klasy <xref:System.Data.Linq.DataContext> Jeśli odrzucenie zmian w pamięci.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public void SubmitChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SubmitChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub SubmitChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SubmitChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oblicza zestaw zmodyfikowanych obiektów do wstawienia, zaktualizować lub usunąć i wykonuje odpowiednich poleceń do implementowania zmian w bazie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zastąpienie metody dla insert, update lub delete, <xref:System.Data.Linq.DataContext.SubmitChanges%2A> wykonuje te metody zamiast domyślnej [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] poleceń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public virtual void SubmitChanges (System.Data.Linq.ConflictMode failureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubmitChanges(valuetype System.Data.Linq.ConflictMode failureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SubmitChanges (failureMode As ConflictMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SubmitChanges(System::Data::Linq::ConflictMode failureMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="failureMode" Type="System.Data.Linq.ConflictMode" />
      </Parameters>
      <Docs>
        <param name="failureMode">Akcja do wykonania, jeśli przesyłanie zakończy się niepowodzeniem. Nieprawidłowe argumenty są następujące:  <see cref="F:System.Data.Linq.ConflictMode.FailOnFirstConflict" /><see cref="F:System.Data.Linq.ConflictMode.ContinueOnConflict" /></param>
        <summary>Wysyła zmian wprowadzonych w taki sposób, aby pobrać obiekty do podstawowej bazy danych i określa działanie podejmowane w przypadku niepowodzenia przesyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny tryb awarii jest <xref:System.Data.Linq.ConflictMode.FailOnFirstConflict>.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transaction">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbTransaction Transaction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbTransaction Transaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Transaction" />
      <MemberSignature Language="VB.NET" Value="Public Property Transaction As DbTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbTransaction ^ Transaction { System::Data::Common::DbTransaction ^ get(); void set(System::Data::Common::DbTransaction ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia lokalny transakcji dla [! INCLUDE[dnprdnshort](~/includes/dnprdnshort-MD.MD)] na potrzeby dostępu do bazy danych.</summary>
        <value>Obiekt transakcji używany przez <see cref="T:System.Data.Linq.DataContext" /> podczas wykonywania zapytań i poleceń.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scenariusz podstawowy dla tej właściwości jest współdziałanie z relacyjnych [!INCLUDE[vstecado](~/includes/vstecado-md.md)] kodu. Na przykład użyć tej właściwości podczas pisania własnych `Create` / `Update` / `Delete` metod, aby ustawić `Transaction` właściwość ADO `Command` obiektu.  
  
 Należy pamiętać o następujących kwestiach:  
  
-   Jeśli ta właściwość nie została jawnie ustawiona, metoda pobierająca zwraca wartość null.  
  
-   Jeśli kod jest wykonywany w <xref:System.Transactions.Transaction> kontekstu, ustawienie dla tej właściwości zgłasza wyjątek.  
  
-   Jeśli ta właściwość jest ustawiony, a nowy <xref:System.Transactions.Transaction> jest otwarty, jest zgłaszany wyjątek podczas wykonywania zapytania lub aktualizacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Translate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje istniejące <see cref="T:System.Data.IDataReader" /> do obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy wiersz w <xref:System.Data.IDataReader> jest konwertowana do obiektu w <xref:System.Collections.Generic.IEnumerable%601>.  
  
```  
public IEnumerable<T> Translate<T>(IDataReader reader) {}  
```  
  
 Opis: Ta metoda jest używana do konwersji istniejącej <xref:System.Data.Common.DbDataReader> do obiektów. Każdy wiersz w <xref:System.Data.Common.DbDataReader> jest konwertowana do obiektu w <xref:System.Collections.Generic.IEnumerable%601>.  
  
 **Parametry ogólne:**  
  
 `T`: Zobacz <xref:System.Data.Linq.DataContext.ExecuteQuery%2A>.  
  
 **Parametry:**  
  
 `Query`: Zobacz opis polecenia w obszarze <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 `Parameters`: Zobacz opis parametrów w obszarze <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 **Zwracany typ:**  
  
 <xref:System.Collections.Generic.IEnumerable%601>: kolekcja obiektów zwrócona przez konwersji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Data.Linq.IMultipleResults Translate (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.IMultipleResults Translate(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (reader As DbDataReader) As IMultipleResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::IMultipleResults ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IMultipleResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> Do skonwertowania.</param>
        <summary>Konwertuje istniejące <see cref="T:System.Data.Common.DbDataReader" /> do obiektów.</summary>
        <returns>Lista obiektów zwrócona przez konwersji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable Translate (Type elementType, System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable Translate(class System.Type elementType, class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (elementType As Type, reader As DbDataReader) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ Translate(Type ^ elementType, System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="elementType">Typ <see cref="T:System.Collections.Generic.IEnumerable`1" /> ma zostać zwrócona.  Algorytm dopasowania kolumny w wyniku do pól i właściwości w obiekcie działa w następujący sposób: Jeśli pole lub właściwość jest zamapowana na nazwę konkretnej kolumny, Oczekiwano nazwy tej kolumny w zestawie wyników.  Jeśli pole lub właściwość nie jest zamapowany, kolumnę z taką samą nazwę jak pole lub właściwość jest oczekiwany w zestawie wyników.  Porównanie jest wykonywane przez wyszukiwanie z uwzględnieniem wielkości liter dopasowanie najpierw. Jeśli nie ma tego dopasowania, kolejne wyszukiwania jest występuje pod kątem dopasowania bez uwzględniania wielkości liter.  Zapytanie musi zwracać wszystkie śledzone pola i właściwości obiektu (z wyjątkiem tych, które są ładowane na podstawie odroczonego) gdy są spełnione wszystkie następujące warunki: <c>T</c> jest jednostką jawnie śledzony przez <see cref="T:System.Data.Linq.DataContext" />.  
  
 <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> jest <see langword="true" />.  Jednostka ma klucz podstawowy.  W przeciwnym razie jest zwracany wyjątek.</param>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> Do skonwertowania.</param>
        <summary>Konwertuje istniejące <see cref="T:System.Data.Common.DbDataReader" /> do obiektów.</summary>
        <returns>Lista obiektów zwrócona przez konwersji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; Translate&lt;TResult&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Translate&lt;TResult&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TResult) (reader As DbDataReader) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ <see cref="T:System.Collections.Generic.IEnumerable`1" /> ma zostać zwrócona.</typeparam>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> Do skonwertowania.</param>
        <summary>Konwertuje istniejące <see cref="T:System.Data.Common.DbDataReader" /> do obiektów.</summary>
        <returns>Kolekcja obiektów zwrócona przez konwersji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Table&lt;TEntity&gt;" FullName="System.Data.Linq.Table&lt;TEntity&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="464ca0511256b1663123b55ea5ac4383f11a22f3" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51312552" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Table&lt;TEntity&gt; : System.Collections.Generic.IEnumerable&lt;TEntity&gt;, System.ComponentModel.IListSource, System.Data.Linq.ITable, System.Linq.IQueryable&lt;TEntity&gt;, System.Linq.IQueryProvider where TEntity : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Table`1&lt;class TEntity&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt;, class System.Collections.IEnumerable, class System.ComponentModel.IListSource, class System.Data.Linq.ITable, class System.Linq.IQueryable, class System.Linq.IQueryable`1&lt;!TEntity&gt;, class System.Linq.IQueryProvider" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.Table`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Table(Of TEntity)&#xA;Implements IEnumerable(Of TEntity), IListSource, IQueryable(Of TEntity), IQueryProvider, ITable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TEntity&gt;&#xA; where TEntity : classpublic ref class Table sealed : System::Collections::Generic::IEnumerable&lt;TEntity&gt;, System::ComponentModel::IListSource, System::Data::Linq::ITable, System::Linq::IQueryable&lt;TEntity&gt;, System::Linq::IQueryProvider" />
  <TypeSignature Language="F#" Value="type Table&lt;'Entity (requires 'Entity : null)&gt; = class&#xA;    interface ITable&#xA;    interface IQueryProvider&#xA;    interface IListSource&#xA;    interface seq&lt;'Entity (requires 'Entity : null)&gt;&#xA;    interface IEnumerable&#xA;    interface IQueryable&lt;'Entity (requires 'Entity : null)&gt;&#xA;    interface IQueryable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Data.Linq.ITable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Linq.IQueryable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Linq.IQueryable&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Linq.IQueryProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TEntity">Typ danych w tabeli.</typeparam>
    <summary>Reprezentuje tabelę dla określonego typu w źródłowej bazie danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa umożliwia zapytanie dotyczące tabeli i dodawania, usuwania i dołączyć obiektów.  
  
 Aplikacja może uzyskiwać dostęp do <xref:System.Data.Linq.Table%601> wystąpienie za pośrednictwem <xref:System.Data.Linq.DataContext.GetTable%2A> lub za pomocą silnie typizowane właściwości dla silnie typizowanej <xref:System.Data.Linq.DataContext>. Oznacza to gdy projektant generuje obiekt DataContext, generuje ona właściwości do reprezentowania każdej tabeli. Na przykład:  
  
```  
[global::System.Data.Linq.Mapping.DatabaseAttribute(Name="SignOffTool")]  
public partial class DataClasses1DataContext : System.Data.Linq.DataContext {  
   public System.Data.Linq.Table<User> Users {  
      get {  
         return this.GetTable<User>();  
      }  
   }  
}  
```  
  
 W tym silnie typizowaną DataContext mogą uzyskiwać dostęp właściwości użytkowników do pobrania `Table<User>`.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Attach">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza jednostkę, aby <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `Attach` metody z jednostkami, które zostały utworzone w jednym <xref:System.Data.Linq.DataContext>, serializowany do klienta, a następnie wykonać deserializacji (z powrotem zamiar przeprowadzić aktualizację lub operacja usuwania). Aby uzyskać więcej informacji, zobacz [pobierania danych i operacje CUD w aplikacjach N-warstwowych (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 Nie należy próbować `Attach` jednostki, która nie została odłączona, za pomocą serializacji. Jednostki, które nie zostały zaszeregowane nadal utrzymuje skojarzenia z odroczonego modułów ładujących, które może spowodować nieoczekiwane wyniki, jeśli jednostka staje się śledzone przez drugi kontekstu danych.  
  
 Po dołączeniu nowej jednostki odroczone moduły ładujące przeznaczone dla dowolnej kolekcji podrzędnej (na przykład `EntitySet` kolekcji obiektów z skojarzone tabele) są inicjowane. Gdy <xref:System.Data.Linq.DataContext.SubmitChanges%2A> jest wywoływana, elementy członkowskie elementu podrzędnego kolekcje są umieszczane w `Unmodified` stanu. Aby zaktualizować elementów członkowskich kolekcji podrzędnej, należy jawnie wywołać `Attach` i określ tej jednostki.  
  
 `Attach` Dołącza wszystkie jednostki na grafie obiektu podanego obiektu. Na przykład, poniższy kod C#:  
  
```  
using (SampleDataContext db = new SampleDataContext()) {  
    Employee employee = new Employee { employeeId = 1 };  
  
    Master master = new Master();  
    master.Employee = employee;  
  
    Child child = new Child();  
    child.Employee = employee;  
  
    db.Employees.Attach(employee);  
  
    master.Child = child;  
  
    db.Masters.InsertOnSubmit(master);  
  
    db.SubmitChanges();  
}  
  
```  
  
 Jest równoważny kod języka Visual Basic:  
  
```  
Using db As New SampleDataContext()    Dim employee As New Employee With { .employeeId = 1 }  
  
    Dim master As New Master()  
    master.Employee = employee  
  
    Dim child As New Child()  
    child.Employee = employee  
  
    db.Employees.Attach(employee)  
  
    master.Child = child  
  
    db.Masters.InsertOnSubmit(master)  
  
    db.SubmitChanges()  
  
End Using  
```  
  
 Wywoływanie `Attach` na `Employee` dołącza pracowników, główne i podrzędne, ponieważ `Employee` zawiera relacje z zarówno węzła głównego, jak i podrzędnych. Należy jawnie wywołać `InsertOnSubmit` Zmień stan z przyłączonych do wstawionego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.Attach(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(TEntity entity);" />
      <MemberSignature Language="F#" Value="member this.Attach : 'Entity -&gt; unit" Usage="table.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Oryginalnych wartości jednostki do dołączenia.</param>
        <summary>Dołącza jednostki odłączone lub "odłączone" na nową <see cref="T:System.Data.Linq.DataContext" /> podczas oryginalnej wartości są wymagane do kontroli optymistycznej współbieżności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `Attach` metody z jednostkami, które zostały utworzone w jednym <xref:System.Data.Linq.DataContext>, serializowany do klienta, a następnie wykonać deserializacji Wstecz, aby przeprowadzić aktualizację lub operacja usuwania. Ponieważ nowe <xref:System.Data.Linq.DataContext> nie ma możliwości śledzenia, oryginalne wartości były dla odłączonych jednostek, klient jest odpowiedzialny za dostarczanie tych wartości. W tej wersji programu <xref:System.Data.Linq.Table%601.Attach%2A>, jednostki zakłada, że w jego oryginalnej wartości. Po wywołaniu tej metody, można zaktualizować jej pola, na przykład wraz z dodatkowymi danymi wysłanych z klienta.  
  
 Po dołączeniu nowej jednostki odroczone moduły ładujące przeznaczone dla dowolnej kolekcji podrzędnej (na przykład `EntitySet` kolekcji obiektów z skojarzone tabele) są inicjowane. Gdy <xref:System.Data.Linq.DataContext.SubmitChanges%2A> jest wywoływana, elementy członkowskie elementu podrzędnego kolekcje są umieszczane w `Unmodified` stanu. Aby zaktualizować elementów członkowskich kolekcji podrzędnej, należy jawnie wywołać `Attach` i określ tej jednostki.  
  
 Aby uzyskać więcej informacji, zobacz [pobierania danych i operacje CUD w aplikacjach N-warstwowych (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 Nie należy próbować `Attach` jednostki, która nie została odłączona, za pomocą serializacji. Jednostki, które nie zostały zaszeregowane nadal utrzymuje skojarzenia z odroczonego modułów ładujących, które może spowodować nieoczekiwane wyniki, jeśli jednostka staje się śledzone przez drugi kontekstu danych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (TEntity entity, bool asModified);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(!TEntity entity, bool asModified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.Attach(`0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As TEntity, asModified As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(TEntity entity, bool asModified);" />
      <MemberSignature Language="F#" Value="member this.Attach : 'Entity * bool -&gt; unit" Usage="table.Attach (entity, asModified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="asModified" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka do podłączenia.</param>
        <param name="asModified">
          <see langword="true" /> Aby dołączyć jednostkę ze zmianami; <see langword="false" /> można dołączyć jednostki jako niezmodyfikowany.</param>
        <summary>Dołącza jednostkę, aby <see cref="T:System.Data.Linq.DataContext" /> w stanie zmodyfikowany lub zostały zmodyfikowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dołączenie *zmodyfikowana*, jednostki albo musi zadeklarować członka wersji lub nie musi uczestniczyć w Sprawdzanie konfliktu aktualizacji. Po dołączeniu nowej jednostki odroczone moduły ładujące przeznaczone dla dowolnej kolekcji podrzędnej (na przykład `EntitySet` kolekcji obiektów z skojarzone tabele) są inicjowane. Gdy <xref:System.Data.Linq.DataContext.SubmitChanges%2A> jest wywoływana, elementy członkowskie elementu podrzędnego kolekcje są umieszczane w `Unmodified` stanu. Aby zaktualizować elementów członkowskich kolekcji podrzędnej, należy jawnie wywołać `Attach` i określ tej jednostki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (TEntity entity, TEntity original);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(!TEntity entity, !TEntity original) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.Attach(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As TEntity, original As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(TEntity entity, TEntity original);" />
      <MemberSignature Language="F#" Value="member this.Attach : 'Entity * 'Entity -&gt; unit" Usage="table.Attach (entity, original)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="original" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka do podłączenia.</param>
        <param name="original">Wystąpienie typu jednostki z elementów członkowskich danych, które zawierają oryginalnych wartości.</param>
        <summary>Dołącza jednostkę, aby <see cref="T:System.Data.Linq.DataContext" /> w dowolnym stanie zmodyfikowany lub zostały zmodyfikowane przez określenie jednostki i stanu pierwotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższym przykładzie `Customer` obiektu została już skonfigurowana. Możesz wywołać `Attach` bez konieczności powtarzania aktualizacji.  
  
 Po dołączeniu nowej jednostki odroczone moduły ładujące przeznaczone dla dowolnej kolekcji podrzędnej (na przykład `EntitySet` kolekcji obiektów z skojarzone tabele) są inicjowane. Gdy <xref:System.Data.Linq.DataContext.SubmitChanges%2A> jest wywoływana, elementy członkowskie elementu podrzędnego kolekcje są umieszczane w `Unmodified` stanu. Aby zaktualizować elementów członkowskich kolekcji podrzędnej, należy jawnie wywołać `Attach` i określ tej jednostki.  
  
   
  
## Examples  
 [!code-csharp[DLinqNTier#4](~/samples/snippets/csharp/VS_Snippets_Data/DLinqNTier/cs/Program.cs#4)]
 [!code-vb[DLinqNTier#4](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqNTier/vb/Module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AttachAll&lt;TSubEntity&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza wszystkie jednostki w kolekcji do <see cref="T:System.Data.Linq.DataContext" /> w stanie zmodyfikowany lub zostały zmodyfikowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dołączenie zmodyfikowana, jednostki albo musi zadeklarować członka wersji lub nie musi uczestniczyć w Sprawdzanie konfliktu aktualizacji.  
  
 Po dołączeniu nowej jednostki odroczone moduły ładujące przeznaczone dla dowolnej kolekcji podrzędnej (na przykład `EntitySet` kolekcji obiektów z skojarzone tabele) są inicjowane. Gdy <xref:System.Data.Linq.DataContext.SubmitChanges%2A> jest wywoływana, elementy członkowskie elementu podrzędnego kolekcje są umieszczane w `Unmodified` stanu. Aby zaktualizować elementów członkowskich kolekcji podrzędnej, należy jawnie wywołać `Attach` i określ tej jednostki.  
  
 Aby uzyskać więcej informacji, zobacz [pobierania danych i operacje CUD w aplikacjach N-warstwowych (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AttachAll&lt;TSubEntity&gt;">
      <MemberSignature Language="C#" Value="public void AttachAll&lt;TSubEntity&gt; (System.Collections.Generic.IEnumerable&lt;TSubEntity&gt; entities) where TSubEntity : TEntity;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachAll&lt;(!TEntity) TSubEntity&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSubEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.AttachAll``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachAll(Of TSubEntity As TEntity) (entities As IEnumerable(Of TSubEntity))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSubEntity&gt;&#xA; where TSubEntity : TEntity void AttachAll(System::Collections::Generic::IEnumerable&lt;TSubEntity&gt; ^ entities);" />
      <MemberSignature Language="F#" Value="member this.AttachAll : seq&lt;#'Entity&gt; -&gt; unit" Usage="table.AttachAll entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSubEntity">
          <Constraints>
            <BaseTypeName>TEntity</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TSubEntity&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSubEntity">Typ jednostki do dołączenia.</typeparam>
        <param name="entities">Kolekcja jednostek.</param>
        <summary>Dołącza wszystkie jednostki w kolekcji do <see cref="T:System.Data.Linq.DataContext" /> w stanie zmodyfikowany lub zostały zmodyfikowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza wszystkie jednostki w kolekcji na nową <xref:System.Data.Linq.DataContext>. Po dołączeniu nowej jednostki odroczone moduły ładujące przeznaczone dla dowolnej kolekcji podrzędnej (na przykład `EntitySet` kolekcji obiektów z skojarzone tabele) są inicjowane. Gdy <xref:System.Data.Linq.DataContext.SubmitChanges%2A> jest wywoływana, elementy członkowskie elementu podrzędnego kolekcje są umieszczane w `Unmodified` stanu. Aby zaktualizować elementów członkowskich kolekcji podrzędnej, należy jawnie wywołać `Attach` i określ tej jednostki.  
  
 Aby uzyskać więcej informacji, zobacz [pobierania danych i operacje CUD w aplikacjach N-warstwowych (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttachAll&lt;TSubEntity&gt;">
      <MemberSignature Language="C#" Value="public void AttachAll&lt;TSubEntity&gt; (System.Collections.Generic.IEnumerable&lt;TSubEntity&gt; entities, bool asModified) where TSubEntity : TEntity;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachAll&lt;(!TEntity) TSubEntity&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSubEntity&gt; entities, bool asModified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.AttachAll``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachAll(Of TSubEntity As TEntity) (entities As IEnumerable(Of TSubEntity), asModified As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSubEntity&gt;&#xA; where TSubEntity : TEntity void AttachAll(System::Collections::Generic::IEnumerable&lt;TSubEntity&gt; ^ entities, bool asModified);" />
      <MemberSignature Language="F#" Value="member this.AttachAll : seq&lt;#'Entity&gt; * bool -&gt; unit" Usage="table.AttachAll (entities, asModified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSubEntity">
          <Constraints>
            <BaseTypeName>TEntity</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TSubEntity&gt;" />
        <Parameter Name="asModified" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TSubEntity">Typ jednostki do dołączenia.</typeparam>
        <param name="entities">Kolekcja jednostek.</param>
        <param name="asModified">
          <see langword="true" /> Jeśli obiekt ma znacznika czasu lub elementu członkowskiego RowVersion; <see langword="false" /> Jeśli oryginalne wartości są używane do sprawdzania optymistycznej współbieżności.</param>
        <summary>Dołącza wszystkie jednostki w kolekcji do <see cref="T:System.Data.Linq.DataContext" /> w stanie zmodyfikowany lub zostały zmodyfikowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza wszystkie jednostki w kolekcji do <xref:System.Data.Linq.DataContext> albo *zmodyfikowane* lub *niezmodyfikowanego* stanu. Jeśli dołączenie zmodyfikowana, jednostki albo musi zadeklarować członka wersji lub nie musi uczestniczyć w Sprawdzanie konfliktu aktualizacji. Jeśli dołączenie jako niezmodyfikowany, jednostki zakłada się, że reprezentują oryginalną wartość. Po wywołaniu tej metody, można zmodyfikować pola jednostki wraz z innymi informacjami z klienta przed <xref:System.Data.Linq.DataContext.SubmitChanges%2A> jest wywoływana. Aby uzyskać więcej informacji, zobacz [pobierania danych i operacje CUD w aplikacjach N-warstwowych (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 Po dołączeniu nowej jednostki odroczone moduły ładujące przeznaczone dla dowolnej kolekcji podrzędnej (na przykład `EntitySet` kolekcji obiektów z skojarzone tabele) są inicjowane. Gdy <xref:System.Data.Linq.DataContext.SubmitChanges%2A> jest wywoływana, elementy członkowskie elementu podrzędnego kolekcje są umieszczane w `Unmodified` stanu. Aby zaktualizować elementów członkowskich kolekcji podrzędnej, należy jawnie wywołać `Attach` i określ tej jednostki.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak możesz zaktualizować `Order` obiektu na inny <xref:System.Data.Linq.DataContext> wystąpienia. W przykładzie założono, czy masz połączenie z bazą danych, a wprowadzono [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] pliku (w tym przypadku przykładowej bazy danych Northwind).  
  
 [!code-csharp[DLinqNTier#1](~/samples/snippets/csharp/VS_Snippets_Data/DLinqNTier/cs/Program.cs#1)]
 [!code-vb[DLinqNTier#1](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqNTier/vb/Module1.vb#1)]  
  
 W poniższym przykładzie do obiektu jednostki do dołączenia ma relacji klucza obcego z innym obiektem i jest przechowywany w pamięci podręcznej, lecz nie jest dołączony. Gdy wywołujesz <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, `ChangeProcessor` dodaje `Insert` operację dla wszystkich obiektów klucza obcego. Jest to efekt uboczny, gdy wystąpienie jednostki jest użyć ponownie w innej <xref:System.Data.Linq.DataContext> wystąpienia. Z tego powodu [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] nie obsługuje ponownego użycia obiektów.  
  
 [!code-csharp[DlinqNTier#7](~/samples/snippets/csharp/VS_Snippets_Data/DLinqNTier/cs/Program.cs#7)]
 [!code-vb[DlinqNTier#7](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqNTier/vb/Module1.vb#7)]  
  
 Poniższy przykład przedstawia scenariusz, w którym anulował wszystkich zamówień klienta A i B Klient przyjmuje na własność. Możesz dołączyć wszystkie zamówienia klienta, A w tym samym czasie.  
  
 [!code-csharp[DlinqNTier#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqNTier/cs/Program.cs#3)]
 [!code-vb[DlinqNTier#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqNTier/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="public System.Data.Linq.DataContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.DataContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Table`1.Context" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Context As DataContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::DataContext ^ Context { System::Data::Linq::DataContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Data.Linq.DataContext" Usage="System.Data.Linq.Table&lt;'Entity (requires 'Entity : null)&gt;.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Linq.DataContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Data.Linq.DataContext" /> który został użyty do pobrania to <see cref="T:System.Data.Linq.Table`1" />.</summary>
        <value>Kontekst danych, który został użyty do pobrania w tej tabeli.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteAllOnSubmit&lt;TSubEntity&gt;">
      <MemberSignature Language="C#" Value="public void DeleteAllOnSubmit&lt;TSubEntity&gt; (System.Collections.Generic.IEnumerable&lt;TSubEntity&gt; entities) where TSubEntity : TEntity;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteAllOnSubmit&lt;(!TEntity) TSubEntity&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSubEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.DeleteAllOnSubmit``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteAllOnSubmit(Of TSubEntity As TEntity) (entities As IEnumerable(Of TSubEntity))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSubEntity&gt;&#xA; where TSubEntity : TEntity void DeleteAllOnSubmit(System::Collections::Generic::IEnumerable&lt;TSubEntity&gt; ^ entities);" />
      <MemberSignature Language="F#" Value="member this.DeleteAllOnSubmit : seq&lt;#'Entity&gt; -&gt; unit" Usage="table.DeleteAllOnSubmit entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSubEntity">
          <Constraints>
            <BaseTypeName>TEntity</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TSubEntity&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSubEntity">Typ elementów do usunięcia.</typeparam>
        <param name="entities">Jednostki do usunięcia.</param>
        <summary>Umieszcza wszystkie jednostki z kolekcji do <see langword="pending delete" /> stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednostki, które są umieszczane w stanie oczekiwanie na usunięcie przy użyciu tej metody nie są usuwane z wyników zapytania do momentu po <xref:System.Data.Linq.DataContext.SubmitChanges%2A> jest wywoływana. Odłączone jednostki musi być podłączony, aby można było je usunąć. Aby uzyskać więcej informacji, zobacz [pobierania danych i operacje CUD w aplikacjach N-warstwowych (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 Poniższy fragment kodu języka C# demonstruje jedno użycie tej metody:  
  
```  
IEnumerable<Customer> customersWithoutOrders = (from c in db.Customers  
   where c.Orders.Count == 0  
   select c).ToList();  
  
db.Customers.DeleteAllOnSubmit(customersWithoutOrders);  
db.SubmitChanges();  
```  
  
 W języku Visual Basic:  
  
```  
Dim customersWithoutOrders As IEnumerable(Of Customer) = (From c In db.Customers _   
    Where c.Orders.Count = 0 _   
    Select c).ToList()  
  
db.Customers.DeleteAllOnSubmit(customersWithoutOrders)  
db.SubmitChanges()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteOnSubmit">
      <MemberSignature Language="C#" Value="public void DeleteOnSubmit (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteOnSubmit(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.DeleteOnSubmit(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteOnSubmit (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteOnSubmit(TEntity entity);" />
      <MemberSignature Language="F#" Value="member this.DeleteOnSubmit : 'Entity -&gt; unit" Usage="table.DeleteOnSubmit entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka do usunięcia.</param>
        <summary>Umieszcza jednostki z tej tabeli do <see langword="pending delete" /> stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usunięto jednostki nie są usuwane z wyników zapytania do momentu po <xref:System.Data.Linq.DataContext.SubmitChanges%2A> jest wywoływana. Odłączone jednostki najpierw musi być podłączony, aby można było je usunąć. Aby uzyskać więcej informacji, zobacz [pobierania danych i operacje CUD w aplikacjach N-warstwowych (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
> [!NOTE]
>  [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] nie obsługuje ani nie rozpoznają operations usuwanie kaskadowe. Jeśli chcesz usunąć wiersz w tabeli, która ma ograniczenia względem jego, musisz któryś zbiór `ON DELETE CASCADE` reguły ograniczenie klucza obcego w bazie danych lub Użyj własnego kodu, aby najpierw usunąć obiekty podrzędne, które uniemożliwiają usunięcie obiektu nadrzędnego. W przeciwnym razie jest zgłaszany wyjątek.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.Table#3](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.table/cs/program.cs#3)]
 [!code-vb[System.Data.Linq.Table#3](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.table/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;TEntity&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerator`1&lt;!TEntity&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerator&lt;TEntity&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'Entity (requires 'Entity : null)&gt;" Usage="table.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera moduł wyliczający, który iteruje po kolekcji.</summary>
        <returns>Moduł wyliczający, który może służyć do iterowania po kolekcji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModifiedMembers">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ModifiedMemberInfo[] GetModifiedMembers (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.Linq.ModifiedMemberInfo[] GetModifiedMembers(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.GetModifiedMembers(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModifiedMembers (entity As TEntity) As ModifiedMemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::Linq::ModifiedMemberInfo&gt; ^ GetModifiedMembers(TEntity entity);" />
      <MemberSignature Language="F#" Value="member this.GetModifiedMembers : 'Entity -&gt; System.Data.Linq.ModifiedMemberInfo[]" Usage="table.GetModifiedMembers entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ModifiedMemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostki, z którego można pobrać tablicy.</param>
        <summary>Zwraca tablicę zmodyfikowane elementy członkowskie, które zawierają swoje bieżące i oryginalne wartości.</summary>
        <returns>Tablica zmodyfikowane elementy członkowskie, które zawierają swoje bieżące i oryginalne wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNewBindingList">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IBindingList GetNewBindingList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.IBindingList GetNewBindingList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.GetNewBindingList" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNewBindingList () As IBindingList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::IBindingList ^ GetNewBindingList();" />
      <MemberSignature Language="F#" Value="member this.GetNewBindingList : unit -&gt; System.ComponentModel.IBindingList" Usage="table.GetNewBindingList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IBindingList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową listę dla powiązania ze źródłem danych.</summary>
        <returns>Nowy <see cref="T:System.ComponentModel.IBindingList" /> dla powiązania ze źródłem danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona lista obsługuje standardowe operacje, takie jak dodawania, usuwania, liczba operacji wstawienia i aktualizacje, ale zapisuje musi być jawnie zarządzane przez programistę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOriginalEntityState">
      <MemberSignature Language="C#" Value="public TEntity GetOriginalEntityState (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TEntity GetOriginalEntityState(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.GetOriginalEntityState(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOriginalEntityState (entity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TEntity GetOriginalEntityState(TEntity entity);" />
      <MemberSignature Language="F#" Value="member this.GetOriginalEntityState : 'Entity -&gt; 'Entity" Usage="table.GetOriginalEntityState entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka, w których oryginalny stan jest zwracana.</param>
        <summary>Zwraca <see cref="T:System.Data.Linq.Table`1" /> wystąpienia, która zawiera oryginalny stan jednostki.</summary>
        <returns>A <see cref="T:System.Data.Linq.Table`1" /> wystąpienia, która zawiera oryginalny stan jednostki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca oryginalnej jednostki, ponieważ został on utworzony lub dołączonych do bieżącego <xref:System.Data.Linq.DataContext>. Oryginalny stan jednostki, która serializacji i deserializacji musi być dostarczone przez mechanizm śledzenia niezależne i dostarczana, gdy jednostka jest dołączony do nowej <xref:System.Data.Linq.DataContext>. Aby uzyskać więcej informacji, zobacz [pobierania danych i operacje CUD w aplikacjach N-warstwowych (LINQ to SQL)](~/docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertAllOnSubmit&lt;TSubEntity&gt;">
      <MemberSignature Language="C#" Value="public void InsertAllOnSubmit&lt;TSubEntity&gt; (System.Collections.Generic.IEnumerable&lt;TSubEntity&gt; entities) where TSubEntity : TEntity;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertAllOnSubmit&lt;(!TEntity) TSubEntity&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSubEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.InsertAllOnSubmit``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertAllOnSubmit(Of TSubEntity As TEntity) (entities As IEnumerable(Of TSubEntity))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSubEntity&gt;&#xA; where TSubEntity : TEntity void InsertAllOnSubmit(System::Collections::Generic::IEnumerable&lt;TSubEntity&gt; ^ entities);" />
      <MemberSignature Language="F#" Value="member this.InsertAllOnSubmit : seq&lt;#'Entity&gt; -&gt; unit" Usage="table.InsertAllOnSubmit entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSubEntity">
          <Constraints>
            <BaseTypeName>TEntity</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TSubEntity&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSubEntity">Typ elementów do wstawienia.</typeparam>
        <param name="entities">Jednostki do dodania.</param>
        <summary>Dodaje wszystkie jednostki w kolekcji do <see cref="T:System.Data.Linq.DataContext" /> w <see langword="pending insert" /> stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodano jednostki nie będą w wynikach kwerendy aż po <xref:System.Data.Linq.DataContext.SubmitChanges%2A> została wywołana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertOnSubmit">
      <MemberSignature Language="C#" Value="public void InsertOnSubmit (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertOnSubmit(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.InsertOnSubmit(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertOnSubmit (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertOnSubmit(TEntity entity);" />
      <MemberSignature Language="F#" Value="member this.InsertOnSubmit : 'Entity -&gt; unit" Usage="table.InsertOnSubmit entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka, która ma zostać dodana.</param>
        <summary>Dodaje jednostki w usłudze <see langword="pending insert" /> do tego stanu <see cref="T:System.Data.Linq.Table`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dodano jednostkę nie pojawi się w wynikach kwerendy z tej tabeli do momentu po <xref:System.Data.Linq.DataContext.SubmitChanges%2A> została wywołana.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.Table#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.table/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.Table#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.table/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Table`1.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Data.Linq.Table&lt;'Entity (requires 'Entity : null)&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.Linq.ITable.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy typ jednostek zawarty w tym <see cref="T:System.Data.Linq.Table`1" /> wystąpienia ma klucz podstawowy.</summary>
        <value>
          <see langword="true" /> Jeśli typ jednostki nie ma klucza podstawowego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;TEntity&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;TEntity&gt; IEnumerable&lt;TEntity&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!TEntity&gt; System.Collections.Generic.IEnumerable&lt;TEntity&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Collections#Generic#IEnumerable&lt;TEntity&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of TEntity) Implements IEnumerable(Of TEntity).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;TEntity&gt; ^ System.Collections.Generic.IEnumerable&lt;TEntity&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;TEntity&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>Moduł wyliczający, który może służyć do iterowania po kolekcji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>Moduł wyliczający, który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Collections.Generic.IEnumerable%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Table`1.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kolekcja jest kolekcją <see cref="T:System.Collections.IList" /> obiektów.</summary>
        <value>
          <see langword="true" /> Jeśli kolekcja jest kolekcją <see cref="T:System.Collections.IList" /> obiekty; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.ComponentModel.IListSource> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IList" /> , może być powiązana ze źródłem danych z obiektu, który nie implementuje <see cref="T:System.Collections.IList" /> sam.</summary>
        <returns>
          <see cref="T:System.Collections.IList" /> Może być powiązana ze źródłem danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.ComponentModel.IListSource> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="System.Data.Linq.ITable.Attach">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Umożliwia zdeserializowany jednostek, które ma zostać skojarzony z nowe wystąpienie klasy <see cref="T:System.Data.Linq.DataContext" /> tak, aby mogą zostać zaktualizowane lub usunięte z bazy danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="System.Data.Linq.ITable.Attach">
      <MemberSignature Language="C#" Value="void ITable.Attach (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.Attach(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#Attach(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Attach (entity As Object) Implements ITable.Attach" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.Attach(System::Object ^ entity) = System::Data::Linq::ITable::Attach;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.Attach(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka do podłączenia.</param>
        <summary>Dołącza jednostkę, aby <see cref="T:System.Data.Linq.DataContext" /> w stanie zostały zmodyfikowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Data.Linq.ITable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.Attach">
      <MemberSignature Language="C#" Value="void ITable.Attach (object entity, bool asModified);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.Attach(object entity, bool asModified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#Attach(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub Attach (entity As Object, asModified As Boolean) Implements ITable.Attach" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.Attach(System::Object ^ entity, bool asModified) = System::Data::Linq::ITable::Attach;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.Attach(System.Object,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="asModified" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka do podłączenia.</param>
        <param name="asModified">
          <see langword="true" /> Aby dołączyć jednostkę ze zmianami; <see langword="false" /> dołączony jednostki jako niezmodyfikowany.</param>
        <summary>Dołącza wszystkie jednostki w kolekcji do <see cref="T:System.Data.Linq.DataContext" /> w stanie zmodyfikowany lub zostały zmodyfikowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Data.Linq.ITable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.Attach">
      <MemberSignature Language="C#" Value="void ITable.Attach (object entity, object original);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.Attach(object entity, object original) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#Attach(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Attach (entity As Object, original As Object) Implements ITable.Attach" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.Attach(System::Object ^ entity, System::Object ^ original) = System::Data::Linq::ITable::Attach;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.Attach(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="original" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka do podłączenia.</param>
        <param name="original">Wystąpienie typu jednostki z elementów członkowskich danych, które zawierają oryginalnych wartości.</param>
        <summary>Dołącza jednostkę, aby <see cref="T:System.Data.Linq.DataContext" /> w dowolnym stanie zmodyfikowany lub zostały zmodyfikowane przez określenie jednostki i stanu pierwotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Data.Linq.ITable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="System.Data.Linq.ITable.AttachAll">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza wszystkie jednostki w kolekcji do <see cref="T:System.Data.Linq.DataContext" /> w stanie zmodyfikowany lub zostały zmodyfikowane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="System.Data.Linq.ITable.AttachAll">
      <MemberSignature Language="C#" Value="void ITable.AttachAll (System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.AttachAll(class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#AttachAll(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Sub AttachAll (entities As IEnumerable) Implements ITable.AttachAll" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.AttachAll(System::Collections::IEnumerable ^ entities) = System::Data::Linq::ITable::AttachAll;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.AttachAll(System.Collections.IEnumerable)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="entities">Kolekcja jednostek do podłączenia.</param>
        <summary>Dołącza wszystkie jednostki w kolekcji do <see cref="T:System.Data.Linq.DataContext" /> w stanie zmodyfikowany lub zostały zmodyfikowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Data.Linq.ITable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.AttachAll">
      <MemberSignature Language="C#" Value="void ITable.AttachAll (System.Collections.IEnumerable entities, bool asModified);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.AttachAll(class System.Collections.IEnumerable entities, bool asModified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#AttachAll(System.Collections.IEnumerable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Sub AttachAll (entities As IEnumerable, asModified As Boolean) Implements ITable.AttachAll" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.AttachAll(System::Collections::IEnumerable ^ entities, bool asModified) = System::Data::Linq::ITable::AttachAll;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.AttachAll(System.Collections.IEnumerable,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
        <Parameter Name="asModified" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="entities">Kolekcja jednostek jako podłączonym.</param>
        <param name="asModified">
          <see langword="true" /> Aby dołączyć jednostek ze zmianami; <see langword="false" /> do dołączania jednostek jako niezmodyfikowany.</param>
        <summary>Dołącza wszystkie jednostki w kolekcji do <see cref="T:System.Data.Linq.DataContext" /> w stanie zmodyfikowany lub zostały zmodyfikowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Data.Linq.ITable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.DeleteAllOnSubmit">
      <MemberSignature Language="C#" Value="void ITable.DeleteAllOnSubmit (System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.DeleteAllOnSubmit(class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#DeleteAllOnSubmit(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Sub DeleteAllOnSubmit (entities As IEnumerable) Implements ITable.DeleteAllOnSubmit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.DeleteAllOnSubmit(System::Collections::IEnumerable ^ entities) = System::Data::Linq::ITable::DeleteAllOnSubmit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.DeleteAllOnSubmit(System.Collections.IEnumerable)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="entities">Jednostki, usuwany.</param>
        <summary>Umieszcza wszystkie jednostki z kolekcji do <see langword="pending delete" /> stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Data.Linq.ITable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.DeleteOnSubmit">
      <MemberSignature Language="C#" Value="void ITable.DeleteOnSubmit (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.DeleteOnSubmit(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#DeleteOnSubmit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub DeleteOnSubmit (entity As Object) Implements ITable.DeleteOnSubmit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.DeleteOnSubmit(System::Object ^ entity) = System::Data::Linq::ITable::DeleteOnSubmit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.DeleteOnSubmit(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka, która ma zostać usunięty.</param>
        <summary>Umieszcza jednostki z tej tabeli do <see langword="pending delete" /> stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Data.Linq.ITable> interfejsu.  
  
> [!NOTE]
>  [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] nie obsługuje ani nie rozpoznają operations usuwanie kaskadowe. Jeśli chcesz usunąć wiersz w tabeli, która ma ograniczenia względem jego, musisz któryś zbiór `ON DELETE CASCADE` reguły ograniczenie klucza obcego w bazie danych lub Użyj własnego kodu, aby najpierw usunąć obiekty podrzędne, które uniemożliwiają usunięcie obiektu nadrzędnego. W przeciwnym razie jest zgłaszany wyjątek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.GetModifiedMembers">
      <MemberSignature Language="C#" Value="System.Data.Linq.ModifiedMemberInfo[] ITable.GetModifiedMembers (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Data.Linq.ModifiedMemberInfo[] System.Data.Linq.ITable.GetModifiedMembers(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#GetModifiedMembers(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function GetModifiedMembers (entity As Object) As ModifiedMemberInfo() Implements ITable.GetModifiedMembers" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Data::Linq::ModifiedMemberInfo&gt; ^ System.Data.Linq.ITable.GetModifiedMembers(System::Object ^ entity) = System::Data::Linq::ITable::GetModifiedMembers;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.GetModifiedMembers(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("NOT IMPLEMENTED YET")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ModifiedMemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostki, z którego można uzyskać zmodyfikowane elementy członkowskie.</param>
        <summary>Zwraca tablicę zmodyfikowane elementy członkowskie, które zawierają swoje bieżące i oryginalne wartości.</summary>
        <returns>Tablica elementów członkowskich zmodyfikowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Data.Linq.ITable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.GetOriginalEntityState">
      <MemberSignature Language="C#" Value="object ITable.GetOriginalEntityState (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Data.Linq.ITable.GetOriginalEntityState(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#GetOriginalEntityState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function GetOriginalEntityState (entity As Object) As Object Implements ITable.GetOriginalEntityState" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.Data.Linq.ITable.GetOriginalEntityState(System::Object ^ entity) = System::Data::Linq::ITable::GetOriginalEntityState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.GetOriginalEntityState(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("NOT IMPLEMENTED YET")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka, w których oryginalny stan ma być dostępny.</param>
        <summary>Pobiera oryginalnych wartości danej jednostki.</summary>
        <returns>Kopia oryginalna jednostka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Data.Linq.ITable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.InsertAllOnSubmit">
      <MemberSignature Language="C#" Value="void ITable.InsertAllOnSubmit (System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.InsertAllOnSubmit(class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#InsertAllOnSubmit(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Sub InsertAllOnSubmit (entities As IEnumerable) Implements ITable.InsertAllOnSubmit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.InsertAllOnSubmit(System::Collections::IEnumerable ^ entities) = System::Data::Linq::ITable::InsertAllOnSubmit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.InsertAllOnSubmit(System.Collections.IEnumerable)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="entities">Kolekcja jednostek, które mają zostać dodane.</param>
        <summary>Dodaje wszystkie jednostki w kolekcji do <see cref="T:System.Data.Linq.DataContext" /> w <see langword="pending insert" /> stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Data.Linq.ITable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Linq.ITable.InsertOnSubmit">
      <MemberSignature Language="C#" Value="void ITable.InsertOnSubmit (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Data.Linq.ITable.InsertOnSubmit(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Data#Linq#ITable#InsertOnSubmit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub InsertOnSubmit (entity As Object) Implements ITable.InsertOnSubmit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Data.Linq.ITable.InsertOnSubmit(System::Object ^ entity) = System::Data::Linq::ITable::InsertOnSubmit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.Linq.ITable.InsertOnSubmit(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka do dodania.</param>
        <summary>Dodaje jednostki w usłudze <see langword="pending insert" /> stanu do tej tabeli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Data.Linq.ITable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryable.ElementType">
      <MemberSignature Language="C#" Value="Type System.Linq.IQueryable.ElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type System.Linq.IQueryable.ElementType" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Table`1.System#Linq#IQueryable#ElementType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ElementType As Type Implements IQueryable.ElementType" />
      <MemberSignature Language="C++ CLI" Value="property Type ^ System::Linq::IQueryable::ElementType { Type ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Linq.IQueryable.ElementType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ elementów, które są zwracane, gdy jest wykonywana drzewa wyrażeń skojarzone z tym obiektem.</summary>
        <value>Typ elementów, które są zwracane, gdy jest wykonywana drzewa wyrażeń skojarzone z tym obiektem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Linq.IQueryable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryable.Expression">
      <MemberSignature Language="C#" Value="System.Linq.Expressions.Expression System.Linq.IQueryable.Expression { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.Expressions.Expression System.Linq.IQueryable.Expression" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Table`1.System#Linq#IQueryable#Expression" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Expression As Expression Implements IQueryable.Expression" />
      <MemberSignature Language="C++ CLI" Value="property System::Linq::Expressions::Expression ^ System::Linq::IQueryable::Expression { System::Linq::Expressions::Expression ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Linq.IQueryable.Expression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera drzewa wyrażeń, który jest skojarzony z tym wystąpieniem <see cref="T:System.Linq.IQueryable" />.</summary>
        <value>
          <see cref="T:System.Linq.Expressions.Expression" /> Skojarzony z tym wystąpieniem <see cref="T:System.Linq.IQueryable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Linq.IQueryable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryable.Provider">
      <MemberSignature Language="C#" Value="System.Linq.IQueryProvider System.Linq.IQueryable.Provider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.IQueryProvider System.Linq.IQueryable.Provider" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.Table`1.System#Linq#IQueryable#Provider" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Provider As IQueryProvider Implements IQueryable.Provider" />
      <MemberSignature Language="C++ CLI" Value="property System::Linq::IQueryProvider ^ System::Linq::IQueryable::Provider { System::Linq::IQueryProvider ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Linq.IQueryable.Provider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dostawcę zapytań, który jest skojarzony z tym źródłem danych.</summary>
        <value>
          <see cref="T:System.Linq.IQueryProvider" /> Skojarzony z tym źródłem danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Linq.IQueryable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryProvider.CreateQuery">
      <MemberSignature Language="C#" Value="System.Linq.IQueryable IQueryProvider.CreateQuery (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Linq.IQueryable System.Linq.IQueryProvider.CreateQuery(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Linq#IQueryProvider#CreateQuery(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Linq::IQueryable ^ System.Linq.IQueryProvider.CreateQuery(System::Linq::Expressions::Expression ^ expression) = System::Linq::IQueryProvider::CreateQuery;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Wyrażenie zapytania, z którego jest wykonywane obliczenia.</param>
        <summary>Konstruuje <see cref="T:System.Linq.IQueryable" /> obiekt, który może służyć do oceny zapytanie, reprezentowane przez określone wyrażenie drzewa.</summary>
        <returns>
          <see cref="T:System.Linq.IQueryable" /> , Ocenić zapytanie, reprezentowane przez określone wyrażenie drzewa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Linq.IQueryProvider> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryProvider.CreateQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="System.Linq.IQueryable&lt;TResult&gt; IQueryProvider.CreateQuery&lt;TResult&gt; (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Linq.IQueryable`1&lt;!!TResult&gt; System.Linq.IQueryProvider.CreateQuery&lt;TResult&gt;(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Linq#IQueryProvider#CreateQuery``1(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA; virtual System::Linq::IQueryable&lt;TResult&gt; ^ System.Linq.IQueryProvider.CreateQuery(System::Linq::Expressions::Expression ^ expression) = System::Linq::IQueryProvider::CreateQuery;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ danych w tabeli.</typeparam>
        <param name="expression">Wyrażenie zapytania, z którego jest wykonywane obliczenia.</param>
        <summary>Konstruuje <see cref="T:System.Linq.IQueryable`1" /> obiekt, który może służyć do oceny zapytanie, reprezentowane przez określone wyrażenie drzewa.</summary>
        <returns>
          <see cref="T:System.Linq.IQueryable`1" /> , Ocenić zapytanie, reprezentowane przez określone wyrażenie drzewa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Linq.IQueryProvider> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryProvider.Execute">
      <MemberSignature Language="C#" Value="object IQueryProvider.Execute (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Linq.IQueryProvider.Execute(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Linq#IQueryProvider#Execute(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.Linq.IQueryProvider.Execute(System::Linq::Expressions::Expression ^ expression) = System::Linq::IQueryProvider::Execute;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">Wyrażenie kwerendy do wykonania.</param>
        <summary>Wykonuje zapytanie, reprezentowane przez określone wyrażenie drzewa.</summary>
        <returns>Wartość będącą wynikiem wykonania określonego zapytania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Linq.IQueryProvider> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryProvider.Execute&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="TResult IQueryProvider.Execute&lt;TResult&gt; (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance !!TResult System.Linq.IQueryProvider.Execute&lt;TResult&gt;(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.System#Linq#IQueryProvider#Execute``1(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA; virtual TResult System.Linq.IQueryProvider.Execute(System::Linq::Expressions::Expression ^ expression) = System::Linq::IQueryProvider::Execute;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ danych w tabeli.</typeparam>
        <param name="expression">Wyrażenie kwerendy do wykonania.</param>
        <summary>Wykonuje zapytanie silnie typizowane reprezentowanego przez określone wyrażenie drzewa.</summary>
        <returns>Wartość będącą wynikiem wykonania określonego zapytania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.Linq.Table%601> wystąpienia jest rzutowany na <xref:System.Linq.IQueryProvider> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.Table`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="table.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg reprezentujący tabelę.</summary>
        <returns>Ciąg reprezentujący tabelę.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
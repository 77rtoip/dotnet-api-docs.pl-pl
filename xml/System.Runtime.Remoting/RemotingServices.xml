<Type Name="RemotingServices" FullName="System.Runtime.Remoting.RemotingServices">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0ab0ab2dd346b1b257cb338da76789e5122a361e" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69060436" /></Metadata><TypeSignature Language="C#" Value="public static class RemotingServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed RemotingServices extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingServices" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingServices" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingServices = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Program udostępnia kilka metod używania i publikowania zdalnych obiektów i serwerów proxy. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie jesteś dostawcą usług zajmującym się problemami, takimi jak aktywacja, zarządzanie okresem istnienia lub transakcjami, nie musisz odróżnić między odwołaniami serwera proxy i odwołaniami do obiektów. Infrastruktura zdalna używa przezroczystych serwerów proxy, które dają wrażenie, że obiekty zdalne znajdują się w obszarze klienta. Serwery proxy osiągają ten sposób przez przekazywanie wywołań do rzeczywistych obiektów w lokalizacjach zdalnych.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy serwer proxy dla dobrze znanego obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classToProxy">Jest <see cref="T:System.Type" /> to dobrze znany obiekt na końcu serwera, z którym chcesz się połączyć.</param>
        <param name="url">Adres URL klasy serwera.</param>
        <summary>Tworzy serwer proxy dla dobrze znanego obiektu, pod <see cref="T:System.Type" /> adresem URL i.</summary>
        <returns>Serwer proxy do zdalnego obiektu, który wskazuje punkt końcowy obsługiwany przez określony dobrze znany obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony obiekt serwera proxy wskazuje punkt końcowy obsługiwany przez określony dobrze znany obiekt. Żadne komunikaty nie są wysyłane przez sieć do momentu wywołania metody na serwerze proxy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Runtime.Remoting.RemotingServices.Connect%2A> jak używać metody do tworzenia serwera proxy dla dobrze znanego obiektu.  
  
 [!code-cpp[RemotingServices.BasicSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/basicclient.cpp#1)]
 [!code-csharp[RemotingServices.BasicSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/basicclient.cs#1)]
 [!code-vb[RemotingServices.BasicSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/basicclient.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do konfigurowania typów i kanałów komunikacji zdalnej.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Konfiguracja infrastruktury zdalnej. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String, data As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string * obj -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="classToProxy"><see cref="T:System.Type" /> Z dobrze znanego obiektu, z którym chcesz się połączyć.</param>
        <param name="url">Adres URL dobrze znanego obiektu.</param>
        <param name="data">Dane specyficzne dla kanału. Może być <see langword="null" />.</param>
        <summary>Tworzy serwer proxy dla dobrze znanego obiektu, z <see cref="T:System.Type" />uwzględnieniem adresu URL i danych specyficznych dla kanału.</summary>
        <returns>Serwer proxy, który wskazuje punkt końcowy, który jest obsługiwany przez żądany dobrze znany obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony obiekt serwera proxy wskazuje punkt końcowy obsługiwany przez określony dobrze znany obiekt. Żadne komunikaty nie są wysyłane przez sieć do momentu wywołania metody na serwerze proxy.  
  
 Obiekt jest używany do przekazywania informacji do kanału i jest przekazywany <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> do metody. `data`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do konfigurowania typów i kanałów komunikacji zdalnej.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Konfiguracja infrastruktury zdalnej. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public static bool Disconnect (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Disconnect(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Disconnect (obj As MarshalByRefObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Disconnect(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member Disconnect : MarshalByRefObject -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.Disconnect obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do odłączenia od jego kanału.</param>
        <summary>Uniemożliwia obiektowi otrzymywanie dalszych komunikatów za pośrednictwem zarejestrowanych kanałów komunikacji zdalnej.</summary>
        <returns><see langword="true" />Jeśli obiekt został odłączony od pomyślnie zarejestrowanego kanału usług zdalnych; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> jak za pomocą metody rozłączyć obiekt z kanałów zdalnych.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="obj" /> Parametr jest serwerem proxy.</exception>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do konfigurowania typów i kanałów komunikacji zdalnej.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Konfiguracja infrastruktury zdalnej. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMessage">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(class System.MarshalByRefObject target, class System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExecuteMessage (target As MarshalByRefObject, reqMsg As IMethodCallMessage) As IMethodReturnMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMethodReturnMessage ^ ExecuteMessage(MarshalByRefObject ^ target, System::Runtime::Remoting::Messaging::IMethodCallMessage ^ reqMsg);" />
      <MemberSignature Language="F#" Value="static member ExecuteMessage : MarshalByRefObject * System.Runtime.Remoting.Messaging.IMethodCallMessage -&gt; System.Runtime.Remoting.Messaging.IMethodReturnMessage" Usage="System.Runtime.Remoting.RemotingServices.ExecuteMessage (target, reqMsg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMethodReturnMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.MarshalByRefObject" />
        <Parameter Name="reqMsg" Type="System.Runtime.Remoting.Messaging.IMethodCallMessage" />
      </Parameters>
      <Docs>
        <param name="target">Obiekt zdalny, którego Metoda ma zostać wywołana.</param>
        <param name="reqMsg">Komunikat wywołania metody do określonej metody obiektu zdalnego.</param>
        <summary>Nawiązuje połączenie z określonym obiektem zdalnym i wykonuje podane <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" /> na nim.</summary>
        <returns>Odpowiedź metody zdalnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżąca metoda jest używana w specjalnych przypadkach przez serwer do przesyłania dalej określonego wywołania metody do innego, prawdopodobnie zdalnego, obiektu. Tę metodę można wywołać tylko wtedy, gdy obiekt wywołujący znajduje się w odpowiednim kontekście.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> metody do przesyłania dalej wywołań metod do obiektów zdalnych.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do infrastruktury.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Metoda została wywołana z kontekstu innego niż natywny kontekst obiektu.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvoyChainForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvoyChainForProxy (obj As MarshalByRefObject) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMessageSink ^ GetEnvoyChainForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetEnvoyChainForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Serwer proxy zdalnego obiektu, który zażądał ujścia wysłannika, jest skojarzony z.</param>
        <summary>Zwraca łańcuch obiektów ujścia wysłannika, które powinny być używane podczas wysyłania komunikatów do obiektu zdalnego reprezentowanego przez określony serwer proxy.</summary>
        <returns>Łańcuch obiektów ujścia wysłannika skojarzonych z określonym serwerem proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ujścia wysłannika to ujścia wysyłane wraz <xref:System.Runtime.Remoting.ObjRef> z obiektem, który jest używany podczas zwracania komunikatów do tego obiektu. Bieżąca metoda zwraca ujścia wysłannika, które są używane podczas komunikacji między serwerem proxy obiektu a samym obiektem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.IEnvoyInfo" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public static object GetLifetimeService (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLifetimeService(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLifetimeService (obj As MarshalByRefObject) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLifetimeService(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetLifetimeService : MarshalByRefObject -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.GetLifetimeService obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, dla którego ma zostać uzyskana usługa okresu istnienia.</param>
        <summary>Zwraca obiekt usługi okresu istnienia, który kontroluje zasady okresu istnienia określonego obiektu.</summary>
        <returns>Obiekt, który kontroluje okres istnienia <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku domyślnej usługi okresu istnienia zwracany obiekt będzie obiektem typu <xref:System.Runtime.Remoting.Lifetime.ILease>. Jeśli parametr ma `null`wartość, metoda zwraca `null`. `obj`  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> metody w celu uzyskania dzierżawy okresu istnienia dla określonego obiektu.  
  
 [!code-cpp[RemotingServices.TimerSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.TimerSample/CPP/timerclient.cpp#1)]
 [!code-csharp[RemotingServices.TimerSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerclient.cs#1)]
 [!code-vb[RemotingServices.TimerSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerclient.vb#1)]  
  
 Aby skompilować i uruchomić ten przykład, należy skompilować i uruchomić serwer, timerserver. exe i skompilować udostępnioną bibliotekę, timerservice. dll.  
  
 Źródło dla programu timerserver. exe jest następujące:  
  
 [!code-csharp[RemotingServices.TimerSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerserver.cs#2)]
 [!code-vb[RemotingServices.TimerSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerserver.vb#2)]  
  
 Źródło dla timerservice. dll jest następujące:  
  
 [!code-csharp[RemotingServices.TimerSample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerservice.cs#3)]
 [!code-vb[RemotingServices.TimerSample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerservice.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBaseFromMethodMessage">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodBaseFromMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodBaseFromMethodMessage (msg As IMethodMessage) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodBaseFromMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetMethodBaseFromMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; System.Reflection.MethodBase" Usage="System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Komunikat metody, z którego ma zostać wyodrębniona Baza metod.</param>
        <summary>Zwraca bazę metody z danego <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />elementu.</summary>
        <returns>Podstawowa metoda wyodrębniona z <paramref name="msg" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określa to podstawę metody z <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>właściwości <xref:System.Runtime.Remoting.Messaging.IMethodMessage> , <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>i <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> i jest używana przez klasy implementujące <xref:System.Runtime.Remoting.Messaging.IMethodMessage> interfejs. Odbiorcy klas powinny odwoływać się <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> do właściwości. <xref:System.Runtime.Remoting.Messaging.IMethodMessage>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do infrastruktury lub co najmniej jeden z obiektów wywołujących wyższych w stosu wywołań nie ma uprawnień do pobierania informacji o typie niepublicznych składowych.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetObjectData(object obj, class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetObjectData (obj As Object, info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetObjectData(System::Object ^ obj, System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="static member GetObjectData : obj * System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.GetObjectData (obj, info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do serializacji.</param>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> Do którego jest serializowany obiekt.</param>
        <param name="context">Źródło i miejsce docelowe serializacji.</param>
        <summary>Serializacja określonego obiektu Marshal przez odwołanie do podanego <see cref="T:System.Runtime.Serialization.SerializationInfo" />typu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Parametr <paramref name="obj" /> lub <paramref name="info" /> jest .<see langword="null" /></exception>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectUri">
      <MemberSignature Language="C#" Value="public static string GetObjectUri (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetObjectUri(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectUri (obj As MarshalByRefObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetObjectUri(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectUri : MarshalByRefObject -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetObjectUri obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.MarshalByRefObject" /> Dla którego żądany jest identyfikator URI.</param>
        <summary>Pobiera identyfikator URI dla określonego obiektu.</summary>
        <returns>Identyfikator URI określonego obiektu, jeśli ma taki obiekt, lub <see langword="null" /> Jeśli obiekt nie został jeszcze zorganizowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#18)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#18)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjRefForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef GetObjRefForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjRefForProxy (obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ GetObjRefForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjRefForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.GetObjRefForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Serwer proxy połączony z obiektem, <see cref="T:System.Runtime.Remoting.ObjRef" /> dla którego chcesz utworzyć.</param>
        <summary><see cref="T:System.Runtime.Remoting.ObjRef" /> Zwraca wartość reprezentującą obiekt zdalny z określonego serwera proxy.</summary>
        <returns>Reprezentuje obiekt zdalny, do którego jest podłączony określony serwer proxy, lub <see langword="null" /> Jeśli obiekt lub serwer proxy nie został zorganizowany. <see cref="T:System.Runtime.Remoting.ObjRef" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Runtime.Remoting.ObjRef> to możliwy do serializacji reprezentacja obiektu służącego do transferowania odwołania do obiektu między granicami domeny aplikacji. <xref:System.Runtime.Remoting.ObjRef> Tworzenie dla obiektu jest znane jako kierowanie. <xref:System.Runtime.Remoting.ObjRef> Można go przenieść za pośrednictwem kanału do innej domeny aplikacji (prawdopodobnie na innym procesie lub komputerze). Raz w innej domenie <xref:System.Runtime.Remoting.ObjRef> aplikacji należy przeanalizować, aby utworzyć serwer proxy dla obiektu, na ogół połączony z obiektem rzeczywistym. Ta operacja jest znana jako anulowania organizowania. Podczas anulowania organizowania, <xref:System.Runtime.Remoting.ObjRef> jest analizowane, aby wyodrębnić informacje o metodzie obiektu zdalnego, a następnie utworzyć przezroczysty serwer proxy i <xref:System.Runtime.Remoting.Proxies.RealProxy> obiekty.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje <xref:System.Type> opisujące klasę i klasy organizowanego obiektu, identyfikator URI, który jednoznacznie identyfikuje konkretne wystąpienie obiektu i informacje dotyczące komunikacji dotyczące sposobu dotarcia do aplikacji zdalnej, gdzie Obiekt znajduje się.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Runtime.Remoting.ObjRef> jak uzyskać wystąpienie dla określonego obiektu.  
  
 [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CPP/client.cpp#1)]
 [!code-csharp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CS/client.cs#1)]
 [!code-vb[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRealProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRealProxy (proxy As Object) As RealProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Proxies::RealProxy ^ GetRealProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member GetRealProxy : obj -&gt; System.Runtime.Remoting.Proxies.RealProxy" Usage="System.Runtime.Remoting.RemotingServices.GetRealProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Proxies.RealProxy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Przezroczysty serwer proxy.</param>
        <summary>Zwraca rzeczywisty serwer proxy, który wykonuje kopię zapasową określonego przezroczystego serwera proxy.</summary>
        <returns>Prawdziwe wystąpienie serwera proxy wykonuje kopię zapasową przezroczystego serwera proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klient korzystający z obiektu w każdym rodzaju granicy usług zdalnych używa niejawnego serwera proxy dla obiektu. Przezroczysty serwer proxy daje wrażenie, że rzeczywisty obiekt znajduje się w obszarze klienta. Jest to osiągane przez przekazywanie wywołań do rzeczywistego obiektu za pomocą infrastruktury zdalnej.  
  
 Przezroczysty serwer proxy jest obsługiwany przez wystąpienie klasy zarządzanego środowiska uruchomieniowego typu <xref:System.Runtime.Remoting.Proxies.RealProxy>. <xref:System.Runtime.Remoting.Proxies.RealProxy> Implementuje część funkcji wymaganych do przesyłania dalej operacji z przezroczystego serwera proxy.  
  
 Obiekt serwera proxy dziedziczy skojarzoną semantykę zarządzanych obiektów, takich jak wyrzucanie elementów bezużytecznych, obsługę elementów członkowskich i metod, i można ją rozszerzyć w celu utworzenia nowych klas. Serwer proxy działa jako obiekt tej samej klasy, co obiekt zdalny (przezroczysty serwer proxy), a także jest obiektem zarządzanym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetServerTypeForUri">
      <MemberSignature Language="C#" Value="public static Type GetServerTypeForUri (string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetServerTypeForUri(string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetServerTypeForUri (URI As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetServerTypeForUri(System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member GetServerTypeForUri : string -&gt; Type" Usage="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri URI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="URI">Identyfikator URI obiektu, którego <see cref="T:System.Type" /> żądano.</param>
        <summary><see cref="T:System.Type" /> Zwraca obiekt o określonym identyfikatorze URI.</summary>
        <returns><see cref="T:System.Type" /> Obiekt z określonym identyfikatorem URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ usługi zdalne identyfikują punkty końcowe przy użyciu <xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> identyfikatorów URI, metoda jest bardzo przydatna w podłączanych częściach infrastruktury zdalnej (na przykład ujścia kanałów, dynamiczne ujścia i ujścia kontekstu), które używają <xref:System.Runtime.Remoting.Messaging.IMessage> obiektów, ponieważ bieżące Metoda zwróci obiekt skojarzonego typu z identyfikatora URI.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#7)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#7)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do infrastruktury lub co najmniej jeden z obiektów wywołujących wyższych w stosu wywołań nie ma uprawnień do pobierania informacji o typie niepublicznych składowych.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby pobrać informacje o typie niepublicznych elementów członkowskich. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetSessionIdForMethodMessage">
      <MemberSignature Language="C#" Value="public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetSessionIdForMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSessionIdForMethodMessage (msg As IMethodMessage) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetSessionIdForMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetSessionIdForMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg"><see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> Dla którego zażądano identyfikatora sesji.</param>
        <summary>Pobiera identyfikator sesji dla wiadomości.</summary>
        <returns>Ciąg identyfikatora sesji, który jednoznacznie identyfikuje bieżącą sesję.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten sam identyfikator sesji może zostać zwrócony dla obiektów w tej samej aplikacji, ale ta metoda nigdy nie zwróci tego samego identyfikatora sesji dla dwóch obiektów w różnych aplikacjach zdalnych.  
  
 Aby uzyskać więcej informacji na temat identyfikowania sesji i identyfikatorów sesji, zobacz ASP.Net [ASP.NET Session State Overview](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak uzyskać ciąg identyfikatora sesji dla bieżącej sesji.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsMethodOverloaded">
      <MemberSignature Language="C#" Value="public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMethodOverloaded(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMethodOverloaded (msg As IMethodMessage) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMethodOverloaded(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member IsMethodOverloaded : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsMethodOverloaded msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Komunikat, który zawiera wywołanie metody.</param>
        <summary>Zwraca wartość logiczną wskazującą, czy metoda w danej wiadomości jest przeciążona.</summary>
        <returns><see langword="true" />Jeśli metoda wywołana w <paramref name="msg" /> jest przeciążona; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfAppDomain">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfAppDomain (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfAppDomain(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfAppDomain (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfAppDomain(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfAppDomain : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Obiekt do sprawdzenia.</param>
        <summary>Zwraca wartość logiczną wskazującą, czy obiekt określony przez dany przezroczysty serwer proxy jest zawarty w innej domenie aplikacji niż obiekt, który wywołał bieżącą metodę.</summary>
        <returns><see langword="true" />Jeśli obiekt jest poza bieżącą domeną aplikacji; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje o domenach aplikacji, zobacz [domeny aplikacji](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)).  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Domeny aplikacji</related>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfContext">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfContext (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfContext(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfContext (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfContext(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfContext : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Obiekt do sprawdzenia.</param>
        <summary>Zwraca wartość logiczną wskazującą, czy obiekt reprezentowany przez dany serwer proxy jest zawarty w innym kontekście niż obiekt, który wywołał bieżącą metodę.</summary>
        <returns><see langword="true" />Jeśli obiekt znajduje się poza bieżącym kontekstem; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontekst jest uporządkowaną sekwencją właściwości, które definiują środowisko dla obiektów znajdujących się wewnątrz. Konteksty są tworzone podczas procesu aktywacji dla obiektów, które są skonfigurowane tak, aby wymagały pewnych usług automatycznych, takich jak synchronizacja, transakcje, aktywacja just in Time, zabezpieczenia i tak dalej. Wiele obiektów może się znajdować w kontekście.  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Contexts.Context" />
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public static bool IsOneWay (System.Reflection.MethodBase method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOneWay(class System.Reflection.MethodBase method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOneWay (method As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOneWay(System::Reflection::MethodBase ^ method);" />
      <MemberSignature Language="F#" Value="static member IsOneWay : System.Reflection.MethodBase -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsOneWay method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="method">Dana metoda.</param>
        <summary>Zwraca wartość logiczną wskazującą, czy klient, który wezwał metodę określoną w podanej wiadomości, czeka na zakończenie przetwarzania metody przez serwer przed kontynuowaniem wykonywania.</summary>
        <returns><see langword="true" />Jeśli metoda jest jednym ze sposobów; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wywoływana jest metoda jednokierunkowa, klient nie czeka na zakończenie przetwarzania komunikatu przez serwer. Metoda klienta wraca do aplikacji bez znajomości tego, czy serwer pomyślnie przetworzy komunikat. Metody są oznaczane jako jednokierunkowe przy użyciu <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.  
  
 Metody jednokierunkowe nie mogą mieć wartości zwracanej ani żadnych parametrów out.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#2)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#2)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredni obiekt wywołujący nie ma uprawnień do infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsTransparentProxy">
      <MemberSignature Language="C#" Value="public static bool IsTransparentProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTransparentProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTransparentProxy (proxy As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTransparentProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member IsTransparentProxy : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsTransparentProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Odwołanie do obiektu do sprawdzenia.</param>
        <summary>Zwraca wartość logiczną wskazującą, czy dany obiekt jest przezroczystym serwerem proxy czy obiektem rzeczywistym.</summary>
        <returns>Wartość logiczna wskazująca, czy obiekt określony w <paramref name="proxy" /> parametrze jest przezroczystym serwerem proxy lub obiektem rzeczywistym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klient, który używa obiektu w każdym rodzaju granicy komunikacji zdalnej, w rzeczywistości używa przezroczystego serwera proxy dla obiektu. Przezroczysty serwer proxy daje wrażenie, że rzeczywisty obiekt znajduje się w obszarze klienta. Jest to osiągane przez przekazywanie wywołań do rzeczywistego obiektu za pomocą infrastruktury zdalnej.  
  
 Przezroczysty serwer proxy jest używany przez wystąpienie klasy zarządzanego środowiska uruchomieniowego typu <xref:System.Runtime.Remoting.Proxies.RealProxy>. <xref:System.Runtime.Remoting.Proxies.RealProxy> Implementuje część funkcji wymaganych do przesyłania dalej operacji z przezroczystego serwera proxy. Obiekt serwera proxy dziedziczy skojarzoną semantykę zarządzanych obiektów, takich jak wyrzucanie elementów bezużytecznych, obsługę elementów członkowskich i metod, i można ją rozszerzyć w celu utworzenia nowych klas. W ten sposób serwer proxy ma podwójny charakter; na jednym z nich musi działać jako obiekt tej samej klasy, co obiekt zdalny (przezroczysty serwer proxy), a na drugim jest obiektem zarządzanym.  
  
 Obiekt serwera proxy może być używany bez względu na jakiekolwiek podpodziały usług zdalnych w <xref:System.AppDomain>ramach. Aplikacje nie muszą rozróżniać odwołań serwera proxy i odwołań do obiektów. Jednak dostawcy usług zajmujący się problemami, takimi jak aktywacja, zarządzanie okresem istnienia i transakcjami, muszą wprowadzić takie różnice.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> metody, aby określić, czy obiekt jest serwerem proxy czy obiektem rzeczywistym. Aby uzyskać kompletny przykładowy kod, zobacz przykład dla <xref:System.Runtime.Remoting.Messaging.AsyncResult> klasy.  
  
 [!code-cpp[AsyncResult.NewExamples#6](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncResult.NewExamples/CPP/ad.cpp#6)]
 [!code-csharp[AsyncResult.NewExamples#6](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncResult.NewExamples/CS/ad.cs#6)]
 [!code-vb[AsyncResult.NewExamples#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncResult.NewExamples/VB/ad.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="LogRemotingStage">
      <MemberSignature Language="C#" Value="public static void LogRemotingStage (int stage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogRemotingStage(int32 stage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogRemotingStage (stage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LogRemotingStage(int stage);" />
      <MemberSignature Language="F#" Value="static member LogRemotingStage : int -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.LogRemotingStage stage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("REMOTING_PERF")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("It existed for only internal use in .NET and unimplemented in mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use of this method is not recommended. The LogRemotingStage existed for internal diagnostic purposes only.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stage">Wewnętrznie zdefiniowana stała, która identyfikuje etap w wymianie zdalnej.</param>
        <summary>Rejestruje etap w wymianie zdalnej na zewnętrzny debuger.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Symbol przetwarzania wstępnego jest stosowany do metody przy <xref:System.Diagnostics.ConditionalAttribute> użyciu atrybutu. `"REMOTING_PERF"`  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Konfiguracja infrastruktury zdalnej. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Marshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje daną <see cref="T:System.MarshalByRefObject" /> wartość na wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy, która może być serializowana do transmisji między domenami aplikacji a siecią.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal Obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="Obj">Obiekt do przekonwertowania.</param>
        <summary>Przyjmuje, rejestruje ją z infrastrukturą zdalną i konwertuje ją na wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy. <see cref="T:System.MarshalByRefObject" /></summary>
        <returns>Wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy, która reprezentuje obiekt określony <paramref name="Obj" /> w parametrze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Runtime.Remoting.ObjRef> to możliwy do serializacji reprezentacja obiektu służącego do transferowania odwołania do obiektu między granicami domeny aplikacji. <xref:System.Runtime.Remoting.ObjRef> Tworzenie dla obiektu jest znane jako kierowanie. <xref:System.Runtime.Remoting.ObjRef> Można go przenieść za pośrednictwem kanału do innej domeny aplikacji (prawdopodobnie na innym procesie lub komputerze). Raz w innej domenie <xref:System.Runtime.Remoting.ObjRef> aplikacji należy przeanalizować, aby utworzyć serwer proxy dla obiektu, na ogół połączony z obiektem rzeczywistym. Ta operacja jest znana jako anulowania organizowania.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje <xref:System.Type> opisujące klasę i klasy organizowanego obiektu, identyfikator URI, który jednoznacznie identyfikuje konkretne wystąpienie obiektu i informacje dotyczące komunikacji dotyczące sposobu osiągnięcia dostępu do częściowej procedury obsługi zdalnej miejsce, w którym znajduje się obiekt.  
  
 Podczas organizowania jest używany kontekst z bieżącego wątku, a nie kontekst, który był aktywny podczas tworzenia obiektu. Jeśli identyfikator URI nie został jawnie ustawiony przez <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> metodę, jest generowany automatycznie przez infrastrukturę tożsamości usług zdalnych.  
  
 Nie można skojarzyć identyfikatora URI z serwerem proxy z jednego z dwóch powodów: identyfikator URI został wygenerowany po stronie serwera dla obiektu, który reprezentuje, lub obiekt jest dobrze znany, w którym przypadku jest znany identyfikator URI. Z tego powodu, jeśli `Obj` parametr jest serwerem proxy, zostanie zgłoszony wyjątek. W przypadku niestandardowych serwerów proxy to ograniczenie jest swobodne, ponieważ przezroczysty serwer proxy jest traktowany jako obiekt serwera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="Obj" /> Parametr jest serwerem proxy obiektu.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyższych w stosu wywołań nie ma uprawnień do konfigurowania typów i kanałów komunikacji zdalnej.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Konfiguracja infrastruktury zdalnej. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Domeny aplikacji</related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, URI As String) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, URI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Obj">Obiekt do przekonwertowania.</param>
        <param name="URI">Określony identyfikator URI, za pomocą którego ma zostać <see cref="T:System.Runtime.Remoting.ObjRef" />zainicjowana nowa. Może być <see langword="null" />.</param>
        <summary>Konwertuje dane podane <see cref="T:System.MarshalByRefObject" /> w wystąpieniu <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy z określonym identyfikatorem URI.</summary>
        <returns>Wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy, która reprezentuje obiekt określony <paramref name="Obj" /> w parametrze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Runtime.Remoting.ObjRef> to możliwy do serializacji reprezentacja obiektu służącego do transferowania odwołania do obiektu między granicami domeny aplikacji. <xref:System.Runtime.Remoting.ObjRef> Tworzenie dla obiektu jest znane jako kierowanie. <xref:System.Runtime.Remoting.ObjRef> Można go przenieść za pośrednictwem kanału do innej domeny aplikacji (prawdopodobnie na innym procesie lub komputerze). Raz w innej domenie <xref:System.Runtime.Remoting.ObjRef> aplikacji należy przeanalizować, aby utworzyć serwer proxy dla obiektu, na ogół połączony z obiektem rzeczywistym. Ta operacja jest znana jako anulowania organizowania.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje <xref:System.Type> opisujące klasę i klasy organizowanego obiektu, identyfikator URI, który jednoznacznie identyfikuje konkretne wystąpienie obiektu i informacje dotyczące komunikacji dotyczące sposobu osiągnięcia dostępu do częściowej procedury obsługi zdalnej miejsce, w którym znajduje się obiekt.  
  
 Podczas organizowania jest używany kontekst z bieżącego wątku, a nie kontekst, który był aktywny podczas tworzenia obiektu.  
  
 Nie można skojarzyć identyfikatora URI z serwerem proxy z jednego z dwóch powodów: identyfikator URI został wygenerowany po stronie serwera dla obiektu, który reprezentuje, lub obiekt jest dobrze znany, w którym przypadku jest znany identyfikator URI. Z tego powodu, jeśli `Obj` parametr jest serwerem proxy, zostanie zgłoszony wyjątek. W przypadku niestandardowych serwerów proxy to ograniczenie jest swobodne, ponieważ przezroczysty serwer proxy jest traktowany jako obiekt serwera.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać bieżącej <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> metody do organizowania określonego obiektu.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="Obj" />jest serwerem proxy obiektów, a <paramref name="URI" /> parametr nie <see langword="null" />jest.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyższych w stosu wywołań nie ma uprawnień do konfigurowania typów i kanałów komunikacji zdalnej.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Konfiguracja infrastruktury zdalnej. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Domeny aplikacji</related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string ObjURI, class System.Type RequestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, ObjURI As String, RequestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ ObjURI, Type ^ RequestedType);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string * Type -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, ObjURI, RequestedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="ObjURI" Type="System.String" />
        <Parameter Name="RequestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="Obj">Obiekt do przekonwertowania na <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <param name="ObjURI">Identyfikator URI, który obiekt określony w <paramref name="Obj" /> parametrze jest zorganizowany przy użyciu. Może być <see langword="null" />.</param>
        <param name="RequestedType"><see cref="T:System.Type" /> Jest<paramref name="Obj" /> organizowane jako. Może być <see langword="null" />.</param>
        <summary>Przyjmuje i konwertuje ją na wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy o określonym <see cref="T:System.Type" />identyfikatorze URI i podanej wartości. <see cref="T:System.MarshalByRefObject" /></summary>
        <returns>Wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy, która reprezentuje obiekt określony <paramref name="Obj" /> w parametrze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Runtime.Remoting.ObjRef> to możliwy do serializacji reprezentacja obiektu służącego do transferowania odwołania do obiektu między granicami domeny aplikacji. <xref:System.Runtime.Remoting.ObjRef> Tworzenie dla obiektu jest znane jako kierowanie. <xref:System.Runtime.Remoting.ObjRef> Można go przenieść za pośrednictwem kanału do innej domeny aplikacji (prawdopodobnie na innym procesie lub komputerze). Raz w innej domenie <xref:System.Runtime.Remoting.ObjRef> aplikacji należy przeanalizować, aby utworzyć serwer proxy dla obiektu, na ogół połączony z obiektem rzeczywistym. Ta operacja jest znana jako anulowania organizowania.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje <xref:System.Type> opisujące klasę i klasy organizowanego obiektu, identyfikator URI, który jednoznacznie identyfikuje konkretne wystąpienie obiektu i informacje dotyczące komunikacji dotyczące sposobu osiągnięcia dostępu do częściowej procedury obsługi zdalnej miejsce, w którym znajduje się obiekt.  
  
 Określony <xref:System.Type> jest używany przez infrastrukturę komunikacji zdalnej w celu ograniczenia zakresu widocznej hierarchii typów. Na przykład jeśli obiekt A pochodzi od obiektu B, który pochodzi z obiektu C i <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> jest wywoływany, klient może rzutować serwer proxy między C i B, ale nie na.  
  
 Podczas organizowania jest używany kontekst z bieżącego wątku, a nie kontekst, który był aktywny podczas tworzenia obiektu.  
  
 Nie można skojarzyć identyfikatora URI z serwerem proxy z jednego z dwóch powodów: identyfikator URI został wygenerowany po stronie serwera dla obiektu, który reprezentuje, lub obiekt jest dobrze znany, w którym przypadku jest znany identyfikator URI. Z tego powodu, jeśli `Obj` parametr jest serwerem proxy, zostanie zgłoszony wyjątek. W przypadku niestandardowych serwerów proxy to ograniczenie jest swobodne, ponieważ przezroczysty serwer proxy jest traktowany jako obiekt serwera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="Obj" />jest serwerem proxy obiektu zdalnego, a <paramref name="ObjUri" /> parametr nie <see langword="null" />jest.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyższych w stosu wywołań nie ma uprawnień do konfigurowania typów i kanałów komunikacji zdalnej.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Konfiguracja infrastruktury zdalnej. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Domeny aplikacji</related>
      </Docs>
    </Member>
    <Member MemberName="SetObjectUriForMarshal">
      <MemberSignature Language="C#" Value="public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetObjectUriForMarshal(class System.MarshalByRefObject obj, string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetObjectUriForMarshal (obj As MarshalByRefObject, uri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetObjectUriForMarshal(MarshalByRefObject ^ obj, System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member SetObjectUriForMarshal : MarshalByRefObject * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal (obj, uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, dla którego ma zostać ustawiony identyfikator URI.</param>
        <param name="uri">Identyfikator URI, który ma zostać przypisany do określonego obiektu.</param>
        <summary>Ustawia identyfikator URI dla kolejnego wywołania <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator URI ustawiony przez bieżącą metodę jest używany podczas organizowania danego obiektu.  
  
 Po przekierowaniu identyfikator URI określonego obiektu jest ustawiany na ciąg w `uri` parametrze dołączonym <xref:System.Guid> do bieżącego <xref:System.AppDomain>elementu.  
  
 Jeśli bieżąca aplikacja nasłuchuje na porcie http, wówczas zarówno `uri` ciąg określony w parametrze, `uri` jak i <xref:System.Guid> ciąg dołączony do bieżącej <xref:System.AppDomain> trasy do określonego obiektu. Na przykład, jeśli aplikacja nasłuchuje na porcie http 9000, a następnie `http://localhost:9000/objectUri`w obu `http://localhost:9000/<appdomainguid>/objectUri` i trasie do obiektu określonego w `obj` parametrze.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób ustawiania identyfikatora URI, który będzie używany przez <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> metodę podczas organizowania określonego obiektu.  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="obj" />nie jest obiektem lokalnym, został już zorganizowany lub bieżąca metoda została już wywołana.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyższych w stosu wywołań nie ma uprawnień do konfigurowania typów i kanałów komunikacji zdalnej.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Konfiguracja infrastruktury zdalnej. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unmarshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje daną <see cref="T:System.Runtime.Remoting.ObjRef" /> wartość na obiekt proxy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal objectRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
      </Parameters>
      <Docs>
        <param name="objectRef"><see cref="T:System.Runtime.Remoting.ObjRef" /> Reprezentuje obiekt zdalny, dla którego tworzony jest serwer proxy.</param>
        <summary><see cref="T:System.Runtime.Remoting.ObjRef" /> Przyjmuje i tworzy obiekt proxy.</summary>
        <returns>Serwer proxy do obiektu reprezentowanego przez dany <see cref="T:System.Runtime.Remoting.ObjRef" /> element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Runtime.Remoting.ObjRef> to możliwy do serializacji reprezentacja obiektu służącego do transferowania odwołania do obiektu między granicami domeny aplikacji. <xref:System.Runtime.Remoting.ObjRef> Tworzenie dla obiektu jest znane jako kierowanie. <xref:System.Runtime.Remoting.ObjRef> Można go przenieść za pośrednictwem kanału do innej domeny aplikacji (prawdopodobnie na innym procesie lub komputerze). Raz w innej domenie <xref:System.Runtime.Remoting.ObjRef> aplikacji należy przeanalizować, aby utworzyć serwer proxy dla obiektu, na ogół połączony z obiektem rzeczywistym. Ta operacja jest znana jako anulowania organizowania. Podczas anulowania organizowania, <xref:System.Runtime.Remoting.ObjRef> jest analizowane, aby wyodrębnić informacje o metodzie obiektu zdalnego, a następnie utworzyć przezroczysty serwer proxy i <xref:System.Runtime.Remoting.Proxies.RealProxy> obiekty. Zawartość przeanalizowanego <xref:System.Runtime.Remoting.ObjRef> elementu jest dodawana do przezroczystego serwera proxy przed zarejestrowaniem przezroczystego serwera proxy w środowisku uruchomieniowym języka wspólnego.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje <xref:System.Type> opisujące klasę i klasy organizowanego obiektu, identyfikator URI, który jednoznacznie identyfikuje konkretne wystąpienie obiektu i informacje dotyczące komunikacji dotyczące sposobu osiągnięcia dostępu do częściowej procedury obsługi zdalnej miejsce, w którym znajduje się obiekt.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób anulowania organizowania obiektu.  
  
 [!code-cpp[RemotingServices.Unmarshal#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CPP/client.cpp#2)]
 [!code-csharp[RemotingServices.Unmarshal#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CS/client.cs#2)]
 [!code-vb[RemotingServices.Unmarshal#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.Unmarshal/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Runtime.Remoting.ObjRef" /> Wystąpienie określone <paramref name="objectRef" /> w parametrze nie jest poprawnie sformułowane.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyższych w stosu wywołań nie ma uprawnień do konfigurowania typów i kanałów komunikacji zdalnej.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Konfiguracja infrastruktury zdalnej. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef, bool fRefine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef, fRefine As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef, bool fRefine);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef * bool -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal (objectRef, fRefine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
        <Parameter Name="fRefine" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="objectRef"><see cref="T:System.Runtime.Remoting.ObjRef" /> Reprezentuje obiekt zdalny, dla którego tworzony jest serwer proxy.</param>
        <param name="fRefine"><see langword="true" />Aby uściślić serwer proxy do typu na serwerze; w przeciwnym razie. <see langword="false" /></param>
        <summary><see cref="T:System.Runtime.Remoting.ObjRef" /> Przyjmuje i tworzy obiekt proxy z tego obiektu, a następnie poprawia go na typ na serwerze.</summary>
        <returns>Serwer proxy do obiektu reprezentowanego przez dany <see cref="T:System.Runtime.Remoting.ObjRef" /> element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Runtime.Remoting.ObjRef> to możliwy do serializacji reprezentacja obiektu służącego do transferowania odwołania do obiektu między granicami domeny aplikacji. <xref:System.Runtime.Remoting.ObjRef> Tworzenie dla obiektu jest znane jako kierowanie. <xref:System.Runtime.Remoting.ObjRef> Można go przenieść za pośrednictwem kanału do innej domeny aplikacji (prawdopodobnie na innym procesie lub komputerze). Raz w innej domenie <xref:System.Runtime.Remoting.ObjRef> aplikacji należy przeanalizować, aby utworzyć serwer proxy dla obiektu, na ogół połączony z obiektem rzeczywistym. Ta operacja jest znana jako anulowania organizowania. Podczas anulowania organizowania, <xref:System.Runtime.Remoting.ObjRef> jest analizowane, aby wyodrębnić informacje o metodzie obiektu zdalnego, a następnie utworzyć przezroczysty serwer proxy i <xref:System.Runtime.Remoting.Proxies.RealProxy> obiekty. Zawartość przeanalizowanego <xref:System.Runtime.Remoting.ObjRef> elementu jest dodawana do przezroczystego serwera proxy przed zarejestrowaniem przezroczystego serwera proxy w środowisku uruchomieniowym języka wspólnego.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje <xref:System.Type> opisujące klasę i klasy organizowanego obiektu, identyfikator URI, który jednoznacznie identyfikuje konkretne wystąpienie obiektu i informacje dotyczące komunikacji dotyczące sposobu osiągnięcia dostępu do częściowej procedury obsługi zdalnej miejsce, w którym znajduje się obiekt.  
  
 Po pierwszym utworzeniu serwer proxy jest typu <xref:System.MarshalByRefObject>. Podczas rzutowania go na różne typy infrastruktura zdalna śledzi najbardziej używany typ, aby uniknąć niepotrzebnego ładowania typu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Runtime.Remoting.ObjRef" /> Wystąpienie określone <paramref name="objectRef" /> w parametrze nie jest poprawnie sformułowane.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyższych w stosu wywołań nie ma uprawnień do konfigurowania typów i kanałów komunikacji zdalnej.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Konfiguracja infrastruktury zdalnej. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="RemotingServices" FullName="System.Runtime.Remoting.RemotingServices">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f116e83772ad89fa2d72ace082b41f76d2be95c6" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39967262" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class RemotingServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed RemotingServices extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingServices" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingServices" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingServices = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia kilka metod przy użyciu i publikowania, obiekty w węzłach i serwery proxy. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie masz dostawcy usług, zajmujących się problemy, takie jak aktywacji, zarządzanie okresem istnienia lub transakcje, nie musisz rozróżnienie między serwera proxy, odwołania i odwołania do obiektu. Infrastruktura usług zdalnych używa przezroczystych obiektów proxy, które dają wrażenie, że obiekty zdalne znajdują się w obszarze klienta. Serwery proxy to osiągnąć poprzez przesłanie wywołania ich do rzeczywistych obiektów w lokalizacjach zdalnych.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy serwer proxy dla obiektu dobrze znane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classToProxy">
          <see cref="T:System.Type" /> Dobrze znanych obiektu po stronie serwera, do którego chcesz się połączyć.</param>
        <param name="url">Adres URL Klasa serwera.</param>
        <summary>Tworzy serwer proxy dla obiektu dobrze znanych <see cref="T:System.Type" /> i adres URL.</summary>
        <returns>Serwer proxy do zdalnego obiektu, który wskazuje na obsługiwanych przez określony obiekt dobrze znanego punktu końcowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wskazuje proxy zwrócone przez określony obiekt dobrze znanego punktu końcowego. Nie komunikaty są wysyłane za pośrednictwem sieci, dopóki metoda jest wywoływana na serwerze proxy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Runtime.Remoting.RemotingServices.Connect%2A> metodę, aby utworzyć serwer proxy, aby dobrze znane obiekty.  
  
 [!code-cpp[RemotingServices.BasicSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/basicclient.cpp#1)]
 [!code-csharp[RemotingServices.BasicSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/basicclient.cs#1)]
 [!code-vb[RemotingServices.BasicSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/basicclient.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia do konfigurowania typów komunikacji zdalnej i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla konfiguracji infrastruktury komunikacji zdalnej. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String, data As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string * obj -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="classToProxy">
          <see cref="T:System.Type" /> Dobrze znanych obiektu, do którego chcesz się połączyć.</param>
        <param name="url">Adres URL dobrze znane obiekty.</param>
        <param name="data">Kanał określonych danych. Może być <see langword="null" />.</param>
        <summary>Tworzy serwer proxy dla obiektu dobrze znanych <see cref="T:System.Type" />, adres URL i dane specyficzne dla kanału.</summary>
        <returns>Serwer proxy, który wskazuje punkt końcowy, który jest obsługiwany przez żądany obiekt dobrze znane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wskazuje proxy zwrócone przez określony obiekt dobrze znanego punktu końcowego. Nie komunikaty są wysyłane za pośrednictwem sieci, dopóki metoda jest wywoływana na serwerze proxy.  
  
 `data` Obiekt jest używany do przekazywania informacji do kanału i jest przekazywany do <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia do konfigurowania typów komunikacji zdalnej i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla konfiguracji infrastruktury komunikacji zdalnej. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public static bool Disconnect (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Disconnect(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Disconnect (obj As MarshalByRefObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Disconnect(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member Disconnect : MarshalByRefObject -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.Disconnect obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, aby rozłączyć się z jej kanału.</param>
        <summary>Zatrzymuje obiektu odbieranie wszelkie dalsze komunikaty za pośrednictwem kanałów zarejestrowanych usług zdalnych.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekt został odłączony od kanałów komunikacji zdalnej zarejestrowanych pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> metodę, aby rozłączyć obiektu kanałów komunikacji zdalnej.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> Parametr jest serwer proxy.</exception>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia do konfigurowania typów komunikacji zdalnej i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla konfiguracji infrastruktury komunikacji zdalnej. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMessage">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(class System.MarshalByRefObject target, class System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExecuteMessage (target As MarshalByRefObject, reqMsg As IMethodCallMessage) As IMethodReturnMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMethodReturnMessage ^ ExecuteMessage(MarshalByRefObject ^ target, System::Runtime::Remoting::Messaging::IMethodCallMessage ^ reqMsg);" />
      <MemberSignature Language="F#" Value="static member ExecuteMessage : MarshalByRefObject * System.Runtime.Remoting.Messaging.IMethodCallMessage -&gt; System.Runtime.Remoting.Messaging.IMethodReturnMessage" Usage="System.Runtime.Remoting.RemotingServices.ExecuteMessage (target, reqMsg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMethodReturnMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.MarshalByRefObject" />
        <Parameter Name="reqMsg" Type="System.Runtime.Remoting.Messaging.IMethodCallMessage" />
      </Parameters>
      <Docs>
        <param name="target">Zdalny obiekt do wywołania metody.</param>
        <param name="reqMsg">Komunikat wywołanie metody do metody określonego obiektu zdalnego.</param>
        <summary>Nawiązanie połączenia z określonego obiektu zdalnego i wykonuje podane <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" /> na nim.</summary>
        <returns>Odpowiedź metody zdalnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżąca metoda jest używana w szczególnych przypadkach przez serwer do przekazywania określonej metody wywołania do innego, prawdopodobnie zdalnych obiektu. Tę metodę można wywołać tylko wtedy, gdy obiekt wywołujący w odpowiedniego kontekstu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> metoda do wywołania metody do zdalnego obiektów przekazywania.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnień infrastruktury.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Metoda została wywołana w kontekście innej niż natywne kontekście obiektu.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">za działanie z kodem infrastruktury. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvoyChainForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvoyChainForProxy (obj As MarshalByRefObject) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMessageSink ^ GetEnvoyChainForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetEnvoyChainForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Serwer proxy obiektu zdalnego, który zażądał ujść usługa envoy są skojarzone.</param>
        <summary>Zwraca łańcuch ujść usługa envoy, które powinny być używane podczas wysyłania wiadomości do zdalnego obiektu reprezentowanego przez określony serwer proxy.</summary>
        <returns>Łańcuch ujść usługa envoy skojarzone z określonego serwera proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa envoy ujść są wysyłane wraz z ujść <xref:System.Runtime.Remoting.ObjRef> obiektu, który jest używany podczas zwracania wiadomości do tego obiektu. Bieżąca metoda zwraca ujść usługa envoy, które są używane podczas komunikacji między serwerem proxy obiektu i sam obiekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnień infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">za działanie z kodem infrastruktury. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.IEnvoyInfo" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public static object GetLifetimeService (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLifetimeService(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLifetimeService (obj As MarshalByRefObject) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLifetimeService(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetLifetimeService : MarshalByRefObject -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.GetLifetimeService obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który można uzyskać usługi okres istnienia dla.</param>
        <summary>Zwraca obiekt usługi okres istnienia, który kontroluje zasady okres istnienia określonego obiektu.</summary>
        <returns>Obiekt, który kontroluje okres istnienia <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługi domyślny okres istnienia zwracany obiekt będzie obiektu typu <xref:System.Runtime.Remoting.Lifetime.ILease>. Jeśli `obj` parametr jest `null`, metoda zwraca `null`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> metodę umożliwiającą uzyskanie dzierżawy okres istnienia dla określonego obiektu.  
  
 [!code-cpp[RemotingServices.TimerSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.TimerSample/CPP/timerclient.cpp#1)]
 [!code-csharp[RemotingServices.TimerSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerclient.cs#1)]
 [!code-vb[RemotingServices.TimerSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerclient.vb#1)]  
  
 Aby skompilować i uruchomić ten przykład, należy skompilować i uruchomić timerservice.dll server, timerserver.exe i kompilacji biblioteki udostępnionej.  
  
 Źródło timerserver.exe następująco:  
  
 [!code-csharp[RemotingServices.TimerSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerserver.cs#2)]
 [!code-vb[RemotingServices.TimerSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerserver.vb#2)]  
  
 Źródło timerservice.dll następująco:  
  
 [!code-csharp[RemotingServices.TimerSample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerservice.cs#3)]
 [!code-vb[RemotingServices.TimerSample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerservice.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnień infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">za działanie z kodem infrastruktury. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBaseFromMethodMessage">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodBaseFromMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodBaseFromMethodMessage (msg As IMethodMessage) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodBaseFromMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetMethodBaseFromMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; System.Reflection.MethodBase" Usage="System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Komunikat metody do wyodrębniania podstawowej z metody.</param>
        <summary>Zwraca metodę podstawowej z danym <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />.</summary>
        <returns>Podstawowa metoda wyodrębnione z <paramref name="msg" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określa podstawowy z metody <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>, <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>, i <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> właściwości <xref:System.Runtime.Remoting.Messaging.IMethodMessage> i jest używany przez klasy Implementowanie <xref:System.Runtime.Remoting.Messaging.IMethodMessage> interfejsu. Konsumenci <xref:System.Runtime.Remoting.Messaging.IMethodMessage> powinny odwoływać się do klasy <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnień infrastruktury lub co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do pobierania informacji o typie niepubliczne składowe.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">za działanie z kodem infrastruktury. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetObjectData(object obj, class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetObjectData (obj As Object, info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetObjectData(System::Object ^ obj, System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="static member GetObjectData : obj * System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.GetObjectData (obj, info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do zserializowania.</param>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Do którego serializowany jest obiekt.</param>
        <param name="context">Źródło i miejsce docelowe serializacji.</param>
        <summary>Serializuje określony marshal przez obiekt odwołania do udostępnionych <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Lub <paramref name="info" /> parametr <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnień infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">za działanie z kodem infrastruktury. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectUri">
      <MemberSignature Language="C#" Value="public static string GetObjectUri (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetObjectUri(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectUri (obj As MarshalByRefObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetObjectUri(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectUri : MarshalByRefObject -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetObjectUri obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.MarshalByRefObject" /> Dla jest żądanego identyfikatora URI.</param>
        <summary>Pobiera identyfikator URI dla określonego obiektu.</summary>
        <returns>Identyfikator URI określonego obiektu, jeśli taki istnieje, lub <see langword="null" /> Jeśli obiekt nie ma jeszcze zorganizować.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#18)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#18)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnień infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">za działanie z kodem infrastruktury. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjRefForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef GetObjRefForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjRefForProxy (obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ GetObjRefForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjRefForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.GetObjRefForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Serwer proxy jest podłączony do obiektu, którego chcesz utworzyć <see cref="T:System.Runtime.Remoting.ObjRef" /> dla.</param>
        <summary>Zwraca <see cref="T:System.Runtime.Remoting.ObjRef" /> reprezentujący obiektu zdalnego z określonego serwera proxy.</summary>
        <returns>A <see cref="T:System.Runtime.Remoting.ObjRef" /> reprezentujący obiektu zdalnego jest połączony określonego serwera proxy, lub <see langword="null" /> Jeśli obiekt lub serwer proxy nie mają został przekazany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element <xref:System.Runtime.Remoting.ObjRef> jest możliwy do serializacji reprezentujący obiekt używany do transferu odwołanie do obiektu między granic domeny aplikacji. Tworzenie <xref:System.Runtime.Remoting.ObjRef> dla obiektu jest nazywany szeregowanie. <xref:System.Runtime.Remoting.ObjRef> Mogą być przesyłane za pośrednictwem kanału w innej domenie aplikacji (prawdopodobnie na inny proces lub komputer). Jeden raz w innej domenie aplikacji <xref:System.Runtime.Remoting.ObjRef> musi przeanalizować w celu utworzenia serwera proxy dla obiektu, zazwyczaj jest podłączony do rzeczywistego obiektu. Ta operacja jest określany jako unmarshaling. Podczas unmarshaling, <xref:System.Runtime.Remoting.ObjRef> jest analizowany można wyodrębnić informacji o metodzie obiektu zdalnego i proxy przezroczyste i <xref:System.Runtime.Remoting.Proxies.RealProxy> obiekty są tworzone.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje opisujące <xref:System.Type> i klasa obiektu są organizowane, identyfikator URI, który jednoznacznie identyfikuje wystąpienie określonego obiektu, a komunikacja powiązane informacje o tym, jak można uzyskać dostępu do zdalnej aplikacji gdzie znajduje się obiekt.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób uzyskiwania <xref:System.Runtime.Remoting.ObjRef> wystąpienie określonego obiektu.  
  
 [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CPP/client.cpp#1)]
 [!code-csharp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CS/client.cs#1)]
 [!code-vb[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnień infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">za działanie z kodem infrastruktury. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRealProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRealProxy (proxy As Object) As RealProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Proxies::RealProxy ^ GetRealProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member GetRealProxy : obj -&gt; System.Runtime.Remoting.Proxies.RealProxy" Usage="System.Runtime.Remoting.RemotingServices.GetRealProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Proxies.RealProxy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Przezroczystym serwerem proxy.</param>
        <summary>Zwraca wartość rzeczywistego kopii określonego przezroczystym serwerem proxy serwera proxy.</summary>
        <returns>Wystąpienie proxy rzeczywistych kopii przezroczystym serwerem proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klient, który używa obiektu w dowolnych granic wywołaniem funkcji zdalnych jest faktycznie przy użyciu przezroczystym serwerem proxy dla obiektu. Przezroczystym serwerem proxy zapewnia wrażenie, że faktyczny obiekt znajduje się w obszarze klienta. Jego osiąga to za przekazywanie wywołań na nim do rzeczywistego obiektu przy użyciu infrastruktury komunikacji zdalnej.  
  
 Przezroczystym serwerem proxy jest wspierana przez wystąpienie klasy zarządzanego środowiska wykonawczego typu <xref:System.Runtime.Remoting.Proxies.RealProxy>. <xref:System.Runtime.Remoting.Proxies.RealProxy> Zaimplementowano część funkcje potrzebne do operacji w przód od przezroczystym serwerem proxy.  
  
 Obiekt serwera proxy dziedziczy skojarzone semantyki obiektów zarządzanych, takich jak wyrzucanie elementów bezużytecznych, Obsługa elementów członkowskich i metod i mogą zostać rozszerzone do postaci nowych klas. Serwer proxy działa jako obiekt taka sama klasa co obiektu zdalnego (przezroczystym serwerem proxy), jest również zarządzanego obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnień infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">za działanie z kodem infrastruktury. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetServerTypeForUri">
      <MemberSignature Language="C#" Value="public static Type GetServerTypeForUri (string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetServerTypeForUri(string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetServerTypeForUri (URI As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetServerTypeForUri(System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member GetServerTypeForUri : string -&gt; Type" Usage="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri URI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="URI">Identyfikator URI obiektu, którego <see cref="T:System.Type" /> żądania.</param>
        <summary>Zwraca <see cref="T:System.Type" /> obiektu z określonym identyfikatorem URI.</summary>
        <returns>
          <see cref="T:System.Type" /> Obiektu z określonym identyfikatorem URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ komunikacja zdalna identyfikuje punktów końcowych przy użyciu identyfikatorów URI <xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> metodą jest przydatne w przypadku podłączanych części infrastruktury usług zdalnych (na przykład ujścia kanału ujść dynamiczne i ujść kontekstu), korzystających z <xref:System.Runtime.Remoting.Messaging.IMessage> obiektów, ponieważ bieżący Metoda zwraca obiekt typu skojarzony z identyfikatora URI.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#7)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#7)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnień infrastruktury lub co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do pobierania informacji o typie niepubliczne składowe.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">za działanie z kodem infrastruktury. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">można pobrać informacji o typie niepubliczne składowe. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetSessionIdForMethodMessage">
      <MemberSignature Language="C#" Value="public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetSessionIdForMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSessionIdForMethodMessage (msg As IMethodMessage) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetSessionIdForMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetSessionIdForMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">
          <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> Dla żądanego jest identyfikator sesji.</param>
        <summary>Pobiera identyfikator sesji dla wiadomości.</summary>
        <returns>Ciąg Identyfikatora sesji, który unikatowo identyfikuje w bieżącej sesji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tym samym Identyfikatorem sesji, może zostać zwrócona dla obiektów w tej samej aplikacji, ale ta metoda będzie nigdy nie należy zwracać ten sam identyfikator sesji dla dwóch obiektów w innych aplikacjach zdalnego.  
  
 Aby uzyskać więcej informacji na temat identyfikowania sesji i identyfikatorów sesji, zobacz ASP.Net [ASP.NET Session State Overview](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób uzyskiwania ciąg Identyfikatora sesji dla bieżącej sesji.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnień infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">za działanie z kodem infrastruktury. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsMethodOverloaded">
      <MemberSignature Language="C#" Value="public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMethodOverloaded(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMethodOverloaded (msg As IMethodMessage) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMethodOverloaded(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member IsMethodOverloaded : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsMethodOverloaded msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Komunikat, który zawiera wywołanie metody w danym.</param>
        <summary>Zwraca wartość logiczną wskazującą, czy jest przeciążona metoda w podanym komunikatem.</summary>
        <returns>
          <see langword="true" /> Jeśli metoda jest wywoływana <paramref name="msg" /> jest przeciążona; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnień infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">za działanie z kodem infrastruktury. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfAppDomain">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfAppDomain (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfAppDomain(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfAppDomain (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfAppDomain(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfAppDomain : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Obiekt do sprawdzenia.</param>
        <summary>Zwraca wartość logiczną wskazującą, czy obiekt określony przez dany przezroczystym serwerem proxy znajduje się w domenie innej aplikacji, niż obiekt, który wywołuje bieżącej metody.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekt jest spoza bieżącej domeny aplikacji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacji o domenach aplikacji, zobacz [domen aplikacji](http://msdn.microsoft.com/library/39e57d07-a740-4cd4-ae82-e119ea3856c1).  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfContext">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfContext (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfContext(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfContext (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfContext(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfContext : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Obiekt do sprawdzenia.</param>
        <summary>Zwraca wartość logiczną wskazującą, czy obiekt reprezentowany przez dany serwer proxy znajduje się w innym kontekście niż obiekt, który wywołuje bieżącej metody.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekt jest poza bieżącym kontekście; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontekst jest uporządkowana sekwencja właściwości, które definiują środowisko dla obiektów, które znajdują się wewnątrz niego. Konteksty są tworzone podczas procesu aktywacji dla obiektów, które są skonfigurowane, aby wymagała niektóre automatyczne usług takich synchronizacji, transakcje, just-in-time aktywacji, zabezpieczeń i tak dalej. Wiele obiektów może być przechowywana w kontekście.  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Contexts.Context" />
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public static bool IsOneWay (System.Reflection.MethodBase method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOneWay(class System.Reflection.MethodBase method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOneWay (method As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOneWay(System::Reflection::MethodBase ^ method);" />
      <MemberSignature Language="F#" Value="static member IsOneWay : System.Reflection.MethodBase -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsOneWay method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="method">Metoda zagrożona.</param>
        <summary>Zwraca wartość logiczną wskazującą, czy klient, który wywołuje metodę określone w podanym komunikatem oczekuje na serwer zakończyć przetwarzanie metody przed kontynuowaniem wykonywania.</summary>
        <returns>
          <see langword="true" /> Jeśli metoda jest jednym ze sposobów; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wywoływana jest metoda jednokierunkowe, klient nie czeka na serwera na zakończenie przetwarzania wiadomości. Metoda klienta zwraca do aplikacji nie zna Określa, czy serwer pomyślnie przetworzy komunikat. Metody są oznaczone jako przy użyciu jednokierunkowego <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.  
  
 Metody jednokierunkowe nie może mieć wartości zwracanej ani żadnych parametrów out.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#2)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#2)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnień infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">za działanie z kodem infrastruktury. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsTransparentProxy">
      <MemberSignature Language="C#" Value="public static bool IsTransparentProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTransparentProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTransparentProxy (proxy As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTransparentProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member IsTransparentProxy : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsTransparentProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Odwołanie do obiektu do sprawdzenia.</param>
        <summary>Zwraca wartość logiczną wskazującą, czy dany obiekt jest przezroczystym serwerem proxy lub rzeczywistego obiektu.</summary>
        <returns>Wartość logiczna, która wskazuje, czy obiekt określony w <paramref name="proxy" /> parametr ma przezroczystym serwerem proxy lub rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klient, który używa obiektu w dowolnych granic wywołaniem funkcji zdalnych jest faktycznie przy użyciu przezroczystym serwerem proxy dla obiektu. Przezroczystym serwerem proxy zapewnia wrażenie, że faktyczny obiekt znajduje się w obszarze klienta. Jego osiąga to za przekazywanie wywołań na nim do rzeczywistego obiektu przy użyciu infrastruktury komunikacji zdalnej.  
  
 Przezroczystym serwerem proxy jest przechowywane przez wystąpienie klasy zarządzanego środowiska wykonawczego typu <xref:System.Runtime.Remoting.Proxies.RealProxy>. <xref:System.Runtime.Remoting.Proxies.RealProxy> Zaimplementowano część funkcje potrzebne do operacji w przód od przezroczystym serwerem proxy. Obiekt serwera proxy dziedziczy skojarzone semantyki obiektów zarządzanych, takich jak wyrzucanie elementów bezużytecznych, Obsługa elementów członkowskich i metod i mogą zostać rozszerzone do postaci nowych klas. Ten sposób serwer proxy ma charakter podwójnego; z jednej strony wymaga do działania jako obiekt taka sama klasa co obiektu zdalnego (proxy przezroczyste), a na drugim jest samego zarządzanego obiektu.  
  
 Obiekt serwera proxy może służyć bez względu na jakikolwiek podpodział komunikacji zdalnej w ciągu <xref:System.AppDomain>. Aplikacje muszą rozróżnia odwołania do serwera proxy i odwołania do obiektu. Jednak usługodawców zajmujących się problemy, takie jak aktywacji, zarządzanie okresem istnienia i transakcje konieczne wprowadzenie takiego rozróżnienia.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> metodę pozwala ustalić, czy obiekt jest serwer proxy lub rzeczywistego obiektu. Aby uzyskać kompletny przykładowy kod, zobacz przykład dla <xref:System.Runtime.Remoting.Messaging.AsyncResult> klasy.  
  
 [!code-cpp[AsyncResult.NewExamples#6](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncResult.NewExamples/CPP/ad.cpp#6)]
 [!code-csharp[AsyncResult.NewExamples#6](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncResult.NewExamples/CS/ad.cs#6)]
 [!code-vb[AsyncResult.NewExamples#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncResult.NewExamples/VB/ad.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="LogRemotingStage">
      <MemberSignature Language="C#" Value="public static void LogRemotingStage (int stage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogRemotingStage(int32 stage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogRemotingStage (stage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LogRemotingStage(int stage);" />
      <MemberSignature Language="F#" Value="static member LogRemotingStage : int -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.LogRemotingStage stage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.Conditional("REMOTING_PERF")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("It existed for only internal use in .NET and unimplemented in mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Use of this method is not recommended. The LogRemotingStage existed for internal diagnostic purposes only.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stage">Wewnętrznie zdefiniowanej stałej, identyfikujący etap w programie exchange komunikacji zdalnej.</param>
        <summary>Rejestruje etap w programie exchange komunikacji zdalnej w celu zewnętrznego debugera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A `"REMOTING_PERF"` symbolu przetwarzania wstępnego jest stosowana do metody przy użyciu <xref:System.Diagnostics.ConditionalAttribute> atrybutu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla konfiguracji infrastruktury komunikacji zdalnej. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Marshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje dany <see cref="T:System.MarshalByRefObject" /> jako wystąpienia elementu <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy, która może być serializowany do transmisji między domenami aplikacji oraz za pośrednictwem sieci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal Obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="Obj">Obiekt do przekonwertowania.</param>
        <summary>Trwa <see cref="T:System.MarshalByRefObject" />, a następnie rejestruje je za pomocą infrastruktury usług zdalnych i konwertuje je do wystąpienia <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy.</summary>
        <returns>Wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasa, która reprezentuje obiekt określony w <paramref name="Obj" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element <xref:System.Runtime.Remoting.ObjRef> jest możliwy do serializacji reprezentujący obiekt używany do transferu odwołanie do obiektu między granic domeny aplikacji. Tworzenie <xref:System.Runtime.Remoting.ObjRef> dla obiektu jest nazywany szeregowanie. <xref:System.Runtime.Remoting.ObjRef> Mogą być przesyłane za pośrednictwem kanału w innej domenie aplikacji (prawdopodobnie na inny proces lub komputer). Jeden raz w innej domenie aplikacji <xref:System.Runtime.Remoting.ObjRef> musi przeanalizować w celu utworzenia serwera proxy dla obiektu, zazwyczaj jest podłączony do rzeczywistego obiektu. Ta operacja jest określany jako unmarshaling.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje opisujące <xref:System.Type> i klasa obiektu są organizowane, identyfikator URI, który jednoznacznie identyfikuje wystąpienie określonego obiektu, a komunikacja powiązane informacje o tym, jak nawiązać połączenie podpodział komunikacji zdalnej gdzie znajduje się obiekt.  
  
 Podczas przekazywania międzyprocesowego, używany jest kontekst z bieżącego wątku, kontekst nie było aktywne podczas tworzenia obiektu. Jeśli identyfikator URI nie została jawnie ustawiona przez <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> metody, jest generowany automatycznie przez infrastrukturę tożsamości komunikacji zdalnej.  
  
 Identyfikator URI nie można skojarzyć z serwerem proxy, jednego z dwóch powodów: identyfikator URI został wygenerowany po stronie serwera dla obiektu, czyli przedstawia liczbę albo obiekt jest dobrze znanych, w którym to przypadku jest znany identyfikator URI. Z tego powodu jeśli `Obj` parametr to serwer proxy, zostanie zgłoszony wyjątek. Dla niestandardowego proxy to ograniczenie jest złagodzone ponieważ przezroczystym serwerem proxy jest traktowany jako obiektu serwera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" /> Parametru jest obiekt serwera proxy.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do konfigurowania typów komunikacji zdalnej i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla konfiguracji infrastruktury komunikacji zdalnej. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, URI As String) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, URI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Obj">Obiekt do przekonwertowania.</param>
        <param name="URI">Określony identyfikator URI, z którym należy zainicjować nowy <see cref="T:System.Runtime.Remoting.ObjRef" />. Może być <see langword="null" />.</param>
        <summary>Konwertuje dany <see cref="T:System.MarshalByRefObject" /> jako wystąpienia elementu <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy przy użyciu określonego identyfikatora URI.</summary>
        <returns>Wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasa, która reprezentuje obiekt określony w <paramref name="Obj" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element <xref:System.Runtime.Remoting.ObjRef> jest możliwy do serializacji reprezentujący obiekt używany do transferu odwołanie do obiektu między granic domeny aplikacji. Tworzenie <xref:System.Runtime.Remoting.ObjRef> dla obiektu jest nazywany szeregowanie. <xref:System.Runtime.Remoting.ObjRef> Mogą być przesyłane za pośrednictwem kanału w innej domenie aplikacji (prawdopodobnie na inny proces lub komputer). Jeden raz w innej domenie aplikacji <xref:System.Runtime.Remoting.ObjRef> musi przeanalizować w celu utworzenia serwera proxy dla obiektu, zazwyczaj jest podłączony do rzeczywistego obiektu. Ta operacja jest określany jako unmarshaling.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje opisujące <xref:System.Type> i klasa obiektu są organizowane, identyfikator URI, który jednoznacznie identyfikuje wystąpienie określonego obiektu, a komunikacja powiązane informacje o tym, jak nawiązać połączenie podpodział komunikacji zdalnej gdzie znajduje się obiekt.  
  
 Podczas przekazywania międzyprocesowego, używany jest kontekst z bieżącego wątku, kontekst nie było aktywne podczas tworzenia obiektu.  
  
 Identyfikator URI nie można skojarzyć z serwerem proxy, jednego z dwóch powodów: identyfikator URI został wygenerowany po stronie serwera dla obiektu, czyli przedstawia liczbę albo obiekt jest dobrze znanych, w którym to przypadku jest znany identyfikator URI. Z tego powodu jeśli `Obj` parametr to serwer proxy, zostanie zgłoszony wyjątek. Dla niestandardowego proxy to ograniczenie jest złagodzone ponieważ przezroczystym serwerem proxy jest traktowany jako obiektu serwera.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania bieżącej <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> metodę, aby kierować określony obiekt.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" /> Serwer proxy obiektu i <paramref name="URI" /> parametr nie jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do konfigurowania typów komunikacji zdalnej i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla konfiguracji infrastruktury komunikacji zdalnej. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string ObjURI, class System.Type RequestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, ObjURI As String, RequestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ ObjURI, Type ^ RequestedType);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string * Type -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, ObjURI, RequestedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="ObjURI" Type="System.String" />
        <Parameter Name="RequestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="Obj">Obiekt do przekonwertowania na <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <param name="ObjURI">Obiekt określony w identyfikatorze URI <c>Obj</c> parametr jest przekazywany z. Może być <see langword="null" />.</param>
        <param name="RequestedType">
          <see cref="T:System.Type" />
          <c>Obj</c> jest organizowana jako. Może być <see langword="null" />.</param>
        <summary>Trwa <see cref="T:System.MarshalByRefObject" /> i konwertuje je do wystąpienia <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy przy użyciu określonego identyfikatora URI i podane <see cref="T:System.Type" />.</summary>
        <returns>Wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasa, która reprezentuje obiekt określony w <paramref name="Obj" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element <xref:System.Runtime.Remoting.ObjRef> jest możliwy do serializacji reprezentujący obiekt używany do transferu odwołanie do obiektu między granic domeny aplikacji. Tworzenie <xref:System.Runtime.Remoting.ObjRef> dla obiektu jest nazywany szeregowanie. <xref:System.Runtime.Remoting.ObjRef> Mogą być przesyłane za pośrednictwem kanału w innej domenie aplikacji (prawdopodobnie na inny proces lub komputer). Jeden raz w innej domenie aplikacji <xref:System.Runtime.Remoting.ObjRef> musi przeanalizować w celu utworzenia serwera proxy dla obiektu, zazwyczaj jest podłączony do rzeczywistego obiektu. Ta operacja jest określany jako unmarshaling.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje opisujące <xref:System.Type> i klasa obiektu są organizowane, identyfikator URI, który jednoznacznie identyfikuje wystąpienie określonego obiektu, a komunikacja powiązane informacje o tym, jak nawiązać połączenie podpodział komunikacji zdalnej gdzie znajduje się obiekt.  
  
 Określony <xref:System.Type> jest używana przez infrastrukturę usług zdalnych do ograniczenia zakresu hierarchii typów narażonych. Na przykład, jeśli obiekt A pochodzi z obiektu B, który pochodzi z obiektu C, a <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> nosi nazwę, a następnie klienta można rzutować proxy między C i B, ale nie do serwera A.  
  
 Podczas przekazywania międzyprocesowego, używany jest kontekst z bieżącego wątku, kontekst nie było aktywne podczas tworzenia obiektu.  
  
 Identyfikator URI nie można skojarzyć z serwerem proxy, jednego z dwóch powodów: identyfikator URI został wygenerowany po stronie serwera dla obiektu, czyli przedstawia liczbę albo obiekt jest dobrze znanych, w którym to przypadku jest znany identyfikator URI. Z tego powodu jeśli `Obj` parametr to serwer proxy, zostanie zgłoszony wyjątek. Dla niestandardowego proxy to ograniczenie jest złagodzone ponieważ przezroczystym serwerem proxy jest traktowany jako obiektu serwera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" /> to serwer proxy obiektu zdalnego i <paramref name="ObjUri" /> parametr nie jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do konfigurowania typów komunikacji zdalnej i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla konfiguracji infrastruktury komunikacji zdalnej. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="SetObjectUriForMarshal">
      <MemberSignature Language="C#" Value="public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetObjectUriForMarshal(class System.MarshalByRefObject obj, string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetObjectUriForMarshal (obj As MarshalByRefObject, uri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetObjectUriForMarshal(MarshalByRefObject ^ obj, System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member SetObjectUriForMarshal : MarshalByRefObject * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal (obj, uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, aby ustawić identyfikator URI dla.</param>
        <param name="uri">Identyfikator URI do przypisania do określonego obiektu.</param>
        <summary>Ustawia identyfikator URI do kolejnych wywołań <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawiony przez metodę bieżącego identyfikatora URI jest używany, gdy marshaling danego obiektu.  
  
 Po organizowanie, identyfikatora URI określonego obiektu zostanie ustawiony na ciąg w `uri` parametru dołączany na <xref:System.Guid> bieżącego <xref:System.AppDomain>.  
  
 Jeśli bieżąca aplikacja nasłuchuje na porcie HTTP, a następnie obie ciąg określony w `uri` parametru i `uri` ciąg dołączany na <xref:System.Guid> bieżącego <xref:System.AppDomain> trasy do określonego obiektu. Aby uzyskać przykład, jeśli aplikacja nasłuchuje na porcie HTTP 9000, a następnie obie http://localhost:9000/objectUri, i http://localhost:9000/\<appdomainguid>/objectUri trasy do obiektu określonego w `obj` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób ustawiania identyfikatora URI, który będzie używany przez <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> metodę przekazywania międzyprocesowego określony obiekt.  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="obj" /> jest już został przekazany lokalnego obiektu, lub bieżącej metody została już wywołana na.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do konfigurowania typów komunikacji zdalnej i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla konfiguracji infrastruktury komunikacji zdalnej. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unmarshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje dany <see cref="T:System.Runtime.Remoting.ObjRef" /> na obiekt serwera proxy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal objectRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
      </Parameters>
      <Docs>
        <param name="objectRef">
          <see cref="T:System.Runtime.Remoting.ObjRef" /> Reprezentujący zdalnego obiektu, dla którego utworzono serwer proxy.</param>
        <summary>Trwa <see cref="T:System.Runtime.Remoting.ObjRef" /> i utworzy obiekt serwera proxy z niej.</summary>
        <returns>Serwer proxy do obiektu, danego <see cref="T:System.Runtime.Remoting.ObjRef" /> reprezentuje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element <xref:System.Runtime.Remoting.ObjRef> jest możliwy do serializacji reprezentujący obiekt używany do transferu odwołanie do obiektu między granic domeny aplikacji. Tworzenie <xref:System.Runtime.Remoting.ObjRef> dla obiektu jest nazywany szeregowanie. <xref:System.Runtime.Remoting.ObjRef> Mogą być przesyłane za pośrednictwem kanału w innej domenie aplikacji (prawdopodobnie na inny proces lub komputer). Jeden raz w innej domenie aplikacji <xref:System.Runtime.Remoting.ObjRef> musi przeanalizować w celu utworzenia serwera proxy dla obiektu, zazwyczaj jest podłączony do rzeczywistego obiektu. Ta operacja jest określany jako unmarshaling. Podczas unmarshaling, <xref:System.Runtime.Remoting.ObjRef> jest analizowany można wyodrębnić informacji o metodzie obiektu zdalnego i proxy przezroczyste i <xref:System.Runtime.Remoting.Proxies.RealProxy> obiekty są tworzone. Zawartość przeanalizowany element <xref:System.Runtime.Remoting.ObjRef> jest dodawany do przezroczystym serwerem proxy przed zarejestrowaniem przezroczystym serwerem proxy przy użyciu środowiska uruchomieniowego języka wspólnego.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje opisujące <xref:System.Type> i klasa obiektu są organizowane, identyfikator URI, który jednoznacznie identyfikuje wystąpienie określonego obiektu, a komunikacja powiązane informacje o tym, jak nawiązać połączenie podpodział komunikacji zdalnej gdzie znajduje się obiekt.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak wycofać obiektu.  
  
 [!code-cpp[RemotingServices.Unmarshal#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CPP/client.cpp#2)]
 [!code-csharp[RemotingServices.Unmarshal#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CS/client.cs#2)]
 [!code-vb[RemotingServices.Unmarshal#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.Unmarshal/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Runtime.Remoting.ObjRef" /> Wystąpieniu określonym w <paramref name="objectRef" /> parametr nie jest poprawnie sformułowany.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do konfigurowania typów komunikacji zdalnej i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla konfiguracji infrastruktury komunikacji zdalnej. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef, bool fRefine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef, fRefine As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef, bool fRefine);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef * bool -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal (objectRef, fRefine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
        <Parameter Name="fRefine" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="objectRef">
          <see cref="T:System.Runtime.Remoting.ObjRef" /> Reprezentujący zdalnego obiektu, dla którego utworzono serwer proxy.</param>
        <param name="fRefine">
          <see langword="true" /> Aby uzyskać dokładniejsze serwer proxy, aby typ na serwerze; w przeciwnym razie <see langword="false" />.</param>
        <summary>Trwa <see cref="T:System.Runtime.Remoting.ObjRef" /> i utworzy obiekt serwera proxy z niej, rafinacja jej typ na serwerze.</summary>
        <returns>Serwer proxy do obiektu, danego <see cref="T:System.Runtime.Remoting.ObjRef" /> reprezentuje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element <xref:System.Runtime.Remoting.ObjRef> jest możliwy do serializacji reprezentujący obiekt używany do transferu odwołanie do obiektu między granic domeny aplikacji. Tworzenie <xref:System.Runtime.Remoting.ObjRef> dla obiektu jest nazywany szeregowanie. <xref:System.Runtime.Remoting.ObjRef> Mogą być przesyłane za pośrednictwem kanału w innej domenie aplikacji (prawdopodobnie na inny proces lub komputer). Jeden raz w innej domenie aplikacji <xref:System.Runtime.Remoting.ObjRef> musi przeanalizować w celu utworzenia serwera proxy dla obiektu, zazwyczaj jest podłączony do rzeczywistego obiektu. Ta operacja jest określany jako unmarshaling. Podczas unmarshaling, <xref:System.Runtime.Remoting.ObjRef> jest analizowany można wyodrębnić informacji o metodzie obiektu zdalnego i proxy przezroczyste i <xref:System.Runtime.Remoting.Proxies.RealProxy> obiekty są tworzone. Zawartość przeanalizowany element <xref:System.Runtime.Remoting.ObjRef> jest dodawany do przezroczystym serwerem proxy przed zarejestrowaniem przezroczystym serwerem proxy przy użyciu środowiska uruchomieniowego języka wspólnego.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje opisujące <xref:System.Type> i klasa obiektu są organizowane, identyfikator URI, który jednoznacznie identyfikuje wystąpienie określonego obiektu, a komunikacja powiązane informacje o tym, jak nawiązać połączenie podpodział komunikacji zdalnej gdzie znajduje się obiekt.  
  
 W chwili utworzenia serwera proxy jest typu <xref:System.MarshalByRefObject>. Jak rzutować go na różne typy infrastruktury usług zdalnych przechowuje informacje o najczęściej używanych typu, aby uniknąć niepotrzebnego ładowania typu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Runtime.Remoting.ObjRef" /> Wystąpieniu określonym w <paramref name="objectRef" /> parametr nie jest poprawnie sformułowany.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do konfigurowania typów komunikacji zdalnej i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla konfiguracji infrastruktury komunikacji zdalnej. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
  </Members>
</Type>
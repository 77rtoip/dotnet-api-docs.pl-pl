<Type Name="RemotingServices" FullName="System.Runtime.Remoting.RemotingServices">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="56e4b36797e7345ce0280d99cdf2a9aa7a27d094" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36534578" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class RemotingServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed RemotingServices extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingServices" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingServices" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingServices = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia kilka metod przy użyciu i publikowania zdalny obiektów i serwerów proxy. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jesteś dostawcą usług dotyczących problemów, takich jak aktywacji, zarządzanie okresem istnienia lub transakcji jest konieczne rozróżnienia odwołuje się do serwera proxy i odwołania do obiektów. W zdalnej infrastrukturze używa przezroczysty serwerów proxy, które dają pogląd, że obiektów zdalnych znajdują się w obszarze klienta. Serwery proxy można to osiągnąć poprzez przesłanie wywołania na nich rzeczywistych obiektów w lokalizacjach zdalnych.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy serwer proxy dla obiekt dobrze znany.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classToProxy">
          <see cref="T:System.Type" /> Dobrze znanego obiektu po stronie serwera, z którym chcesz się połączyć.</param>
        <param name="url">Adres URL serwera klasy.</param>
        <summary>Tworzy serwer proxy dla obiekt dobrze znanego <see cref="T:System.Type" /> i adres URL.</summary>
        <returns>Serwer proxy do obiektu zdalnego, która wskazuje punkt końcowy obsługiwana przez określony obiekt dobrze znany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt zwrócony proxy wskazuje obsługiwana przez określony obiekt dobrze znanego punktu końcowego. Nie komunikaty są wysyłane za pośrednictwem sieci, dopóki metoda jest wywoływana na serwerze proxy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Runtime.Remoting.RemotingServices.Connect%2A> metodę w celu utworzenia serwera proxy do dobrze znanego obiektu.  
  
 [!code-cpp[RemotingServices.BasicSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/basicclient.cpp#1)]
 [!code-csharp[RemotingServices.BasicSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/basicclient.cs#1)]
 [!code-vb[RemotingServices.BasicSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/basicclient.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia do konfigurowania usług zdalnych typy i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do konfiguracji w zdalnej infrastrukturze. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String, data As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string * obj -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="classToProxy">
          <see cref="T:System.Type" /> Dobrze znanego obiektu, z którym chcesz się połączyć.</param>
        <param name="url">Adres URL dobrze znanego obiektu.</param>
        <param name="data">Kanał określonych danych. Może być <see langword="null" />.</param>
        <summary>Tworzy serwer proxy dla obiekt dobrze znanego <see cref="T:System.Type" />, adres URL i dane specyficzne dla kanału.</summary>
        <returns>Serwer proxy, który wskazuje punktu końcowego, który jest obsługiwana przez dobrze znanego żądanego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt zwrócony proxy wskazuje obsługiwana przez określony obiekt dobrze znanego punktu końcowego. Nie komunikaty są wysyłane za pośrednictwem sieci, dopóki metoda jest wywoływana na serwerze proxy.  
  
 `data` Obiektu służy do przekazywania informacji do kanału i jest przekazywana do <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia do konfigurowania usług zdalnych typy i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do konfiguracji w zdalnej infrastrukturze. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public static bool Disconnect (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Disconnect(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Disconnect (obj As MarshalByRefObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Disconnect(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member Disconnect : MarshalByRefObject -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.Disconnect obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, aby rozłączyć kanału.</param>
        <summary>Zatrzymuje obiektu odbieranie wszelkich dalsze komunikaty za pośrednictwem kanałów zarejestrowanych usług zdalnych.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekt został odłączony od zdalnych zarejestrowanych kanałów pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> metodę, aby rozłączyć obiektu zdalnych kanałów.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> Parametr jest serwer proxy.</exception>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia do konfigurowania usług zdalnych typy i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do konfiguracji w zdalnej infrastrukturze. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMessage">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(class System.MarshalByRefObject target, class System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExecuteMessage (target As MarshalByRefObject, reqMsg As IMethodCallMessage) As IMethodReturnMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMethodReturnMessage ^ ExecuteMessage(MarshalByRefObject ^ target, System::Runtime::Remoting::Messaging::IMethodCallMessage ^ reqMsg);" />
      <MemberSignature Language="F#" Value="static member ExecuteMessage : MarshalByRefObject * System.Runtime.Remoting.Messaging.IMethodCallMessage -&gt; System.Runtime.Remoting.Messaging.IMethodReturnMessage" Usage="System.Runtime.Remoting.RemotingServices.ExecuteMessage (target, reqMsg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMethodReturnMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.MarshalByRefObject" />
        <Parameter Name="reqMsg" Type="System.Runtime.Remoting.Messaging.IMethodCallMessage" />
      </Parameters>
      <Docs>
        <param name="target">Zdalnego obiekt, którego chcesz wywołać metodę.</param>
        <param name="reqMsg">— Metoda komunikat wywołanie do metody określonego obiektu zdalnego.</param>
        <summary>Łączy do określonego obiektu zdalnego i wykonuje dostarczonych <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" /> na nim.</summary>
        <returns>Odpowiedź metody zdalnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżącej metody jest używany do przekazywania określonej metody wywołania do innego, prawdopodobnie zdalnego obiektu w szczególnych przypadkach przez serwer. Ta metoda może być wywołana tylko wtedy, gdy obiekt wywołujący w odpowiedniego kontekstu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> metody do wywołania metody do obiektów zdalnych przekazywania.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Metoda została wywołana w kontekście innym niż w macierzystym kontekście obiektu.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvoyChainForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvoyChainForProxy (obj As MarshalByRefObject) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMessageSink ^ GetEnvoyChainForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetEnvoyChainForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Serwer proxy żądanym wychwytywanie wysłannika obiektu zdalnego są skojarzone z.</param>
        <summary>Zwraca łańcuch wychwytywanie wysłannika, które powinny być używane podczas wysyłania wiadomości do zdalnego obiektu reprezentowanego przez określony serwer proxy.</summary>
        <returns>Łańcuch wychwytywanie wysłannika skojarzone z określonym serwerem proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wychwytywanie wysłannika są wychwytywanie wysłane razem z <xref:System.Runtime.Remoting.ObjRef> obiektu, który jest używany podczas zwracania komunikaty do tego obiektu. Bieżąca metoda zwraca wychwytywanie wysłannika, które są używane podczas komunikacji między serwerem proxy obiektu, a sam obiekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.IEnvoyInfo" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public static object GetLifetimeService (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLifetimeService(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLifetimeService (obj As MarshalByRefObject) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLifetimeService(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetLifetimeService : MarshalByRefObject -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.GetLifetimeService obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt uzyskać usługę okres istnienia.</param>
        <summary>Zwraca obiekt usługi okres istnienia, który określa okres istnienia zasad określonego obiektu.</summary>
        <returns>Obiekt, który określa okres istnienia <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny okres istnienia usługi zwrócony obiekt zostanie obiekt typu <xref:System.Runtime.Remoting.Lifetime.ILease>. Jeśli `obj` parametr jest `null`, metoda zwraca `null`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> metodę, aby uzyskać dzierżawę okres istnienia dla określonego obiektu.  
  
 [!code-cpp[RemotingServices.TimerSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.TimerSample/CPP/timerclient.cpp#1)]
 [!code-csharp[RemotingServices.TimerSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerclient.cs#1)]
 [!code-vb[RemotingServices.TimerSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerclient.vb#1)]  
  
 Aby skompilować i uruchomić ten przykład, należy skompilować i uruchomić timerservice.dll serwera, timerserver.exe i kompilacji biblioteki współużytkowanej.  
  
 Źródło timerserver.exe w następujący sposób:  
  
 [!code-csharp[RemotingServices.TimerSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerserver.cs#2)]
 [!code-vb[RemotingServices.TimerSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerserver.vb#2)]  
  
 Źródło timerservice.dll w następujący sposób:  
  
 [!code-csharp[RemotingServices.TimerSample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerservice.cs#3)]
 [!code-vb[RemotingServices.TimerSample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerservice.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBaseFromMethodMessage">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodBaseFromMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodBaseFromMethodMessage (msg As IMethodMessage) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodBaseFromMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetMethodBaseFromMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; System.Reflection.MethodBase" Usage="System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Metoda komunikat do wyodrębniania metody podstawowej z.</param>
        <summary>Zwraca metodę podstawową z danym <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />.</summary>
        <returns>Base — metoda wyodrębniony z <paramref name="msg" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określa podstawowy z metody <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>, <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>, i <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> właściwości <xref:System.Runtime.Remoting.Messaging.IMethodMessage> i jest używany przez Implementacja klasy <xref:System.Runtime.Remoting.Messaging.IMethodMessage> interfejsu. Kto jest odbiorcą docelowym <xref:System.Runtime.Remoting.Messaging.IMethodMessage> klas powinien odwoływać <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury albo co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do pobierania informacji o typie niepublicznych elementów członkowskich.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetObjectData(object obj, class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetObjectData (obj As Object, info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetObjectData(System::Object ^ obj, System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="static member GetObjectData : obj * System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.GetObjectData (obj, info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do zserializowania.</param>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Do którego serializowany jest obiekt.</param>
        <param name="context">Źródło i miejsce docelowe serializacji.</param>
        <summary>Serializuje określony kierowanie przez obiekt odwołania do dostarczonego <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> Lub <paramref name="info" /> parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectUri">
      <MemberSignature Language="C#" Value="public static string GetObjectUri (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetObjectUri(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectUri (obj As MarshalByRefObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetObjectUri(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectUri : MarshalByRefObject -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetObjectUri obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.MarshalByRefObject" /> Dla jest żądany identyfikator URI.</param>
        <summary>Pobiera identyfikator URI dla określonego obiektu.</summary>
        <returns>Identyfikator URI określony obiekt, jeśli istnieje, lub <see langword="null" /> Jeśli obiekt nie ma jeszcze zorganizować.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#18)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#18)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjRefForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef GetObjRefForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjRefForProxy (obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ GetObjRefForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjRefForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.GetObjRefForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Połączony serwer proxy do obiektu, którego chcesz utworzyć <see cref="T:System.Runtime.Remoting.ObjRef" /> dla.</param>
        <summary>Zwraca <see cref="T:System.Runtime.Remoting.ObjRef" /> reprezentujący obiektu zdalnego z określonego serwera proxy.</summary>
        <returns>A <see cref="T:System.Runtime.Remoting.ObjRef" /> reprezentujący obiektu zdalnego jest połączony określonego serwera proxy, lub <see langword="null" /> Jeśli obiekt lub serwer proxy nie mają zorganizowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Runtime.Remoting.ObjRef> jest możliwy do serializacji reprezentację obiekt używany do przesyłania odwołanie do obiektu granicy domeny aplikacji. Tworzenie <xref:System.Runtime.Remoting.ObjRef> dla obiekt nosi nazwę przekazywanie. <xref:System.Runtime.Remoting.ObjRef> Mogą być transferowane za pośrednictwem kanału do innej domeny aplikacji (prawdopodobnie na inny proces lub komputer). Raz w innej domenie aplikacji <xref:System.Runtime.Remoting.ObjRef> musi być analizowana do utworzenia serwera proxy dla obiekt zazwyczaj podłączone do rzeczywistego obiektu. Ta operacja nosi nazwę unmarshaling. Podczas unmarshaling, <xref:System.Runtime.Remoting.ObjRef> jest analizowany w celu wyodrębnienia informacji metody obiektu zdalnego i obu przezroczystego obiektu pośredniczącego i <xref:System.Runtime.Remoting.Proxies.RealProxy> obiekty są tworzone.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje opisujące <xref:System.Type> i klasa obiektu są przekazywane, identyfikator URI, który unikatowo identyfikuje wystąpienie określonego obiektu i komunikacja powiązane informacje o możliwości dotarcia aplikacji zdalnej gdzie znajduje się obiekt.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak uzyskać <xref:System.Runtime.Remoting.ObjRef> wystąpienia dla określonego obiektu.  
  
 [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CPP/client.cpp#1)]
 [!code-csharp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CS/client.cs#1)]
 [!code-vb[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRealProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRealProxy (proxy As Object) As RealProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Proxies::RealProxy ^ GetRealProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member GetRealProxy : obj -&gt; System.Runtime.Remoting.Proxies.RealProxy" Usage="System.Runtime.Remoting.RemotingServices.GetRealProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Proxies.RealProxy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Przezroczystego obiektu pośredniczącego.</param>
        <summary>Zwraca rzeczywistego obiektu pośredniczącego, tworzenie kopii określonego przezroczystego obiektu pośredniczącego.</summary>
        <returns>Wystąpienie rzeczywistego obiektu pośredniczącego kopii przezroczystego obiektu pośredniczącego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klient, który używa obiektu na dowolny rodzaj granic komunikacji zdalnej jest rzeczywiście przy użyciu przezroczystego obiektu pośredniczącego dla obiekt. Przezroczystego obiektu pośredniczącego daje wrażenie, że rzeczywistego obiektu znajduje się w obszarze klienta. Go osiąga to poprzez przesłanie wywołania na nim rzeczywistego obiektu przy użyciu infrastruktury komunikacji zdalnej.  
  
 Przezroczystego obiektu pośredniczącego nie jest obsługiwana przez wystąpienie klasy zarządzanego środowiska wykonawczego typu <xref:System.Runtime.Remoting.Proxies.RealProxy>. <xref:System.Runtime.Remoting.Proxies.RealProxy> Zaimplementowano część funkcji potrzebnych do przekazywania operacje z przezroczystego obiektu pośredniczącego.  
  
 Obiekt serwera proxy dziedziczy semantykę skojarzone obiekty zarządzane, takie jak wyrzucanie elementów bezużytecznych, obsługuje metod i elementów członkowskich i może zostać rozszerzony do formularza nowych klas. Serwer proxy działa jako obiekt tej samej klasy do obiektu zdalnego (przezroczystego obiektu pośredniczącego) i jest również zarządzanego obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetServerTypeForUri">
      <MemberSignature Language="C#" Value="public static Type GetServerTypeForUri (string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetServerTypeForUri(string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetServerTypeForUri (URI As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetServerTypeForUri(System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member GetServerTypeForUri : string -&gt; Type" Usage="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri URI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="URI">Identyfikator URI obiektu, którego <see cref="T:System.Type" /> jest wymagane.</param>
        <summary>Zwraca <see cref="T:System.Type" /> obiektu z określonym identyfikatorem URI.</summary>
        <returns>
          <see cref="T:System.Type" /> Obiektu z określonym identyfikatorem URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ remoting identyfikuje punktów końcowych przy użyciu identyfikatorów URI, <xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> metoda jest przydatne w przypadku plug w zdalnej infrastrukturze (na przykład wychwytywanie kanału, dynamiczne wychwytywanie i kontekstu wychwytywanie) używające <xref:System.Runtime.Remoting.Messaging.IMessage> obiektów, ponieważ bieżący Metoda zwraca obiekt typu skojarzonego z identyfikatora URI.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#7)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#7)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury albo co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do pobierania informacji o typie niepublicznych elementów członkowskich.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby pobrać informacje o typie niepublicznych elementów członkowskich. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetSessionIdForMethodMessage">
      <MemberSignature Language="C#" Value="public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetSessionIdForMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSessionIdForMethodMessage (msg As IMethodMessage) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetSessionIdForMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetSessionIdForMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">
          <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> Dla jest żądany identyfikator sesji.</param>
        <summary>Pobiera identyfikator sesji dla wiadomości.</summary>
        <returns>Ciąg Identyfikatora sesji, który unikatowo identyfikuje bieżącej sesji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten sam identyfikator sesji może być zwrócony dla obiektów w tej samej aplikacji, ale ta metoda zwróci nigdy tego samego Identyfikatora sesji dla dwóch obiektów w innych aplikacjach zdalnego.  
  
 Aby uzyskać więcej informacji na temat identyfikowania sesji i identyfikatory sesji, zobacz ASP.Net [przegląd stanu sesji ASP.NET](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak pobrać ciąg Identyfikatora sesji dla bieżącej sesji.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsMethodOverloaded">
      <MemberSignature Language="C#" Value="public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMethodOverloaded(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMethodOverloaded (msg As IMethodMessage) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMethodOverloaded(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member IsMethodOverloaded : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsMethodOverloaded msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Komunikat, który zawiera wywołanie metody zagrożona.</param>
        <summary>Zwraca wartość logiczną, wskazującą, czy w podanym komunikatem metody jest przeciążona.</summary>
        <returns>
          <see langword="true" /> Jeśli metoda jest wywoływana <paramref name="msg" /> jest przeciążony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfAppDomain">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfAppDomain (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfAppDomain(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfAppDomain (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfAppDomain(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfAppDomain : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Obiekt do sprawdzenia.</param>
        <summary>Zwraca wartość logiczną, wskazującą, czy obiekt określony przez dany przezroczystego obiektu pośredniczącego znajduje się w domenie aplikacji innej niż obiekt, który wywołał bieżącej metody.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekt jest poza bieżącej domeny aplikacji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacji o domenach aplikacji, zobacz [domen aplikacji](http://msdn.microsoft.com/library/39e57d07-a740-4cd4-ae82-e119ea3856c1).  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfContext">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfContext (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfContext(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfContext (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfContext(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfContext : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Obiekt do sprawdzenia.</param>
        <summary>Zwraca wartość logiczną, wskazującą, czy obiekt reprezentowany przez dany serwer proxy znajduje się w innym kontekście niż obiekt, który wywołuje bieżącej metody.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekt jest poza bieżącym kontekście; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontekst jest uporządkowana sekwencja właściwości, które definiują środowisko dla obiektów, które znajdują się w nim. Konteksty są tworzone w procesie aktywacji dla obiektów, które są skonfigurowane do żądania niektóre automatyczne usługi takie synchronizacji, transakcje, w czasie aktywacji, zabezpieczeń i tak dalej. Wiele obiektów na żywo można w kontekście.  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Contexts.Context" />
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public static bool IsOneWay (System.Reflection.MethodBase method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOneWay(class System.Reflection.MethodBase method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOneWay (method As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOneWay(System::Reflection::MethodBase ^ method);" />
      <MemberSignature Language="F#" Value="static member IsOneWay : System.Reflection.MethodBase -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsOneWay method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="method">Metoda zagrożona.</param>
        <summary>Zwraca wartość logiczną, wskazującą, czy klient, który wywołał metodę określone w tego komunikatu oczekuje na zakończenie przetwarzania metody przed kontynuowaniem wykonywania serwera.</summary>
        <returns>
          <see langword="true" /> Jeśli metoda jest jednokierunkowa; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu metody jednokierunkowe klienta nie oczekuje na zakończenie przetwarzania komunikatu serwera. Zwraca metodę klienta stosowanie nie wie, czy serwer pomyślnie przetworzy komunikat. Metody są oznaczone jako jednokierunkowej przy użyciu <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.  
  
 Metody jednokierunkowe nie mogą mieć wartości zwracanej ani żadnych parametrów wyjściowych.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#2)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#2)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Bezpośredniego obiektu wywołującego nie ma uprawnienia infrastruktury.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem infrastruktury. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsTransparentProxy">
      <MemberSignature Language="C#" Value="public static bool IsTransparentProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTransparentProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTransparentProxy (proxy As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTransparentProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member IsTransparentProxy : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsTransparentProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Odwołanie do obiektu do sprawdzenia.</param>
        <summary>Zwraca wartość logiczną, wskazującą, czy dany obiekt jest przezroczystego obiektu pośredniczącego lub rzeczywistego obiektu.</summary>
        <returns>Wartość logiczna, która wskazuje, czy obiekt określony w <paramref name="proxy" /> parametru czy przezroczystego obiektu pośredniczącego rzeczywistego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klient, który używa obiektu na dowolny rodzaj granic komunikacji zdalnej jest rzeczywiście przy użyciu przezroczystego obiektu pośredniczącego dla obiekt. Przezroczystego obiektu pośredniczącego daje wrażenie, że rzeczywistego obiektu znajduje się w obszarze klienta. Go osiąga to poprzez przesłanie wywołania na nim rzeczywistego obiektu przy użyciu infrastruktury komunikacji zdalnej.  
  
 Przezroczystego obiektu pośredniczącego jest przechowywanych przez wystąpienie klasy zarządzanego środowiska wykonawczego typu <xref:System.Runtime.Remoting.Proxies.RealProxy>. <xref:System.Runtime.Remoting.Proxies.RealProxy> Zaimplementowano część funkcji potrzebnych do przekazywania operacje z przezroczystego obiektu pośredniczącego. Obiekt serwera proxy dziedziczy semantykę skojarzone obiekty zarządzane, takie jak wyrzucanie elementów bezużytecznych, obsługuje metod i elementów członkowskich i może zostać rozszerzony do formularza nowych klas. W związku z tym serwer proxy ma charakter podwójną; z jednej strony wymaga do działania jako obiekt o tej samej klasy do obiektu zdalnego (przezroczystego obiektu pośredniczącego), a w drugim jest samego obiektu zarządzanego.  
  
 Obiekt serwera proxy można niezależnie jakiekolwiek podziały komunikacji zdalnej w ramach <xref:System.AppDomain>. Aplikacje muszą rozróżnia odwołuje się do serwera proxy i odwołania do obiektów. Jednak usługodawców dotyczących problemów, takich jak aktywacja Zarządzanie okresem istnienia i transakcji konieczne dokonanie takiego rozróżnienia.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> metodę, aby określić, czy obiekt jest serwer proxy lub rzeczywistego obiektu. Pełny przykład kodu, zobacz przykład <xref:System.Runtime.Remoting.Messaging.AsyncResult> klasy.  
  
 [!code-cpp[AsyncResult.NewExamples#6](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncResult.NewExamples/CPP/ad.cpp#6)]
 [!code-csharp[AsyncResult.NewExamples#6](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncResult.NewExamples/CS/ad.cs#6)]
 [!code-vb[AsyncResult.NewExamples#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncResult.NewExamples/VB/ad.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="LogRemotingStage">
      <MemberSignature Language="C#" Value="public static void LogRemotingStage (int stage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogRemotingStage(int32 stage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogRemotingStage (stage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LogRemotingStage(int stage);" />
      <MemberSignature Language="F#" Value="static member LogRemotingStage : int -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.LogRemotingStage stage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("REMOTING_PERF")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("It existed for only internal use in .NET and unimplemented in mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stage">Wewnętrznie zdefiniowaną stałą, identyfikujący etapem exchange komunikacji zdalnej.</param>
        <summary>Rejestruje etap w zdalnych w programie exchange zewnętrznego debugera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A `"REMOTING_PERF"` przetwarzania wstępnego symbol jest stosowana do metody przy użyciu <xref:System.Diagnostics.ConditionalAttribute> atrybutu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do konfiguracji w zdalnej infrastrukturze. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Marshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje dany <see cref="T:System.MarshalByRefObject" /> w wystąpienie klasy <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy, która może być Zserializowany transmisji między domenami aplikacji i za pośrednictwem sieci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal Obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="Obj">Obiekt do przekonwertowania.</param>
        <summary>Przyjmuje <see cref="T:System.MarshalByRefObject" />, rejestruje go w zdalnej infrastrukturze i konwertuje ją na wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy.</summary>
        <returns>Wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasa, która reprezentuje obiekt określony w <paramref name="Obj" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Runtime.Remoting.ObjRef> jest możliwy do serializacji reprezentację obiekt używany do przesyłania odwołanie do obiektu granicy domeny aplikacji. Tworzenie <xref:System.Runtime.Remoting.ObjRef> dla obiekt nosi nazwę przekazywanie. <xref:System.Runtime.Remoting.ObjRef> Mogą być transferowane za pośrednictwem kanału do innej domeny aplikacji (prawdopodobnie na inny proces lub komputer). Raz w innej domenie aplikacji <xref:System.Runtime.Remoting.ObjRef> musi być analizowana do utworzenia serwera proxy dla obiekt zazwyczaj podłączone do rzeczywistego obiektu. Ta operacja nosi nazwę unmarshaling.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje opisujące <xref:System.Type> i klasa obiektu są przekazywane, identyfikator URI, który unikatowo identyfikuje wystąpienie określonego obiektu i komunikacja powiązane informacje o możliwości dotarcia części usług zdalnych gdzie znajduje się obiekt.  
  
 Podczas przekazywania międzyprocesowego, kontekst z bieżącym wątku jest używany, nie kontekst który był aktywny podczas tworzenia obiektu. Jeśli identyfikator URI nie została jawnie ustawiona przez <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> metody, jest ona generowana automatycznie przez infrastrukturę tożsamości usług zdalnych.  
  
 Nie można skojarzyć identyfikatora URI z serwera proxy dla jednej z dwóch powodów: identyfikator URI został wygenerowany po stronie serwera dla obiekt reprezentuje albo obiekt jest dobrze znany, w którym to przypadku jest znany identyfikator URI. Dlatego jeśli `Obj` parametr jest serwer proxy, zostanie wygenerowany wyjątek. Dla niestandardowych proxy to ograniczenie jest rozluźnić, ponieważ przezroczystego obiektu pośredniczącego jest traktowane jako obiektu serwera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" /> Parametr jest obiekt serwera proxy.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do konfigurowania usług zdalnych typy i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do konfiguracji w zdalnej infrastrukturze. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, URI As String) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, URI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Obj">Obiekt do przekonwertowania.</param>
        <param name="URI">Określony identyfikator URI, z którą ma zostać zainicjować nowe <see cref="T:System.Runtime.Remoting.ObjRef" />. Może być <see langword="null" />.</param>
        <summary>Konwertuje dany <see cref="T:System.MarshalByRefObject" /> w wystąpienie klasy <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy z określonym identyfikatorem URI.</summary>
        <returns>Wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasa, która reprezentuje obiekt określony w <paramref name="Obj" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Runtime.Remoting.ObjRef> jest możliwy do serializacji reprezentację obiekt używany do przesyłania odwołanie do obiektu granicy domeny aplikacji. Tworzenie <xref:System.Runtime.Remoting.ObjRef> dla obiekt nosi nazwę przekazywanie. <xref:System.Runtime.Remoting.ObjRef> Mogą być transferowane za pośrednictwem kanału do innej domeny aplikacji (prawdopodobnie na inny proces lub komputer). Raz w innej domenie aplikacji <xref:System.Runtime.Remoting.ObjRef> musi być analizowana do utworzenia serwera proxy dla obiekt zazwyczaj podłączone do rzeczywistego obiektu. Ta operacja nosi nazwę unmarshaling.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje opisujące <xref:System.Type> i klasa obiektu są przekazywane, identyfikator URI, który unikatowo identyfikuje wystąpienie określonego obiektu i komunikacja powiązane informacje o możliwości dotarcia części usług zdalnych gdzie znajduje się obiekt.  
  
 Podczas przekazywania międzyprocesowego, kontekst z bieżącym wątku jest używany, nie kontekst który był aktywny podczas tworzenia obiektu.  
  
 Nie można skojarzyć identyfikatora URI z serwera proxy dla jednej z dwóch powodów: identyfikator URI został wygenerowany po stronie serwera dla obiekt reprezentuje albo obiekt jest dobrze znany, w którym to przypadku jest znany identyfikator URI. Dlatego jeśli `Obj` parametr jest serwer proxy, zostanie wygenerowany wyjątek. Dla niestandardowych proxy to ograniczenie jest rozluźnić, ponieważ przezroczystego obiektu pośredniczącego jest traktowane jako obiektu serwera.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia bieżącego <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> metody do organizowania określonego obiektu.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" /> jest serwer proxy obiektu i <paramref name="URI" /> parametr nie jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do konfigurowania usług zdalnych typy i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do konfiguracji w zdalnej infrastrukturze. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string ObjURI, class System.Type RequestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, ObjURI As String, RequestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ ObjURI, Type ^ RequestedType);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string * Type -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, ObjURI, RequestedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="ObjURI" Type="System.String" />
        <Parameter Name="RequestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="Obj">Obiekt do przekonwertowania na <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <param name="ObjURI">Obiekt określony w identyfikatorze URI <c>Obj</c> parametru jest przekazywane z. Może być <see langword="null" />.</param>
        <param name="RequestedType">
          <see cref="T:System.Type" />
          <c>Obj</c> jest przekazywane jako. Może być <see langword="null" />.</param>
        <summary>Przyjmuje <see cref="T:System.MarshalByRefObject" /> i konwertuje ją na wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasy z określonym identyfikatorem URI i udostępnionych <see cref="T:System.Type" />.</summary>
        <returns>Wystąpienie <see cref="T:System.Runtime.Remoting.ObjRef" /> klasa, która reprezentuje obiekt określony w <paramref name="Obj" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Runtime.Remoting.ObjRef> jest możliwy do serializacji reprezentację obiekt używany do przesyłania odwołanie do obiektu granicy domeny aplikacji. Tworzenie <xref:System.Runtime.Remoting.ObjRef> dla obiekt nosi nazwę przekazywanie. <xref:System.Runtime.Remoting.ObjRef> Mogą być transferowane za pośrednictwem kanału do innej domeny aplikacji (prawdopodobnie na inny proces lub komputer). Raz w innej domenie aplikacji <xref:System.Runtime.Remoting.ObjRef> musi być analizowana do utworzenia serwera proxy dla obiekt zazwyczaj podłączone do rzeczywistego obiektu. Ta operacja nosi nazwę unmarshaling.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje opisujące <xref:System.Type> i klasa obiektu są przekazywane, identyfikator URI, który unikatowo identyfikuje wystąpienie określonego obiektu i komunikacja powiązane informacje o możliwości dotarcia części usług zdalnych gdzie znajduje się obiekt.  
  
 Określony <xref:System.Type> jest używany przez w zdalnej infrastrukturze, aby ograniczyć zakres hierarchii typów uwidocznione. Na przykład, jeśli obiekt A pochodzi z obiektu B, który pochodzi z obiektu C, a <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> nosi nazwę, a następnie klienta można rzutować proxy między C i B, ale nie do serwera A.  
  
 Podczas przekazywania międzyprocesowego, kontekst z bieżącym wątku jest używany, nie kontekst który był aktywny podczas tworzenia obiektu.  
  
 Nie można skojarzyć identyfikatora URI z serwera proxy dla jednej z dwóch powodów: identyfikator URI został wygenerowany po stronie serwera dla obiekt reprezentuje albo obiekt jest dobrze znany, w którym to przypadku jest znany identyfikator URI. Dlatego jeśli `Obj` parametr jest serwer proxy, zostanie wygenerowany wyjątek. Dla niestandardowych proxy to ograniczenie jest rozluźnić, ponieważ przezroczystego obiektu pośredniczącego jest traktowane jako obiektu serwera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" /> Serwer proxy obiektu zdalnego i <paramref name="ObjUri" /> parametr nie jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do konfigurowania usług zdalnych typy i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do konfiguracji w zdalnej infrastrukturze. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="SetObjectUriForMarshal">
      <MemberSignature Language="C#" Value="public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetObjectUriForMarshal(class System.MarshalByRefObject obj, string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetObjectUriForMarshal (obj As MarshalByRefObject, uri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetObjectUriForMarshal(MarshalByRefObject ^ obj, System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member SetObjectUriForMarshal : MarshalByRefObject * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal (obj, uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Można ustawić identyfikator URI dla obiekt.</param>
        <param name="uri">Identyfikator URI, można przypisać do określonego obiektu.</param>
        <summary>Ustawia identyfikator URI dla kolejne wywołania <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawiony przez metodę bieżący identyfikator URI jest używany podczas organizowania danego obiektu.  
  
 Po przekazywanie, identyfikator URI określony obiekt jest ustawiona na ciąg w `uri` parametru dołączany na <xref:System.Guid> bieżącego <xref:System.AppDomain>.  
  
 Jeśli bieżąca aplikacja nasłuchuje na porcie HTTP, a następnie zarówno ciąg określony w `uri` parametru i `uri` ciąg dołączany na <xref:System.Guid> bieżącego <xref:System.AppDomain> trasy do określonego obiektu. Na przykład, jeśli aplikacja nasłuchuje na porcie HTTP 9000, a następnie zarówno http://localhost:9000/objectUri, i http://localhost:9000/\<appdomainguid>/objectUri trasy do obiektu określonego w `obj` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób ustawiania identyfikatora URI, który będzie używany przez <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> metody podczas organizowania określony obiekt.  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="obj" /> jest lokalny obiekt, został już zorganizowany lub bieżącej metody została już wywołana dla.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do konfigurowania usług zdalnych typy i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do konfiguracji w zdalnej infrastrukturze. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unmarshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje dany <see cref="T:System.Runtime.Remoting.ObjRef" /> na obiekt serwera proxy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal objectRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
      </Parameters>
      <Docs>
        <param name="objectRef">
          <see cref="T:System.Runtime.Remoting.ObjRef" /> Reprezentujący obiektu zdalnego, dla której utworzona jest serwer proxy.</param>
        <summary>Trwa <see cref="T:System.Runtime.Remoting.ObjRef" /> i tworzy obiekt serwera proxy od niego.</summary>
        <returns>Serwer proxy do obiektu który danego <see cref="T:System.Runtime.Remoting.ObjRef" /> reprezentuje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Runtime.Remoting.ObjRef> jest możliwy do serializacji reprezentację obiekt używany do przesyłania odwołanie do obiektu granicy domeny aplikacji. Tworzenie <xref:System.Runtime.Remoting.ObjRef> dla obiekt nosi nazwę przekazywanie. <xref:System.Runtime.Remoting.ObjRef> Mogą być transferowane za pośrednictwem kanału do innej domeny aplikacji (prawdopodobnie na inny proces lub komputer). Raz w innej domenie aplikacji <xref:System.Runtime.Remoting.ObjRef> musi być analizowana do utworzenia serwera proxy dla obiekt zazwyczaj podłączone do rzeczywistego obiektu. Ta operacja nosi nazwę unmarshaling. Podczas unmarshaling, <xref:System.Runtime.Remoting.ObjRef> jest analizowany w celu wyodrębnienia informacji metody obiektu zdalnego i obu przezroczystego obiektu pośredniczącego i <xref:System.Runtime.Remoting.Proxies.RealProxy> obiekty są tworzone. Zawartość przeanalizowany <xref:System.Runtime.Remoting.ObjRef> dodaniu przezroczystego obiektu pośredniczącego przed przezroczystego obiektu pośredniczącego został zarejestrowany za pomocą środowiska CLR.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje opisujące <xref:System.Type> i klasa obiektu są przekazywane, identyfikator URI, który unikatowo identyfikuje wystąpienie określonego obiektu i komunikacja powiązane informacje o możliwości dotarcia części usług zdalnych gdzie znajduje się obiekt.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak wycofać obiektu.  
  
 [!code-cpp[RemotingServices.Unmarshal#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CPP/client.cpp#2)]
 [!code-csharp[RemotingServices.Unmarshal#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CS/client.cs#2)]
 [!code-vb[RemotingServices.Unmarshal#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.Unmarshal/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Runtime.Remoting.ObjRef" /> Określonym w wystąpieniu <paramref name="objectRef" /> parametru nie jest poprawnie sformułowany.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do konfigurowania usług zdalnych typy i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do konfiguracji w zdalnej infrastrukturze. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef, bool fRefine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef, fRefine As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef, bool fRefine);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef * bool -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal (objectRef, fRefine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
        <Parameter Name="fRefine" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="objectRef">
          <see cref="T:System.Runtime.Remoting.ObjRef" /> Reprezentujący obiektu zdalnego, dla której utworzona jest serwer proxy.</param>
        <param name="fRefine">
          <see langword="true" /> Aby uściślić serwera proxy do typu na serwerze; w przeciwnym razie <see langword="false" />.</param>
        <summary>Trwa <see cref="T:System.Runtime.Remoting.ObjRef" /> i tworzy obiekt serwera proxy poza, uściślenie jej typ na serwerze.</summary>
        <returns>Serwer proxy do obiektu który danego <see cref="T:System.Runtime.Remoting.ObjRef" /> reprezentuje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Runtime.Remoting.ObjRef> jest możliwy do serializacji reprezentację obiekt używany do przesyłania odwołanie do obiektu granicy domeny aplikacji. Tworzenie <xref:System.Runtime.Remoting.ObjRef> dla obiekt nosi nazwę przekazywanie. <xref:System.Runtime.Remoting.ObjRef> Mogą być transferowane za pośrednictwem kanału do innej domeny aplikacji (prawdopodobnie na inny proces lub komputer). Raz w innej domenie aplikacji <xref:System.Runtime.Remoting.ObjRef> musi być analizowana do utworzenia serwera proxy dla obiekt zazwyczaj podłączone do rzeczywistego obiektu. Ta operacja nosi nazwę unmarshaling. Podczas unmarshaling, <xref:System.Runtime.Remoting.ObjRef> jest analizowany w celu wyodrębnienia informacji metody obiektu zdalnego i obu przezroczystego obiektu pośredniczącego i <xref:System.Runtime.Remoting.Proxies.RealProxy> obiekty są tworzone. Zawartość przeanalizowany <xref:System.Runtime.Remoting.ObjRef> dodaniu przezroczystego obiektu pośredniczącego przed przezroczystego obiektu pośredniczącego został zarejestrowany za pomocą środowiska CLR.  
  
 A <xref:System.Runtime.Remoting.ObjRef> zawiera informacje opisujące <xref:System.Type> i klasa obiektu są przekazywane, identyfikator URI, który unikatowo identyfikuje wystąpienie określonego obiektu i komunikacja powiązane informacje o możliwości dotarcia części usług zdalnych gdzie znajduje się obiekt.  
  
 Po pierwszym utworzeniu serwera proxy jest typu <xref:System.MarshalByRefObject>. Jak rzutować go do różnych typów w zdalnej infrastrukturze przechowuje informacje o najczęściej używanych typu, aby uniknąć obciążania typ niepotrzebnie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Runtime.Remoting.ObjRef" /> Określonym w wystąpieniu <paramref name="objectRef" /> parametru nie jest poprawnie sformułowany.</exception>
        <exception cref="T:System.Security.SecurityException">Co najmniej jeden z obiektów wywołujących wyżej w stos wywołań nie ma uprawnienia do konfigurowania usług zdalnych typy i kanałów.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do konfiguracji w zdalnej infrastrukturze. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Wartość uprawnienia: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
  </Members>
</Type>
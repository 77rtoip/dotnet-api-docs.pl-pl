<Type Name="ObjectContext" FullName="System.Data.Objects.ObjectContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0739e35dfd766a98d9d788dc1ddf7da712d3e3b2" /><Meta Name="ms.sourcegitcommit" Value="0807ab0a64414edc9b4d09d3877857e83cb7f7a4" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/13/2019" /><Meta Name="ms.locfileid" Value="68972558" /></Metadata><TypeSignature Language="C#" Value="public class ObjectContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ObjectContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.ObjectContext" />
  <TypeSignature Language="VB.NET" Value="Public Class ObjectContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectContext : IDisposable" />
  <TypeSignature Language="F#" Value="type ObjectContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Oferuje funkcje do wykonywania zapytań i pracy z danymi jednostki jako obiektami.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Data.Objects.ObjectContext> Klasa nie jest bezpieczna wątkowo. Nie można zapewnić integralności obiektów danych w <xref:System.Data.Objects.ObjectContext> ramach scenariuszy wielowątkowych.  
  
 <xref:System.Data.Objects.ObjectContext> Klasa jest klasą podstawową służącą do współdziałania z danymi jako obiekty, które są wystąpieniami typów jednostek, które są zdefiniowane w modelu koncepcyjnym. Wystąpienie <xref:System.Data.Objects.ObjectContext> Klasy hermetyzuje następujące elementy:  
  
-   Połączenie z bazą danych w postaci <xref:System.Data.EntityClient.EntityConnection> obiektu.  
  
-   Metadane opisujące model w postaci <xref:System.Data.Metadata.Edm.MetadataWorkspace> obiektu.  
  
-   <xref:System.Data.Objects.ObjectStateManager> Obiekt, który zarządza obiektami utrwalanymi w pamięci podręcznej.  
  
 Gdy warstwa obiektu reprezentująca model koncepcyjny jest generowana przez narzędzia Entity Data Model, Klasa, która reprezentuje <xref:System.Data.Metadata.Edm.EntityContainer> dla modelu, pochodzi <xref:System.Data.Objects.ObjectContext>od.  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie pokazano, jak utworzyć obiekt <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Wykonywanie zapytań dotyczących danych jako obiektów (Entity Framework)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Objects.ObjectContext" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (System.Data.EntityClient.EntityConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As EntityConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
      </Parameters>
      <Docs>
        <param name="connection"><see cref="T:System.Data.EntityClient.EntityConnection" /> Zawiera odwołania do modelu i połączenia ze źródłem danych.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Data.Objects.ObjectContext" /> klasy dla danego połączenia. Podczas konstruowania obszar roboczy metadanych jest wyodrębniany z <see cref="T:System.Data.EntityClient.EntityConnection" /> obiektu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connection" /> Ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connection" /> Jest nieprawidłowy.  
  
—lub— 
Obszar roboczy metadanych jest nieprawidłowy.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::String ^ connectionString);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connectionString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Parametry połączenia, które również zapewniają dostęp do informacji metadanych.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Data.Objects.ObjectContext" /> klasy z podanym ciągiem połączenia i nazwą kontenera jednostki domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `connectionString` Jest to ciąg, który zawiera informacje wymagane do uzyskania dostępu do modelu koncepcyjnego i nawiązania połączenia ze źródłem danych. <xref:System.Data.EntityClient.EntityConnectionStringBuilder> Klasa może służyć do poprawnego formatowania ciągu.  
  
 [Narzędzia Entity Data Model](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb399249(v%3dvs.100)) generują nazwane parametry połączenia, które są przechowywane w pliku konfiguracyjnym aplikacji. Te nazwane parametry połączenia można dostarczyć zamiast `connectionString` parametru podczas tworzenia wystąpienia <xref:System.Data.Objects.ObjectContext> klasy.  
  
   
  
## Examples  
 Przykład w tym temacie jest oparty na [modelu sprzedaży AdventureWorks](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie pokazano, jak utworzyć obiekt <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connectionString" /> Ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connectionString" /> Jest nieprawidłowy.  
  
—lub— 
Obszar roboczy metadanych jest nieprawidłowy.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (System.Data.EntityClient.EntityConnection connection, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connection As EntityConnection, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connection, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connection"><see cref="T:System.Data.EntityClient.EntityConnection" /> Zawiera odwołania do modelu i połączenia ze źródłem danych.</param>
        <param name="defaultContainerName">Nazwa domyślnego kontenera jednostek. <paramref name="defaultContainerName" /> Gdy jest ustawiana za pomocą tej metody, właściwość jest tylko do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Data.Objects.ObjectContext" /> klasy z danym połączeniem i nazwą kontenera jednostek.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connection" /> Ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException">Obszar roboczy <paramref name="defaultContainerName" />metadanych ,lubjestnieprawidłowy.<paramref name="connection" /></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (string connectionString, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string connectionString, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connectionString As String, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::String ^ connectionString, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connectionString, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Parametry połączenia, które również zapewniają dostęp do informacji metadanych.</param>
        <param name="defaultContainerName">Nazwa domyślnego kontenera jednostek. <paramref name="defaultContainerName" /> Gdy jest ustawiana za pomocą tej metody, właściwość jest tylko do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Data.Objects.ObjectContext" /> klasy z podanym ciągiem połączenia i nazwą kontenera jednostek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `connectionString` Jest to ciąg, który zawiera informacje wymagane do uzyskania dostępu do modelu koncepcyjnego i nawiązania połączenia ze źródłem danych. <xref:System.Data.EntityClient.EntityConnectionStringBuilder> Klasa może służyć do poprawnego formatowania ciągu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connectionString" /> Ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException">Obszar roboczy <paramref name="defaultContainerName" />metadanych ,lubjestnieprawidłowy.<paramref name="connectionString" /></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="AcceptAllChanges">
      <MemberSignature Language="C#" Value="public void AcceptAllChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptAllChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AcceptAllChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptAllChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptAllChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptAllChanges : unit -&gt; unit" Usage="objectContext.AcceptAllChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Akceptuje wszystkie zmiany wprowadzone do obiektów w kontekście obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Akceptuje zmiany we wszystkich skojarzonych pozycjach w <xref:System.Data.Objects.ObjectStateManager> tak, że ich wynikowy stan jest niezmieniony lub odłączony.  
  
 Ta metoda wykonuje iterację wszystkich <xref:System.Data.Objects.ObjectStateEntry> obiektów <xref:System.Data.Objects.ObjectStateManager> w obiekcie, które są dodawane lub modyfikowane, a następnie ustawia stan wpisu na niezmieniony. Usunięte elementy zostaną odłączone.  
  
 Jeśli metoda została wywołana <xref:System.Data.Objects.SaveOptions.AcceptAllChangesAfterSave> i nie została określona, użytkownik musi wywołać <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> metodę. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> Metoda jest przydatna w scenariuszu, w którym transakcja zakończyła się niepowodzeniem, a użytkownik chce ponowić próbę.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="AddObject">
      <MemberSignature Language="C#" Value="public void AddObject (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddObject(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AddObject(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddObject (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddObject(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AddObject : string * obj -&gt; unit" Usage="objectContext.AddObject (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Reprezentuje nazwę zestawu jednostek, która może być opcjonalnie kwalifikowana przez nazwę kontenera jednostek.</param>
        <param name="entity"><see cref="T:System.Object" /> Do dodania.</param>
        <summary>Dodaje obiekt do kontekstu obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie metody <xref:System.Data.Objects.ObjectContext.AddObject%2A> w celudodaniaobiektudokontekstuobiektu.<xref:System.Data.Objects.ObjectContext> Zrób to, gdy obiekt jest nowym obiektem, który nie istnieje jeszcze w źródle danych. Aby uzyskać więcej informacji, zobacz Dołączanie [i odłączanie obiektów](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Obiekty są <xref:System.Data.Objects.ObjectStateManager> dodawane do <xref:System.Data.EntityState.Deleted> lub <xref:System.Data.EntityState.Detached> wstanie.<xref:System.Data.EntityState.Added>  
  
 Podczas tworzenia nowego obiektu, który jest powiązany z innym obiektem w kontekście obiektu, należy dodać obiekt za pomocą jednej z następujących metod:  
  
-   Wywołaj <xref:System.Data.Objects.DataClasses.EntityCollection%601> metodę na i określ powiązany obiekt. <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> Zrób to dla relacji jeden-do-wielu lub wiele-do-wielu.  
  
-   <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A> Ustaw właściwość <xref:System.Data.Objects.DataClasses.EntityReference%601> na obiekt pokrewny. Zrób to dla relacji jeden-do-jednego lub wiele-do-jednego.  
  
 Aby uzyskać więcej informacji, zobacz [Tworzenie, Dodawanie, modyfikowanie i usuwanie obiektów](https://msdn.microsoft.com/library/f76f1fad-c553-4b59-820b-89b3dec2fad1).  
  
 Jeśli obiekt jest w stanie odłączonym, nie może mieć elementu <xref:System.Data.EntityKey>.  
  
 Reguły dla tego `entitySetName` formatu są następujące:  
  
-   Jeśli właściwość ma `null`wartość, `entitySetName` musi być w  *\<pełni kwalifikowana jako nazwa kontenera jednostek >.* <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A>  *Nazwa\<zestawu jednostek >*.  
  
-   Jeśli <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> tak nie `null`jest, `entitySetName` może być  *\<nazwą kontenera jednostek >*. *Nazwa\<zestawu jednostek >* lub  *\<nazwa zestawu jednostek >*.  
  
 `object` Jeśli <xref:System.Data.Metadata.Edm.EntitySet> ma i mawartość<xref:System.Data.Metadata.Edm.EntitySet> , klucz`entitySetName` jednostki musi być zgodny z znalezionym w oparciu o nazwę kontenera jednostek i. <xref:System.Data.EntityKey> `entitySetName`  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie dodano nowy produkt i zapisuje zmiany w bazie danych.  
  
 [!code-csharp[DP ObjectServices Concepts#AddObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobject)]
 [!code-vb[DP ObjectServices Concepts#AddObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="entity" />  
  
—lub— 
Nie <paramref name="entitySetName" /> kwalifikuje się.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.AddObject(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyCurrentValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyCurrentValues&lt;TEntity&gt; (string entitySetName, TEntity currentEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyCurrentValues&lt;class TEntity&gt;(string entitySetName, !!TEntity currentEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyCurrentValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyCurrentValues(Of TEntity As Class) (entitySetName As String, currentEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyCurrentValues(System::String ^ entitySetName, TEntity currentEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyCurrentValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyCurrentValues (entitySetName, currentEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="currentEntity" Type="TEntity" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Typ jednostki obiektu.</typeparam>
        <param name="entitySetName">Nazwa zestawu jednostek, do którego należy obiekt.</param>
        <param name="currentEntity">Odłączony obiekt, który ma aktualizacje właściwości do zastosowania do oryginalnego obiektu. Klucz <paramref name="currentEntity" /> jednostki musi <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> być zgodny z właściwością wpisu w <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Kopiuje wartości skalarne z podanego obiektu do obiektu w <see cref="T:System.Data.Objects.ObjectContext" /> , który ma ten sam klucz.</summary>
        <returns>Zaktualizowany obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda służy do stosowania zmian dokonanych w obiektach <xref:System.Data.Objects.ObjectContext>poza, takich jak odłączone obiekty, które są odbierane przez usługę sieci Web. <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> Metoda kopiuje wartości skalarne z podanego obiektu do obiektu w <xref:System.Data.Objects.ObjectContext> , który ma ten sam klucz. Możesz użyć <xref:System.Data.EntityKey> odłączonego obiektu, aby pobrać wystąpienie tego obiektu ze źródła danych. Aby uzyskać więcej informacji, zobacz [jak: Zwraca określony obiekt przy użyciu jego klucza](https://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Wszystkie wartości, które różnią się od oryginalnych wartości obiektu, są oznaczane jako zmodyfikowane. Należy zauważyć, że metoda nie stosuje bieżących wartości do powiązanych obiektów `currentEntity`.  
  
 Jeśli masz Graf z bieżącymi wartościami i chcesz zastosować oryginalne wartości, wywołaj <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> metodę.  
  
 Możesz <xref:System.Data.Objects.ObjectSet%601.ApplyCurrentValues%2A> również użyć <xref:System.Data.Objects.ObjectSet%601> metody <xref:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues%2A> lub.<xref:System.Data.Objects.ObjectStateEntry> Aby uzyskać więcej informacji, zobacz [Tworzenie aplikacji N-warstwowych](https://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entitySetName" />lub <paramref name="current" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Data.Metadata.Edm.EntitySet" /> <see cref="T:System.Data.EntityKey" />Element <see cref="T:System.Data.Metadata.Edm.EntitySet" /> from<paramref name="entitySetName" /> nie jest zgodny z obiektem.  
  
—lub— 
Obiekt nie znajduje się w <see cref="T:System.Data.Objects.ObjectStateManager" /> elemencie lub jest <see cref="F:System.Data.EntityState.Detached" /> w stanie.  
  
—lub— 
Klucz jednostki podanego obiektu jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="entitySetName" />jest pustym ciągiem.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyCurrentValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyOriginalValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyOriginalValues&lt;TEntity&gt; (string entitySetName, TEntity originalEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyOriginalValues&lt;class TEntity&gt;(string entitySetName, !!TEntity originalEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyOriginalValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyOriginalValues(Of TEntity As Class) (entitySetName As String, originalEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyOriginalValues(System::String ^ entitySetName, TEntity originalEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyOriginalValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyOriginalValues (entitySetName, originalEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="originalEntity" Type="TEntity" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Typ obiektu jednostki.</typeparam>
        <param name="entitySetName">Nazwa zestawu jednostek, do którego należy obiekt.</param>
        <param name="originalEntity">Odłączony obiekt, który ma oryginalne wartości do zastosowania do obiektu. Klucz <paramref name="originalEntity" /> jednostki musi <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> być zgodny z właściwością wpisu w <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Kopiuje wartości skalarne z podanego obiektu do zestawu oryginalnych wartości dla obiektu w <see cref="T:System.Data.Objects.ObjectContext" /> , który ma ten sam klucz.</summary>
        <returns>Zaktualizowany obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda służy do stosowania zmian dokonanych w obiektach <xref:System.Data.Objects.ObjectContext>poza, takich jak odłączone obiekty, które są odbierane przez usługę sieci Web. <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> Metoda kopiuje wartości skalarne z podanego obiektu do obiektu w <xref:System.Data.Objects.ObjectContext> , który ma ten sam klucz. Możesz użyć <xref:System.Data.EntityKey> odłączonego obiektu, aby pobrać wystąpienie tego obiektu ze źródła danych. Aby uzyskać więcej informacji, zobacz [jak: Zwraca określony obiekt przy użyciu jego klucza](https://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Wszystkie wartości, które różnią się od bieżących wartości obiektu, są oznaczane jako zmodyfikowane. Należy zauważyć, że metoda nie stosuje bieżących wartości do powiązanych obiektów `originalEntity`.  
  
 Jeśli masz wykres z oryginalnymi wartościami i chcesz zastosować bieżące wartości, wywołaj <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> metodę.  
  
 Możesz <xref:System.Data.Objects.ObjectSet%601.ApplyOriginalValues%2A> również użyć <xref:System.Data.Objects.ObjectSet%601> metody <xref:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues%2A> lub.<xref:System.Data.Objects.ObjectStateEntry> Aby uzyskać więcej informacji, zobacz [Tworzenie aplikacji N-warstwowych](https://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entitySetName" />lub <paramref name="original" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Data.Metadata.Edm.EntitySet" /> <see cref="T:System.Data.EntityKey" />Element <see cref="T:System.Data.Metadata.Edm.EntitySet" /> from<paramref name="entitySetName" /> nie jest zgodny z obiektem.  
  
—lub— 
Nie można znaleźć obiektu <see cref="T:System.Data.Objects.ObjectStateManager" />w obiekcie. <see cref="T:System.Data.Objects.ObjectStateEntry" /> —lub— 
Obiekt jest w <see cref="F:System.Data.EntityState.Added" /> <see cref="F:System.Data.EntityState.Detached" /> stanie lub.  
  
—lub— 
Klucz jednostki podanego obiektu jest nieprawidłowy lub ma zmiany właściwości.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="entitySetName" />jest pustym ciągiem.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyOriginalValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyChanges">
      <MemberSignature Language="C#" Value="public void ApplyPropertyChanges (string entitySetName, object changed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyPropertyChanges(string entitySetName, object changed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyPropertyChanges(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyPropertyChanges (entitySetName As String, changed As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyPropertyChanges(System::String ^ entitySetName, System::Object ^ changed);" />
      <MemberSignature Language="F#" Value="member this.ApplyPropertyChanges : string * obj -&gt; unit" Usage="objectContext.ApplyPropertyChanges (entitySetName, changed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use ApplyCurrentValues instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="changed" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Nazwa zestawu jednostek, do którego należy obiekt.</param>
        <param name="changed">Odłączony obiekt, który ma aktualizacje właściwości do zastosowania do oryginalnego obiektu.</param>
        <summary>Stosuje zmiany właściwości z odłączonego obiektu do obiektu już dołączonego do kontekstu obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda służy do stosowania zmian właściwości z zmodyfikowanej, odłączonej wersji obiektu do oryginalnej wersji dołączonej <xref:System.Data.Objects.ObjectContext>do. <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> Obsługuje to takie scenariusze, jak usługi sieci Web, gdzie obiekt jednostki jest odłączony i wysyłany do aplikacji zdalnej, w której są wprowadzane aktualizacje właściwości. Ta metoda pozwala łatwiej zastosować te zmiany z powrotem do oryginalnego obiektu.  
  
 Gdy <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>obiekt jest <xref:System.Data.EntityState.Modified> w stanie. Musisz wywołać <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metodę, aby zaktualizować źródło danych.  
  
 Oryginalny obiekt musi istnieć w <xref:System.Data.Objects.ObjectStateManager> elemencie i musi być <xref:System.Data.EntityState.Modified> w stanie or <xref:System.Data.EntityState.Unchanged> . Oryginalny obiekt jest modyfikowany tylko wtedy, gdy w `changed` obiekcie są modyfikowane właściwości.  
  
 Właściwość podanego obiektu musi być ustawiona na wartość prawidłowy <xref:System.Data.EntityKey>. <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A>  
  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>nie ma wpływu na właściwości nawigacji ani powiązane obiekty.  
  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>Ustawia tylko właściwości, które istnieją w metadanych jednostki dla tego typu. Na przykład właściwości, które są dodawane w klasie częściowej nie są uwzględniane w <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> operacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Gdy <paramref name="entitySetName" /> jest <see langword="null" /> lub jest pustym ciągiem.  
  
—lub— 
Gdy <paramref name="changed" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Gdy element <see cref="T:System.Data.Metadata.Edm.EntitySet" /> nie jest zgodny z obiektem <see cref="T:System.Data.EntityKey" />. <paramref name="entitySetName" /> <see cref="T:System.Data.Metadata.Edm.EntitySet" />  
  
—lub— 
Gdy jednostka jest w stanie innym niż <see cref="F:System.Data.EntityState.Modified" /> lub. <see cref="F:System.Data.EntityState.Unchanged" />  
  
—lub— 
Oryginalny obiekt nie jest dołączony do kontekstu.</exception>
        <exception cref="T:System.ArgumentException">Gdy typ <paramref name="changed" /> obiektu nie jest tego samego typu co oryginalny obiekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (System.Data.Objects.DataClasses.IEntityWithKey entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(class System.Data.Objects.DataClasses.IEntityWithKey entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Attach(System.Data.Objects.DataClasses.IEntityWithKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As IEntityWithKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(System::Data::Objects::DataClasses::IEntityWithKey ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Attach : System.Data.Objects.DataClasses.IEntityWithKey -&gt; unit" Usage="objectContext.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Data.Objects.DataClasses.IEntityWithKey" />
      </Parameters>
      <Docs>
        <param name="entity">Obiekt, który ma zostać dołączony.</param>
        <summary>Dołącza obiekt lub wykres obiektu do kontekstu obiektu, gdy obiekt ma klucz jednostkowy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie metody <xref:System.Data.Objects.ObjectContext.Attach%2A> w celudołączeniaobiektudokontekstuobiektu.<xref:System.Data.Objects.ObjectContext> Zrób to, gdy obiekt już istnieje w źródle danych, ale nie jest obecnie dołączony do kontekstu. Aby uzyskać więcej informacji, zobacz [Dostosowywanie obiektów](https://msdn.microsoft.com/library/af6f07ce-2261-4c65-87cf-d018ad082921).  
  
 <xref:System.Data.Objects.ObjectContext.Attach%2A>służy do dołączania obiektu lub obiektu najwyższego poziomu do grafu obiektów.  
  
 Obiekt, który jest dołączany musi implementować <xref:System.Data.Objects.DataClasses.IEntityWithKey> , aby <xref:System.Data.EntityKey>uwidocznić. Wszystkie wygenerowane klasy jednostek <xref:System.Data.Objects.DataClasses.IEntityWithKey>są implementowane.  
  
 Po dołączeniu obiektów pokrewnych należy również `Attach` wywołać metodę <xref:System.Data.Objects.DataClasses.EntityReference%601> lub, <xref:System.Data.Objects.DataClasses.EntityCollection%601> aby zdefiniować relację.  
  
 Ta metoda wywołuje <xref:System.Data.Objects.ObjectContext.AttachTo%2A> metodę.  
  
 Podczas dołączania obiektów stosowane są następujące zagadnienia:  
  
-   Jeśli dołączony obiekt ma powiązane obiekty, te obiekty również zostaną dołączone do kontekstu obiektu.  
  
-   Obiekty są dodawane do kontekstu obiektu w stanie niezmienionym.  
  
-   Obiekt, który jest przesyłany do <xref:System.Data.Objects.ObjectContext.Attach%2A> metody, musi mieć prawidłową <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> wartość. Jeśli obiekt nie ma prawidłowej <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> wartości, <xref:System.Data.Objects.ObjectContext.AttachTo%2A> Użyj metody, aby określić nazwę zestawu jednostek.  
  
   
  
## Examples  
 Przykład w tym temacie jest oparty na [modelu sprzedaży AdventureWorks](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W tym przykładzie są dołączone dwa obiekty, a następnie zdefiniowana jest relacja.  
  
 [!code-csharp[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#attachrelatedobjects)]
 [!code-vb[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#attachrelatedobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> Ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.InvalidOperationException">Nieprawidłowy klucz jednostki.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AttachTo">
      <MemberSignature Language="C#" Value="public void AttachTo (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachTo(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AttachTo(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachTo (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachTo(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AttachTo : string * obj -&gt; unit" Usage="objectContext.AttachTo (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Reprezentuje nazwę zestawu jednostek, która może być opcjonalnie kwalifikowana przez nazwę kontenera jednostek.</param>
        <param name="entity"><see cref="T:System.Object" /> Do dołączenia.</param>
        <summary>Dołącza obiekt lub wykres obiektu do kontekstu obiektu w określonym zestawie jednostek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.AttachTo%2A> `null` `Nothing` <xref:System.Data.EntityKey> Wywołanie metody w celudołączeniaobiektudookreślonegozestawujednostekwkontekścieobiektulub,jeśliobiektmawartość(wVisualBasic).<xref:System.Data.Objects.ObjectContext> Aby uzyskać więcej informacji, zobacz Dołączanie [i odłączanie obiektów](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Obiekt, który jest dołączany może być pojedynczym obiektem lub być częścią wykresu.  
  
 Reguły dla tego `entitySetName` formatu są następujące:  
  
-   Jeśli właściwość ma `null`wartość, `entitySetName` musi być w  *\<pełni kwalifikowana jako nazwa kontenera jednostek >.* <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A>  *Nazwa\<zestawu jednostek >*.  
  
-   Jeśli tak nie `null`jest, `entitySetName` może być  *\<nazwą kontenera jednostek >.* <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A>  *Nazwa\<zestawu jednostek >* lub  *\<nazwa zestawu jednostek >*.  
  
 Obiekt, który jest dołączany, nie musi <xref:System.Data.EntityKey> być skojarzony z nim. Jeśli obiekt nie ma klucza jednostki, `entitySetName` nie może być pustym ciągiem.  
  
 Jeśli obiekt, który <xref:System.Data.EntityKey> jest dołączany `entitySetName` , ma wartość, a następnie <xref:System.Data.Metadata.Edm.EntitySet> klucz jednostki musi `entitySetName` być zgodny z <xref:System.Data.Metadata.Edm.EntitySet> znalezionym w oparciu o nazwę kontenera jednostki i.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> Ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.InvalidOperationException">Nieprawidłowy zestaw jednostek.  
  
—lub— 
Obiekt ma klucz tymczasowy.  
  
—lub— 
Obiekt ma element <see cref="T:System.Data.EntityKey" /> <see cref="T:System.Data.Metadata.Edm.EntitySet" /> i nie jest zgodny z zestawem jednostek przekazaną jako argument metody.  
  
—lub— 
Obiekt nie ma <see cref="T:System.Data.EntityKey" /> zestawu jednostek i nie został podany.  
  
—lub— 
Każdy obiekt z grafu obiektów ma tymczasowy <see cref="T:System.Data.EntityKey" />.  
  
—lub— 
Każdy obiekt z grafu obiektów ma nieprawidłowe <see cref="T:System.Data.EntityKey" /> (na przykład wartości w kluczu nie pasują do wartości w obiekcie).  
  
—lub— 
Nie można odnaleźć zestawu jednostek z podaną <paramref name="entitySetName" /> nazwą i nazwą kontenera jednostek.  
  
—lub— 
Każdy obiekt z grafu obiektów już istnieje w innym Menedżerze stanu.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int32&gt; CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;int&gt; CommandTimeout { Nullable&lt;int&gt; get(); void set(Nullable&lt;int&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : Nullable&lt;int&gt; with get, set" Usage="System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość limitu czasu (w sekundach) dla wszystkich operacji kontekstu obiektu. <see langword="null" /> Wartość wskazuje, że zostanie użyta wartość domyślna dostawcy.</summary>
        <value><see cref="T:System.Int32" /> Wartość, która jest wartością limitu czasu (w sekundach).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny limit czasu dla zapytań dotyczących obiektów i <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> operacja jest definiowany przez bazowego dostawcę połączenia. Można jednak zastąpić tę domyślną wartość limitu czasu przy użyciu <xref:System.Data.Objects.ObjectContext.CommandTimeout%2A> właściwości <xref:System.Data.Objects.ObjectContext>w, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querytimeout)]
 [!code-vb[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querytimeout)]  
  
 Zrób to w przypadku złożonej kwerendy lub gdy inne problemy z wydajnością powodują, że zapytania lub wywołania <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> do czasu są często.  
  
   
  
## Examples  
 [Zapytania dotyczące obiektów](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość limitu czasu jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Objects.ObjectContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera połączenie używane przez kontekst obiektu.</summary>
        <value><see cref="T:System.Data.Common.DbConnection" /> Obiekt, który jest połączeniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca obiekt połączenia, który został przekazano do konstruktora lub został utworzony podczas konstruowania. Własność połączenia jest określana przez używane konstruktory.  
  
   
  
## Examples  
 Ten przykład tworzy <xref:System.Data.EntityClient.EntityConnection> obiekt, który jest przesyłany do konstruktora długotrwałej <xref:System.Data.Objects.ObjectContext>. Połączenie jest otwierane ręcznie. Zarówno obiekt, jak i <xref:System.Data.Objects.ObjectContext> obiekt są <xref:System.Data.EntityClient.EntityConnection> usuwane ręcznie.  
  
 [!code-csharp[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#openentityconnection)]
 [!code-vb[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#openentityconnection)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Data.Objects.ObjectContext" /> Gdy wystąpienie zostało usunięte.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ContextOptions">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectContextOptions ContextOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectContextOptions ContextOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContextOptions As ObjectContextOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectContextOptions ^ ContextOptions { System::Data::Objects::ObjectContextOptions ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContextOptions : System.Data.Objects.ObjectContextOptions" Usage="System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectContextOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wystąpienie, które zawiera opcje, które mają wpływ na zachowanie <see cref="T:System.Data.Objects.ObjectContext" />. <see cref="T:System.Data.Objects.ObjectContextOptions" /></summary>
        <value>Wystąpienie, które zawiera opcje, które mają wpływ na zachowanie <see cref="T:System.Data.Objects.ObjectContext" />. <see cref="T:System.Data.Objects.ObjectContextOptions" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="objectContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy bazę danych przy użyciu bieżącego połączenia ze źródłem danych i metadanych w <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> , aby wyświetlić skrypt języka definicji danych (DDL). Wywołanie <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> do wykonania skryptu.  
  
 Większość pracy jest delegowana do <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [Praca z językiem definicji danych](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateDatabaseScript">
      <MemberSignature Language="C#" Value="public string CreateDatabaseScript ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string CreateDatabaseScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDatabaseScript () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ CreateDatabaseScript();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabaseScript : unit -&gt; string" Usage="objectContext.CreateDatabaseScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Generuje skrypt języka definicji danych (DDL), który tworzy obiekty schematu (tabele, klucze podstawowe, klucze obce) dla metadanych w <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />. <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" /> Ładuje metadane z plików SSDL (Store Definition Language).</summary>
        <returns>Skrypt języka DDL, który tworzy obiekty schematu dla metadanych w <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> , aby wyświetlić Skrypt DDL. Wywołanie <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> do wykonania skryptu.  
  
 Większość pracy jest delegowana do <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [Praca z językiem definicji danych](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateEntityKey">
      <MemberSignature Language="C#" Value="public System.Data.EntityKey CreateEntityKey (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.EntityKey CreateEntityKey(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateEntityKey(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateEntityKey (entitySetName As String, entity As Object) As EntityKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::EntityKey ^ CreateEntityKey(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.CreateEntityKey : string * obj -&gt; System.Data.EntityKey" Usage="objectContext.CreateEntityKey (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">W pełni kwalifikowana nazwa zestawu jednostek, do którego należy obiekt Entity.</param>
        <param name="entity">Obiekt, dla którego jest pobierany klucz jednostki.</param>
        <summary>Tworzy klucz jednostki dla określonego obiektu lub zwraca klucz jednostki, jeśli już istnieje.</summary>
        <returns><see cref="T:System.Data.EntityKey" /> Obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Data.EntityKey> dlaelementu<xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> nie istnieje ,metodatworzydlaniegonowyklucz.`entity`  
  
 Ta metoda służy do określenia, czy obiekt, który ma taki sam <xref:System.Data.EntityKey> , jest już dołączony <xref:System.Data.Objects.ObjectContext>do. Jeśli obiekt, który ma ten sam <xref:System.Data.EntityKey> element, jest już dołączony, zgłaszany jest wyjątek. Użyj metody, aby próbować <xref:System.Data.EntityKey> pobrać odłączonego obiektu przed wywołaniem <xref:System.Data.Objects.ObjectContext.Attach%2A> metody. <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A>  
  
   
  
## Examples  
 Przykład w tym temacie jest oparty na [modelu sprzedaży AdventureWorks](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W tym przykładzie <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> służy do pobierania klucza jednostki istniejącego obiektu.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdatesgetobject)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdatesgetobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Gdy parametr ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException">Gdy <paramref name="entitySetName" /> jest pusty.  
  
—lub— 
Gdy typ <paramref name="entity" /> obiektu nie istnieje w zestawie jednostek.  
  
—lub— 
Gdy nie <paramref name="entitySetName" /> jest w pełni kwalifikowana.</exception>
        <exception cref="T:System.InvalidOperationException">W przypadku pomyślnego skonstruowania klucza jednostki na podstawie podanych parametrów.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T CreateObject&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T CreateObject&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObject``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject(Of T As Class) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class T CreateObject();" />
      <MemberSignature Language="F#" Value="member this.CreateObject : unit -&gt; 'T (requires 'T : null)" Usage="objectContext.CreateObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Typ obiektu do zwrócenia.</typeparam>
        <summary>Tworzy i zwraca wystąpienie żądanego typu.</summary>
        <returns>Wystąpienie żądanego typu <paramref name="T" />lub wystąpienie typu pochodnego, który umożliwia <paramref name="T" /> użycie z Entity Framework. Zwrócony obiekt jest wystąpieniem żądanego typu lub wystąpieniem typu pochodnego, który umożliwia użycie żądanego typu z Entity Framework.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.CreateObject%2A> Metoda jest używana z niestandardowymi klasami danych poco, aby upewnić się, że zwracany obiekt może być prawidłowo zarządzany przez Entity Framework. Aby uzyskać więcej informacji, zobacz [wymagania dotyczące tworzenia serwerów proxy poco](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) i [pracy z jednostkami poco](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) () As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet();" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : unit -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Żądany <see cref="T:System.Data.Objects.ObjectSet`1" />typ jednostki.</typeparam>
        <summary>Tworzy nowe <see cref="T:System.Data.Objects.ObjectSet`1" /> wystąpienie, które jest używane do wykonywania zapytań, dodawania, modyfikowania i usuwania obiektów określonego typu jednostki.</summary>
        <returns>Nowe <see cref="T:System.Data.Objects.ObjectSet`1" /> wystąpienie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość nie jest ustawiona <see cref="T:System.Data.Objects.ObjectContext" />na. <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" />  
  
—lub— 
Określony typ należy do więcej niż jednego zestawu jednostek.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; (string entitySetName) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;(string entitySetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) (entitySetName As String) As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet(System::String ^ entitySetName);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : string -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet entitySetName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Żądany <see cref="T:System.Data.Objects.ObjectSet`1" />typ jednostki.</typeparam>
        <param name="entitySetName">Nazwa zestawu jednostek dla zwracanych <see cref="T:System.Data.Objects.ObjectSet`1" />elementów. Ciąg musi być kwalifikowany przez domyślną nazwę kontenera, jeśli <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> właściwość nie jest ustawiona <see cref="T:System.Data.Objects.ObjectContext" />na.</param>
        <summary>Tworzy nowe <see cref="T:System.Data.Objects.ObjectSet`1" /> wystąpienie, które jest używane do wykonywania zapytań, dodawania, modyfikowania i usuwania obiektów określonego typu oraz z określoną nazwą zestawu jednostek.</summary>
        <returns>Nowe <see cref="T:System.Data.Objects.ObjectSet`1" /> wystąpienie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Data.Metadata.Edm.EntitySet" /> <see cref="T:System.Data.EntityKey" />Element <see cref="T:System.Data.Metadata.Edm.EntitySet" /> from<paramref name="entitySetName" /> nie jest zgodny z obiektem.  
  
—lub— 
Właściwość nie jest ustawiona <see cref="T:System.Data.Objects.ObjectContext" /> dla i nazwa nie jest <paramref name="entitySetName" /> kwalifikowana jako część parametru. <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" />  
  
—lub— 
Określony typ należy do więcej niż jednego zestawu jednostek.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProxyTypes">
      <MemberSignature Language="C#" Value="public void CreateProxyTypes (System.Collections.Generic.IEnumerable&lt;Type&gt; types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateProxyTypes(class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateProxyTypes(System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateProxyTypes (types As IEnumerable(Of Type))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateProxyTypes(System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.CreateProxyTypes : seq&lt;Type&gt; -&gt; unit" Usage="objectContext.CreateProxyTypes types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="types">Wyliczenie <see cref="T:System.Type" /> obiektów, które reprezentują niestandardowe klasy danych, które są mapowane do modelu koncepcyjnego.</param>
        <summary>Generuje odpowiedni typ, który może być używany z Entity Framework dla każdego typu w podanym wyliczeniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poszczególne typy w `types` wyliczeniu, które nie są mapowane na typ jednostki w modelu koncepcyjnym, są ignorowane.  
  
 Aby uzyskać więcej informacji, zobacz [wymagania dotyczące tworzenia serwerów proxy poco](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) i [pracy z jednostkami poco](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateQuery&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; CreateQuery&lt;T&gt; (string queryString, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!!T&gt; CreateQuery&lt;T&gt;(string queryString, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateQuery``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateQuery(Of T) (queryString As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ CreateQuery(System::String ^ queryString, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateQuery : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectContext.CreateQuery (queryString, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">Typ jednostki zwracanej <see cref="T:System.Data.Objects.ObjectQuery`1" />.</typeparam>
        <param name="queryString">Ciąg zapytania, który ma zostać wykonany.</param>
        <param name="parameters">Parametry do przekazania do zapytania.</param>
        <summary><see cref="T:System.Data.Objects.ObjectQuery`1" /> Tworzy w bieżącym kontekście obiektu przy użyciu określonego ciągu zapytania.</summary>
        <returns><see cref="T:System.Data.Objects.ObjectQuery`1" /> Określony typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.Objects.ObjectContext.CreateQuery%2A> , aby utworzyć <xref:System.Data.Objects.ObjectQuery%601> obiekt z określonego typu, który należy do bieżącego kontekstu obiektu.  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 Przykład tworzy proste zapytanie i wykonuje iterację w kolekcji wyników.  
  
 [!code-csharp[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#createquery)]
 [!code-vb[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#createquery)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr <paramref name="queryString" /> lub <paramref name="parameters" /> jest .<see langword="null" /></exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Wykonywanie zapytania do modelu koncepcyjnego</related>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="objectContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy baza danych określona jako baza danych w bieżącym połączeniu źródła danych istnieje w źródle danych.</summary>
        <returns><see langword="true" />Jeśli baza danych istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość pracy jest delegowana do <xref:System.Data.Common.DbProviderServices.DatabaseExists%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [Praca z językiem definicji danych](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      </Docs>
    </Member>
    <Member MemberName="DefaultContainerName">
      <MemberSignature Language="C#" Value="public string DefaultContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultContainerName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultContainerName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultContainerName : string with get, set" Usage="System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślną nazwę kontenera.</summary>
        <value><see cref="T:System.String" /> Jest to domyślna nazwa kontenera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A>nigdy nie `null`zwraca; zwraca wartość, która została ustawiona lub jest pustym ciągiem. Użytkownik może ustawić tę właściwość na `null`, ale wewnętrznie nazwa zostanie ustawiona na pusty ciąg, więc użytkownik nigdy nie musi sprawdzać zarówno pusty ciąg, jak i. `null`  
  
 Nazwa domyślnego kontenera jest również definiowana jako część konstruktora. Jeśli domyślna nazwa kontenera jest ustawiana za pomocą chronionego konstruktora, właściwość jest tylko do odczytu.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="objectContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa bazę danych, która została określona jako baza danych w bieżącym połączeniu ze źródłem danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość pracy jest delegowana do <xref:System.Data.Common.DbProviderServices.DeleteDatabase%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [Praca z językiem definicji danych](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="DeleteObject">
      <MemberSignature Language="C#" Value="public void DeleteObject (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteObject(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteObject (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteObject(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.DeleteObject : obj -&gt; unit" Usage="objectContext.DeleteObject entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Obiekt, który określa jednostkę do usunięcia. Obiekt może być w dowolnym stanie z wyjątkiem <see cref="F:System.Data.EntityState.Detached" />.</param>
        <summary>Oznacza obiekt do usunięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznacza obiekt do usunięcia z <xref:System.Data.Objects.ObjectStateManager>. Obiekt zostanie usunięty ze źródła danych, <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> gdy wywoływana jest metoda.  
  
 Usunięcie obiektu nadrzędnego spowoduje również usunięcie wszystkich obiektów podrzędnych z ograniczonej relacji. Ten wynik jest taki sam jak włączenie `CascadeDelete` właściwości skojarzenia dla relacji.  
  
 <xref:System.Data.Objects.ObjectContext.DeleteObject%2A> Metodę można wywołać dla obiektów, które zostały już usunięte.  
  
   
  
## Examples  
 Przykłady te są oparte na [modelu sprzedaży AdventureWorks](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 Ten przykład tworzy <xref:System.Data.EntityKey> obiekt z określonym identyfikatorem ProductID, używa klucza do pobrania obiektu produktu ze źródła danych, usuwa produkt i zapisuje zmiany w bazie danych.  
  
 [!code-csharp[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#deleteobject)]
 [!code-vb[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#deleteobject)]  
  
 Ten przykład powoduje usunięcie istniejącego elementu zamówienia, dodanie nowego elementu i zapisanie zmian w bazie danych.  
  
 [!code-csharp[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savechanges)]
 [!code-vb[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savechanges)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="entity" />nie istnieje.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.DeleteObject(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Detach">
      <MemberSignature Language="C#" Value="public void Detach (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Detach(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Detach(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Detach (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Detach(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Detach : obj -&gt; unit" Usage="objectContext.Detach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Obiekt, który ma zostać odłączony. Tylko jest usuwany; Jeśli istnieją powiązane obiekty, które są śledzone przez ten sam <see cref="T:System.Data.Objects.ObjectStateManager" />, nie zostaną odłączone automatycznie. <paramref name="entity" /></param>
        <summary>Usuwa obiekt z kontekstu obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usuwa obiekt z <xref:System.Data.Objects.ObjectStateManager>. Spowoduje to wyłączenie śledzenia zmian i rozpoznawania tożsamości dla tego obiektu. Aby uzyskać więcej informacji, zobacz Dołączanie [i odłączanie obiektów](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.Detach%2A> metody system nie będzie już nadal zawierać odwołań do tego obiektu i może być zbierany przez moduł wyrzucania elementów bezużytecznych.  
  
> [!NOTE]
>  Wyrzucanie elementów bezużytecznych może wystąpić tylko wtedy, gdy kod użytkownika nie ma żadnych odwołań do odłączonego obiektu.  
  
 Podczas odłączania obiektów należy wziąć pod uwagę następujące zagadnienia:  
  
-   <xref:System.Data.Objects.ObjectContext.Detach%2A>dotyczy tylko określonego obiektu, który jest przesyłany do metody. Jeśli odłączony obiekt ma powiązane obiekty w kontekście obiektu, te obiekty nie są odłączone.  
  
-   Odłączanie obiektów nie ma wpływu na dane w źródle danych.  
  
-   Dyrektywy usuwania kaskadowego i ograniczenia referencyjne nie są wymuszane podczas operacji odłączania.  
  
 Aby uzyskać więcej informacji, zobacz Dołączanie [i odłączanie obiektów](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
   
  
## Examples  
 [!code-csharp[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#detachobjects)]
 [!code-vb[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#detachobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> Ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.InvalidOperationException">Nie jest on skojarzony z tym <see cref="T:System.Data.Objects.ObjectContext" /> (na przykład nowo utworzony i nie został skojarzony z żadnym kontekstem lub został uzyskany przy użyciu innego kontekstu lub został już odłączony). <paramref name="entity" /></exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Detach(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="DetectChanges">
      <MemberSignature Language="C#" Value="public void DetectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DetectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub DetectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetectChanges();" />
      <MemberSignature Language="F#" Value="member this.DetectChanges : unit -&gt; unit" Usage="objectContext.DetectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, <see cref="T:System.Data.Objects.ObjectStateEntry" /> że zmiany są synchronizowane ze zmianami we wszystkich obiektach, które <see cref="T:System.Data.Objects.ObjectStateManager" />są śledzone przez.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez kontekst obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="objectContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez kontekst obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zamyka połączenie, jeśli zostało otwarte przez Entity Framework. Po <xref:System.Data.Objects.ObjectContext.Dispose%2A> wywołaniu, operacje, które wymagają otwartego połączenia, takie jak wykonanie zapytania lub <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> wywołanie metody, spowodują wyjątek. Operacje, które nie wymagają otwartego połączenia, takie jak Tworzenie zapytania lub dołączanie obiektów, nie spowodują wyjątku. <xref:System.Data.Objects.ObjectContext.Dispose%2A> Metoda nie zamyka żadnych jawnie otwartych połączeń.  
  
 Ograniczenie zakresu elementu <xref:System.Data.Objects.ObjectContext> `using` w bloku (`Using` w Visual Basic) gwarantuje, że zasoby zostaną prawidłowo usunięte. Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i](https://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99)transakcjami.  
  
 Metoda wywołuje metodę(`Overridable`w Visual Basic) <xref:System.Data.Objects.ObjectContext.Dispose%28System.Boolean%29>. `virtual` <xref:System.Data.Objects.ObjectContext.Dispose>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="objectContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia zasoby używane przez kontekst obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zamyka połączenie. Po <xref:System.Data.Objects.ObjectContext.Dispose%2A> wywołaniu, operacje, które wymagają otwartego połączenia, takie jak wykonanie zapytania lub <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> wywołanie metody, spowodują wyjątek. Operacje, które nie wymagają otwartego połączenia, takie jak Tworzenie zapytania lub dołączanie obiektów, nie spowodują wyjątku.  
  
 Ograniczenie zakresu elementu <xref:System.Data.Objects.ObjectContext> `using` w bloku (`Using` w Visual Basic) gwarantuje, że zasoby zostaną prawidłowo usunięte. Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i](https://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99)transakcjami.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction">
      <MemberSignature Language="C#" Value="public int ExecuteFunction (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteFunction(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction (functionName As String, ParamArray parameters As ObjectParameter()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; int" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="functionName">Nazwa procedury składowanej lub funkcji. Nazwa może zawierać nazwę kontenera, <c>&lt;na przykład&gt;nazwę&lt; kontenera. Nazwa&gt;funkcji</c>. Gdy domyślna nazwa kontenera jest znana, wymagana jest tylko nazwa funkcji.</param>
        <param name="parameters">Tablica <see cref="T:System.Data.Objects.ObjectParameter" /> obiektów.</param>
        <summary>Wykonuje procedurę składowaną lub funkcję zdefiniowaną w źródle danych i wyrażoną w modelu koncepcyjnym; odrzuca wszystkie wyniki zwrócone przez funkcję; i zwraca liczbę wierszy, na które ma wpływ wykonanie.</summary>
        <returns>Liczba wierszy, których to dotyczy.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="function" />ma wartość null lub jest pusty 
—lub— 
 <paramref name="function" />nie znaleziono.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jednostek nie obsługuje tego <paramref name="function" />elementu.  
  
—lub— 
Wystąpił niezgodność typów w czytniku i <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction(Of TElement) (functionName As String, ParamArray parameters As ObjectParameter()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Typ jednostki zwracanej, <see cref="T:System.Data.Objects.ObjectResult`1" /> gdy funkcja jest wykonywana względem źródła danych. Ten typ musi implementować <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Nazwa procedury składowanej lub funkcji. Nazwa może zawierać nazwę kontenera, <c>&lt;na przykład&gt;nazwę&lt; kontenera. Nazwa&gt;funkcji</c>. Gdy domyślna nazwa kontenera jest znana, wymagana jest tylko nazwa funkcji.</param>
        <param name="parameters">Tablica <see cref="T:System.Data.Objects.ObjectParameter" /> obiektów.</param>
        <summary>Wykonuje procedurę składowaną lub funkcję zdefiniowaną w źródle danych i zamapowane w modelu koncepcyjnym z określonymi parametrami. Zwraca typ <see cref="T:System.Data.Objects.ObjectResult`1" />.</summary>
        <returns><see cref="T:System.Data.Objects.ObjectResult`1" /> Dla danych zwracanych przez procedurę składowaną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> Metoda jest metodą pomocnika, która jest używana do wykonywania procedur składowanych lub funkcji, które są zdefiniowane w źródle danych i wyrażone w modelu koncepcyjnym. Narzędzia Entity Data Model generują metodę dla każdego [elementu FunctionImport](/ef/ef6/modeling/designer/advanced/edmx/csdl-spec#functionimport-element-csdl) w modelu koncepcyjnym. Te metody wywołują silnie wpisaną `ExecuteFunction` do zwrócenia wpisanej <xref:System.Data.Objects.ObjectResult%601>. Aby uzyskać więcej informacji, zobacz [kod aplikacji przy użyciu procedur składowanych (Entity Framework)](https://docs.microsoft.com/previous-versions/cc716795(v=vs.90)).  
  
 Wszystkie parametry dla funkcji są wymagane w tablicy parametrów, a wszystkie typy są sprawdzane względem metadanych funkcji importu, w tym typu samej funkcji. `null`wartości są dozwolone dla typów wartości CLR. Sprawdzanie poprawności parametru jest wykonywane przez dostawcę.  
  
 <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> Metoda<xref:System.Data.Objects.MergeOption> używa wartości .<xref:System.Data.Objects.MergeOption.AppendOnly> W związku z tym, jeśli obiekt już istnieje w kontekście obiektu, nie zostanie załadowany ze źródła danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="function" />ma wartość null lub jest pusty 
—lub— 
 <paramref name="function" />nie znaleziono.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jednostek nie obsługuje tego <paramref name="function" />elementu.  
  
—lub— 
Wystąpił niezgodność typów w czytniku i <paramref name="function" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, System.Data.Objects.MergeOption mergeOption, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, valuetype System.Data.Objects.MergeOption mergeOption, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.MergeOption,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.MergeOption * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Typ jednostki zwracanej, <see cref="T:System.Data.Objects.ObjectResult`1" /> gdy funkcja jest wykonywana względem źródła danych. Ten typ musi implementować <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Nazwa procedury składowanej lub funkcji. Nazwa może zawierać nazwę kontenera, <c>&lt;na przykład&gt;nazwę&lt; kontenera. Nazwa&gt;funkcji</c>. Gdy domyślna nazwa kontenera jest znana, wymagana jest tylko nazwa funkcji.</param>
        <param name="mergeOption"><see cref="T:System.Data.Objects.MergeOption" /> Do użycia podczas wykonywania zapytania.</param>
        <param name="parameters">Tablica <see cref="T:System.Data.Objects.ObjectParameter" /> obiektów.</param>
        <summary>Wykonuje daną procedurę składowaną lub funkcję zdefiniowaną w źródle danych i wyrażoną w modelu koncepcyjnym, z określonymi parametrami i opcją scalania. Zwraca typ <see cref="T:System.Data.Objects.ObjectResult`1" />.</summary>
        <returns><see cref="T:System.Data.Objects.ObjectResult`1" /> Dla danych zwracanych przez procedurę składowaną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> Metoda jest metodą pomocnika, która jest używana do wykonywania procedur składowanych lub funkcji, które są zdefiniowane w źródle danych i wyrażone w modelu koncepcyjnym. Narzędzia Entity Data Model generują metodę dla każdego [elementu FunctionImport](/ef/ef6/modeling/designer/advanced/edmx/csdl-spec#functionimport-element-csdl) w modelu koncepcyjnym. Te metody wywołują silnie wpisaną `ExecuteFunction` do zwrócenia wpisanej <xref:System.Data.Objects.ObjectResult%601>. Aby uzyskać więcej informacji, zobacz [kod aplikacji przy użyciu procedur składowanych (Entity Framework)](https://docs.microsoft.com/previous-versions/cc716795(v=vs.90)).  
  
 Wszystkie parametry dla funkcji są wymagane w tablicy parametrów, a wszystkie typy są sprawdzane względem metadanych funkcji importu, w tym typu samej funkcji. `null`wartości są dozwolone dla typów wartości CLR. Sprawdzanie poprawności parametru jest wykonywane przez dostawcę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="function" />ma wartość null lub jest pusty 
—lub— 
 <paramref name="function" />nie znaleziono.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jednostek nie obsługuje tego <paramref name="function" />elementu.  
  
—lub— 
Wystąpił niezgodność typów w czytniku i <paramref name="function" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommand">
      <MemberSignature Language="C#" Value="public int ExecuteStoreCommand (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteStoreCommand(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreCommand (commandText As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteStoreCommand(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreCommand : string * obj[] -&gt; int" Usage="objectContext.ExecuteStoreCommand (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Object[]" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="commandText">Polecenie do wykonania w języku macierzystym źródła danych.</param>
        <param name="parameters">Tablica parametrów do przekazania do polecenia.</param>
        <summary>Wykonuje dowolne polecenie bezpośrednio względem źródła danych przy użyciu istniejącego połączenia.</summary>
        <returns>Liczba wierszy, których to dotyczy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używanie sparametryzowanych poleceń pomaga chronić przed atakami polegającymi na iniekcji SQL, w których osoba atakująca "wprowadza" polecenie do instrukcji SQL, która narusza zabezpieczenia na serwerze. Sparametryzowane polecenia Guard przed atakami polegającymi na iniekcji SQL przez zagwarantowanie, że wartości odebrane ze źródła zewnętrznego są przesyłane jako tylko wartości i nie są częścią instrukcji SQL. W związku z tym polecenia SQL wstawione do wartości nie są wykonywane w źródle danych. Zamiast tego są oceniane tylko jako wartość parametru. Oprócz korzyści z zabezpieczeń, polecenia sparametryzowane zapewniają wygodną metodę organizowania wartości przekazywania instrukcji SQL lub procedury składowanej.  
  
 Wartość może być <xref:System.Data.Common.DbParameter> tablicą obiektów lub tablicą wartości parametrów. `parameters` Jeśli są podane tylko wartości, tablica <xref:System.Data.Common.DbParameter> obiektów jest tworzona na podstawie kolejności wartości w tablicy.  
  
 Polecenie Store jest wykonywane w kontekście bieżącej transakcji, jeśli istnieje bieżąca transakcja.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednie wykonywanie poleceń magazynu](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Instrukcje: Bezpośrednie wykonywanie poleceń względem źródła danych](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteStoreQuery&lt;TElement&gt; (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteStoreQuery&lt;TElement&gt;(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreQuery(Of TElement) (commandText As String, ParamArray parameters As Object()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteStoreQuery(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Object[]" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Typ zwracanych danych.</typeparam>
        <param name="commandText">Polecenie do wykonania w języku macierzystym źródła danych.</param>
        <param name="parameters">Tablica parametrów do przekazania do polecenia.</param>
        <summary>Wykonuje zapytanie bezpośrednio względem źródła danych, które zwraca sekwencję wpisanych wyników.</summary>
        <returns>Wyliczenie obiektów typu <paramref name="TElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> Metoda używa istniejącego połączenia do wykonywania dowolnego polecenia bezpośrednio względem źródła danych. Polecenie Store jest wykonywane w kontekście bieżącej transakcji, jeśli istnieje taka transakcja.  
  
 <xref:System.Data.Common.DbCommand> <xref:System.Data.Common.DbDataReader> <xref:System.Data.Common.DbCommand.ExecuteReader%2A> Wywołanie metody jest równoważne <xref:System.Data.Common.DbCommand.ExecuteReader%2A> wywołaniu metody klasy, zwraca tylko <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> jednostki i zwraca wartości właściwości w. <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A>  
  
 Wywołaj <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> z określoną nazwą zestawu jednostek, jeśli chcesz, aby wyniki były śledzone.  
  
 <xref:System.Data.Common.DbDataReader> Wywołaj <xref:System.Data.Objects.ObjectContext.Translate%2A> metodę w celu przetłumaczenia obiektów na obiekty, gdy czytnik zawiera wiersze danych, które są mapowane na określony typ jednostki.  
  
 Używanie sparametryzowanych poleceń pomaga chronić przed atakami polegającymi na iniekcji SQL, w których osoba atakująca "wprowadza" polecenie do instrukcji SQL, która narusza zabezpieczenia na serwerze. Sparametryzowane polecenia Guard przed atakami polegającymi na iniekcji SQL przez zagwarantowanie, że wartości odebrane ze źródła zewnętrznego są przesyłane jako tylko wartości i nie są częścią instrukcji SQL. W związku z tym polecenia SQL wstawione do wartości nie są wykonywane w źródle danych. Zamiast tego są oceniane tylko jako wartość parametru. Oprócz korzyści z zabezpieczeń, polecenia sparametryzowane zapewniają wygodną metodę organizowania wartości przekazywania instrukcji SQL lub procedury składowanej.  
  
 Wartość może być <xref:System.Data.Common.DbParameter> tablicą obiektów lub tablicą wartości parametrów. `parameters` Jeśli są podane tylko wartości, tablica <xref:System.Data.Common.DbParameter> obiektów jest tworzona na podstawie kolejności wartości w tablicy.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednie wykonywanie poleceń magazynu](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Instrukcje: Bezpośrednie wykonywanie poleceń względem źródła danych](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt; (string commandText, string entitySetName, System.Data.Objects.MergeOption mergeOption, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt;(string commandText, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.String,System.Data.Objects.MergeOption,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ ExecuteStoreQuery(System::String ^ commandText, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * string * System.Data.Objects.MergeOption * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, entitySetName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="entitySetName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Typ jednostki zwracanych danych.</typeparam>
        <param name="commandText">Polecenie do wykonania w języku macierzystym źródła danych.</param>
        <param name="entitySetName">Zestaw <typeparamref name="TEntity" /> jednostek typu. Jeśli nie podano nazwy zestawu jednostek, wyniki nie będą śledzone.</param>
        <param name="mergeOption"><see cref="T:System.Data.Objects.MergeOption" /> Do użycia podczas wykonywania zapytania. Wartość domyślna to <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <param name="parameters">Tablica parametrów do przekazania do polecenia.</param>
        <summary>Wykonuje zapytanie bezpośrednio względem źródła danych i zwraca sekwencję wpisanych wyników. Określ zestaw jednostek i opcję scalania, aby wyniki zapytania mogły być śledzone jako jednostki.</summary>
        <returns>Wyliczenie obiektów typu <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> Metoda używa istniejącego połączenia do wykonywania dowolnego polecenia bezpośrednio względem źródła danych. Polecenie Store jest wykonywane w kontekście bieżącej transakcji, jeśli istnieje taka transakcja.  
  
 <xref:System.Data.Common.DbCommand> <xref:System.Data.Common.DbDataReader> <xref:System.Data.Common.DbCommand.ExecuteReader%2A> Wywołanie metody jest równoważne <xref:System.Data.Common.DbCommand.ExecuteReader%2A> wywołaniu metody klasy, zwraca tylko <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> jednostki i zwraca wartości właściwości w. <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A>  
  
 Określ nazwę zestawu jednostek, jeśli chcesz, aby wyniki były śledzone jako jednostki.  
  
 Metoda <xref:System.Data.Objects.ObjectContext.Translate%2A> Call do <xref:System.Data.Common.DbDataReader> translacji obiektów na obiekty, gdy czytnik zawiera wiersze danych, które są mapowane na określony typ jednostki.  
  
 Używanie sparametryzowanych poleceń pomaga chronić przed atakami polegającymi na iniekcji SQL, w których osoba atakująca "wprowadza" polecenie do instrukcji SQL, która narusza zabezpieczenia na serwerze. Sparametryzowane polecenia Guard przed atakami polegającymi na iniekcji SQL przez zagwarantowanie, że wartości odebrane ze źródła zewnętrznego są przesyłane jako tylko wartości i nie są częścią instrukcji SQL. W związku z tym polecenia SQL wstawione do wartości nie są wykonywane w źródle danych. Zamiast tego są oceniane tylko jako wartość parametru. Oprócz korzyści z zabezpieczeń, polecenia sparametryzowane zapewniają wygodną metodę organizowania wartości przekazywania instrukcji SQL lub procedury składowanej.  
  
 Wartość może być <xref:System.Data.Common.DbParameter> tablicą obiektów lub tablicą wartości parametrów. `parameters` Jeśli są podane tylko wartości, tablica <xref:System.Data.Common.DbParameter> obiektów jest tworzona na podstawie kolejności wartości w tablicy.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednie wykonywanie poleceń magazynu](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Instrukcje: Bezpośrednie wykonywanie poleceń względem źródła danych](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKnownProxyTypes">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Type&gt; GetKnownProxyTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; GetKnownProxyTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetKnownProxyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetKnownProxyTypes () As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ GetKnownProxyTypes();" />
      <MemberSignature Language="F#" Value="static member GetKnownProxyTypes : unit -&gt; seq&lt;Type&gt;" Usage="System.Data.Objects.ObjectContext.GetKnownProxyTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie istniejące typy proxy.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" /> Wszystkie istniejące typy proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda <xref:System.Data.Objects.ObjectContext.GetKnownProxyTypes%2A> jest używana, gdy dla jednostek poco jest włączone generowanie obiektów serwera proxy. Aby uzyskać więcej informacji, zobacz [wymagania dotyczące tworzenia serwerów proxy poco](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) i [pracy z jednostkami poco](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectByKey">
      <MemberSignature Language="C#" Value="public object GetObjectByKey (System.Data.EntityKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetObjectByKey(class System.Data.EntityKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectByKey(System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObjectByKey (key As EntityKey) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetObjectByKey(System::Data::EntityKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.GetObjectByKey : System.Data.EntityKey -&gt; obj" Usage="objectContext.GetObjectByKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz obiektu, który ma zostać znaleziony.</param>
        <summary>Zwraca obiekt, który ma określony klucz jednostki.</summary>
        <returns><see cref="T:System.Object" /> Jest to wystąpienie typu jednostki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A>próbuje pobrać obiekt, który ma określony <xref:System.Data.EntityKey> <xref:System.Data.Objects.ObjectStateManager>z. Jeśli obiekt nie jest obecnie załadowany do kontekstu obiektu, zapytanie jest wykonywane w próbie zwrócenia obiektu ze źródła danych. Aby uzyskać więcej informacji, zobacz [zapytania dotyczące obiektów](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A><xref:System.Data.ObjectNotFoundException> podnosi czas, gdy nie można znaleźć obiektu. Aby uniknąć obsługi tego wyjątku, należy zamiast tego <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> użyć metody.  
  
 Ta metoda zwróci obiekty w <xref:System.Data.EntityState.Deleted> stanie.  
  
 Nie można użyć klucza tymczasowego do zwrócenia obiektu ze źródła danych.  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Przykład tworzy <xref:System.Data.EntityKey> obiekt dla jednostki danego typu, a następnie pobiera jednostkę według klucza.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_getobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_getobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="key" /></exception>
        <exception cref="T:System.Data.ObjectNotFoundException">Nie znaleziono obiektu w <see cref="T:System.Data.Objects.ObjectStateManager" /> ani w źródle danych.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Wykonywanie zapytań dotyczących danych jako obiektów (Entity Framework)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObjectType">
      <MemberSignature Language="C#" Value="public static Type GetObjectType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetObjectType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetObjectType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetObjectType : Type -&gt; Type" Usage="System.Data.Objects.ObjectContext.GetObjectType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Obiekt serwera proxy.</param>
        <summary>Zwraca typ jednostki jednostki POCO skojarzonej z obiektem proxy określonego typu.</summary>
        <returns><see cref="T:System.Type" /> Skojarzona jednostka poco.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda <xref:System.Data.Objects.ObjectContext.GetObjectType%2A> jest używana, gdy dla jednostek poco jest włączone generowanie obiektów serwera proxy. Aby uzyskać więcej informacji, zobacz [wymagania dotyczące tworzenia serwerów proxy poco](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) i [pracy z jednostkami poco](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadProperty">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Jawnie ładuje obiekt pokrewny w przypadku używania niestandardowych klas danych POCO.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku korzystania z niestandardowych klas danych POCO obiekty powiązane nie mogą być jawnie załadowane, podobnie jak wystąpienia typów jednostek, które są generowane przez narzędzia Entity Data Model. Wynika to z faktu, że narzędzia generują właściwości nawigacji <xref:System.Data.Objects.DataClasses.EntityCollection%601> , <xref:System.Data.Objects.DataClasses.EntityReference%601> które zwracają obiekt lub <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> obiekty powiązane, <xref:System.Data.Objects.DataClasses.RelatedEnd>gdy jest wywoływana na. Jednostki poco można nadal ładować przy <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> użyciu ładowania opóźnionego przez ustawienie `true` właściwości na wystąpienie <xref:System.Data.Objects.ObjectContextOptions> , które jest zwracane przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwość, lub za pomocą eager ładowania z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metodą w <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty (entity As Object, navigationProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="navigationProperty" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka, dla której mają zostać załadowane powiązane obiekty.</param>
        <param name="navigationProperty">Nazwa właściwości nawigacji, która zwraca powiązane obiekty do załadowania.</param>
        <summary>Jawnie ładuje obiekt związany z podanym obiektem przez określoną właściwość nawigacji i korzystając z opcji scalania domyślnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Metoda musi zostać wywołana w celu osiągnięcia jawnego ładowania podczas korzystania z niestandardowych klas danych poco.  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>można uzyskać dostęp do powiązanego obiektu za pomocą właściwości nawigacji jednostki źródłowej.  
  
 W przypadku korzystania z niestandardowych klas danych POCO obiekty powiązane nie mogą być jawnie załadowane, podobnie jak wystąpienia typów jednostek, które są generowane przez narzędzia Entity Data Model. Wynika to z faktu, że narzędzia generują właściwości nawigacji <xref:System.Data.Objects.DataClasses.EntityCollection%601> , <xref:System.Data.Objects.DataClasses.EntityReference%601> które zwracają obiekt lub <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> obiekty powiązane, <xref:System.Data.Objects.DataClasses.RelatedEnd>gdy jest wywoływana na. Jednostki poco można nadal ładować przy <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> użyciu ładowania opóźnionego przez ustawienie `true` właściwości na wystąpienie <xref:System.Data.Objects.ObjectContextOptions> , które jest zwracane przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwość, lub za pomocą eager ładowania z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metodą w <xref:System.Data.Objects.ObjectQuery%601>.  
  
 Gdy metoda jest wywoływana, obiekty są ładowane <xref:System.Data.Objects.ObjectContext> do, <xref:System.Data.Objects.MergeOption.AppendOnly>przy użyciu wartości domyślnej <xref:System.Data.Objects.MergeOption>. <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="entity" /> Jest w<see cref="F:System.Data.EntityState.Added" /> stanie, lub ,<see cref="F:System.Data.EntityState.Deleted" /> <see cref="F:System.Data.EntityState.Detached" /> 
—lub— 
Jest dołączony do innego <see cref="T:System.Data.Objects.ObjectContext" />wystąpienia. <paramref name="entity" /></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="navigationProperty" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka, dla której mają zostać załadowane powiązane obiekty.</param>
        <param name="navigationProperty">Nazwa właściwości nawigacji, która zwraca powiązane obiekty do załadowania.</param>
        <param name="mergeOption">Wartość <see cref="T:System.Data.Objects.MergeOption" /> , która ma być używana podczas ładowania powiązanych obiektów.</param>
        <summary>Jawnie ładuje obiekt, który jest powiązany z podanym obiektem przez określoną właściwość nawigacji i używając określonej opcji scalania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Metoda musi zostać wywołana w celu osiągnięcia jawnego ładowania podczas korzystania z niestandardowych klas danych poco.  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>można uzyskać dostęp do powiązanego obiektu za pomocą właściwości nawigacji jednostki źródłowej.  
  
 W przypadku korzystania z niestandardowych klas danych POCO obiekty powiązane nie mogą być jawnie załadowane, podobnie jak wystąpienia typów jednostek, które są generowane przez narzędzia Entity Data Model. Wynika to z faktu, że narzędzia generują właściwości nawigacji <xref:System.Data.Objects.DataClasses.EntityCollection%601> , <xref:System.Data.Objects.DataClasses.EntityReference%601> które zwracają obiekt lub <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> obiekty powiązane, <xref:System.Data.Objects.DataClasses.RelatedEnd>gdy jest wywoływana na. Jednostki poco można nadal ładować przy <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> użyciu ładowania opóźnionego przez ustawienie `true` właściwości na wystąpienie <xref:System.Data.Objects.ObjectContextOptions> , które jest zwracane przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwość, lub za pomocą eager ładowania z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metodą w <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="entity" /> Jest w<see cref="F:System.Data.EntityState.Added" /> stanie, lub ,<see cref="F:System.Data.EntityState.Deleted" /> <see cref="F:System.Data.EntityState.Detached" /> 
—lub— 
Jest dołączony do innego <see cref="T:System.Data.Objects.ObjectContext" />wystąpienia. <paramref name="entity" /></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty(Of TEntity) (entity As TEntity, selector As Expression(Of Func(Of TEntity, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; -&gt; unit" Usage="objectContext.LoadProperty (entity, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Typ podanego obiektu.</typeparam>
        <param name="entity">Obiekt źródłowy, dla którego mają zostać załadowane powiązane obiekty.</param>
        <param name="selector">Wyrażenie LINQ definiujące powiązane obiekty do załadowania.</param>
        <summary>Jawnie ładuje obiekt, który jest powiązany z podanym obiektem przez określoną kwerendę LINQ i przy użyciu opcji scalania domyślnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Metoda musi zostać wywołana w celu osiągnięcia jawnego ładowania podczas korzystania z niestandardowych klas danych poco.  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>można uzyskać dostęp do powiązanego obiektu za pomocą właściwości nawigacji jednostki źródłowej.  
  
 Właściwość do załadowania jest określona przez wyrażenie LINQ, które musi znajdować się w formie prostego dostępu do elementu członkowskiego właściwości, `(entity) => entity.PropertyName`w, gdzie *PropertyName* jest właściwością nawigacji, która zwraca powiązane obiekty do załadowania. Wyjątek wystąpi, jeśli będą używane inne formy wyrażenia LINQ.  
  
 W przypadku korzystania z niestandardowych klas danych POCO obiekty powiązane nie mogą być jawnie załadowane, podobnie jak wystąpienia typów jednostek, które są generowane przez narzędzia Entity Data Model. Wynika to z faktu, że narzędzia generują właściwości nawigacji <xref:System.Data.Objects.DataClasses.EntityCollection%601> , <xref:System.Data.Objects.DataClasses.EntityReference%601> które zwracają obiekt lub <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> obiekty powiązane, <xref:System.Data.Objects.DataClasses.RelatedEnd>gdy jest wywoływana na. Jednostki poco można nadal ładować przy <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> użyciu ładowania opóźnionego przez ustawienie `true` właściwości na wystąpienie <xref:System.Data.Objects.ObjectContextOptions> , które jest zwracane przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwość, lub za pomocą eager ładowania z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metodą w <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="selector" />nie dostarcza prawidłowego parametru wejściowego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="selector" />ma wartość null.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="entity" /> Jest w<see cref="F:System.Data.EntityState.Added" /> stanie, lub ,<see cref="F:System.Data.EntityState.Deleted" /> <see cref="F:System.Data.EntityState.Detached" /> 
—lub— 
Jest dołączony do innego <see cref="T:System.Data.Objects.ObjectContext" />wystąpienia. <paramref name="entity" /></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, selector, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Typ podanego obiektu.</typeparam>
        <param name="entity">Obiekt źródłowy, dla którego mają zostać załadowane powiązane obiekty.</param>
        <param name="selector">Wyrażenie LINQ definiujące powiązane obiekty do załadowania.</param>
        <param name="mergeOption">Wartość <see cref="T:System.Data.Objects.MergeOption" /> , która ma być używana podczas ładowania powiązanych obiektów.</param>
        <summary>Jawnie ładuje obiekt, który jest powiązany z podanym obiektem przez określoną kwerendę LINQ i przy użyciu określonej opcji scalania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Metoda musi zostać wywołana w celu osiągnięcia jawnego ładowania podczas korzystania z niestandardowych klas danych poco.  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>można uzyskać dostęp do powiązanego obiektu za pomocą właściwości nawigacji jednostki źródłowej.  
  
 Właściwość do załadowania jest określona przez wyrażenie LINQ, które musi mieć postać prostego dostępu do elementu członkowskiego właściwości, jak w `(entity) => entity.PropertyName` przypadku, gdzie *PropertyName* jest właściwością nawigacji, która zwraca powiązane obiekty do załadowania. Wyjątek wystąpi, jeśli będą używane inne formy wyrażenia LINQ.  
  
 W przypadku korzystania z niestandardowych klas danych POCO obiekty powiązane nie mogą być jawnie załadowane, podobnie jak wystąpienia typów jednostek, które są generowane przez narzędzia Entity Data Model. Wynika to z faktu, że narzędzia generują właściwości nawigacji <xref:System.Data.Objects.DataClasses.EntityCollection%601> , <xref:System.Data.Objects.DataClasses.EntityReference%601> które zwracają obiekt lub <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> obiekty powiązane, <xref:System.Data.Objects.DataClasses.RelatedEnd>gdy jest wywoływana na. Jednostki poco można nadal ładować przy <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> użyciu ładowania opóźnionego przez ustawienie `true` właściwości na wystąpienie <xref:System.Data.Objects.ObjectContextOptions> , które jest zwracane przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwość, lub za pomocą eager ładowania z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metodą w <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="selector" />nie dostarcza prawidłowego parametru wejściowego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="selector" />ma wartość null.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="entity" /> Jest w<see cref="F:System.Data.EntityState.Added" /> stanie, lub ,<see cref="F:System.Data.EntityState.Deleted" /> <see cref="F:System.Data.EntityState.Detached" /> 
—lub— 
Jest dołączony do innego <see cref="T:System.Data.Objects.ObjectContext" />wystąpienia. <paramref name="entity" /></exception>
      </Docs>
    </Member>
    <Member MemberName="MetadataWorkspace">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MetadataWorkspace As MetadataWorkspace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Metadata::Edm::MetadataWorkspace ^ MetadataWorkspace { System::Data::Metadata::Edm::MetadataWorkspace ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataWorkspace : System.Data.Metadata.Edm.MetadataWorkspace" Usage="System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.MetadataWorkspace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obszar roboczy metadanych używany przez kontekst obiektu.</summary>
        <value>Skojarzony z tym <see cref="T:System.Data.Objects.ObjectContext" /> obiektem.<see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Metadata.Edm.MetadataWorkspace> Klasa jest centralnym interfejsem API środowiska uruchomieniowego, którego można użyć do współdziałania z metadanymi Entity Data Model (EDM) w kontekście aplikacji. 
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ObjectMaterialized">
      <MemberSignature Language="C#" Value="public event System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.ObjectMaterialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ObjectMaterialized As ObjectMaterializedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::Objects::ObjectMaterializedEventHandler ^ ObjectMaterialized;" />
      <MemberSignature Language="F#" Value="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " Usage="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectMaterializedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy nowy obiekt Entity jest tworzony na podstawie danych w źródle danych w ramach zapytania lub operacji ładowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane po ustawieniu wszystkich właściwości skalarnych, złożonych i odwołania dla obiektu, ale przed załadowaniem kolekcji. Jeśli obiekt o tej samej wartości klucza istnieje w kontekście obiektu, Entity Framework nie utworzy ponownie obiektu i to zdarzenie nie zostanie zgłoszone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectStateManager">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectStateManager ObjectStateManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectStateManager ObjectStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ObjectStateManager As ObjectStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectStateManager ^ ObjectStateManager { System::Data::Objects::ObjectStateManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ObjectStateManager : System.Data.Objects.ObjectStateManager" Usage="System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectStateManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera menedżera stanu obiektów używanego przez kontekst obiektu do śledzenia zmian obiektów.</summary>
        <value>Używane w tym <see cref="T:System.Data.Objects.ObjectContext" />celu. <see cref="T:System.Data.Objects.ObjectStateManager" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Przykłady te są oparte na [modelu sprzedaży AdventureWorks](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Ten przykład pobiera <xref:System.Data.Objects.ObjectStateManager> <xref:System.Data.Objects.ObjectContext> z i używa menedżera stanu, aby uzyskać dostęp do obiektu w kontekście.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectstatemanager)]
 [!code-vb[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectstatemanager)]  
  
 W tym przykładzie używa <xref:System.Data.Objects.ObjectStateManager.TryGetObjectStateEntry%2A> metody w zwracanym <xref:System.Data.Objects.ObjectStateManager> celu pobrania obiektu na podstawie jego klucza jednostki.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdates)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdates)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="QueryProvider">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryProvider QueryProvider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.IQueryProvider QueryProvider" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property QueryProvider As IQueryProvider" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Linq::IQueryProvider ^ QueryProvider { System::Linq::IQueryProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryProvider : System.Linq.IQueryProvider" Usage="System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dostawcę zapytania LINQ skojarzonego z tym kontekstem obiektu.</summary>
        <value><see cref="T:System.Linq.IQueryProvider" /> Wystąpienie używane przez ten kontekst obiektu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualizuje określone obiekty w kontekście obiektu za pomocą danych ze źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność, w której obiekty są odświeżane, jest niejednoznaczna.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="objectContext.Refresh (refreshMode, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="refreshMode"><see cref="T:System.Data.Objects.RefreshMode" /> Wartość wskazująca, czy zmiany właściwości w kontekście obiektu są zastępowane wartościami właściwości ze źródła danych.</param>
        <param name="collection"><see cref="T:System.Collections.IEnumerable" /> Kolekcja obiektów do odświeżenia.</param>
        <summary>Aktualizuje kolekcję obiektów w kontekście obiektu za pomocą danych ze źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma podwójny cel zezwalania obiektom w kontekście obiektu na odświeżanie danych ze źródła danych oraz mechanizm, w którym można rozwiązać konflikty. Aby uzyskać więcej informacji, zobacz [Zapisywanie zmian i Zarządzanie współbieżnością](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 Kolejność, w której obiekty są odświeżane, jest niejednoznaczna.  
  
 Po <xref:System.Data.Objects.ObjectContext.Refresh%2A> wywołaniu pierwotne wartości obiektu będą zawsze aktualizowane przy użyciu wartości źródła danych, ale bieżące wartości mogą lub nie mogą zostać zaktualizowane za pomocą wartości źródła danych. Jest <xref:System.Data.Objects.RefreshMode> to zależne od wartości. <xref:System.Data.Objects.RefreshMode.StoreWins> Tryb oznacza, że obiekty w kolekcji należy zaktualizować tak, aby odpowiadały wartościom źródła danych. <xref:System.Data.Objects.RefreshMode.ClientWins>oznacza, że tylko zmiany w kontekście obiektu zostaną utrwalone, nawet jeśli wprowadzono inne zmiany w źródle danych.  
  
 Aby upewnić się, że obiekty zostały zaktualizowane za pomocą logiki po stronie źródła danych, <xref:System.Data.Objects.ObjectContext.Refresh%2A> można <xref:System.Data.Objects.RefreshMode.StoreWins> wywołać <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metodę po wywołaniu metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="refreshMode" />jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="collection" />jest puste.  
  
—lub— 
Obiekt nie jest dołączony do kontekstu.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * obj -&gt; unit" Usage="objectContext.Refresh (refreshMode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Jedna z <see cref="T:System.Data.Objects.RefreshMode" /> wartości, która określa tryb używany do <see cref="T:System.Data.Objects.ObjectStateManager" />odświeżania.</param>
        <param name="entity">Obiekt, który ma zostać odświeżony.</param>
        <summary>Aktualizuje obiekt w kontekście obiektu za pomocą danych ze źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.Refresh%2A>Program ma dwa cele umożliwiające odświeżenie obiektu za pomocą danych ze źródła danych oraz mechanizm, w którym można rozwiązać konflikty. Aby uzyskać więcej informacji, zobacz [Zapisywanie zmian i Zarządzanie współbieżnością](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 Kolejność, w której obiekty są odświeżane, jest niejednoznaczna.  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.Refresh%2A> metody pierwotne wartości obiektu będą zawsze aktualizowane przy użyciu wartości źródła danych, ale bieżące wartości mogą lub nie mogą być aktualizowane przy użyciu wartości źródła danych. Jest <xref:System.Data.Objects.RefreshMode>to zależne od. <xref:System.Data.Objects.RefreshMode.StoreWins> Tryb oznacza, że obiekt powinien zostać zaktualizowany w celu dopasowania do wartości źródła danych. <xref:System.Data.Objects.RefreshMode.ClientWins> Wartość oznacza, że tylko zmiany w kontekście obiektu zostaną utrwalone, nawet jeśli wprowadzono inne zmiany w źródle danych.  
  
 Aby upewnić się, że obiekt został zaktualizowany przez logikę po stronie źródła danych, można wywołać <xref:System.Data.Objects.ObjectContext.Refresh%2A> metodę <xref:System.Data.Objects.RefreshMode.StoreWins> z <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> wartością po wywołaniu metody.  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Przykład próbuje zapisać zmiany, co może spowodować konflikt współbieżności. Następnie pokazano, jak rozwiązać konflikt współbieżności przez odświeżenie kontekstu obiektu przed ponownym zapisaniem zmian.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="refreshMode" />jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="collection" />jest puste.  
  
—lub— 
Obiekt nie jest dołączony do kontekstu.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Utrzymuje wszystkie aktualizacje źródła danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges();" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : unit -&gt; int" Usage="objectContext.SaveChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Utrzymuje wszystkie aktualizacje źródła danych i resetuje śledzenie zmian w kontekście obiektu.</summary>
        <returns>Liczba obiektów w <see cref="F:System.Data.EntityState.Added" />,, <see cref="F:System.Data.EntityState.Deleted" /> lub stanu <see cref="F:System.Data.EntityState.Modified" />, gdy <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> została wywołana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby upewnić się, że obiekty na kliencie zostały zaktualizowane przez logikę po stronie źródła danych, można wywołać <xref:System.Data.Objects.ObjectContext.Refresh%2A> metodę <xref:System.Data.Objects.RefreshMode.StoreWins> z wartością po wywołaniu <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Aby uzyskać więcej informacji, zobacz [Zapisywanie zmian i Zarządzanie współbieżnością](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>działa w ramach transakcji. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>wycofa tę transakcję i zgłosi wyjątek, jeśli którykolwiek z zanieczyszczonych <xref:System.Data.Objects.ObjectStateEntry> obiektów nie może zostać utrwalony.  
  
 Jeśli wystąpi naruszenie optymistyczne współbieżności, zostanie zgłoszone zdarzenie <xref:System.Data.OptimisticConcurrencyException> . Można rozwiązać optymistyczne naruszenie współbieżności, <xref:System.Data.Objects.ObjectContext.Refresh%2A> przechwytując je, wywołując metodę <xref:System.Data.Objects.RefreshMode.StoreWins> z wartością lub <xref:System.Data.Objects.RefreshMode.ClientWins> , a następnie wywołując <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> ponownie. Aby uzyskać więcej informacji, zobacz [jak: Zarządzanie współbieżnością danych w kontekście](https://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a)obiektu.  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Ten przykład próbuje zapisać zmiany, co może spowodować konflikt współbieżności. Następnie pokazuje, jak rozwiązać konflikt współbieżności przez odświeżenie kontekstu obiektu przed ponownym zapisaniem zmian.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">W źródle danych wystąpił jednooptymistyczne naruszenie współbieżności.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges (bool acceptChangesDuringSave);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges(bool acceptChangesDuringSave) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges (acceptChangesDuringSave As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges(bool acceptChangesDuringSave);" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : bool -&gt; int" Usage="objectContext.SaveChanges acceptChangesDuringSave" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use SaveChanges(SaveOptions options) instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptChangesDuringSave" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="acceptChangesDuringSave">Ten parametr jest wymagany w przypadku obsługi transakcji po stronie klienta. Jeśli <see langword="true" />funkcja śledzenia zmian na wszystkich obiektach zostanie zresetowana <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" /> po zakończeniu. Jeśli <see langword="false" />, należy <see cref="M:System.Data.Objects.ObjectContext.AcceptAllChanges" /> wywołać metodę po <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />.</param>
        <summary>Utrzymuje wszystkie aktualizacje źródła danych i opcjonalnie resetuje śledzenie zmian w kontekście obiektu.</summary>
        <returns>Liczba obiektów w <see cref="F:System.Data.EntityState.Added" />,, <see cref="F:System.Data.EntityState.Deleted" /> lub stanu <see cref="F:System.Data.EntityState.Modified" />, gdy <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> została wywołana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast tego wywołaj metodę. <xref:System.Data.Objects.ObjectContext.SaveChanges%28System.Data.Objects.SaveOptions%29>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Wystąpiło optymistyczne naruszenie współbieżności.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public virtual int SaveChanges (System.Data.Objects.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 SaveChanges(valuetype System.Data.Objects.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Data.Objects.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChanges (options As SaveOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int SaveChanges(System::Data::Objects::SaveOptions options);" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : System.Data.Objects.SaveOptions -&gt; int&#xA;override this.SaveChanges : System.Data.Objects.SaveOptions -&gt; int" Usage="objectContext.SaveChanges options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Data.Objects.SaveOptions" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="options"><see cref="T:System.Data.Objects.SaveOptions" /> Wartość, która określa zachowanie operacji.</param>
        <summary>Utrzymuje wszystkie aktualizacje źródła danych o określonym <see cref="T:System.Data.Objects.SaveOptions" />.</summary>
        <returns>Liczba obiektów w <see cref="F:System.Data.EntityState.Added" />,, <see cref="F:System.Data.EntityState.Deleted" /> lub stanu <see cref="F:System.Data.EntityState.Modified" />, gdy <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> została wywołana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konkretnego przeciążenia <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> programu, aby upewnić <xref:System.Data.Objects.ObjectContext.DetectChanges%2A> się, że jest wywoływana przed zapisaniem zmian w źródle <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> danych lub jest wywoływana po zapisaniu zmian w źródle danych.  
  
 To wyliczenie ma <xref:System.FlagsAttribute> pozwala na bitowe łączenie wartości jego elementów członkowskich.  
  
 Aby upewnić się, że obiekty na kliencie zostały zaktualizowane przez logikę po stronie źródła danych, można wywołać <xref:System.Data.Objects.ObjectContext.Refresh%2A> metodę <xref:System.Data.Objects.RefreshMode.StoreWins> z wartością po wywołaniu <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> Metoda działa w transakcji. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>wycofa tę transakcję i zgłosi wyjątek, jeśli którykolwiek z zanieczyszczonych <xref:System.Data.Objects.ObjectStateEntry> obiektów nie może zostać utrwalony.  
  
 Jeśli wystąpi naruszenie optymistyczne współbieżności, zostanie zgłoszone zdarzenie <xref:System.Data.OptimisticConcurrencyException> . Można rozwiązać optymistyczne naruszenie współbieżności, <xref:System.Data.Objects.ObjectContext.Refresh%2A> przechwytując je, wywołując metodę <xref:System.Data.Objects.RefreshMode.StoreWins> z lub <xref:System.Data.Objects.RefreshMode.ClientWins> wartości, a następnie ponownie wywołując <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metodę. Aby uzyskać więcej informacji, zobacz [jak: Zarządzanie współbieżnością danych w kontekście](https://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a)obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Wystąpiło optymistyczne naruszenie współbieżności.</exception>
      </Docs>
    </Member>
    <Member MemberName="SavingChanges">
      <MemberSignature Language="C#" Value="public event EventHandler SavingChanges;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SavingChanges" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.SavingChanges" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SavingChanges As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SavingChanges;" />
      <MemberSignature Language="F#" Value="member this.SavingChanges : EventHandler " Usage="member this.SavingChanges : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmiany są zapisywane w źródle danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie jest zgłaszane na początku <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> operacji na <xref:System.Data.Objects.ObjectContext>. <xref:System.Data.Objects.ObjectContext.SavingChanges> To zdarzenie jest zwykle używane do sprawdzania poprawności zmienionych obiektów przed zapisaniem nowych wartości w bazie danych.  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Rejestruje procedurę obsługi dla <xref:System.Data.Objects.ObjectContext.SavingChanges> zdarzenia, które wykonuje walidację stanu jednostki.  
  
 [!code-csharp[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savingchanges)]
 [!code-vb[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savingchanges)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; Translate&lt;TElement&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; Translate&lt;TElement&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TElement) (reader As DbDataReader) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">Typ jednostki danych w <see cref="T:System.Data.Common.DbDataReader" />.</typeparam>
        <param name="reader"><see cref="T:System.Data.Common.DbDataReader" /> Zawiera dane jednostki do przetłumaczenia na obiekty jednostek.</param>
        <summary>Tłumaczy <see cref="T:System.Data.Common.DbDataReader" /> , który zawiera wiersze danych jednostki w obiektach żądanego typu jednostki.</summary>
        <returns>Wyliczenie obiektów typu <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest używana do translacji danych jednostki <xref:System.Data.Common.DbDataReader> z obiektów do obiektu żądanego typu. <xref:System.Data.Objects.ObjectContext.Translate%2A> Ten proces jest wykonywany automatycznie, gdy <xref:System.Data.Objects.ObjectQuery%601> jest wykonywane w celu zwrócenia danych jednostki. <xref:System.Data.Objects.ObjectContext.Translate%2A> Metoda umożliwia wykonywanie standardowego zapytania ADO.NET w odniesieniu do źródła danych i tłumaczenie zwracanych wierszy danych na obiekty Entity.  
  
 Podane <xref:System.Data.Common.DbDataReader> muszą zawierać dane, które są mapowane na żądany typ jednostki.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednie wykonywanie poleceń magazynu](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Instrukcje: Bezpośrednie wykonywanie poleceń względem źródła danych](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Gdy <paramref name="reader" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; Translate&lt;TEntity&gt; (System.Data.Common.DbDataReader reader, string entitySetName, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; Translate&lt;TEntity&gt;(class System.Data.Common.DbDataReader reader, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader * string * System.Data.Objects.MergeOption -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.Translate (reader, entitySetName, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="entitySetName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Typ jednostki danych w <see cref="T:System.Data.Common.DbDataReader" />.</typeparam>
        <param name="reader"><see cref="T:System.Data.Common.DbDataReader" /> Zawiera dane jednostki do przetłumaczenia na obiekty jednostek.</param>
        <param name="entitySetName">Zestaw <typeparamref name="TEntity" /> jednostek typu.</param>
        <param name="mergeOption">Do <see cref="T:System.Data.Objects.MergeOption" /> użycia, gdy tłumaczone obiekty są dodawane do kontekstu obiektu. Wartość domyślna to <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <summary>Tłumaczy <see cref="T:System.Data.Common.DbDataReader" /> , który zawiera wiersze danych jednostki w obiektach żądanego typu jednostki, w określonym zestawie jednostek oraz z określoną opcją scalania.</summary>
        <returns>Wyliczenie obiektów typu <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest używana do translacji danych jednostki <xref:System.Data.Common.DbDataReader> z obiektów do obiektu żądanego typu. <xref:System.Data.Objects.ObjectContext.Translate%2A> Ten proces jest wykonywany automatycznie, gdy <xref:System.Data.Objects.ObjectQuery%601> jest wykonywane w celu zwrócenia danych jednostki. <xref:System.Data.Objects.ObjectContext.Translate%2A> Metoda umożliwia wykonywanie standardowego zapytania ADO.NET w odniesieniu do źródła danych i tłumaczenie zwracanych wierszy danych na obiekty Entity.  
  
 Podane <xref:System.Data.Common.DbDataReader> muszą zawierać dane, które są mapowane na żądany typ jednostki.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednie wykonywanie poleceń magazynu](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Instrukcje: Bezpośrednie wykonywanie poleceń względem źródła danych](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Gdy <paramref name="reader" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Podana <paramref name="mergeOption" /> wartość nie jest prawidłową <see cref="T:System.Data.Objects.MergeOption" /> wartością.</exception>
        <exception cref="T:System.InvalidOperationException">Podana <paramref name="entitySetName" /> wartość nie jest prawidłowym zestawem jednostek dla tego <paramref name="TResult" /> typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetObjectByKey">
      <MemberSignature Language="C#" Value="public bool TryGetObjectByKey (System.Data.EntityKey key, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetObjectByKey(class System.Data.EntityKey key, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.TryGetObjectByKey(System.Data.EntityKey,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetObjectByKey (key As EntityKey, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetObjectByKey(System::Data::EntityKey ^ key, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetObjectByKey : System.Data.EntityKey *  -&gt; bool" Usage="objectContext.TryGetObjectByKey (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
        <Parameter Name="value" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Klucz obiektu, który ma zostać znaleziony.</param>
        <param name="value">Gdy ta metoda zwraca, zawiera obiekt.</param>
        <summary>Zwraca obiekt, który ma określony klucz jednostki.</summary>
        <returns><see langword="true" />Jeśli obiekt został pomyślnie pobrany. <see langword="false" />Jeśli jest to tymczasowa, połączenie jest <see langword="null" />lub <paramref name="value" /> jest <see langword="null" />. <paramref name="key" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A>próbuje pobrać obiekt, który ma określony <xref:System.Data.EntityKey> <xref:System.Data.Objects.ObjectStateManager>z. Jeśli obiekt nie jest obecnie załadowany do kontekstu obiektu, zapytanie jest wykonywane w próbie zwrócenia obiektu ze źródła danych. Aby uzyskać więcej informacji, zobacz [zapytania dotyczące obiektów](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 Użyj metody, aby uniknąć <xref:System.Data.ObjectNotFoundException> obsługi wywoływanej przez <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> nie można znaleźć obiektu. <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A>  
  
 Ta metoda zwróci obiekty w <xref:System.Data.EntityState.Deleted> stanie.  
  
 Nie można użyć klucza tymczasowego do zwrócenia obiektu ze źródła danych.  
  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> `false` <xref:System.Data.ObjectNotFoundException> Metoda stosuje standardowy wzorzec .NET `TryParse` dla metody, zwracając Kiedy zostanie przechwycony. <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A>  
  
   
  
## Examples  
 Przykład w tym temacie jest oparty na [modelu sprzedaży AdventureWorks](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Przykład tworzy <xref:System.Data.EntityKey> dla jednostki danego typu, a następnie próbuje pobrać jednostkę według klucza.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_trygetobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_trygetobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Niezgodne metadane <paramref name="key" />dla.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
  </Members>
</Type>

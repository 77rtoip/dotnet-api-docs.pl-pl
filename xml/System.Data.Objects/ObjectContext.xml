<Type Name="ObjectContext" FullName="System.Data.Objects.ObjectContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c4ba70387433464de3989a5ff9cbaa8a50be073a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36687526" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ObjectContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ObjectContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.ObjectContext" />
  <TypeSignature Language="VB.NET" Value="Public Class ObjectContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectContext : IDisposable" />
  <TypeSignature Language="F#" Value="type ObjectContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zawiera urządzenia wykonywania kwerend i Praca z danymi jednostki jako obiekty.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Data.Objects.ObjectContext> Klasa nie jest bezpieczne dla wątków. Integralność danych obiektów w <xref:System.Data.Objects.ObjectContext> nie będzie można zapewnić w scenariuszach wielowątkowych.  
  
 <xref:System.Data.Objects.ObjectContext> Klasa jest podstawowe klasy do interakcji z danymi jako obiekty, które są wystąpień typów jednostek, które są zdefiniowane w modelu koncepcyjnym. Wystąpienie <xref:System.Data.Objects.ObjectContext> klasa hermetyzuje następujące:  
  
-   Połączenie z bazą danych w formie <xref:System.Data.EntityClient.EntityConnection> obiektu.  
  
-   Metadane opisujące modelu w postaci <xref:System.Data.Metadata.Edm.MetadataWorkspace> obiektu.  
  
-   <xref:System.Data.Objects.ObjectStateManager> Obiekt, który zarządza obiektów utrwalone w pamięci podręcznej.  
  
 Podczas generowania warstwy obiektu, który reprezentuje model koncepcyjny przy użyciu modelu Entity Data Model tools Klasa reprezentująca <xref:System.Data.Metadata.Edm.EntityContainer> dla modelu pochodzi z <xref:System.Data.Objects.ObjectContext>.  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie pokazano sposób tworzenia <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Objects.ObjectContext" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (System.Data.EntityClient.EntityConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As EntityConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
      </Parameters>
      <Docs>
        <param name="connection">
          <see cref="T:System.Data.EntityClient.EntityConnection" /> Zawiera odwołania do modelu i połączenia źródła danych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Objects.ObjectContext" /> klasy z danego połączenia. Podczas konstruowania, obszaru roboczego metadanych jest wyodrębniana z <see cref="T:System.Data.EntityClient.EntityConnection" /> obiektu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connection" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" /> Jest nieprawidłowy.  - lub - obszaru roboczego metadanych jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::String ^ connectionString);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connectionString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Ciąg połączenia, który umożliwia również dostęp do informacji o metadanych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Objects.ObjectContext" /> klasy z danego połączenia ciągu i domyślną nazwę kontenera jednostek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `connectionString` Jest ciągiem, który zawiera informacje, które są wymagane, dostępu do modelu koncepcyjnego i nawiązywania połączenia ze źródłem danych. <xref:System.Data.EntityClient.EntityConnectionStringBuilder> Klasa może być używana do poprawnie formatowania ciągu.  
  
 Wygeneruj ciąg połączenia nazwanego, który jest przechowywany w pliku konfiguracji aplikacji. Ten ciąg połączenia nazwanego mogą być dostarczane zamiast `connectionString` parametru podczas tworzenia wystąpienia <xref:System.Data.Objects.ObjectContext> klasy.  
  
   
  
## Examples  
 Przykład, w tym temacie jest oparty na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie przedstawiono sposób tworzenia <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connectionString" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connectionString" /> Jest nieprawidłowy.  - lub - obszaru roboczego metadanych jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (System.Data.EntityClient.EntityConnection connection, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connection As EntityConnection, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connection, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connection">
          <see cref="T:System.Data.EntityClient.EntityConnection" /> Zawiera odwołania do modelu i połączenia źródła danych.</param>
        <param name="defaultContainerName">Nazwa domyślnego kontenera jednostek. Gdy <c>defaultContainerName</c> jest ustawiony za pomocą tej metody, właściwości staje się tylko do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Objects.ObjectContext" /> klasy o danej nazwie kontenera połączenia i jednostek.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connection" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" />, <paramref name="defaultContainerName" />, Lub obszaru roboczego metadanych jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (string connectionString, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string connectionString, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connectionString As String, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::String ^ connectionString, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connectionString, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Ciąg połączenia, który umożliwia również dostęp do informacji o metadanych.</param>
        <param name="defaultContainerName">Nazwa domyślnego kontenera jednostek. Gdy <c>defaultContainerName</c> jest ustawiony za pomocą tej metody, właściwości staje się tylko do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Objects.ObjectContext" /> klasy o nazwie kontenera ciągu i jednostek danego połączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `connectionString` Jest ciągiem, który zawiera informacje, które są wymagane, dostępu do modelu koncepcyjnego i nawiązywania połączenia ze źródłem danych. <xref:System.Data.EntityClient.EntityConnectionStringBuilder> Klasa może być używana do poprawnie formatowania ciągu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connectionString" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connectionString" />, <paramref name="defaultContainerName" />, Lub obszaru roboczego metadanych jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptAllChanges">
      <MemberSignature Language="C#" Value="public void AcceptAllChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptAllChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AcceptAllChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptAllChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptAllChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptAllChanges : unit -&gt; unit" Usage="objectContext.AcceptAllChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Akceptuje wszystkie zmiany wprowadzone w obiektach w kontekście obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Akceptuje zmian na wszystkie powiązane wpisy w <xref:System.Data.Objects.ObjectStateManager> , ich stan wynikowy jest bez zmian lub "odłączony".  
  
 Ta metoda wykonuje wszystkie iteracje <xref:System.Data.Objects.ObjectStateEntry> obiektów w ramach <xref:System.Data.Objects.ObjectStateManager> dodany lub zmodyfikowany, a następnie ustawia stan wpisu do Unchanged. Elementy usunięte, w stanie odłączony.  
  
 Jeśli <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> wywołano metodę i <xref:System.Data.Objects.SaveOptions.AcceptAllChangesAfterSave> nie została określona, użytkownik musi wywołać <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> metody. <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> Metoda jest przydatna w scenariuszu, gdzie transakcji nie powiodło się, a użytkownik chce ponowić próbę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObject">
      <MemberSignature Language="C#" Value="public void AddObject (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddObject(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AddObject(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddObject (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddObject(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AddObject : string * obj -&gt; unit" Usage="objectContext.AddObject (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Reprezentuje nazwę zestawu jednostek, opcjonalnie może być kwalifikowana przez nazwę kontenera jednostek.</param>
        <param name="entity">
          <see cref="T:System.Object" /> Do dodania.</param>
        <summary>Dodaje obiekt do kontekstu obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Data.Objects.ObjectContext.AddObject%2A> na <xref:System.Data.Objects.ObjectContext> można dodać obiektu do kontekstu obiektów. W tym, gdy obiekt jest nowy obiekt, który jeszcze nie istnieje w źródle danych. Aby uzyskać więcej informacji, zobacz [Dołączanie i odłączanie obiektów](http://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Obiekty są dodawane do <xref:System.Data.Objects.ObjectStateManager> w <xref:System.Data.EntityState.Detached>, <xref:System.Data.EntityState.Deleted> lub <xref:System.Data.EntityState.Added> stanu.  
  
 Tworząc nowy obiekt, który jest powiązany z innym obiektem w kontekście obiektu, Dodaj obiekt przy użyciu jednej z następujących metod:  
  
-   Wywołanie <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> metoda <xref:System.Data.Objects.DataClasses.EntityCollection%601> i określ obiektu pokrewnego. W tym przypadku relacji jeden do wielu lub wiele do wielu.  
  
-   Ustaw <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A> właściwość <xref:System.Data.Objects.DataClasses.EntityReference%601> do powiązanego obiektu. W tym przypadku relacji jeden do jednego lub wiele do jednego.  
  
 Aby uzyskać więcej informacji, zobacz [tworzenie, dodawanie, modyfikowanie i usuwanie obiektów](http://msdn.microsoft.com/library/f76f1fad-c553-4b59-820b-89b3dec2fad1).  
  
 Jeśli obiekt jest w stanie odłączony nie mogą mieć <xref:System.Data.EntityKey>.  
  
 Zasady `entitySetName` formatu są następujące:  
  
-   Jeśli <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> właściwość jest `null`, a następnie `entitySetName` musi być w pełni kwalifikowana, podobnie jak w * \<nazwa kontenera jednostek >*.* \<Nazwa zestawu jednostek >*.  
  
-   Jeśli <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> nie jest `null`, a następnie `entitySetName` mogą być * \<nazwa kontenera jednostek >*.* \<Nazwa zestawu jednostek >* lub * \<Nazwa zestawu jednostek >*.  
  
 Jeśli `object` ma <xref:System.Data.EntityKey> i `entitySetName` ma wartość, a następnie <xref:System.Data.Metadata.Edm.EntitySet> jednostki klucz musi być zgodny <xref:System.Data.Metadata.Edm.EntitySet> który został znaleziony na podstawie `entitySetName` i nazwa kontenera jednostek.  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie dodaje nowym produktem i zapisuje zmiany w bazie danych.  
  
 [!code-csharp[DP ObjectServices Concepts#AddObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobject)]
 [!code-vb[DP ObjectServices Concepts#AddObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entity" /> Parametr jest <see langword="null" />.  - lub - <paramref name="entitySetName" /> nie kwalifikuje się.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.AddObject(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyCurrentValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyCurrentValues&lt;TEntity&gt; (string entitySetName, TEntity currentEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyCurrentValues&lt;class TEntity&gt;(string entitySetName, !!TEntity currentEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyCurrentValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyCurrentValues(Of TEntity As Class) (entitySetName As String, currentEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyCurrentValues(System::String ^ entitySetName, TEntity currentEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyCurrentValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyCurrentValues (entitySetName, currentEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="currentEntity" Type="TEntity" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Typ jednostki obiektu.</typeparam>
        <param name="entitySetName">Nazwa jednostki zestawu, do którego należy obiekt.</param>
        <param name="currentEntity">Odłączony obiekt, który ma właściwość aktualizuje, aby zastosować do oryginalnego obiektu. Klucz jednostki <c>currentEntity</c> musi odpowiadać <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> właściwości wpisu w <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Kopiuje wartości skalarnych podanego obiektu do obiektu w <see cref="T:System.Data.Objects.ObjectContext" /> mający ten sam klucz.</summary>
        <returns>Zaktualizowany obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> Metoda służy do stosowania zmian, które zostały wprowadzone w obiektach poza <xref:System.Data.Objects.ObjectContext>, takich jak odłączyć obiekty, które są odbierane przez usługę sieci Web. Metoda kopiuje wartości skalarnych podanego obiektu do obiektu w <xref:System.Data.Objects.ObjectContext> mający ten sam klucz. Można użyć <xref:System.Data.EntityKey> odłączyć obiektu można pobrać wystąpienia tego obiektu ze źródła danych. Aby uzyskać więcej informacji, zobacz [porady: zwraca określonego za pomocą obiektu swojego klucza](http://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Wartości, które różnią się od oryginalnej wartości obiektu jest oznaczona jako zmodyfikowana. Uwaga: metody bieżące wartości nie ma zastosowania do obiektów powiązanych `currentEntity`.  
  
 Jeśli masz wykres bieżącymi wartościami i chcesz zastosować oryginalnych wartości, należy wywołać <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> metody.  
  
 Można także użyć <xref:System.Data.Objects.ObjectSet%601.ApplyCurrentValues%2A> z <xref:System.Data.Objects.ObjectSet%601> lub <xref:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues%2A> metody <xref:System.Data.Objects.ObjectStateEntry>. Aby uzyskać więcej informacji, zobacz [tworzenie aplikacji warstwowych](http://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySetName" /> lub <paramref name="current" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Data.Metadata.Edm.EntitySet" /> z <paramref name="entitySetName" /> niezgodny <see cref="T:System.Data.Metadata.Edm.EntitySet" /> obiektu <see cref="T:System.Data.EntityKey" />.  - lub - obiekt nie znajduje się w <see cref="T:System.Data.Objects.ObjectStateManager" /> lub jest ona w <see cref="F:System.Data.EntityState.Detached" /> stanu.  - lub - klucz podanego obiektu jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="entitySetName" /> jest pustym ciągiem.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyCurrentValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyOriginalValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyOriginalValues&lt;TEntity&gt; (string entitySetName, TEntity originalEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyOriginalValues&lt;class TEntity&gt;(string entitySetName, !!TEntity originalEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyOriginalValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyOriginalValues(Of TEntity As Class) (entitySetName As String, originalEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyOriginalValues(System::String ^ entitySetName, TEntity originalEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyOriginalValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyOriginalValues (entitySetName, originalEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="originalEntity" Type="TEntity" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Typ obiektu jednostki.</typeparam>
        <param name="entitySetName">Nazwa jednostki zestawu, do którego należy obiekt.</param>
        <param name="originalEntity">Odłączony obiekt, który ma oryginalnych wartości do zastosowania do obiektu. Klucz jednostki <c>originalEntity</c> musi odpowiadać <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> właściwości wpisu w <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Kopiuje wartości skalarnych z podanego obiektu w zestawie oryginalnych wartości dla obiekt w <see cref="T:System.Data.Objects.ObjectContext" /> mający ten sam klucz.</summary>
        <returns>Zaktualizowany obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> Metoda służy do stosowania zmian, które zostały wprowadzone w obiektach poza <xref:System.Data.Objects.ObjectContext>, takich jak odłączyć obiekty, które są odbierane przez usługę sieci Web. Metoda kopiuje wartości skalarnych podanego obiektu do obiektu w <xref:System.Data.Objects.ObjectContext> mający ten sam klucz. Można użyć <xref:System.Data.EntityKey> odłączyć obiektu można pobrać wystąpienia tego obiektu ze źródła danych. Aby uzyskać więcej informacji, zobacz [porady: zwraca określonego za pomocą obiektu swojego klucza](http://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Wartości, które różnią się od bieżących wartości obiektu jest oznaczona jako zmodyfikowana. Uwaga: metody bieżące wartości nie ma zastosowania do obiektów powiązanych `originalEntity`.  
  
 Jeśli masz wykres z oryginalnych wartości i chcesz zastosować bieżące wartości, należy wywołać <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> metody.  
  
 Można także użyć <xref:System.Data.Objects.ObjectSet%601.ApplyOriginalValues%2A> z <xref:System.Data.Objects.ObjectSet%601> lub <xref:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues%2A> metody <xref:System.Data.Objects.ObjectStateEntry>. Aby uzyskać więcej informacji, zobacz [tworzenie aplikacji warstwowych](http://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entitySetName" /> lub <paramref name="original" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Data.Metadata.Edm.EntitySet" /> z <paramref name="entitySetName" /> niezgodny <see cref="T:System.Data.Metadata.Edm.EntitySet" /> obiektu <see cref="T:System.Data.EntityKey" />.  - lub - <see cref="T:System.Data.Objects.ObjectStateEntry" /> dla obiekt nie można znaleźć w <see cref="T:System.Data.Objects.ObjectStateManager" />. - lub - obiekt jest w <see cref="F:System.Data.EntityState.Added" /> lub <see cref="F:System.Data.EntityState.Detached" /> stanu.  - lub - klucz podanego obiektu jest nieprawidłowa lub zawiera zmiany właściwości.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="entitySetName" /> jest pustym ciągiem.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyOriginalValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyChanges">
      <MemberSignature Language="C#" Value="public void ApplyPropertyChanges (string entitySetName, object changed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyPropertyChanges(string entitySetName, object changed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyPropertyChanges(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyPropertyChanges (entitySetName As String, changed As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyPropertyChanges(System::String ^ entitySetName, System::Object ^ changed);" />
      <MemberSignature Language="F#" Value="member this.ApplyPropertyChanges : string * obj -&gt; unit" Usage="objectContext.ApplyPropertyChanges (entitySetName, changed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use ApplyCurrentValues instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="changed" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Nazwa jednostki zestawu, do którego należy obiekt.</param>
        <param name="changed">Odłączony obiekt, który ma właściwość aktualizuje, aby zastosować do oryginalnego obiektu.</param>
        <summary>Stosuje zmiany właściwości z obiektu odłączony obiekt, który został już dołączony do kontekstu obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> Metoda jest używana do zastosowania zmian właściwości z wersji modyfikacji, odłączony obiekt z wersją oryginalną dołączony do <xref:System.Data.Objects.ObjectContext>. To obsługuje scenariusze, takie jak usługi sieci Web, w którym odłączyć i wysyłane do aplikacji zdalnej, w których są wykonane aktualizacje właściwości do obiektu jednostki. Ta metoda umożliwia łatwiejsze zastosować te zmiany do oryginalnego obiektu.  
  
 Po <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>, gdy obiekt jest w <xref:System.Data.EntityState.Modified> stanu. Należy wywołać <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metodę, aby zaktualizować źródła danych.  
  
 Oryginalny obiekt musi istnieć w <xref:System.Data.Objects.ObjectStateManager> i musi być w <xref:System.Data.EntityState.Modified> lub <xref:System.Data.EntityState.Unchanged> stanu. Oryginalny obiekt jest modyfikować tylko w przypadku modyfikacji właściwości w `changed` obiektu.  
  
 <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> Musi być ustawiona właściwość podanego obiektu do prawidłowej <xref:System.Data.EntityKey>.  
  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> nie ma wpływu na właściwości nawigacji lub powiązane obiekty.  
  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> Określa tylko właściwości znajdujące się w metadanych obiektu dla typu. Na przykład, właściwości, które są dodawane w klasie częściowej nie znajdują się w <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> operacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Gdy <paramref name="entitySetName" /> jest <see langword="null" /> lub ciąg pusty.  - lub - gdy <paramref name="changed" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Gdy <see cref="T:System.Data.Metadata.Edm.EntitySet" /> z <paramref name="entitySetName" /> niezgodny <see cref="T:System.Data.Metadata.Edm.EntitySet" /> obiektu <see cref="T:System.Data.EntityKey" />.  Gdy jednostka jest w stanie innym niż - lub - <see cref="F:System.Data.EntityState.Modified" /> lub <see cref="F:System.Data.EntityState.Unchanged" />.  - lub - oryginalny obiekt nie jest dołączony do kontekstu.</exception>
        <exception cref="T:System.ArgumentException">Gdy typ <paramref name="changed" /> obiekt nie jest taki sam typ jak oryginalny obiekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (System.Data.Objects.DataClasses.IEntityWithKey entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(class System.Data.Objects.DataClasses.IEntityWithKey entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Attach(System.Data.Objects.DataClasses.IEntityWithKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As IEntityWithKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(System::Data::Objects::DataClasses::IEntityWithKey ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Attach : System.Data.Objects.DataClasses.IEntityWithKey -&gt; unit" Usage="objectContext.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Data.Objects.DataClasses.IEntityWithKey" />
      </Parameters>
      <Docs>
        <param name="entity">Obiekt można dołączyć.</param>
        <summary>Gdy obiekt ma klucz jednostki dołącza obiektu lub wykres obiektu do kontekstu obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Data.Objects.ObjectContext.Attach%2A> na <xref:System.Data.Objects.ObjectContext> można dołączyć obiektu do kontekstu obiektów. W tym przypadku obiekt już istnieje w źródle danych, ale nie jest obecnie dołączony do kontekstu. Aby uzyskać więcej informacji, zobacz [Dostosowywanie obiektów](http://msdn.microsoft.com/library/af6f07ce-2261-4c65-87cf-d018ad082921).  
  
 <xref:System.Data.Objects.ObjectContext.Attach%2A> jest używany do dołączania obiekt lub obiekt najwyższego poziomu z wykresu obiektu.  
  
 Dołączany obiekt musi implementować <xref:System.Data.Objects.DataClasses.IEntityWithKey> do udostępnienia <xref:System.Data.EntityKey>. Implementuje wszystkich wygenerowanych klas jednostek <xref:System.Data.Objects.DataClasses.IEntityWithKey>.  
  
 Po dołączeniu powiązane obiekty, musisz również wywołać `Attach` na <xref:System.Data.Objects.DataClasses.EntityReference%601> lub <xref:System.Data.Objects.DataClasses.EntityCollection%601> do definiowania relacji.  
  
 Ta metoda wywołuje <xref:System.Data.Objects.ObjectContext.AttachTo%2A> metody.  
  
 Następujące kwestie podczas podłączania obiektów:  
  
-   Jeśli obiekt dołączany ma powiązane obiekty, te obiekty, również zostanie dołączona do kontekstu obiektów.  
  
-   Obiekty są dodawane do kontekstu obiektów w niezmienionym stanie.  
  
-   Obiekt, który jest przekazywany do <xref:System.Data.Objects.ObjectContext.Attach%2A> metoda musi mieć prawidłową <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> wartość. Jeśli obiekt ma prawidłową <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> wartość, użyj <xref:System.Data.Objects.ObjectContext.AttachTo%2A> metodę, aby określić nazwę zestawu jednostek.  
  
   
  
## Examples  
 Przykład, w tym temacie jest oparty na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W tym przykładzie są dołączone dwa obiekty, a następnie relacja jest definiowana.  
  
 [!code-csharp[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#attachrelatedobjects)]
 [!code-vb[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#attachrelatedobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entity" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nieprawidłowy klucz jednostki.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AttachTo">
      <MemberSignature Language="C#" Value="public void AttachTo (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachTo(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AttachTo(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachTo (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachTo(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AttachTo : string * obj -&gt; unit" Usage="objectContext.AttachTo (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Reprezentuje nazwę zestawu jednostek, opcjonalnie może być kwalifikowana przez nazwę kontenera jednostek.</param>
        <param name="entity">
          <see cref="T:System.Object" /> Do dołączenia.</param>
        <summary>Dołącza obiektu lub wykres obiektu do kontekstu obiektów w zestawie określonej jednostki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Data.Objects.ObjectContext.AttachTo%2A> na <xref:System.Data.Objects.ObjectContext> można dołączyć obiektu, do określonego zestawu jednostek w kontekście obiektu albo obiekt nie ma `null` (`Nothing` w języku Visual Basic) <xref:System.Data.EntityKey> wartość. Aby uzyskać więcej informacji, zobacz [Dołączanie i odłączanie obiektów](http://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Obiekt dołączany można pojedynczego obiektu lub należeć do wykresu.  
  
 Zasady `entitySetName` formatu są następujące:  
  
-   Jeśli <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> właściwość jest `null`, a następnie `entitySetName` musi być w pełni kwalifikowana, podobnie jak w * \<nazwa kontenera jednostek >*.* \<Nazwa zestawu jednostek >*.  
  
-   Jeśli <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> nie jest `null`, a następnie `entitySetName` mogą być * \<nazwa kontenera jednostek >*.* \<Nazwa zestawu jednostek >* lub * \<Nazwa zestawu jednostek >*.  
  
 Obiekt dołączany nie muszą mieć <xref:System.Data.EntityKey> skojarzonych z nim. Jeśli obiekt ma klucz jednostki, następnie `entitySetName` nie może być pustym ciągiem.  
  
 Jeśli dołączany obiekt jest <xref:System.Data.EntityKey> i `entitySetName` ma wartość, a następnie <xref:System.Data.Metadata.Edm.EntitySet> jednostki klucz musi być zgodny <xref:System.Data.Metadata.Edm.EntitySet> który został znaleziony na podstawie `entitySetName` i nazwa kontenera jednostek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entity" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Zestaw jednostek nieprawidłowy.  - lub - obiekt ma klucza tymczasowego.  - lub - obiekt ma <see cref="T:System.Data.EntityKey" /> i <see cref="T:System.Data.Metadata.Edm.EntitySet" /> nie jest zgodny z zestawu jednostek przekazany jako argument metody.  Obiekt nie ma - lub - <see cref="T:System.Data.EntityKey" /> i jest dostępne nie zestawu jednostek.  - lub - dowolnego obiektu z wykresu obiektu ma tymczasowej <see cref="T:System.Data.EntityKey" />.  - lub - dowolnego obiektu z wykresu obiektu ma nieprawidłową <see cref="T:System.Data.EntityKey" /> (na przykład wartości w kluczu nie pasuje do wartości w obiekcie).  - lub - nie można odnaleźć zestawu jednostek z danym <paramref name="entitySetName" /> nazwy i nazwa kontenera jednostek.  - lub - dowolnego obiektu z wykresu obiektu już istnieje w innym Menedżer stanów.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int32&gt; CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;int&gt; CommandTimeout { Nullable&lt;int&gt; get(); void set(Nullable&lt;int&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : Nullable&lt;int&gt; with get, set" Usage="System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość limitu czasu w sekundach, dla wszystkich operacji kontekstu obiektu. A <see langword="null" /> wartość oznacza, że zostanie użyta wartość domyślna podstawowego dostawcy.</summary>
        <value>
          <see cref="T:System.Int32" /> Wartość, która jest wartość limitu czasu w sekundach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny limit czasu dla obiekt zapytań i <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> operacji jest definiowana za pomocą źródłowego dostawcy połączenia. Jednak można zastąpić to domyślna wartość limitu czasu przy użyciu <xref:System.Data.Objects.ObjectContext.CommandTimeout%2A> właściwość <xref:System.Data.Objects.ObjectContext>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querytimeout)]
 [!code-vb[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querytimeout)]  
  
 To zrobić, jeśli masz złożonego zapytania, lub gdy spowodować inne problemy z wydajnością zapytania lub wywołań <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> często przekraczają limit czasu.  
  
   
  
## Examples  
 [Obiekt zapytania](http://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość limitu czasu jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Objects.ObjectContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera połączenie używane przez kontekst.</summary>
        <value>A <see cref="T:System.Data.Common.DbConnection" /> obiekt połączenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca obiekt połączenia, który został przekazany do konstruktora lub został utworzony podczas konstruowania. Własności tego połączenia jest określana przez konstruktorów używane.  
  
   
  
## Examples  
 Ten przykład tworzy <xref:System.Data.EntityClient.EntityConnection> obiekt, który jest przekazywany do konstruktora długotrwałe <xref:System.Data.Objects.ObjectContext>. Połączenie jest otwarte ręcznie. Zarówno <xref:System.Data.EntityClient.EntityConnection> obiektu i <xref:System.Data.Objects.ObjectContext> obiektu są usuwane ręcznie.  
  
 [!code-csharp[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#openentityconnection)]
 [!code-vb[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#openentityconnection)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Gdy <see cref="T:System.Data.Objects.ObjectContext" /> wystąpienia został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContextOptions">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectContextOptions ContextOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectContextOptions ContextOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContextOptions As ObjectContextOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectContextOptions ^ ContextOptions { System::Data::Objects::ObjectContextOptions ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContextOptions : System.Data.Objects.ObjectContextOptions" Usage="System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectContextOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Data.Objects.ObjectContextOptions" /> wystąpienia, który zawiera opcje, które mają wpływ na zachowanie <see cref="T:System.Data.Objects.ObjectContext" />.</summary>
        <value>
          <see cref="T:System.Data.Objects.ObjectContextOptions" /> Wystąpienia, który zawiera opcje, które mają wpływ na zachowanie <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="objectContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy bazy danych przy użyciu bieżącego połączenia źródła danych i metadanych w <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> można wyświetlić skryptu (DDL) języka definicji danych. Wywołanie <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> można wykonać skryptu.  
  
 Większość pracy jest delegowane do <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [Praca z języka definicji danych](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateDatabaseScript">
      <MemberSignature Language="C#" Value="public string CreateDatabaseScript ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string CreateDatabaseScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDatabaseScript () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ CreateDatabaseScript();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabaseScript : unit -&gt; string" Usage="objectContext.CreateDatabaseScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Generuje skryptu (DDL) języka definicji danych, który tworzy obiekty schematu (tabele, kluczy podstawowych, kluczy obcych) metadanych w <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />. <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" /> Ładuje metadane z magazynu schematu definition language (SSDL) plików.</summary>
        <returns>Skrypt języka DDL, który tworzy obiekty schematu metadanych w <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> Aby przejrzeć skrypt języka DDL. Wywołanie <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> można wykonać skryptu.  
  
 Większość pracy jest delegowane do <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [Praca z języka definicji danych](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateEntityKey">
      <MemberSignature Language="C#" Value="public System.Data.EntityKey CreateEntityKey (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.EntityKey CreateEntityKey(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateEntityKey(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateEntityKey (entitySetName As String, entity As Object) As EntityKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::EntityKey ^ CreateEntityKey(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.CreateEntityKey : string * obj -&gt; System.Data.EntityKey" Usage="objectContext.CreateEntityKey (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">W pełni kwalifikowana nazwa jednostki ustawić, do którego należy obiekt jednostki.</param>
        <param name="entity">Obiekt, dla którego są pobierane klucza jednostki.</param>
        <summary>Tworzy kluczem jednostki dla określonego obiektu lub zwraca klucz jednostki, jeśli już istnieje.</summary>
        <returns>
          <see cref="T:System.Data.EntityKey" /> Obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Data.EntityKey> nie istnieje dla `entity`, <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> metoda tworzy nowy klucz.  
  
 Ta metoda jest używana do określenia, czy obiekt, który ma taką samą <xref:System.Data.EntityKey> jest już dołączony do <xref:System.Data.Objects.ObjectContext>. Jeśli obiekt, który ma taką samą <xref:System.Data.EntityKey> jest już dołączony zgłoszony wyjątek. Użyj <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> metody, aby spróbować pobrać <xref:System.Data.EntityKey> obiektu odłączony przed wywołaniem <xref:System.Data.Objects.ObjectContext.Attach%2A> metody.  
  
   
  
## Examples  
 Przykład, w tym temacie jest oparty na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W tym przykładzie <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> służy do pobierania klucza jednostki istniejącego obiektu.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdatesgetobject)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdatesgetobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Gdy jest albo parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Gdy <paramref name="entitySetName" /> jest pusta.  — lub — jeśli typ <paramref name="entity" /> obiekt nie istnieje w zestawie jednostek.  - lub - gdy <paramref name="entitySetName" /> nie jest w pełni kwalifikowana.</exception>
        <exception cref="T:System.InvalidOperationException">Po klucz jednostki nie można skonstruować pomyślnie oparte na podanych parametrów.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T CreateObject&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T CreateObject&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObject``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject(Of T As Class) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class T CreateObject();" />
      <MemberSignature Language="F#" Value="member this.CreateObject : unit -&gt; 'T (requires 'T : null)" Usage="objectContext.CreateObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Typ obiektu do zwrócenia.</typeparam>
        <summary>Tworzy i zwraca wystąpienia żądanego typu.</summary>
        <returns>Wystąpienia o żądanym typie <paramref name="T" />, lub wystąpienia typu pochodnego, która umożliwia <paramref name="T" /> ma być używany z programu Entity Framework. Zwrócony obiekt jest wystąpienia o żądanym typie lub wystąpienia typu pochodnego, który umożliwia żądanego typu, który ma być używany z programu Entity Framework.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.CreateObject%2A> z klasami danych niestandardowych POCO metodę, aby upewnić się, że zwrócony obiekt można poprawnie zarządzane przez program Entity Framework. Aby uzyskać więcej informacji, zobacz [wymagania dotyczące tworzenia obiektów POCO proxy](http://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) i [Praca z obiektów POCO jednostek](http://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) () As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet();" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : unit -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Żądany typ jednostki <see cref="T:System.Data.Objects.ObjectSet`1" />.</typeparam>
        <summary>Tworzy nową <see cref="T:System.Data.Objects.ObjectSet`1" /> wystąpienia, który służy do zapytań, dodawanie, modyfikowanie i usuwanie obiektów określonego typu jednostek.</summary>
        <returns>Nowe <see cref="T:System.Data.Objects.ObjectSet`1" /> wystąpienia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> Właściwość nie jest ustawiona na <see cref="T:System.Data.Objects.ObjectContext" />.  - lub - określonego typu należy do więcej niż jeden zestaw jednostek.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; (string entitySetName) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;(string entitySetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) (entitySetName As String) As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet(System::String ^ entitySetName);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : string -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet entitySetName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Żądany typ jednostki <see cref="T:System.Data.Objects.ObjectSet`1" />.</typeparam>
        <param name="entitySetName">Nazwa zestaw jednostek dla zwróconego <see cref="T:System.Data.Objects.ObjectSet`1" />. Ciąg musi być kwalifikowana przez nazwę kontenera domyślnego, jeśli <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> właściwość nie jest ustawiona na <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Tworzy nową <see cref="T:System.Data.Objects.ObjectSet`1" /> wystąpienie, które służy do zapytań, dodawanie, modyfikowanie i usuwanie obiektów określonego typu i o określonej jednostki Nazwa zestawu.</summary>
        <returns>Nowe <see cref="T:System.Data.Objects.ObjectSet`1" /> wystąpienia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Data.Metadata.Edm.EntitySet" /> z <paramref name="entitySetName" /> niezgodny <see cref="T:System.Data.Metadata.Edm.EntitySet" /> obiektu <see cref="T:System.Data.EntityKey" />.  - lub - <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> właściwość nie jest ustawiona na <see cref="T:System.Data.Objects.ObjectContext" /> i nazwa nie jest kwalifikowany jako część <paramref name="entitySetName" /> parametru.  - lub - określonego typu należy do więcej niż jeden zestaw jednostek.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProxyTypes">
      <MemberSignature Language="C#" Value="public void CreateProxyTypes (System.Collections.Generic.IEnumerable&lt;Type&gt; types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateProxyTypes(class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateProxyTypes(System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateProxyTypes (types As IEnumerable(Of Type))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateProxyTypes(System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.CreateProxyTypes : seq&lt;Type&gt; -&gt; unit" Usage="objectContext.CreateProxyTypes types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="types">Wyliczenie <see cref="T:System.Type" /> obiektów, które reprezentują klasy danych niestandardowych, które mapują do modelu koncepcyjnego.</param>
        <summary>Generuje równoważne typ, który może służyć Entity Framework dla każdego typu w wyliczeniu dostarczony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poszczególne typy w `types` wyliczenia, które nie są mapowane na typ jednostki w modelu koncepcyjnym są ignorowane.  
  
 Aby uzyskać więcej informacji, zobacz [wymagania dotyczące tworzenia obiektów POCO proxy](http://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) i [Praca z obiektów POCO jednostek](http://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateQuery&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; CreateQuery&lt;T&gt; (string queryString, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!!T&gt; CreateQuery&lt;T&gt;(string queryString, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateQuery``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateQuery(Of T) (queryString As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ CreateQuery(System::String ^ queryString, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateQuery : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectContext.CreateQuery (queryString, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">Typ jednostki zwróconego elementu <see cref="T:System.Data.Objects.ObjectQuery`1" />.</typeparam>
        <param name="queryString">Ciąg zapytania do wykonania.</param>
        <param name="parameters">Parametry do przekazania do zapytania.</param>
        <summary>Tworzy <see cref="T:System.Data.Objects.ObjectQuery`1" /> w bieżącym kontekście obiektu przy użyciu określony ciąg zapytania.</summary>
        <returns>
          <see cref="T:System.Data.Objects.ObjectQuery`1" /> Określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.Objects.ObjectContext.CreateQuery%2A> utworzyć <xref:System.Data.Objects.ObjectQuery%601> określonego typu, który należy do bieżącego kontekstu obiektów.  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 W przykładzie tworzy prostego zapytania i iteruje po kolekcji wyników.  
  
 [!code-csharp[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#createquery)]
 [!code-vb[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#createquery)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queryString" /> Lub <paramref name="parameters" /> parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="objectContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy baza danych jest określony jako bazy danych dla bieżącego połączenia źródła danych istnieje w źródle danych.</summary>
        <returns>
          <see langword="true" /> Jeśli baza danych istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość pracy jest delegowane do <xref:System.Data.Common.DbProviderServices.DatabaseExists%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [Praca z języka definicji danych](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      </Docs>
    </Member>
    <Member MemberName="DefaultContainerName">
      <MemberSignature Language="C#" Value="public string DefaultContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultContainerName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultContainerName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultContainerName : string with get, set" Usage="System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę kontenera domyślnego.</summary>
        <value>A <see cref="T:System.String" /> oznacza to nazwa kontenera domyślnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> nigdy nie zwraca `null`; albo zwraca wartość, która została zestawu lub pusty ciąg. Użytkownik może ustawić tę właściwość na `null`, ale wewnętrznie nazwa zostanie ustawiona na pusty ciąg, więc użytkownik musi nigdy nie sprawdzaj zarówno pustego ciągu i `null`.  
  
 Domyślna nazwa kontenera jest również definiowany jako część konstruktora. Jeśli domyślna nazwa kontenera jest ustawiana za pośrednictwem Konstruktor chroniony, staje się właściwość tylko do odczytu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="objectContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa z bazy danych, które jest określone jako bazy danych dla bieżącego połączenia źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość pracy jest delegowane do <xref:System.Data.Common.DbProviderServices.DeleteDatabase%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [Praca z języka definicji danych](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="DeleteObject">
      <MemberSignature Language="C#" Value="public void DeleteObject (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteObject(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteObject (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteObject(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.DeleteObject : obj -&gt; unit" Usage="objectContext.DeleteObject entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Obiekt, który określa jednostki do usunięcia. Obiekt może być w dowolnym stanie, z wyjątkiem <see cref="F:System.Data.EntityState.Detached" />.</param>
        <summary>Oznacza obiekt do usunięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznacza obiekt do usunięcia z <xref:System.Data.Objects.ObjectStateManager>. Obiekt jest usunięty w danych źródłowych, kiedy <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metoda jest wywoływana.  
  
 Usunięcie obiektu nadrzędnego spowoduje również usunięcie wszystkich obiektów podrzędnych w relacji ograniczone. Ten wynik jest taka sama jak włączanie `CascadeDelete` właściwości skojarzenia dla tej relacji.  
  
 <xref:System.Data.Objects.ObjectContext.DeleteObject%2A> Można wywołać metody w obiektach, które są już usunięte.  
  
   
  
## Examples  
 Te przykłady są oparte na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 Ten przykład tworzy <xref:System.Data.EntityKey> o określonym identyfikatorze ProductID, korzysta z klucza można pobrać obiektu produktu ze źródła danych, usunięcie produktu i zapisuje zmiany w bazie danych.  
  
 [!code-csharp[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#deleteobject)]
 [!code-vb[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#deleteobject)]  
  
 W tym przykładzie powoduje usunięcie istniejącego elementu kolejności, dodaje nowy element i zapisuje zmiany w bazie danych.  
  
 [!code-csharp[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savechanges)]
 [!code-vb[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savechanges)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entity" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> nie istnieje.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.DeleteObject(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Detach">
      <MemberSignature Language="C#" Value="public void Detach (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Detach(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Detach(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Detach (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Detach(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Detach : obj -&gt; unit" Usage="objectContext.Detach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Obiekt odłączenia. Tylko <c>jednostki</c> zostanie usunięta; Jeśli istnieją powiązane obiekty, które są śledzone przez ten sam <see cref="T:System.Data.Objects.ObjectStateManager" />, te będą nie można odłączyć automatycznie.</param>
        <summary>Usuwa obiekt z kontekstu obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usuwa obiekt z <xref:System.Data.Objects.ObjectStateManager>. Powoduje wyłączenie śledzenia zmian i rozpoznawania tożsamości dla tego obiektu. Aby uzyskać więcej informacji, zobacz [Dołączanie i odłączanie obiektów](http://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Po <xref:System.Data.Objects.ObjectContext.Detach%2A> metoda jest wywoływana, system nie zachowa odwołań, które wskazują ten obiekt i mogą być zbierane przez moduł garbage collector.  
  
> [!NOTE]
>  Wyrzucanie elementów bezużytecznych tylko może wystąpić, jeśli kod użytkownika nie ma żadnych odwołań do obiektu odłączony.  
  
 Następujące kwestie odłączanie obiektów:  
  
-   <xref:System.Data.Objects.ObjectContext.Detach%2A> dotyczy tylko określony obiekt, który jest przekazywany do metody. Jeśli obiekt jest odłączony od ma powiązane obiekty w kontekście obiektu, te obiekty nie są odłączone.  
  
-   Odłączanie obiektów nie ma wpływu na dane w źródle danych.  
  
-   Dyrektywy usuwania kaskadowego i ograniczenia referencyjne nie są wymuszane podczas operacji odłączania.  
  
 Aby uzyskać więcej informacji, zobacz [Dołączanie i odłączanie obiektów](http://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
   
  
## Examples  
 [!code-csharp[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#detachobjects)]
 [!code-vb[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#detachobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entity" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> Nie jest skojarzony z tym <see cref="T:System.Data.Objects.ObjectContext" /> (na przykład został nowo utworzona i nie jeszcze skojarzony z żadnym kontekstem uzyskano za pośrednictwem niektóre inne kontekstu lub już został odłączony).</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Detach(`0)" />
      </Docs>
    </Member>
    <Member MemberName="DetectChanges">
      <MemberSignature Language="C#" Value="public void DetectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DetectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub DetectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetectChanges();" />
      <MemberSignature Language="F#" Value="member this.DetectChanges : unit -&gt; unit" Usage="objectContext.DetectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, że <see cref="T:System.Data.Objects.ObjectStateEntry" /> zmiany są synchronizowane ze zmianami wprowadzonymi w wszystkie obiekty, które są śledzone przez <see cref="T:System.Data.Objects.ObjectStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez kontekst.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="objectContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez kontekst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zamyka połączenie, jeśli został on otwarty przez program Entity Framework. Po <xref:System.Data.Objects.ObjectContext.Dispose%2A> po wywołaniu operacji, które wymagają otwartego połączenia, takiej jak wykonywanie kwerendy lub wywołanie <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> metody, spowoduje, że wystąpił wyjątek. Operacje, które nie wymagają otwartego połączenia, takich jak tworzenie kwerendy lub dołączanie obiektów, nie spowodują wyjątek. <xref:System.Data.Objects.ObjectContext.Dispose%2A> — Metoda nie zamyka wszystkie otwarte jawnie połączenia.  
  
 Ograniczanie zakresu <xref:System.Data.Objects.ObjectContext> w `using` bloku (`Using` w języku Visual Basic) zapewnia, że zasoby są poprawnie usunięta. Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i transakcje](http://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
 <xref:System.Data.Objects.ObjectContext.Dispose> Wywołania metody `virtual` (`Overridable` w języku Visual Basic) <xref:System.Data.Objects.ObjectContext.Dispose%28System.Boolean%29> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="objectContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby używane przez kontekst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powoduje zamknięcie połączenia. Po <xref:System.Data.Objects.ObjectContext.Dispose%2A> po wywołaniu operacji, które wymagają otwartego połączenia, takiej jak wykonywanie kwerendy lub wywołanie <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> metody, spowoduje, że wystąpił wyjątek. Operacje, które nie wymagają otwartego połączenia, takich jak tworzenie kwerendy lub dołączanie obiektów, nie spowodują wyjątek.  
  
 Ograniczanie zakresu <xref:System.Data.Objects.ObjectContext> w `using` bloku (`Using` w języku Visual Basic) zapewnia, że zasoby są poprawnie usunięta. Aby uzyskać więcej informacji, zobacz [Zarządzanie połączeniami i transakcje](http://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction">
      <MemberSignature Language="C#" Value="public int ExecuteFunction (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteFunction(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction (functionName As String, ParamArray parameters As ObjectParameter()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; int" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="functionName">Nazwa procedury składowanej lub funkcji. Nazwa może zawierać nazwy kontenera, takich jak <c> &lt;nazwa kontenera&gt;.&lt; Nazwa funkcji&gt;</c>. Jeśli domyślna nazwa kontenera jest znany, tylko nazwa funkcji jest wymagana.</param>
        <param name="parameters">Tablica <see cref="T:System.Data.Objects.ObjectParameter" /> obiektów.</param>
        <summary>Wykonuje procedurę składowaną lub funkcję, która jest zdefiniowana w źródle danych i wyrażone w modelu koncepcyjnym; odrzuca wszystkie wyniki zwrócone z funkcji; i zwraca liczbę wierszy objętych wykonywania.</summary>
        <returns>Liczba zmodyfikowanych wierszy.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" /> ma wartość null lub pusty - lub - <paramref name="function" /> nie znaleziono.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jednostki nie jest to obsługiwane <paramref name="function" />.  Wystąpiła niezgodność typów w czytniku - lub - i <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction(Of TElement) (functionName As String, ParamArray parameters As ObjectParameter()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Typ jednostki <see cref="T:System.Data.Objects.ObjectResult`1" /> zwracany, gdy funkcja jest wykonywana w źródle danych. Ten typ musi implementować <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Nazwa procedury składowanej lub funkcji. Nazwa może zawierać nazwy kontenera, takich jak <c> &lt;nazwa kontenera&gt;.&lt; Nazwa funkcji&gt;</c>. Jeśli domyślna nazwa kontenera jest znany, tylko nazwa funkcji jest wymagana.</param>
        <param name="parameters">Tablica <see cref="T:System.Data.Objects.ObjectParameter" /> obiektów.</param>
        <summary>Wykonuje procedurę składowaną lub funkcję, która jest zdefiniowana w źródle danych i mapowane w modelu koncepcyjnym z określonymi parametrami. Zwraca wartość typu <see cref="T:System.Data.Objects.ObjectResult`1" />.</summary>
        <returns>
          <see cref="T:System.Data.Objects.ObjectResult`1" /> Dla danych zwracanych przez procedurę składowaną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> — Metoda to metoda pomocnika, która służy do wykonywania procedury składowanej lub funkcji, które są zdefiniowane w źródle danych i wyrażonym w modelu koncepcyjnym. Narzędzia modelu Entity Data Model Generowanie metody dla każdej z nich w modelu koncepcyjnym. Te metody mogą wywoływać silnie typizowanego `ExecuteFunction` do zwrócenia typu <xref:System.Data.Objects.ObjectResult%601>. Aby uzyskać więcej informacji, zobacz [kod aplikacji przy użyciu procedur składowanych (Enity Framework)](http://msdn.microsoft.com/library/d13dd33f-fcf9-4e86-bd00-74bc31521536).  
  
 Wszystkie parametry dla funkcji są wymagane w tablicy parametrów, a wszystkie typy są porównywane z metadanych funkcji importu, takich jak typ samej funkcji. `null` wartości są dozwolone dla typów wartości CLR. Sprawdzanie poprawności parametru jest wykonywane przez dostawcę.  
  
 <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> Używa metody <xref:System.Data.Objects.MergeOption> wartość <xref:System.Data.Objects.MergeOption.AppendOnly>. W związku z tym jeśli obiekt już istnieje w kontekście obiektu, jego nie zostanie załadowany ze źródła danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" /> ma wartość null lub pusty - lub - <paramref name="function" /> nie znaleziono.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jednostki nie jest to obsługiwane <paramref name="function" />.  Wystąpiła niezgodność typów w czytniku - lub - i <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, System.Data.Objects.MergeOption mergeOption, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, valuetype System.Data.Objects.MergeOption mergeOption, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.MergeOption,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.MergeOption * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Typ jednostki <see cref="T:System.Data.Objects.ObjectResult`1" /> zwracany, gdy funkcja jest wykonywana w źródle danych. Ten typ musi implementować <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Nazwa procedury składowanej lub funkcji. Nazwa może zawierać nazwy kontenera, takich jak <c> &lt;nazwa kontenera&gt;.&lt; Nazwa funkcji&gt;</c>. Jeśli domyślna nazwa kontenera jest znany, tylko nazwa funkcji jest wymagana.</param>
        <param name="mergeOption">
          <see cref="T:System.Data.Objects.MergeOption" /> Do użycia podczas wykonywania zapytania.</param>
        <param name="parameters">Tablica <see cref="T:System.Data.Objects.ObjectParameter" /> obiektów.</param>
        <summary>Wykonuje danego procedura składowana lub funkcja, która jest zdefiniowana w źródle danych i wyrażone w modelu koncepcyjnym z określonych parametrów i opcji scalania. Zwraca wartość typu <see cref="T:System.Data.Objects.ObjectResult`1" />.</summary>
        <returns>
          <see cref="T:System.Data.Objects.ObjectResult`1" /> Dla danych zwracanych przez procedurę składowaną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> — Metoda to metoda pomocnika, która służy do wykonywania procedury składowanej lub funkcji, które są zdefiniowane w źródle danych i wyrażonym w modelu koncepcyjnym. Narzędzia modelu Entity Data Model Generowanie metody dla każdej z nich w modelu koncepcyjnym. Te metody mogą wywoływać silnie typizowanego `ExecuteFunction` do zwrócenia typu <xref:System.Data.Objects.ObjectResult%601>. Aby uzyskać więcej informacji, zobacz [kod aplikacji przy użyciu procedur składowanych (Enity Framework)](http://msdn.microsoft.com/library/d13dd33f-fcf9-4e86-bd00-74bc31521536).  
  
 Wszystkie parametry dla funkcji są wymagane w tablicy parametrów, a wszystkie typy są porównywane z metadanych funkcji importu, takich jak typ samej funkcji. `null` wartości są dozwolone dla typów wartości CLR. Sprawdzanie poprawności parametru jest wykonywane przez dostawcę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="function" /> ma wartość null lub pusty - lub - <paramref name="function" /> nie znaleziono.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jednostki nie jest to obsługiwane <paramref name="function" />.  Wystąpiła niezgodność typów w czytniku - lub - i <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommand">
      <MemberSignature Language="C#" Value="public int ExecuteStoreCommand (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteStoreCommand(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreCommand (commandText As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteStoreCommand(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreCommand : string * obj[] -&gt; int" Usage="objectContext.ExecuteStoreCommand (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="commandText">Polecenie do wykonania w języku macierzystym źródła danych.</param>
        <param name="parameters">Tablica parametry do przekazania do polecenia.</param>
        <summary>Wykonuje dowolne polecenie bezpośrednio względem źródła danych przy użyciu istniejącego połączenia.</summary>
        <returns>Liczba zmodyfikowanych wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą sparametryzowanych poleceń chroni przed atakami iniekcji kodu SQL, w których osoba atakująca "injects" polecenia w instrukcji SQL zabezpieczenia dokonywania na serwerze. Sparametryzowanych poleceń chronią przed ataku polegającego na iniekcji SQL, gwarantując, że wartości odebranych z zewnętrznego źródła są przekazywane jako tylko wartości i nie jest częścią instrukcji SQL. W związku z tym polecenia SQL do wartości nie są wykonywane w źródle danych. Zamiast są oceniane tylko jako wartości parametru. Oprócz zabezpieczeń zapewnianych sparametryzowanych poleceń zapewniają wygodną metodę organizowania wartości przekazane za pomocą instrukcji SQL lub procedury składowanej.  
  
 `parameters` Wartość może być tablicą <xref:System.Data.Common.DbParameter> obiektów lub tablica wartości parametrów. Jeśli tylko wartości są dostarczane, tablicę <xref:System.Data.Common.DbParameter> obiekty są tworzone na podstawie kolejności wartości w tablicy.  
  
 Polecenie magazynu jest wykonywany w kontekście bieżącej transakcji, jeśli istnieje w bieżącej transakcji.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednio wykonywania poleceń magazynu](http://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Porady: bezpośrednie wykonywanie poleceń względem źródła danych](http://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteStoreQuery&lt;TElement&gt; (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteStoreQuery&lt;TElement&gt;(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreQuery(Of TElement) (commandText As String, ParamArray parameters As Object()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteStoreQuery(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">To be added.</typeparam>
        <param name="commandText">Polecenie do wykonania w języku macierzystym źródła danych.</param>
        <param name="parameters">Tablica parametry do przekazania do polecenia.</param>
        <summary>Wykonuje zapytanie bezpośrednio względem źródła danych, które zwraca sekwencję maszynowy wyników.</summary>
        <returns>Wyliczenie obiektów typu <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> Metoda wykorzystuje istniejące połączenie do wykonania dowolnego polecenia bezpośrednio względem źródła danych. Polecenie magazynu jest wykonywany w kontekście bieżącej transakcji, jeśli istnieje taka transakcja.  
  
 Wywoływanie <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> jest odpowiednikiem wywołania metody <xref:System.Data.Common.DbCommand.ExecuteReader%2A> metody <xref:System.Data.Common.DbCommand> klasy tylko <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> zwraca jednostki i <xref:System.Data.Common.DbCommand.ExecuteReader%2A> zwraca wartości właściwości <xref:System.Data.Common.DbDataReader>.  
  
 Wywołanie <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> z określonej jednostki Nazwa zestawu, jeśli chcesz, aby uzyskać wyniki mają być śledzone.  
  
 Wywołanie <xref:System.Data.Objects.ObjectContext.Translate%2A> metody tłumaczenie <xref:System.Data.Common.DbDataReader> na obiekty jednostki, gdy czytnik zawiera wiersze danych, które mapują na określony typ jednostki.  
  
 Za pomocą sparametryzowanych poleceń chroni przed atakami iniekcji kodu SQL, w których osoba atakująca "injects" polecenia w instrukcji SQL zabezpieczenia dokonywania na serwerze. Sparametryzowanych poleceń chronią przed ataku polegającego na iniekcji SQL, gwarantując, że wartości odebranych z zewnętrznego źródła są przekazywane jako tylko wartości i nie jest częścią instrukcji SQL. W związku z tym polecenia SQL do wartości nie są wykonywane w źródle danych. Zamiast są oceniane tylko jako wartości parametru. Oprócz zabezpieczeń zapewnianych sparametryzowanych poleceń zapewniają wygodną metodę organizowania wartości przekazane za pomocą instrukcji SQL lub procedury składowanej.  
  
 `parameters` Wartość może być tablicą <xref:System.Data.Common.DbParameter> obiektów lub tablica wartości parametrów. Jeśli tylko wartości są dostarczane, tablicę <xref:System.Data.Common.DbParameter> obiekty są tworzone na podstawie kolejności wartości w tablicy.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednio wykonywania poleceń magazynu](http://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Porady: bezpośrednie wykonywanie poleceń względem źródła danych](http://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt; (string commandText, string entitySetName, System.Data.Objects.MergeOption mergeOption, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt;(string commandText, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.String,System.Data.Objects.MergeOption,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ ExecuteStoreQuery(System::String ^ commandText, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * string * System.Data.Objects.MergeOption * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, entitySetName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="commandText">Polecenie do wykonania w języku macierzystym źródła danych.</param>
        <param name="entitySetName">Zestaw jednostek <c>TResult</c> typu. Jeśli nie podano nazwy zestawu jednostek, wyniki nie będą śledzone.</param>
        <param name="mergeOption">
          <see cref="T:System.Data.Objects.MergeOption" /> Do użycia podczas wykonywania zapytania. Wartość domyślna to <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <param name="parameters">Tablica parametry do przekazania do polecenia.</param>
        <summary>Wykonuje zapytanie bezpośrednio względem źródła danych i zwraca sekwencję maszynowy wyników. Określ zestaw jednostek oraz opcji scalania, aby wyniki zapytania mogą być śledzone jako jednostek.</summary>
        <returns>Wyliczenie obiektów typu <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> Metoda wykorzystuje istniejące połączenie do wykonania dowolnego polecenia bezpośrednio względem źródła danych. Polecenie magazynu jest wykonywany w kontekście bieżącej transakcji, jeśli istnieje taka transakcja.  
  
 Wywoływanie <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> jest odpowiednikiem wywołania metody <xref:System.Data.Common.DbCommand.ExecuteReader%2A> metody <xref:System.Data.Common.DbCommand> klasy tylko <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> zwraca jednostki i <xref:System.Data.Common.DbCommand.ExecuteReader%2A> zwraca wartości właściwości <xref:System.Data.Common.DbDataReader>.  
  
 Określ zestaw jednostek, nazwa, jeśli wyniki mają być śledzone jako jednostek.  
  
 Wywołanie <xref:System.Data.Objects.ObjectContext.Translate%2A> metody tłumaczenie <xref:System.Data.Common.DbDataReader> na obiekty jednostki, gdy czytnik zawiera wiersze danych, które mapują na określony typ jednostki.  
  
 Za pomocą sparametryzowanych poleceń chroni przed atakami iniekcji kodu SQL, w których osoba atakująca "injects" polecenia w instrukcji SQL zabezpieczenia dokonywania na serwerze. Sparametryzowanych poleceń chronią przed ataku polegającego na iniekcji SQL, gwarantując, że wartości odebranych z zewnętrznego źródła są przekazywane jako tylko wartości i nie jest częścią instrukcji SQL. W związku z tym polecenia SQL do wartości nie są wykonywane w źródle danych. Zamiast są oceniane tylko jako wartości parametru. Oprócz zabezpieczeń zapewnianych sparametryzowanych poleceń zapewniają wygodną metodę organizowania wartości przekazane za pomocą instrukcji SQL lub procedury składowanej.  
  
 `parameters` Wartość może być tablicą <xref:System.Data.Common.DbParameter> obiektów lub tablica wartości parametrów. Jeśli tylko wartości są dostarczane, tablicę <xref:System.Data.Common.DbParameter> obiekty są tworzone na podstawie kolejności wartości w tablicy.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednio wykonywania poleceń magazynu](http://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Porady: bezpośrednie wykonywanie poleceń względem źródła danych](http://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKnownProxyTypes">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Type&gt; GetKnownProxyTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; GetKnownProxyTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetKnownProxyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetKnownProxyTypes () As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ GetKnownProxyTypes();" />
      <MemberSignature Language="F#" Value="static member GetKnownProxyTypes : unit -&gt; seq&lt;Type&gt;" Usage="System.Data.Objects.ObjectContext.GetKnownProxyTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie istniejące typy serwera proxy.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Wszystkich istniejących typów serwera proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.GetKnownProxyTypes%2A> Metoda jest używana, jeśli Generowanie obiekt serwera proxy jest włączone dla jednostki POCO. Aby uzyskać więcej informacji, zobacz [wymagania dotyczące tworzenia obiektów POCO proxy](http://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) i [Praca z obiektów POCO jednostek](http://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectByKey">
      <MemberSignature Language="C#" Value="public object GetObjectByKey (System.Data.EntityKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetObjectByKey(class System.Data.EntityKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectByKey(System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObjectByKey (key As EntityKey) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetObjectByKey(System::Data::EntityKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.GetObjectByKey : System.Data.EntityKey -&gt; obj" Usage="objectContext.GetObjectByKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz obiektu, który ma zostać odnaleziona.</param>
        <summary>Zwraca obiekt, który ma określony klucz.</summary>
        <returns>
          <see cref="T:System.Object" /> Czyli wystąpienia typu jednostki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> próbuje pobrać obiektu z określonym <xref:System.Data.EntityKey> z <xref:System.Data.Objects.ObjectStateManager>. Jeśli obiekt nie jest aktualnie załadowany w kontekście obiektu, zapytanie jest wykonywane w celu zwracać obiekt ze źródła danych. Aby uzyskać więcej informacji, zobacz [zapytań obiektu](http://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> zgłasza <xref:System.Data.ObjectNotFoundException> gdy nie można odnaleźć obiektu. Aby uniknąć Obsługa tego wyjątku, zamiast tego użyć <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> metody.  
  
 Ta metoda zwróci obiektów w <xref:System.Data.EntityState.Deleted> stanu.  
  
 Klucza tymczasowego nie można zwracać obiekt ze źródła danych.  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie jest tworzony <xref:System.Data.EntityKey> dla danego typu jednostki, a następnie pobiera jednostek według klucza.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_getobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_getobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Data.ObjectNotFoundException">Nie odnaleziono obiektu w jednym <see cref="T:System.Data.Objects.ObjectStateManager" /> lub źródła danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectType">
      <MemberSignature Language="C#" Value="public static Type GetObjectType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetObjectType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetObjectType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetObjectType : Type -&gt; Type" Usage="System.Data.Objects.ObjectContext.GetObjectType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> Obiektu serwera proxy.</param>
        <summary>Zwraca typ jednostki jednostki POCO skojarzonej z określonego typu obiektu serwera proxy.</summary>
        <returns>
          <see cref="T:System.Type" /> Skojarzone jednostki POCO.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.GetObjectType%2A> Metoda jest używana, jeśli Generowanie obiekt serwera proxy jest włączone dla jednostki POCO. Aby uzyskać więcej informacji, zobacz [wymagania dotyczące tworzenia obiektów POCO proxy](http://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) i [Praca z obiektów POCO jednostek](http://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadProperty">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Jawnie ładuje obiektu pokrewnego, korzystając z POCO danych niestandardowych klas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas używania klas danych niestandardowych POCO, powiązanych obiektów nie można jawnie załadować jak wystąpień typów jednostek, które są generowane przy użyciu modelu Entity Data Model tools. Jest to spowodowane narzędzia generować właściwości nawigacji, które zwracają <xref:System.Data.Objects.DataClasses.EntityCollection%601> lub <xref:System.Data.Objects.DataClasses.EntityReference%601> obiektów pokrewnych podczas <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> jest wywoływana na <xref:System.Data.Objects.DataClasses.RelatedEnd>. Jednostki POCO nadal mogą być ładowane przy użyciu opóźnionego ładowania ustawiając <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> właściwości `true` w wystąpieniu programu <xref:System.Data.Objects.ObjectContextOptions> zwróconego przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwości, lub za pomocą wczesny ładowanie z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metoda <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty (entity As Object, navigationProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="navigationProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostki, dla której mają zostać załadowane powiązanych obiektów.</param>
        <param name="navigationProperty">Nazwa właściwości nawigacji zwracającej pokrewnych obiektów do załadowania.</param>
        <summary>Ładuje jawnie obiektu związane z podanego obiektu określonej właściwości nawigacji i przy użyciu opcji scalania domyślne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Metoda musi zostać wywołana do osiągnięcia jawnego ładowania, korzystając z POCO danych niestandardowych klas.  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, powiązany obiekt jest możliwy za pośrednictwem właściwości nawigacji jednostki źródłowej.  
  
 Podczas używania klas danych niestandardowych POCO, powiązanych obiektów nie można jawnie załadować jak wystąpień typów jednostek, które są generowane przy użyciu modelu Entity Data Model tools. Jest to spowodowane narzędzia generować właściwości nawigacji, które zwracają <xref:System.Data.Objects.DataClasses.EntityCollection%601> lub <xref:System.Data.Objects.DataClasses.EntityReference%601> obiektów pokrewnych podczas <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> jest wywoływana na <xref:System.Data.Objects.DataClasses.RelatedEnd>. Jednostki POCO nadal mogą być ładowane przy użyciu opóźnionego ładowania ustawiając <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> właściwości `true` w wystąpieniu programu <xref:System.Data.Objects.ObjectContextOptions> zwróconego przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwości, lub za pomocą wczesny ładowanie z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metoda <xref:System.Data.Objects.ObjectQuery%601>.  
  
 Gdy <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> metoda jest wywoływana, obiekty są ładowane do <xref:System.Data.Objects.ObjectContext> przy użyciu domyślnej <xref:System.Data.Objects.MergeOption> wartość <xref:System.Data.Objects.MergeOption.AppendOnly>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> w <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> lub <see cref="F:System.Data.EntityState.Deleted" /> stanu, - lub - <paramref name="entity" /> jest dołączony do innego wystąpienia programu <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="navigationProperty" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostki, dla której mają zostać załadowane powiązanych obiektów.</param>
        <param name="navigationProperty">Nazwa właściwości nawigacji zwracającej pokrewnych obiektów do załadowania.</param>
        <param name="mergeOption">
          <see cref="T:System.Data.Objects.MergeOption" /> Wartość używaną podczas ładowania powiązanych obiektów.</param>
        <summary>Ładuje jawnie obiektu, który jest powiązany z podanego obiektu określonej właściwości nawigacji i przy użyciu opcji scalania określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Metoda musi zostać wywołana do osiągnięcia jawnego ładowania, korzystając z POCO danych niestandardowych klas.  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, powiązany obiekt jest możliwy za pośrednictwem właściwości nawigacji jednostki źródłowej.  
  
 Podczas używania klas danych niestandardowych POCO, powiązanych obiektów nie można jawnie załadować jak wystąpień typów jednostek, które są generowane przy użyciu modelu Entity Data Model tools. Jest to spowodowane narzędzia generować właściwości nawigacji, które zwracają <xref:System.Data.Objects.DataClasses.EntityCollection%601> lub <xref:System.Data.Objects.DataClasses.EntityReference%601> obiektów pokrewnych podczas <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> jest wywoływana na <xref:System.Data.Objects.DataClasses.RelatedEnd>. Jednostki POCO nadal mogą być ładowane przy użyciu opóźnionego ładowania ustawiając <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> właściwości `true` w wystąpieniu programu <xref:System.Data.Objects.ObjectContextOptions> zwróconego przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwości, lub za pomocą wczesny ładowanie z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metoda <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> w <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added," /> lub <see cref="F:System.Data.EntityState.Deleted" /> stanu, - lub - <paramref name="entity" /> jest dołączony do innego wystąpienia programu <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty(Of TEntity) (entity As TEntity, selector As Expression(Of Func(Of TEntity, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; -&gt; unit" Usage="objectContext.LoadProperty (entity, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="entity">Obiekt źródłowy, dla której mają zostać załadowane powiązanych obiektów.</param>
        <param name="selector">Wyrażenie LINQ, który definiuje pokrewnych obiektów do załadowania.</param>
        <summary>Ładuje jawnie obiektu, który jest powiązany z dostarczonego obiektu, według określonego zapytania LINQ i przy użyciu opcji scalania domyślne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Metoda musi zostać wywołana do osiągnięcia jawnego ładowania, korzystając z POCO danych niestandardowych klas.  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, powiązany obiekt jest możliwy za pośrednictwem właściwości nawigacji jednostki źródłowej.  
  
 Właściwość załadować jest określona przez wyrażenie LINQ, który musi być w formie właściwości prostej dostęp do elementu członkowskiego, podobnie jak w `(entity) => entity.PropertyName`, gdzie *PropertyName* jest właściwością nawigacji, która zwraca pokrewnych obiektów do załadowania. Wystąpił wyjątek wystąpi, jeśli są używane inne formy wyrażenia LINQ.  
  
 Podczas używania klas danych niestandardowych POCO, powiązanych obiektów nie można jawnie załadować jak wystąpień typów jednostek, które są generowane przy użyciu modelu Entity Data Model tools. Jest to spowodowane narzędzia generować właściwości nawigacji, które zwracają <xref:System.Data.Objects.DataClasses.EntityCollection%601> lub <xref:System.Data.Objects.DataClasses.EntityReference%601> obiektów pokrewnych podczas <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> jest wywoływana na <xref:System.Data.Objects.DataClasses.RelatedEnd>. Jednostki POCO nadal mogą być ładowane przy użyciu opóźnionego ładowania ustawiając <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> właściwości `true` w wystąpieniu programu <xref:System.Data.Objects.ObjectContextOptions> zwróconego przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwości, lub za pomocą wczesny ładowanie z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metoda <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="selector" /> nie zapewnia prawidłowego parametru wejściowego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="selector" /> ma wartość null.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> w <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added," /> lub <see cref="F:System.Data.EntityState.Deleted" /> stanu, - lub - <paramref name="entity" /> jest dołączony do innego wystąpienia programu <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, selector, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="entity">Obiekt źródłowy, dla której mają zostać załadowane powiązanych obiektów.</param>
        <param name="selector">Wyrażenie LINQ, który definiuje pokrewnych obiektów do załadowania.</param>
        <param name="mergeOption">
          <see cref="T:System.Data.Objects.MergeOption" /> Wartość używaną podczas ładowania powiązanych obiektów.</param>
        <summary>Jawnie ładuje powiązanej z podanego obiektu określonego zapytania LINQ i przy użyciu opcji scalania określonego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Metoda musi zostać wywołana do osiągnięcia jawnego ładowania, korzystając z POCO danych niestandardowych klas.  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, powiązany obiekt jest możliwy za pośrednictwem właściwości nawigacji jednostki źródłowej.  
  
 Właściwość załadować jest określona przez wyrażenie LINQ, który musi być w formie właściwości prostej dostęp do elementu członkowskiego, podobnie jak w `(entity) => entity.PropertyName` gdzie *PropertyName* jest właściwością nawigacji, która zwraca pokrewnych obiektów do załadowania. Wystąpił wyjątek wystąpi, jeśli są używane inne formy wyrażenia LINQ.  
  
 Podczas używania klas danych niestandardowych POCO, powiązanych obiektów nie można jawnie załadować jak wystąpień typów jednostek, które są generowane przy użyciu modelu Entity Data Model tools. Jest to spowodowane narzędzia generować właściwości nawigacji, które zwracają <xref:System.Data.Objects.DataClasses.EntityCollection%601> lub <xref:System.Data.Objects.DataClasses.EntityReference%601> obiektów pokrewnych podczas <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> jest wywoływana na <xref:System.Data.Objects.DataClasses.RelatedEnd>. Jednostki POCO nadal mogą być ładowane przy użyciu opóźnionego ładowania ustawiając <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> właściwości `true` w wystąpieniu programu <xref:System.Data.Objects.ObjectContextOptions> zwróconego przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwości, lub za pomocą wczesny ładowanie z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metoda <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="selector" /> nie zapewnia prawidłowego parametru wejściowego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="selector" /> ma wartość null.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> w <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added," /> lub <see cref="F:System.Data.EntityState.Deleted" /> stanu, - lub - <paramref name="entity" /> jest dołączony do innego wystąpienia programu <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetadataWorkspace">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MetadataWorkspace As MetadataWorkspace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Metadata::Edm::MetadataWorkspace ^ MetadataWorkspace { System::Data::Metadata::Edm::MetadataWorkspace ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataWorkspace : System.Data.Metadata.Edm.MetadataWorkspace" Usage="System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.MetadataWorkspace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obszaru roboczego metadanych używane przez kontekst.</summary>
        <value>
          <see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /> Obiekt skojarzony z tym <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Metadata.Edm.MetadataWorkspace> Klasa jest centralna środowisko uruchomieniowe interfejsu API, który służy do interakcji z metadanych modelu danych jednostki (EDM) w kontekście aplikacji. Aby uzyskać więcej informacji, zobacz [obszaru roboczego metadanych](http://msdn.microsoft.com/library/601aee56-3eda-4caa-9082-a01df76c5e84).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectMaterialized">
      <MemberSignature Language="C#" Value="public event System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.ObjectMaterialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ObjectMaterialized As ObjectMaterializedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::Objects::ObjectMaterializedEventHandler ^ ObjectMaterialized;" />
      <MemberSignature Language="F#" Value="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " Usage="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectMaterializedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy jest tworzony nowy obiekt jednostki z danych w źródle danych w ramach operacji zapytania lub obciążenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane po wykonaniu wszystkich skalarną, złożoną, i zostały ustawione właściwości odwołania do obiektu, ale przed kolekcje są ładowane. Jeśli istnieje obiekt o tej samej wartości klucza w kontekście obiektu, Entity Framework nie będzie ponownie utworzyć obiekt i to zdarzenie nie zostanie wygenerowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectStateManager">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectStateManager ObjectStateManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectStateManager ObjectStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ObjectStateManager As ObjectStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectStateManager ^ ObjectStateManager { System::Data::Objects::ObjectStateManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ObjectStateManager : System.Data.Objects.ObjectStateManager" Usage="System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectStateManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera menedżera stanu obiektów, które są używane przez kontekst śledzenie zmian obiektu.</summary>
        <value>
          <see cref="T:System.Data.Objects.ObjectStateManager" /> Używanych przez to <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Te przykłady są oparte na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W tym przykładzie pobiera <xref:System.Data.Objects.ObjectStateManager> z <xref:System.Data.Objects.ObjectContext> i używa Menedżer stanu dostępu do obiektu w tym kontekście.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectstatemanager)]
 [!code-vb[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectstatemanager)]  
  
 W tym przykładzie użyto <xref:System.Data.Objects.ObjectStateManager.TryGetObjectStateEntry%2A> metody w zwróconym <xref:System.Data.Objects.ObjectStateManager> można pobrać obiektu na podstawie jego klucza jednostki.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdates)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdates)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryProvider">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryProvider QueryProvider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.IQueryProvider QueryProvider" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property QueryProvider As IQueryProvider" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Linq::IQueryProvider ^ QueryProvider { System::Linq::IQueryProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryProvider : System.Linq.IQueryProvider" Usage="System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dostawcę zapytań LINQ skojarzone z tym kontekstem obiektu.</summary>
        <value>
          <see cref="T:System.Linq.IQueryProvider" /> Wystąpienie używane przez ten kontekst.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualizuje określone obiekty w kontekście obiektu danych ze źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność, w których obiekty są odświeżane jest niejednoznaczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="objectContext.Refresh (refreshMode, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="refreshMode">A <see cref="T:System.Data.Objects.RefreshMode" /> wartość, która wskazuje, czy wartości właściwości ze źródła danych zostaną zastąpione zmiany właściwości w kontekście obiektu.</param>
        <param name="collection">
          <see cref="T:System.Collections.IEnumerable" /> Kolekcji obiektów do odświeżenia.</param>
        <summary>Aktualizuje kolekcję obiektów w kontekście obiektu danych ze źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma podwójną rolę stosowanie obiektów w kontekście obiektu odświeżenia danych ze źródła danych i jest mechanizm, za pomocą którego można rozwiązać konflikty. Aby uzyskać więcej informacji, zobacz [zapisywania zmian i zarządzanie współbieżności](http://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 Kolejność, w których obiekty są odświeżane jest niejednoznaczny.  
  
 Po <xref:System.Data.Objects.ObjectContext.Refresh%2A> jest nazywany obiektu oryginalnych wartości zawsze zostanie zaktualizowana wartość źródła danych, ale bieżące wartości mogą lub nie mogły zostać zaktualizowane z wartość źródła danych. Zależy to od <xref:System.Data.Objects.RefreshMode> wartość. <xref:System.Data.Objects.RefreshMode.StoreWins> Tryb oznacza, że mają być aktualizowane w kolekcji obiektów do dopasowania wartości źródła danych. <xref:System.Data.Objects.RefreshMode.ClientWins> oznacza, że zostaną utrwalone tylko zmiany w kontekście obiektu, nawet jeśli zostały innych zmian w źródle danych.  
  
 Aby upewnić się, że obiekty zostały zaktualizowane przez logikę po stronie źródła danych, należy wywołać <xref:System.Data.Objects.ObjectContext.Refresh%2A> z <xref:System.Data.Objects.RefreshMode.StoreWins> po wywołaniu metody <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="refreshMode" /> nie jest prawidłowy.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collection" /> jest pusty.  - lub - obiekt nie jest dołączony do kontekstu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * obj -&gt; unit" Usage="objectContext.Refresh (refreshMode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Jeden z <see cref="T:System.Data.Objects.RefreshMode" /> wartości, które określa tryb, który na potrzeby odświeżania <see cref="T:System.Data.Objects.ObjectStateManager" />.</param>
        <param name="entity">Obiekt do odświeżenia.</param>
        <summary>Aktualizuje obiekt w kontekście obiektu danych ze źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.Refresh%2A> ma podwójną rolę stosowanie obiektu odświeżenia danych ze źródła danych, a w rezultacie mechanizm, za pomocą którego można rozwiązać konflikty. Aby uzyskać więcej informacji, zobacz [zapisywania zmian i zarządzanie współbieżności](http://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 Kolejność, w których obiekty są odświeżane jest niejednoznaczny.  
  
 Po <xref:System.Data.Objects.ObjectContext.Refresh%2A> metoda jest wywoływana, oryginalnych wartości obiektu zawsze zostanie zaktualizowana wartość źródła danych, ale bieżące wartości mogą lub nie mogły zostać zaktualizowane z wartość źródła danych. Zależy to od <xref:System.Data.Objects.RefreshMode>. <xref:System.Data.Objects.RefreshMode.StoreWins> Tryb oznacza, że można zaktualizować obiektu, aby dopasować wartości źródła danych. <xref:System.Data.Objects.RefreshMode.ClientWins> Wartość oznacza, że tylko zmiany w kontekście obiektu zostaną utrwalone, nawet jeśli zostały innych zmian w źródle danych.  
  
 Aby upewnić się, że obiekt został zaktualizowany przez logikę po stronie źródła danych, należy wywołać <xref:System.Data.Objects.ObjectContext.Refresh%2A> metody z <xref:System.Data.Objects.RefreshMode.StoreWins> wartość po wywołaniu metody <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metody.  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Przykład próbuje zapisać zmiany, a to może spowodować konflikt współbieżności. Następnie widoczny jest sposób rozwiązania konfliktu współbieżności odświeżając kontekst przed ponownie zapisać zmiany.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="refreshMode" /> nie jest prawidłowy.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collection" /> jest pusty.  - lub - obiekt nie jest dołączony do kontekstu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Utrzymuje wszystkie aktualizacje w źródle danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges();" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : unit -&gt; int" Usage="objectContext.SaveChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Będzie się powtarzał wszystkie aktualizacje w źródle danych i resetuje Zmień śledzenia w kontekście obiektu.</summary>
        <returns>Liczba obiektów w <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" />, lub <see cref="F:System.Data.EntityState.Deleted" /> Jeśli <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> została wywołana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby upewnić się, że obiekty na kliencie zostały zaktualizowane przez logikę po stronie źródła danych, należy wywołać <xref:System.Data.Objects.ObjectContext.Refresh%2A> metody z <xref:System.Data.Objects.RefreshMode.StoreWins> wartość po wywołaniu metody <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Aby uzyskać więcej informacji, zobacz [zapisywania zmian i zarządzanie współbieżności](http://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> działa w ramach transakcji. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> zostanie wycofać tej transakcji i zgłosić wyjątek, jeśli dowolny z zanieczyszczeniu <xref:System.Data.Objects.ObjectStateEntry> obiektów nie może zostać utrwalona.  
  
 Jeśli nastąpiło naruszenie optymistycznej współbieżności, <xref:System.Data.OptimisticConcurrencyException> jest generowany. Naruszenie optymistycznej współbieżności można rozwiązać przez przechwytywanie, wywoływania <xref:System.Data.Objects.ObjectContext.Refresh%2A> metody z <xref:System.Data.Objects.RefreshMode.StoreWins> lub <xref:System.Data.Objects.RefreshMode.ClientWins> wartości, a następnie wywołania <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> ponownie. Aby uzyskać więcej informacji, zobacz [porady: Zarządzanie współbieżność danych w kontekście obiektu](http://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a).  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W tym przykładzie próbuje zapisać zmiany, które mogą powodować konflikt współbieżności. Następnie go pokazano, jak rozwiązać konflikt współbieżności odświeżając kontekst przed ponownie zapisać zmiany.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Wystąpiło naruszenie optymistycznej współbieżności w źródle danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges (bool acceptChangesDuringSave);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges(bool acceptChangesDuringSave) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges (acceptChangesDuringSave As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges(bool acceptChangesDuringSave);" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : bool -&gt; int" Usage="objectContext.SaveChanges acceptChangesDuringSave" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use SaveChanges(SaveOptions options) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptChangesDuringSave" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="acceptChangesDuringSave">Ten parametr jest potrzebne do obsługi transakcji po stronie klienta. Jeśli <see langword="true" />, śledzenia zmian dla wszystkich obiektów jest resetowana po <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" /> zakończeniu. Jeśli <see langword="false" />, należy wywołać <see cref="M:System.Data.Objects.ObjectContext.AcceptAllChanges" /> metody po <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />.</param>
        <summary>Będzie się powtarzał wszystkie aktualizacje w źródle danych, i opcjonalnie resetuje zmienić śledzenia w kontekście obiektu.</summary>
        <returns>Liczba obiektów w <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" />, lub <see cref="F:System.Data.EntityState.Deleted" /> Jeśli <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> została wywołana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Data.Objects.ObjectContext.SaveChanges%28System.Data.Objects.SaveOptions%29> metody zamiast tego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Wystąpiło naruszenie optymistycznej współbieżności.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public virtual int SaveChanges (System.Data.Objects.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 SaveChanges(valuetype System.Data.Objects.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Data.Objects.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChanges (options As SaveOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int SaveChanges(System::Data::Objects::SaveOptions options);" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : System.Data.Objects.SaveOptions -&gt; int&#xA;override this.SaveChanges : System.Data.Objects.SaveOptions -&gt; int" Usage="objectContext.SaveChanges options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Data.Objects.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Data.Objects.SaveOptions" /> wartość, która określa zachowanie operacji.</param>
        <summary>Będzie się powtarzał wszystkie aktualizacje w źródle danych z określonym <see cref="T:System.Data.Objects.SaveOptions" />.</summary>
        <returns>Liczba obiektów w <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" />, lub <see cref="F:System.Data.EntityState.Deleted" /> Jeśli <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> została wywołana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego określonego przeciążenia <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> do albo upewnij się, że <xref:System.Data.Objects.ObjectContext.DetectChanges%2A> jest wywoływana przed zapisaniem zmian źródła danych lub który <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> jest wywoływana po zapisaniu zmian w źródle danych.  
  
 To wyliczenie ma <xref:System.FlagsAttribute> pozwalający bitowe łączenie wartości jego elementów członkowskich.  
  
 Aby upewnić się, że obiekty na kliencie zostały zaktualizowane przez logikę po stronie źródła danych, należy wywołać <xref:System.Data.Objects.ObjectContext.Refresh%2A> metody z <xref:System.Data.Objects.RefreshMode.StoreWins> wartość po wywołaniu metody <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> Metoda działa w ramach transakcji. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> zostanie wycofać tej transakcji i Zgłoś wyjątek, jeśli jeden z zanieczyszczeniu <xref:System.Data.Objects.ObjectStateEntry> obiektów nie może zostać utrwalona.  
  
 Jeśli nastąpiło naruszenie optymistycznej współbieżności, <xref:System.Data.OptimisticConcurrencyException> jest generowany. Naruszenie optymistycznej współbieżności można rozwiązać przez przechwytywanie, wywoływania <xref:System.Data.Objects.ObjectContext.Refresh%2A> metody z <xref:System.Data.Objects.RefreshMode.StoreWins> lub <xref:System.Data.Objects.RefreshMode.ClientWins> wartości, a następnie wywołania <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metody ponownie. Aby uzyskać więcej informacji, zobacz [porady: Zarządzanie współbieżność danych w kontekście obiektu](http://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Wystąpiło naruszenie optymistycznej współbieżności.</exception>
      </Docs>
    </Member>
    <Member MemberName="SavingChanges">
      <MemberSignature Language="C#" Value="public event EventHandler SavingChanges;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SavingChanges" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.SavingChanges" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SavingChanges As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SavingChanges;" />
      <MemberSignature Language="F#" Value="member this.SavingChanges : EventHandler " Usage="member this.SavingChanges : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmiany są zapisywane w źródle danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.SavingChanges> Zdarzenie jest wywoływane na początku <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> operacji na <xref:System.Data.Objects.ObjectContext>. To zdarzenie jest zwykle używany do sprawdzania poprawności zmienionych obiektów przed nowymi wartościami są zapisane w bazie danych.  
  
   
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Rejestruje ten program obsługi <xref:System.Data.Objects.ObjectContext.SavingChanges> zdarzenie, które sprawdza poprawność stanu jednostki.  
  
 [!code-csharp[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savingchanges)]
 [!code-vb[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savingchanges)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; Translate&lt;TElement&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; Translate&lt;TElement&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TElement) (reader As DbDataReader) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">To be added.</typeparam>
        <param name="reader">
          <see cref="T:System.Data.Common.DbDataReader" /> Zawierający dane jednostki do tłumaczenia na obiekty obiektów.</param>
        <summary>Wykonuje translację <see cref="T:System.Data.Common.DbDataReader" /> zawiera wiersze danych jednostki do obiektów typu żądanych identyfikatorów jednostki.</summary>
        <returns>Wyliczenie obiektów typu <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.Translate%2A> Metoda jest używana do tłumaczenia jednostki danych z <xref:System.Data.Common.DbDataReader> na obiekty żądanego typu. Ten proces odbywa się automatycznie po <xref:System.Data.Objects.ObjectQuery%601> jest wykonywana do zwrócenia danych jednostki. <xref:System.Data.Objects.ObjectContext.Translate%2A> — Metoda pozwala na wykonywanie zapytań ADO.NET standardowe względem źródła danych i umożliwiło wierszy danych zwróconych obiektów jednostek.  
  
 Podana <xref:System.Data.Common.DbDataReader> musi zawierać dane, który jest mapowany na typ żądanej jednostki.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednio wykonywania poleceń magazynu](http://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Porady: bezpośrednie wykonywanie poleceń względem źródła danych](http://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Gdy <paramref name="reader" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; Translate&lt;TEntity&gt; (System.Data.Common.DbDataReader reader, string entitySetName, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; Translate&lt;TEntity&gt;(class System.Data.Common.DbDataReader reader, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader * string * System.Data.Objects.MergeOption -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.Translate (reader, entitySetName, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="reader">
          <see cref="T:System.Data.Common.DbDataReader" /> Zawierający dane jednostki do tłumaczenia na obiekty obiektów.</param>
        <param name="entitySetName">Zestaw jednostek <c>TResult</c> typu.</param>
        <param name="mergeOption">
          <see cref="T:System.Data.Objects.MergeOption" /> Do użycia podczas translacji obiekty są dodawane do kontekstu obiektów. Wartość domyślna to <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <summary>Wykonuje translację <see cref="T:System.Data.Common.DbDataReader" /> zawiera wiersze danych jednostki do obiektów typu żądanych identyfikatorów jednostki w zestawie określonej jednostki i przy użyciu opcji scalania określony.</summary>
        <returns>Wyliczenie obiektów typu <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.Translate%2A> Metoda jest używana do tłumaczenia jednostki danych z <xref:System.Data.Common.DbDataReader> na obiekty żądanego typu. Ten proces odbywa się automatycznie po <xref:System.Data.Objects.ObjectQuery%601> jest wykonywana do zwrócenia danych jednostki. <xref:System.Data.Objects.ObjectContext.Translate%2A> — Metoda pozwala na wykonywanie zapytań ADO.NET standardowe względem źródła danych i umożliwiło wierszy danych zwróconych obiektów jednostek.  
  
 Podana <xref:System.Data.Common.DbDataReader> musi zawierać dane, który jest mapowany na typ żądanej jednostki.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednio wykonywania poleceń magazynu](http://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Porady: bezpośrednie wykonywanie poleceń względem źródła danych](http://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Gdy <paramref name="reader" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Gdy podane <paramref name="mergeOption" /> nie jest prawidłową <see cref="T:System.Data.Objects.MergeOption" /> wartość.</exception>
        <exception cref="T:System.InvalidOperationException">Gdy podane <paramref name="entitySetName" /> ustawiono prawidłową jednostkę dla <paramref name="TResult" /> typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetObjectByKey">
      <MemberSignature Language="C#" Value="public bool TryGetObjectByKey (System.Data.EntityKey key, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetObjectByKey(class System.Data.EntityKey key, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.TryGetObjectByKey(System.Data.EntityKey,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetObjectByKey (key As EntityKey, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetObjectByKey(System::Data::EntityKey ^ key, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetObjectByKey : System.Data.EntityKey *  -&gt; bool" Usage="objectContext.TryGetObjectByKey (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
        <Parameter Name="value" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Klucz obiektu, który ma zostać odnaleziona.</param>
        <param name="value">Po powrocie z tej metody zawiera obiekt.</param>
        <summary>Zwraca obiekt, który ma określony klucz.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekt został pobrany pomyślnie. <see langword="false" /> Jeśli <paramref name="key" /> jest tymczasowy, połączenie jest <see langword="null" />, lub <paramref name="value" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> próbuje pobrać obiektu z określonym <xref:System.Data.EntityKey> z <xref:System.Data.Objects.ObjectStateManager>. Jeśli obiekt nie jest aktualnie załadowany w kontekście obiektu, zapytanie jest wykonywane w celu zwracać obiekt ze źródła danych. Aby uzyskać więcej informacji, zobacz [zapytań obiektu](http://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 Użyj <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> metody w celu uniknięcia Obsługa <xref:System.Data.ObjectNotFoundException> zgłoszone przez <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> gdy nie można odnaleźć obiektu.  
  
 Ta metoda zwróci obiektów w <xref:System.Data.EntityState.Deleted> stanu.  
  
 Klucza tymczasowego nie można zwracać obiekt ze źródła danych.  
  
 <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> Metoda stosowana jest standardowa .NET `TryParse` wzorca dla <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> metody zwracanie `false` podczas <xref:System.Data.ObjectNotFoundException> zostanie przechwycony.  
  
   
  
## Examples  
 Przykład, w tym temacie jest oparty na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie jest tworzony <xref:System.Data.EntityKey> dla danego typu, a następnie próbuje pobrać jednostek według klucza jednostki.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_trygetobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_trygetobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Niezgodne metadane dla <paramref name="key" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
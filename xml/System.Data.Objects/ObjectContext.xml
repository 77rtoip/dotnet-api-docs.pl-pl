<Type Name="ObjectContext" FullName="System.Data.Objects.ObjectContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0997f3d7974ba6b3999801d158dad1b588eba4c5" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52598580" /></Metadata><TypeSignature Language="C#" Value="public class ObjectContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ObjectContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.ObjectContext" />
  <TypeSignature Language="VB.NET" Value="Public Class ObjectContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectContext : IDisposable" />
  <TypeSignature Language="F#" Value="type ObjectContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia funkcje służące do tworzenia zapytań i pracy z danymi jednostek jako obiekty.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Data.Objects.ObjectContext> Klasa nie jest bezpieczny dla wątków. Integralność danych obiektów w <xref:System.Data.Objects.ObjectContext> nie, należy zapewnić scenariusze wielowątkowe.  
  
 <xref:System.Data.Objects.ObjectContext> Klasa to klasa podstawowe do interakcji z danymi jako obiekty, które są wystąpieniami typów jednostek, które są zdefiniowane w modelu koncepcyjnym. Wystąpienie <xref:System.Data.Objects.ObjectContext> klasa hermetyzuje następujące czynności:  
  
-   Połączenie z bazą danych w formie <xref:System.Data.EntityClient.EntityConnection> obiektu.  
  
-   Metadane opisujące modelu w postaci <xref:System.Data.Metadata.Edm.MetadataWorkspace> obiektu.  
  
-   <xref:System.Data.Objects.ObjectStateManager> Obiektu, który zarządza obiekty utrwalone w pamięci podręcznej.  
  
 Po wygenerowaniu warstwy obiektu, który reprezentuje model koncepcyjny za pomocą narzędzi Entity Data Model Klasa reprezentująca <xref:System.Data.Metadata.Edm.EntityContainer> dla modelu jest tworzony na podstawie <xref:System.Data.Objects.ObjectContext>.  
  
   
  
## Examples  
 Ten przykład jest oparty na [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie pokazano sposób tworzenia <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Wykonywanie zapytania o dane jako obiekty (Entity Framework)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Objects.ObjectContext" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (System.Data.EntityClient.EntityConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As EntityConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
      </Parameters>
      <Docs>
        <param name="connection"><see cref="T:System.Data.EntityClient.EntityConnection" /> Zawierającej odwołania do modelu i do połączenia ze źródłem danych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Objects.ObjectContext" /> klasy przy użyciu danego połączenia. Podczas konstruowania, obszar roboczy metadanych są wyodrębniane z <see cref="T:System.Data.EntityClient.EntityConnection" /> obiektu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connection" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connection" /> Jest nieprawidłowy.  
  
—lub— 
Obszar roboczy metadanych jest nieprawidłowy.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::String ^ connectionString);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connectionString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Parametry połączenia, który umożliwia również dostęp do informacji o metadanych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Objects.ObjectContext" /> klasy przy użyciu danego połączenia ciągu i domyślny kontener nazwa jednostki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `connectionString` Jest ciągiem, który zawiera informacje wymagane do dostępu do modelu koncepcyjnego oraz do łączenia ze źródłem danych. <xref:System.Data.EntityClient.EntityConnectionStringBuilder> Klasa może być używana, aby poprawnie sformatować ciąg.  
  
 Generuj nazwanych parametrów połączenia przechowywanych w pliku konfiguracji aplikacji. Te parametry połączenia o nazwie mogą być dostarczane zamiast `connectionString` parametru podczas tworzenia wystąpienia <xref:System.Data.Objects.ObjectContext> klasy.  
  
   
  
## Examples  
 W przykładzie w tym temacie opiera się na [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie pokazano sposób tworzenia <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connectionString" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connectionString" /> Jest nieprawidłowy.  
  
—lub— 
Obszar roboczy metadanych jest nieprawidłowy.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (System.Data.EntityClient.EntityConnection connection, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connection As EntityConnection, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connection, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connection"><see cref="T:System.Data.EntityClient.EntityConnection" /> Zawierającej odwołania do modelu i do połączenia ze źródłem danych.</param>
        <param name="defaultContainerName">Nazwa domyślnym kontenerem jednostki. Gdy <paramref name="defaultContainerName" /> jest ustawiony za pomocą tej metody, właściwości staje się tylko do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Objects.ObjectContext" /> klasy przy użyciu danego połączenia i jednostki nazwy kontenera.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connection" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connection" />, <paramref name="defaultContainerName" />, Lub obszaru roboczego metadanych jest nieprawidłowy.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (string connectionString, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string connectionString, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connectionString As String, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::String ^ connectionString, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connectionString, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Parametry połączenia, który umożliwia również dostęp do informacji o metadanych.</param>
        <param name="defaultContainerName">Nazwa domyślnym kontenerem jednostki. Gdy <paramref name="defaultContainerName" /> jest ustawiony za pomocą tej metody, właściwości staje się tylko do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.Objects.ObjectContext" /> klasy o nazwie kontener ciągów i jednostki danego połączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `connectionString` Jest ciągiem, który zawiera informacje wymagane do dostępu do modelu koncepcyjnego oraz do łączenia ze źródłem danych. <xref:System.Data.EntityClient.EntityConnectionStringBuilder> Klasa może być używana, aby poprawnie sformatować ciąg.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connectionString" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connectionString" />, <paramref name="defaultContainerName" />, Lub obszaru roboczego metadanych jest nieprawidłowy.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="AcceptAllChanges">
      <MemberSignature Language="C#" Value="public void AcceptAllChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptAllChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AcceptAllChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptAllChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptAllChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptAllChanges : unit -&gt; unit" Usage="objectContext.AcceptAllChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Akceptuje wszystkie zmiany wprowadzone w obiektach w kontekście obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Akceptuje zmian na wszystkie powiązane wpisy w <xref:System.Data.Objects.ObjectStateManager> więc ich stan wynikowy jest bez zmian lub odłączona.  
  
 Ta metoda iteruje na wszystkich <xref:System.Data.Objects.ObjectStateEntry> obiektów w ramach <xref:System.Data.Objects.ObjectStateManager> są dodane lub zmodyfikowane, a następnie ustawia stan wpisu do Unchanged. Elementy usunięte stają się odłączony.  
  
 Jeśli <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> wywołano metodę i <xref:System.Data.Objects.SaveOptions.AcceptAllChangesAfterSave> nie został określony, użytkownik musi wywołać <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> metody. <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> Metoda jest przydatna w sytuacji, gdy transakcji nie powiodło się, a użytkownik chce spróbować ponownie.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="AddObject">
      <MemberSignature Language="C#" Value="public void AddObject (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddObject(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AddObject(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddObject (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddObject(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AddObject : string * obj -&gt; unit" Usage="objectContext.AddObject (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Reprezentuje nazwę zestawu jednostek, który opcjonalnie może być kwalifikowana przez nazwę kontenera jednostek.</param>
        <param name="entity"><see cref="T:System.Object" /> Do dodania.</param>
        <summary>Dodaje obiekt do kontekstu obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Data.Objects.ObjectContext.AddObject%2A> na <xref:System.Data.Objects.ObjectContext> można dodać obiektu do kontekstu obiektów. W tym gdy obiekt jest nowy obiekt, który jeszcze nie istnieje w źródle danych. Aby uzyskać więcej informacji, zobacz [Dołączanie i odłączanie obiektów](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Obiekty są dodawane do <xref:System.Data.Objects.ObjectStateManager> w <xref:System.Data.EntityState.Detached>, <xref:System.Data.EntityState.Deleted> lub <xref:System.Data.EntityState.Added> stanu.  
  
 Podczas tworzenia nowego obiektu, który jest powiązany z innym obiektem w kontekście obiektu, Dodaj obiekt przy użyciu jednej z następujących metod:  
  
-   Wywołaj <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> metody <xref:System.Data.Objects.DataClasses.EntityCollection%601> i określ obiektu pokrewnego. W tym przypadku relacji jeden do wielu lub wiele do wielu.  
  
-   Ustaw <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A> właściwość <xref:System.Data.Objects.DataClasses.EntityReference%601> do powiązanego obiektu. W tym przypadku relacji jeden do jednego lub wiele do jednego.  
  
 Aby uzyskać więcej informacji, zobacz [tworzenie, dodawanie, modyfikowanie i usuwanie obiektów](https://msdn.microsoft.com/library/f76f1fad-c553-4b59-820b-89b3dec2fad1).  
  
 Jeśli obiekt jest w stanie odłączony nie może mieć <xref:System.Data.EntityKey>.  
  
 Reguły dotyczące `entitySetName` format jest następujący:  
  
-   Jeśli <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> właściwość `null`, a następnie `entitySetName` musi być w pełni kwalifikowana, podobnie jak w  *\<nazwa kontenera jednostki >*. *\<Nazwy zestawu jednostek >*.  
  
-   Jeśli <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> nie `null`, a następnie `entitySetName` może być  *\<nazwa kontenera jednostki >*. *\<Nazwy zestawu jednostek >* lub  *\<nazwy zestawu jednostek >*.  
  
 Jeśli `object` ma <xref:System.Data.EntityKey> i `entitySetName` ma wartość, a następnie <xref:System.Data.Metadata.Edm.EntitySet> jednostki klucz musi być zgodny <xref:System.Data.Metadata.Edm.EntitySet> , został znaleziony na podstawie `entitySetName` i nazwę kontenera jednostek.  
  
   
  
## Examples  
 Ten przykład jest oparty na [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Przykład dodaje nowego produktu i zapisuje zmiany w bazie danych.  
  
 [!code-csharp[DP ObjectServices Concepts#AddObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobject)]
 [!code-vb[DP ObjectServices Concepts#AddObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> Parametr <see langword="null" />.  
  
—lub— 
<paramref name="entitySetName" /> Nie kwalifikuje się.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.AddObject(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyCurrentValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyCurrentValues&lt;TEntity&gt; (string entitySetName, TEntity currentEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyCurrentValues&lt;class TEntity&gt;(string entitySetName, !!TEntity currentEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyCurrentValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyCurrentValues(Of TEntity As Class) (entitySetName As String, currentEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyCurrentValues(System::String ^ entitySetName, TEntity currentEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyCurrentValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyCurrentValues (entitySetName, currentEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="currentEntity" Type="TEntity" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Typ jednostki, obiektu.</typeparam>
        <param name="entitySetName">Ustaw nazwę jednostki, do którego należy obiekt.</param>
        <param name="currentEntity">Odłączony obiekt, który ma właściwość aktualizacji do zastosowania do oryginalnego obiektu. Klucz jednostki <paramref name="currentEntity" /> musi odpowiadać <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> właściwości wpisu w <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Kopiuje wartości skalarnych podanego obiektu do obiektu w <see cref="T:System.Data.Objects.ObjectContext" /> , ma taki sam klucz.</summary>
        <returns>Zaktualizowany obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> Metoda jest używana w celu zastosowania zmian wprowadzonych do obiektów poza <xref:System.Data.Objects.ObjectContext>, takich jak odłączyć obiekty, które są odbierane przez usługę sieci Web. Metoda kopiuje wartości skalarnych podanego obiektu do obiektu w <xref:System.Data.Objects.ObjectContext> , ma taki sam klucz. Możesz użyć <xref:System.Data.EntityKey> odłączyć obiektu można pobrać wystąpienia tego obiektu ze źródła danych. Aby uzyskać więcej informacji, zobacz [jak: określonego obiektu przy użyciu jego klawisz Return](https://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Wszelkie wartości, które różnią się od oryginalnej wartości obiektu jest oznaczona jako zmodyfikowana. Należy pamiętać, metoda nie dotyczą bieżącej wartości obiekty pokrewne z `currentEntity`.  
  
 Jeśli masz wykres bieżącymi wartościami i chcesz zastosować oryginalnych wartości, należy wywołać <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> metody.  
  
 Można także użyć <xref:System.Data.Objects.ObjectSet%601.ApplyCurrentValues%2A> z <xref:System.Data.Objects.ObjectSet%601> lub <xref:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues%2A> metody <xref:System.Data.Objects.ObjectStateEntry>. Aby uzyskać więcej informacji, zobacz [tworzenie aplikacji N-warstwowa](https://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entitySetName" /> lub <paramref name="current" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Data.Metadata.Edm.EntitySet" /> z <paramref name="entitySetName" /> nie odpowiada <see cref="T:System.Data.Metadata.Edm.EntitySet" /> obiektu <see cref="T:System.Data.EntityKey" />.  
  
—lub— 
Obiekt nie znajduje się w <see cref="T:System.Data.Objects.ObjectStateManager" /> lub znajduje się w <see cref="F:System.Data.EntityState.Detached" /> stanu.  
  
—lub— 
Klucz jednostki dostarczonego obiektu jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="entitySetName" /> jest ciągiem pustym.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyCurrentValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyOriginalValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyOriginalValues&lt;TEntity&gt; (string entitySetName, TEntity originalEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyOriginalValues&lt;class TEntity&gt;(string entitySetName, !!TEntity originalEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyOriginalValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyOriginalValues(Of TEntity As Class) (entitySetName As String, originalEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyOriginalValues(System::String ^ entitySetName, TEntity originalEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyOriginalValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyOriginalValues (entitySetName, originalEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="originalEntity" Type="TEntity" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Typ obiektu jednostki.</typeparam>
        <param name="entitySetName">Ustaw nazwę jednostki, do którego należy obiekt.</param>
        <param name="originalEntity">Odłączony obiekt, który ma oryginalnych wartości, które można zastosować do obiektu. Klucz jednostki <paramref name="originalEntity" /> musi odpowiadać <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> właściwości wpisu w <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Kopiuje wartości skalarnych podanego obiektu w zestawie oryginalnej wartości obiektu w <see cref="T:System.Data.Objects.ObjectContext" /> , ma taki sam klucz.</summary>
        <returns>Zaktualizowany obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> Metoda jest używana w celu zastosowania zmian wprowadzonych do obiektów poza <xref:System.Data.Objects.ObjectContext>, takich jak odłączyć obiekty, które są odbierane przez usługę sieci Web. Metoda kopiuje wartości skalarnych podanego obiektu do obiektu w <xref:System.Data.Objects.ObjectContext> , ma taki sam klucz. Możesz użyć <xref:System.Data.EntityKey> odłączyć obiektu można pobrać wystąpienia tego obiektu ze źródła danych. Aby uzyskać więcej informacji, zobacz [jak: określonego obiektu przy użyciu jego klawisz Return](https://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Wszelkie wartości, które różnią się od wartości bieżącego obiektu jest oznaczona jako zmodyfikowana. Należy pamiętać, metoda nie dotyczą bieżącej wartości obiekty pokrewne z `originalEntity`.  
  
 Jeśli masz wykres z oryginalnych wartości i chcesz zastosować bieżące wartości, należy wywołać <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> metody.  
  
 Można także użyć <xref:System.Data.Objects.ObjectSet%601.ApplyOriginalValues%2A> z <xref:System.Data.Objects.ObjectSet%601> lub <xref:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues%2A> metody <xref:System.Data.Objects.ObjectStateEntry>. Aby uzyskać więcej informacji, zobacz [tworzenie aplikacji N-warstwowa](https://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entitySetName" /> lub <paramref name="original" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Data.Metadata.Edm.EntitySet" /> z <paramref name="entitySetName" /> nie odpowiada <see cref="T:System.Data.Metadata.Edm.EntitySet" /> obiektu <see cref="T:System.Data.EntityKey" />.  
  
—lub— 
<see cref="T:System.Data.Objects.ObjectStateEntry" /> Dla obiektu nie można znaleźć w <see cref="T:System.Data.Objects.ObjectStateManager" />. —lub— 
Obiekt jest w <see cref="F:System.Data.EntityState.Added" /> lub <see cref="F:System.Data.EntityState.Detached" /> stanu.  
  
—lub— 
Klucz podanego obiektu jest nieprawidłowa lub zawiera zmiany właściwości.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="entitySetName" /> jest ciągiem pustym.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyOriginalValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyChanges">
      <MemberSignature Language="C#" Value="public void ApplyPropertyChanges (string entitySetName, object changed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyPropertyChanges(string entitySetName, object changed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyPropertyChanges(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyPropertyChanges (entitySetName As String, changed As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyPropertyChanges(System::String ^ entitySetName, System::Object ^ changed);" />
      <MemberSignature Language="F#" Value="member this.ApplyPropertyChanges : string * obj -&gt; unit" Usage="objectContext.ApplyPropertyChanges (entitySetName, changed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use ApplyCurrentValues instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="changed" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Ustaw nazwę jednostki, do którego należy obiekt.</param>
        <param name="changed">Odłączony obiekt, który ma właściwość aktualizacji do zastosowania do oryginalnego obiektu.</param>
        <summary>Stosuje zmiany właściwości z obiektu odłączony do obiektu, który został już dołączony do kontekstu obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> Metoda jest używana, aby zastosować zmiany właściwości z modyfikacji, odłączony wersji obiektu do oryginalnej wersji, które są dołączone do <xref:System.Data.Objects.ObjectContext>. W ten sposób realizowany scenariusze, takie jak usługi sieci Web, w którym odłączona i wysyłane do zdalnej aplikacji, w którym zostały wprowadzone aktualizacje właściwości do obiektu jednostki. Ta metoda umożliwia łatwiej zastosować te zmiany z powrotem do oryginalnego obiektu.  
  
 Po <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>, obiekt jest w <xref:System.Data.EntityState.Modified> stanu. Należy wywołać <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metodę, aby zaktualizować źródła danych.  
  
 Oryginalny obiekt musi istnieć w <xref:System.Data.Objects.ObjectStateManager> i musi znajdować się w <xref:System.Data.EntityState.Modified> lub <xref:System.Data.EntityState.Unchanged> stanu. Oryginalny obiekt jest modyfikowane tylko w przypadku modyfikacji właściwości w `changed` obiektu.  
  
 <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> Właściwość podanego obiektu musi być równa prawidłową <xref:System.Data.EntityKey>.  
  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> nie ma wpływu na właściwości nawigacji lub powiązanych obiektów.  
  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> Określa tylko właściwości znajdujące się w metadanych jednostki dla typu. Na przykład, właściwości, które są dodawane do klasy częściowe nie są uwzględnione w <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> operacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Gdy <paramref name="entitySetName" /> jest <see langword="null" /> ani być pustym ciągiem.  
  
—lub— 
Gdy <paramref name="changed" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Gdy <see cref="T:System.Data.Metadata.Edm.EntitySet" /> z <paramref name="entitySetName" /> nie odpowiada <see cref="T:System.Data.Metadata.Edm.EntitySet" /> obiektu <see cref="T:System.Data.EntityKey" />.  
  
—lub— 
Gdy jednostka jest w stanie innych niż <see cref="F:System.Data.EntityState.Modified" /> lub <see cref="F:System.Data.EntityState.Unchanged" />.  
  
—lub— 
Oryginalny obiekt nie jest dołączony do kontekstu.</exception>
        <exception cref="T:System.ArgumentException">Gdy typ <paramref name="changed" /> obiekt nie jest taki sam jak oryginalnego obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (System.Data.Objects.DataClasses.IEntityWithKey entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(class System.Data.Objects.DataClasses.IEntityWithKey entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Attach(System.Data.Objects.DataClasses.IEntityWithKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As IEntityWithKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(System::Data::Objects::DataClasses::IEntityWithKey ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Attach : System.Data.Objects.DataClasses.IEntityWithKey -&gt; unit" Usage="objectContext.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Data.Objects.DataClasses.IEntityWithKey" />
      </Parameters>
      <Docs>
        <param name="entity">Obiekt, który można dołączyć.</param>
        <summary>Dołącza obiektu lub wykres obiektu do kontekstu obiektów, gdy obiekt ma klucz jednostki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Data.Objects.ObjectContext.Attach%2A> na <xref:System.Data.Objects.ObjectContext> można dołączyć obiektu do kontekstu obiektów. W tym przypadku obiekt już istnieje w źródle danych, ale nie jest obecnie dołączony do kontekstu. Aby uzyskać więcej informacji, zobacz [Dostosowywanie obiektów](https://msdn.microsoft.com/library/af6f07ce-2261-4c65-87cf-d018ad082921).  
  
 <xref:System.Data.Objects.ObjectContext.Attach%2A> Służy do dołączania obiektu najwyższego poziomu w wykresu obiektu lub obiektu.  
  
 Dołączany obiekt musi implementować <xref:System.Data.Objects.DataClasses.IEntityWithKey> do udostępnienia <xref:System.Data.EntityKey>. Implementowanie wszystkich wygenerowanych klas jednostek <xref:System.Data.Objects.DataClasses.IEntityWithKey>.  
  
 Po dołączeniu powiązane obiekty, musisz również wywołać `Attach` na <xref:System.Data.Objects.DataClasses.EntityReference%601> lub <xref:System.Data.Objects.DataClasses.EntityCollection%601> do definiowania relacji.  
  
 Ta metoda wywołuje <xref:System.Data.Objects.ObjectContext.AttachTo%2A> metody.  
  
 Podczas podłączania obiektów obowiązują następujące zastrzeżenia:  
  
-   Jeśli dołączany obiekt ma powiązane obiekty, te obiekty, również jest dołączana do kontekstu obiektów.  
  
-   Obiekty są dodawane do kontekstu obiektów w stanie niezmieniony.  
  
-   Obiekt, który jest przekazywany do <xref:System.Data.Objects.ObjectContext.Attach%2A> metoda musi mieć prawidłową <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> wartość. Jeśli obiekt nie jest prawidłowym <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> wartość, należy użyć <xref:System.Data.Objects.ObjectContext.AttachTo%2A> metodę, aby określić nazwę zestawu jednostek.  
  
   
  
## Examples  
 W przykładzie w tym temacie opiera się na [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W tym przykładzie są dołączone dwa obiekty, a następnie relacja jest definiowana.  
  
 [!code-csharp[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#attachrelatedobjects)]
 [!code-vb[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#attachrelatedobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nieprawidłowy klucz jednostki.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AttachTo">
      <MemberSignature Language="C#" Value="public void AttachTo (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachTo(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AttachTo(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachTo (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachTo(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AttachTo : string * obj -&gt; unit" Usage="objectContext.AttachTo (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Reprezentuje nazwę zestawu jednostek, który opcjonalnie może być kwalifikowana przez nazwę kontenera jednostek.</param>
        <param name="entity"><see cref="T:System.Object" /> Do dołączenia.</param>
        <summary>Dołącza obiektu lub wykres obiektu do kontekstu obiektów w zestawie określonej jednostki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Data.Objects.ObjectContext.AttachTo%2A> na <xref:System.Data.Objects.ObjectContext> można dołączyć obiektu, do określonego zestawu jednostek w kontekście obiektu lub jeśli obiekt ma `null` (`Nothing` w języku Visual Basic) <xref:System.Data.EntityKey> wartość. Aby uzyskać więcej informacji, zobacz [Dołączanie i odłączanie obiektów](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Dołączany obiekt może być pojedynczego obiektu lub być częścią wykresu.  
  
 Reguły dotyczące `entitySetName` format jest następujący:  
  
-   Jeśli <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> właściwość `null`, a następnie `entitySetName` musi być w pełni kwalifikowana, podobnie jak w  *\<nazwa kontenera jednostki >*. *\<Nazwy zestawu jednostek >*.  
  
-   Jeśli <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> nie `null`, a następnie `entitySetName` może być  *\<nazwa kontenera jednostki >*. *\<Nazwy zestawu jednostek >* lub  *\<nazwy zestawu jednostek >*.  
  
 Dołączany obiekt nie jest wymagane do <xref:System.Data.EntityKey> skojarzonych z nim. Jeśli obiekt ma klucz jednostki, następnie `entitySetName` nie może być pustym ciągiem.  
  
 Jeśli jest dołączany obiekt <xref:System.Data.EntityKey> i `entitySetName` ma wartość, a następnie <xref:System.Data.Metadata.Edm.EntitySet> jednostki klucz musi być zgodny <xref:System.Data.Metadata.Edm.EntitySet> , został znaleziony na podstawie `entitySetName` i nazwę kontenera jednostek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Zestaw jednostek nieprawidłowy.  
  
—lub— 
Obiekt zawiera klucz tymczasowy.  
  
—lub— 
Obiekt ma <see cref="T:System.Data.EntityKey" /> i <see cref="T:System.Data.Metadata.Edm.EntitySet" /> nie jest zgodny z zestawu jednostek przekazanego jako argument metody.  
  
—lub— 
Obiekt nie ma <see cref="T:System.Data.EntityKey" /> i uwzględniane w stosownym nie zestawu jednostek.  
  
—lub— 
Dowolny obiekt z wykresu obiektu ma tymczasowy <see cref="T:System.Data.EntityKey" />.  
  
—lub— 
Dowolny obiekt z wykresu obiektu ma nieprawidłową <see cref="T:System.Data.EntityKey" /> (na przykład wartości w kluczu nie pasuje do wartości w obiekcie).  
  
—lub— 
Nie można odnaleźć zestawu jednostek z danym <paramref name="entitySetName" /> nazwę i nazwę kontenera jednostek.  
  
—lub— 
Dowolny obiekt z wykresu obiektu już istnieje w innym menedżera stanu.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int32&gt; CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;int&gt; CommandTimeout { Nullable&lt;int&gt; get(); void set(Nullable&lt;int&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : Nullable&lt;int&gt; with get, set" Usage="System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość limitu czasu w sekundach dla wszystkich operacji w kontekście obiektu. A <see langword="null" /> wartość wskazuje, że zostanie użyta wartość domyślna podstawowego dostawcy.</summary>
        <value><see cref="T:System.Int32" /> Wartość, która jest wartość limitu czasu w sekundach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna wartość limitu czasu dla zapytań dotyczących obiektów oraz <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> operacji jest definiowany przez źródłowy dostawca połączenia. Można jednak zastąpić to domyślna wartość limitu czasu za pomocą <xref:System.Data.Objects.ObjectContext.CommandTimeout%2A> właściwość <xref:System.Data.Objects.ObjectContext>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querytimeout)]
 [!code-vb[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querytimeout)]  
  
 To zrobić, jeśli masz złożone zapytania lub gdy powodować inne problemy z wydajnością zapytań lub wywołania <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> często przekraczają limit czasu.  
  
   
  
## Examples  
 [Zapytań dotyczących obiektów](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość limitu czasu jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Objects.ObjectContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera połączenie używane przez kontekst.</summary>
        <value>A <see cref="T:System.Data.Common.DbConnection" /> obiekt, który jest połączenie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca obiekt połączenia, który został przekazany do konstruktora lub został utworzony podczas konstruowania. Własności tego połączenia jest określany przez konstruktory używane.  
  
   
  
## Examples  
 Ten przykład tworzy <xref:System.Data.EntityClient.EntityConnection> obiektu, który jest przekazywany do konstruktora długo działających <xref:System.Data.Objects.ObjectContext>. Połączenie jest otwarte ręcznie. Zarówno <xref:System.Data.EntityClient.EntityConnection> obiektu i <xref:System.Data.Objects.ObjectContext> obiektu są usunięte ręcznie.  
  
 [!code-csharp[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#openentityconnection)]
 [!code-vb[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#openentityconnection)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Gdy <see cref="T:System.Data.Objects.ObjectContext" /> wystąpienie zostało usunięte.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ContextOptions">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectContextOptions ContextOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectContextOptions ContextOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContextOptions As ObjectContextOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectContextOptions ^ ContextOptions { System::Data::Objects::ObjectContextOptions ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContextOptions : System.Data.Objects.ObjectContextOptions" Usage="System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectContextOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Data.Objects.ObjectContextOptions" /> wystąpienia, który zawiera opcje, które wpływają na zachowanie <see cref="T:System.Data.Objects.ObjectContext" />.</summary>
        <value><see cref="T:System.Data.Objects.ObjectContextOptions" /> Wystąpienia, który zawiera opcje, które wpływają na zachowanie <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="objectContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy bazę danych przy użyciu bieżącego połączenia ze źródłem danych i metadanych w <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> wyświetlić skryptu (DDL) języka definicji danych. Wywołaj <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> można wykonać skryptu.  
  
 Większość pracy jest delegowane do <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [pracy z językiem definicji danych](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateDatabaseScript">
      <MemberSignature Language="C#" Value="public string CreateDatabaseScript ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string CreateDatabaseScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDatabaseScript () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ CreateDatabaseScript();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabaseScript : unit -&gt; string" Usage="objectContext.CreateDatabaseScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Generuje skrypt języka (DDL) definicji danych, która tworzy obiekty schematu (tabele, kluczy podstawowych, klucze obce) metadanych w <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />. <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" /> Ładuje metadanych z plików języka (SSDL) definicji schematu magazynu.</summary>
        <returns>Skrypt języka DDL, który tworzy obiekty schematu dla metadanych w <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> można wyświetlić skryptu języka DDL. Wywołaj <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> można wykonać skryptu.  
  
 Większość pracy jest delegowane do <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [pracy z językiem definicji danych](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateEntityKey">
      <MemberSignature Language="C#" Value="public System.Data.EntityKey CreateEntityKey (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.EntityKey CreateEntityKey(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateEntityKey(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateEntityKey (entitySetName As String, entity As Object) As EntityKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::EntityKey ^ CreateEntityKey(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.CreateEntityKey : string * obj -&gt; System.Data.EntityKey" Usage="objectContext.CreateEntityKey (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Ustaw pełni kwalifikowaną nazwę jednostki, do którego należy obiekt jednostki.</param>
        <param name="entity">Obiekt, dla której jest pobierana klucza jednostki.</param>
        <summary>Tworzy klucz dla konkretnego obiektu lub zwraca klucz jednostki, jeśli już istnieje.</summary>
        <returns><see cref="T:System.Data.EntityKey" /> Obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Data.EntityKey> nie istnieje dla `entity`, <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> metoda tworzy nowy klucz.  
  
 Ta metoda jest używana do określenia, czy obiekt, który ma taką samą <xref:System.Data.EntityKey> jest już dołączony do <xref:System.Data.Objects.ObjectContext>. Jeśli obiekt, który ma taką samą <xref:System.Data.EntityKey> jest już dołączony jest wyjątek. Użyj <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> metodę, aby spróbować pobrać <xref:System.Data.EntityKey> o odłączony obiekt przed wywołaniem <xref:System.Data.Objects.ObjectContext.Attach%2A> metody.  
  
   
  
## Examples  
 W przykładzie w tym temacie opiera się na [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W tym przykładzie <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> służy do pobierania klucza jednostki istniejącego obiektu.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdatesgetobject)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdatesgetobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Gdy jest albo parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Gdy <paramref name="entitySetName" /> jest pusty.  
  
—lub— 
Gdy typ <paramref name="entity" /> obiekt nie istnieje w zestawie jednostek.  
  
—lub— 
Gdy <paramref name="entitySetName" /> nie jest w pełni kwalifikowany.</exception>
        <exception cref="T:System.InvalidOperationException">Gdy kluczem jednostki nie można utworzyć pomyślnie zależnie od podanych parametrów.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T CreateObject&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T CreateObject&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObject``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject(Of T As Class) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class T CreateObject();" />
      <MemberSignature Language="F#" Value="member this.CreateObject : unit -&gt; 'T (requires 'T : null)" Usage="objectContext.CreateObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Typ obiektu, który ma zostać zwrócony.</typeparam>
        <summary>Tworzy i zwraca wystąpienie żądanego typu.</summary>
        <returns>Wystąpienie żądanego typu <paramref name="T" />, lub wystąpienie typu pochodnego, która umożliwia <paramref name="T" /> ma być używany z programem Entity Framework. Zwrócony obiekt jest wystąpieniem żądanego typu lub wystąpienia typu pochodnego, która umożliwia żądanego typu, który ma być używany z programem Entity Framework.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.CreateObject%2A> POCO danych niestandardowych klas metodę, aby upewnić się, że zwrócony obiekt można zarządzać prawidłowo przez program Entity Framework. Aby uzyskać więcej informacji, zobacz [wymagania dotyczące tworzenia obiektów POCO proxy](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) i [Praca z jednostkami obiektów POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) () As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet();" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : unit -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Żądany typ jednostki <see cref="T:System.Data.Objects.ObjectSet`1" />.</typeparam>
        <summary>Tworzy nową <see cref="T:System.Data.Objects.ObjectSet`1" /> wystąpienia, który służy do kwerendy, dodawanie, modyfikowanie i usuwanie obiektów określonego typu jednostek.</summary>
        <returns>Nowy <see cref="T:System.Data.Objects.ObjectSet`1" /> wystąpienia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> Właściwość nie jest ustawiona na <see cref="T:System.Data.Objects.ObjectContext" />.  
  
—lub— 
Podany typ należy do więcej niż jeden zestaw jednostek.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; (string entitySetName) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;(string entitySetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) (entitySetName As String) As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet(System::String ^ entitySetName);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : string -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet entitySetName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Żądany typ jednostki <see cref="T:System.Data.Objects.ObjectSet`1" />.</typeparam>
        <param name="entitySetName">Nazwa zestaw jednostek dla zwracanego <see cref="T:System.Data.Objects.ObjectSet`1" />. Ciąg musi być kwalifikowana przez nazwę kontenera domyślne, jeśli <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> właściwość nie jest ustawiona na <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Tworzy nową <see cref="T:System.Data.Objects.ObjectSet`1" /> wystąpienie, które służy do kwerendy, dodawanie, modyfikowanie i usuwanie obiektów określonego typu i o określonej jednostki Nazwa zestawu.</summary>
        <returns>Nowy <see cref="T:System.Data.Objects.ObjectSet`1" /> wystąpienia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Data.Metadata.Edm.EntitySet" /> z <paramref name="entitySetName" /> nie odpowiada <see cref="T:System.Data.Metadata.Edm.EntitySet" /> obiektu <see cref="T:System.Data.EntityKey" />.  
  
—lub— 
<see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> Właściwość nie jest ustawiona na <see cref="T:System.Data.Objects.ObjectContext" /> i nazwy nie kwalifikuje się jako część <paramref name="entitySetName" /> parametru.  
  
—lub— 
Podany typ należy do więcej niż jeden zestaw jednostek.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProxyTypes">
      <MemberSignature Language="C#" Value="public void CreateProxyTypes (System.Collections.Generic.IEnumerable&lt;Type&gt; types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateProxyTypes(class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateProxyTypes(System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateProxyTypes (types As IEnumerable(Of Type))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateProxyTypes(System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.CreateProxyTypes : seq&lt;Type&gt; -&gt; unit" Usage="objectContext.CreateProxyTypes types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="types">Wyliczenie <see cref="T:System.Type" /> obiektami, które reprezentują klasy danych niestandardowych, które mapowania do modelu koncepcyjnego.</param>
        <summary>Generuje typu równoważne, który mogą być używane z programu Entity Framework, dla każdego typu w podanej wyliczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poszczególne typy w `types` wyliczenie, które nie zostaną zamapowani na typ jednostki w modelu koncepcyjnym są ignorowane.  
  
 Aby uzyskać więcej informacji, zobacz [wymagania dotyczące tworzenia obiektów POCO proxy](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) i [Praca z jednostkami obiektów POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateQuery&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; CreateQuery&lt;T&gt; (string queryString, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!!T&gt; CreateQuery&lt;T&gt;(string queryString, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateQuery``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateQuery(Of T) (queryString As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ CreateQuery(System::String ^ queryString, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateQuery : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectContext.CreateQuery (queryString, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">Typ jednostki zwracanego <see cref="T:System.Data.Objects.ObjectQuery`1" />.</typeparam>
        <param name="queryString">Ciąg zapytania do wykonania.</param>
        <param name="parameters">Parametry do przekazania do zapytania.</param>
        <summary>Tworzy <see cref="T:System.Data.Objects.ObjectQuery`1" /> w bieżącym kontekście obiektu przy użyciu określony ciąg zapytania.</summary>
        <returns><see cref="T:System.Data.Objects.ObjectQuery`1" /> Określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.Objects.ObjectContext.CreateQuery%2A> utworzyć <xref:System.Data.Objects.ObjectQuery%601> określonego typu, który należy do bieżącego kontekstu obiektów.  
  
   
  
## Examples  
 Ten przykład jest oparty na [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 W przykładzie utworzono proste zapytanie i iteruje po kolekcji wyników.  
  
 [!code-csharp[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#createquery)]
 [!code-vb[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#createquery)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="queryString" /> Lub <paramref name="parameters" /> parametr <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Wykonywanie kwerend modelu koncepcyjnego</related>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="objectContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy bazy danych, który jest określony jako bazy danych w bieżącym połączenia ze źródłem danych istnieje w źródle danych.</summary>
        <returns><see langword="true" /> Jeśli baza danych istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość pracy jest delegowane do <xref:System.Data.Common.DbProviderServices.DatabaseExists%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [pracy z językiem definicji danych](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      </Docs>
    </Member>
    <Member MemberName="DefaultContainerName">
      <MemberSignature Language="C#" Value="public string DefaultContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultContainerName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultContainerName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultContainerName : string with get, set" Usage="System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę kontenera domyślnego.</summary>
        <value>A <see cref="T:System.String" /> oznacza to domyślna nazwa kontenera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> nigdy nie zwraca `null`; albo zwraca wartość, która została zestawu lub pusty ciąg. Użytkownik może ustawić tę właściwość na `null`, ale wewnętrznie nazwa zostanie ustawiony na pusty ciąg, więc użytkownik musi nigdy nie sprawdzaj zarówno ciąg pusty i `null`.  
  
 Domyślna nazwa kontenera jest również definiowany jako część konstruktora. Jeśli domyślna nazwa kontenera jest ustawiony przez Konstruktor chroniony, staje się właściwość tylko do odczytu.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="objectContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa bazę danych, który jest określony jako bazy danych w bieżącym połączenia ze źródłem danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Większość pracy jest delegowane do <xref:System.Data.Common.DbProviderServices.DeleteDatabase%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [pracy z językiem definicji danych](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="DeleteObject">
      <MemberSignature Language="C#" Value="public void DeleteObject (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteObject(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteObject (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteObject(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.DeleteObject : obj -&gt; unit" Usage="objectContext.DeleteObject entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Obiekt, który określa jednostki do usunięcia. Obiekt może być w dowolnym stanie, z wyjątkiem <see cref="F:System.Data.EntityState.Detached" />.</param>
        <summary>Oznacza obiekt do usunięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oznacza obiekt do usunięcia z <xref:System.Data.Objects.ObjectStateManager>. Obiekt zostanie usunięty z danych źródłowych, kiedy <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metoda jest wywoływana.  
  
 Usunięcie obiektu nadrzędnego spowoduje również usunięcie wszystkich obiektów podrzędnych w relacji ograniczone. Ten wynik jest taka sama jak włączenie `CascadeDelete` właściwość o Stowarzyszeniu dla relacji.  
  
 <xref:System.Data.Objects.ObjectContext.DeleteObject%2A> Metoda może być wywoływana dla obiektów, które zostały już usunięte.  
  
   
  
## Examples  
 Te przykłady są oparte na [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 Ten przykład tworzy <xref:System.Data.EntityKey> o określonym identyfikatorze ProductID, używa klucza, aby pobrać obiekt produktu ze źródła danych, usunięcie produktu i zapisuje zmiany w bazie danych.  
  
 [!code-csharp[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#deleteobject)]
 [!code-vb[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#deleteobject)]  
  
 W tym przykładzie usuwa istniejący element zamówienia, dodaje nowy element i zapisuje zmiany w bazie danych.  
  
 [!code-csharp[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savechanges)]
 [!code-vb[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savechanges)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="entity" /> nie istnieje.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.DeleteObject(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Detach">
      <MemberSignature Language="C#" Value="public void Detach (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Detach(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Detach(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Detach (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Detach(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Detach : obj -&gt; unit" Usage="objectContext.Detach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Obiekt ma zostać odłączony. Tylko <paramref name="entity" /> zostanie usunięta; Jeśli istnieją powiązane obiekty, które są śledzone przez ten sam <see cref="T:System.Data.Objects.ObjectStateManager" />, te będą nie można odłączyć automatycznie.</param>
        <summary>Usuwa obiekt z kontekstu obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usuwa obiekt z <xref:System.Data.Objects.ObjectStateManager>. Powoduje to wyłączenie śledzenia zmian i rozwiązanie tożsamości dla tego obiektu. Aby uzyskać więcej informacji, zobacz [Dołączanie i odłączanie obiektów](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Po <xref:System.Data.Objects.ObjectContext.Detach%2A> metoda jest wywoływana, system nie jest już zapewnią odwołania, które wskazują na ten obiekt i mogą być zbierane przez moduł odśmiecania pamięci.  
  
> [!NOTE]
>  Wyrzucanie elementów bezużytecznych tylko może wystąpić, jeśli kod użytkownika nie ma żadnych odwołań do obiektu o odłączony.  
  
 Gdy odłączanie obiektów obowiązują następujące zastrzeżenia:  
  
-   <xref:System.Data.Objects.ObjectContext.Detach%2A> dotyczy tylko określony obiekt, który jest przekazywany do metody. Jeśli obiekt odłączany ma powiązane obiekty w kontekście obiektu, te obiekty nie są odłączone.  
  
-   Odłączanie obiektów nie wpływa na dane w źródle danych.  
  
-   Dyrektywy usuwanie kaskadowe i ograniczenia referencyjne nie są wymuszane podczas operacji odłączania.  
  
 Aby uzyskać więcej informacji, zobacz [Dołączanie i odłączanie obiektów](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
   
  
## Examples  
 [!code-csharp[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#detachobjects)]
 [!code-vb[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#detachobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="entity" /> Nie jest skojarzony z tym <see cref="T:System.Data.Objects.ObjectContext" /> (na przykład został nowo utworzona i nie skojarzone z jakimkolwiek kontekście jeszcze została uzyskana za pośrednictwem niektórych innych kontekstu lub został już odłączony).</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Detach(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="DetectChanges">
      <MemberSignature Language="C#" Value="public void DetectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DetectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub DetectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetectChanges();" />
      <MemberSignature Language="F#" Value="member this.DetectChanges : unit -&gt; unit" Usage="objectContext.DetectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, że <see cref="T:System.Data.Objects.ObjectStateEntry" /> zmiany są synchronizowane ze zmianami wprowadzonymi w wszystkie obiekty, które są śledzone przez <see cref="T:System.Data.Objects.ObjectStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez kontekst.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="objectContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez kontekst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zamyka połączenia, jeśli został on otwarty przez program Entity Framework. Po <xref:System.Data.Objects.ObjectContext.Dispose%2A> jest wywoływana, operacje, które wymagają otwartego połączenia, takiej jak wykonywanie kwerendy lub wywołanie <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> metody, spowoduje, że wyjątek. Operacje, które nie wymagają otwartego połączenia, takie jak tworzenie kwerendy lub dołączanie obiektów, nie spowodują wyjątek. <xref:System.Data.Objects.ObjectContext.Dispose%2A> Metody nie zamyka wszystkie jawnie otwartego połączenia.  
  
 Ograniczanie zakresu <xref:System.Data.Objects.ObjectContext> w ramach `using` bloku (`Using` w języku Visual Basic) zapewnia, że zasoby są prawidłowo usunięte. Aby uzyskać więcej informacji, zobacz [zarządzania połączeniami i transakcje](https://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
 <xref:System.Data.Objects.ObjectContext.Dispose> Wywołania metody `virtual` (`Overridable` w języku Visual Basic) <xref:System.Data.Objects.ObjectContext.Dispose%28System.Boolean%29> metody.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="objectContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby używane przez kontekst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powoduje zamknięcie połączenia. Po <xref:System.Data.Objects.ObjectContext.Dispose%2A> jest wywoływana, operacje, które wymagają otwartego połączenia, takiej jak wykonywanie kwerendy lub wywołanie <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> metody, spowoduje, że wyjątek. Operacje, które nie wymagają otwartego połączenia, takie jak tworzenie kwerendy lub dołączanie obiektów, nie spowodują wyjątek.  
  
 Ograniczanie zakresu <xref:System.Data.Objects.ObjectContext> w ramach `using` bloku (`Using` w języku Visual Basic) zapewnia, że zasoby są prawidłowo usunięte. Aby uzyskać więcej informacji, zobacz [zarządzania połączeniami i transakcje](https://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction">
      <MemberSignature Language="C#" Value="public int ExecuteFunction (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteFunction(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction (functionName As String, ParamArray parameters As ObjectParameter()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; int" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="functionName">Nazwa procedury składowanej lub funkcji. Nazwa może zawierać nazwy kontenera, takich jak <c>&lt;nazwa kontenera&gt;.&lt; Nazwa funkcji&gt;</c>. Jeśli domyślna nazwa kontenera jest znany, nazwą funkcji jest wymagana.</param>
        <param name="parameters">Tablica <see cref="T:System.Data.Objects.ObjectParameter" /> obiektów.</param>
        <summary>Wykonuje procedurę składowaną lub funkcję, która jest zdefiniowana w źródle danych i wyrażone w modelu koncepcyjnym; odrzuca wszystkie wyniki zwrócone w wyniku funkcji; i zwraca liczbę wierszy na wykonanie.</summary>
        <returns>Liczba zmodyfikowanych wierszy.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="function" /> ma wartość null lub jest pusty 
—lub— 
 <paramref name="function" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jednostki nie obsługują tych <paramref name="function" />.  
  
—lub— 
Wystąpiła niezgodność typów w czytniku i <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction(Of TElement) (functionName As String, ParamArray parameters As ObjectParameter()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Typ jednostki <see cref="T:System.Data.Objects.ObjectResult`1" /> zwracane, gdy funkcja jest wykonywana względem źródła danych. Ten typ musi implementować <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Nazwa procedury składowanej lub funkcji. Nazwa może zawierać nazwy kontenera, takich jak <c>&lt;nazwa kontenera&gt;.&lt; Nazwa funkcji&gt;</c>. Jeśli domyślna nazwa kontenera jest znany, nazwą funkcji jest wymagana.</param>
        <param name="parameters">Tablica <see cref="T:System.Data.Objects.ObjectParameter" /> obiektów.</param>
        <summary>Wykonuje procedurę składowaną lub funkcję, która jest zdefiniowana w źródle danych i mapowane w modelu koncepcyjnym z określonymi parametrami. Zwraca wpisane <see cref="T:System.Data.Objects.ObjectResult`1" />.</summary>
        <returns><see cref="T:System.Data.Objects.ObjectResult`1" /> Dla danych, który jest zwracany przez procedurę składowaną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> Metoda jest metodą pomocnika, która jest używana do wykonywania procedury składowanej lub funkcji, które są zdefiniowane w źródle danych i wyrażone w modelu koncepcyjnym. Narzędzia modelu Entity Data Model generowania metody dla wszystkich w modelu koncepcyjnym. Te metody mogą wywoływać silnie typizowanego `ExecuteFunction` do zwrócenia wpisane <xref:System.Data.Objects.ObjectResult%601>. Aby uzyskać więcej informacji, zobacz [kodu aplikacji przy użyciu procedur składowanych (jednostki Framework)](https://msdn.microsoft.com/library/d13dd33f-fcf9-4e86-bd00-74bc31521536).  
  
 Wszystkie parametry funkcji są wymagane w tablicy parametrów, a wszystkie typy są porównywane z metadanych dla funkcji importu, takich jak typ samej funkcji. `null` wartości są dozwolone dla typów wartości CLR. Walidacja parametru jest wykonywane przez dostawcę.  
  
 <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> Metoda używa <xref:System.Data.Objects.MergeOption> wartość <xref:System.Data.Objects.MergeOption.AppendOnly>. W związku z tym jeśli istnieje już obiekt w kontekście obiektu, go nie zostanie załadowany ze źródła danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="function" /> ma wartość null lub jest pusty 
—lub— 
 <paramref name="function" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jednostki nie obsługują tych <paramref name="function" />.  
  
—lub— 
Wystąpiła niezgodność typów w czytniku i <paramref name="function" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, System.Data.Objects.MergeOption mergeOption, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, valuetype System.Data.Objects.MergeOption mergeOption, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.MergeOption,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.MergeOption * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Typ jednostki <see cref="T:System.Data.Objects.ObjectResult`1" /> zwracane, gdy funkcja jest wykonywana względem źródła danych. Ten typ musi implementować <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Nazwa procedury składowanej lub funkcji. Nazwa może zawierać nazwy kontenera, takich jak <c>&lt;nazwa kontenera&gt;.&lt; Nazwa funkcji&gt;</c>. Jeśli domyślna nazwa kontenera jest znany, nazwą funkcji jest wymagana.</param>
        <param name="mergeOption"><see cref="T:System.Data.Objects.MergeOption" /> Do użycia podczas wykonywania zapytania.</param>
        <param name="parameters">Tablica <see cref="T:System.Data.Objects.ObjectParameter" /> obiektów.</param>
        <summary>Wykonuje danej procedury składowanej lub funkcji, który jest zdefiniowany w źródle danych i wyrażone w modelu koncepcyjnym, przy użyciu określonych parametrów i opcji scalania. Zwraca wpisane <see cref="T:System.Data.Objects.ObjectResult`1" />.</summary>
        <returns><see cref="T:System.Data.Objects.ObjectResult`1" /> Dla danych, który jest zwracany przez procedurę składowaną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> Metoda jest metodą pomocnika, która jest używana do wykonywania procedury składowanej lub funkcji, które są zdefiniowane w źródle danych i wyrażone w modelu koncepcyjnym. Narzędzia modelu Entity Data Model generowania metody dla wszystkich w modelu koncepcyjnym. Te metody mogą wywoływać silnie typizowanego `ExecuteFunction` do zwrócenia wpisane <xref:System.Data.Objects.ObjectResult%601>. Aby uzyskać więcej informacji, zobacz [kodu aplikacji przy użyciu procedur składowanych (jednostki Framework)](https://msdn.microsoft.com/library/d13dd33f-fcf9-4e86-bd00-74bc31521536).  
  
 Wszystkie parametry funkcji są wymagane w tablicy parametrów, a wszystkie typy są porównywane z metadanych dla funkcji importu, takich jak typ samej funkcji. `null` wartości są dozwolone dla typów wartości CLR. Walidacja parametru jest wykonywane przez dostawcę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="function" /> ma wartość null lub jest pusty 
—lub— 
 <paramref name="function" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jednostki nie obsługują tych <paramref name="function" />.  
  
—lub— 
Wystąpiła niezgodność typów w czytniku i <paramref name="function" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommand">
      <MemberSignature Language="C#" Value="public int ExecuteStoreCommand (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteStoreCommand(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreCommand (commandText As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteStoreCommand(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreCommand : string * obj[] -&gt; int" Usage="objectContext.ExecuteStoreCommand (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="commandText">Polecenie do wykonania w macierzystym języku źródła danych.</param>
        <param name="parameters">Tablica parametrów do przekazania do polecenia.</param>
        <summary>Wykonuje dowolne polecenie bezpośrednio w odniesieniu do źródła danych, przy użyciu istniejącego połączenia.</summary>
        <returns>Liczba zmodyfikowanych wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używanie poleceń sparametryzowanych pomaga zabezpieczyć się przed atakami polegającymi na iniekcji SQL, w których osoba atakująca "wprowadza" polecenie do instrukcji SQL zabezpieczenia naruszeń na serwerze. Poleceń sparametryzowanych zabezpieczyć się przed ataku polegającego na iniekcji SQL przez zagwarantowanie, że wartości odebranych ze źródła zewnętrznego są przekazywane jako tylko wartości i nie jest częścią instrukcji SQL. W wyniku polecenia SQL wstawione do wartości nie są wykonywane w źródle danych. Przeciwnie są oceniane tylko jako wartość parametru. Oprócz zabezpieczeń zapewnianych poleceń sparametryzowanych zapewniają wygodną metodę służący do organizowania wartości przekazane za pomocą instrukcji języka SQL lub procedury składowanej.  
  
 `parameters` Wartość może być tablica <xref:System.Data.Common.DbParameter> obiektów lub tablicę wartości parametrów. Jeśli tylko wartości są dostarczane, tablicę <xref:System.Data.Common.DbParameter> obiekty są tworzone na podstawie kolejności wartości w tablicy.  
  
 Polecenie magazynu jest wykonywany w kontekście bieżącej transakcji, jeśli istnieje w bieżącej transakcji.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednie wykonywanie poleceń Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Instrukcje: bezpośrednie wykonywanie poleceń względem źródła danych](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteStoreQuery&lt;TElement&gt; (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteStoreQuery&lt;TElement&gt;(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreQuery(Of TElement) (commandText As String, ParamArray parameters As Object()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteStoreQuery(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">To be added.</typeparam>
        <param name="commandText">Polecenie do wykonania w macierzystym języku źródła danych.</param>
        <param name="parameters">Tablica parametrów do przekazania do polecenia.</param>
        <summary>Wykonuje zapytanie bezpośrednio w odniesieniu do źródła danych, które zwraca sekwencję wpisane wyników.</summary>
        <returns>Wyliczenie obiektów typu <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> Metoda wykorzystuje istniejące połączenie, wykonać dowolne polecenie bezpośrednio w odniesieniu do źródła danych. Polecenie magazynu jest wykonywane w kontekście bieżącej transakcji, jeśli istnieje taki transakcji.  
  
 Wywoływanie <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> metodą jest równoważne z wywoływaniem <xref:System.Data.Common.DbCommand.ExecuteReader%2A> metody <xref:System.Data.Common.DbCommand> klasy tylko <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> zwraca jednostki i <xref:System.Data.Common.DbCommand.ExecuteReader%2A> zwraca wartości właściwości w <xref:System.Data.Common.DbDataReader>.  
  
 Wywołaj <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> przy użyciu określonej jednostki Nazwa zestawu, jeśli chcesz, aby uzyskać wyniki mają być śledzone.  
  
 Wywołaj <xref:System.Data.Objects.ObjectContext.Translate%2A> metody do translacji <xref:System.Data.Common.DbDataReader> na obiekty jednostki, gdy proces czytający zawiera wiersze danych, które mapują do określonego typu jednostek.  
  
 Używanie poleceń sparametryzowanych pomaga zabezpieczyć się przed atakami polegającymi na iniekcji SQL, w których osoba atakująca "wprowadza" polecenie do instrukcji SQL zabezpieczenia naruszeń na serwerze. Poleceń sparametryzowanych zabezpieczyć się przed ataku polegającego na iniekcji SQL przez zagwarantowanie, że wartości odebranych ze źródła zewnętrznego są przekazywane jako tylko wartości i nie jest częścią instrukcji SQL. W wyniku polecenia SQL wstawione do wartości nie są wykonywane w źródle danych. Przeciwnie są oceniane tylko jako wartość parametru. Oprócz zabezpieczeń zapewnianych poleceń sparametryzowanych zapewniają wygodną metodę służący do organizowania wartości przekazane za pomocą instrukcji języka SQL lub procedury składowanej.  
  
 `parameters` Wartość może być tablica <xref:System.Data.Common.DbParameter> obiektów lub tablicę wartości parametrów. Jeśli tylko wartości są dostarczane, tablicę <xref:System.Data.Common.DbParameter> obiekty są tworzone na podstawie kolejności wartości w tablicy.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednie wykonywanie poleceń Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Instrukcje: bezpośrednie wykonywanie poleceń względem źródła danych](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt; (string commandText, string entitySetName, System.Data.Objects.MergeOption mergeOption, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt;(string commandText, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.String,System.Data.Objects.MergeOption,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ ExecuteStoreQuery(System::String ^ commandText, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * string * System.Data.Objects.MergeOption * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, entitySetName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="commandText">Polecenie do wykonania w macierzystym języku źródła danych.</param>
        <param name="entitySetName">Zestaw jednostek <c>TResult</c> typu. Jeśli nie podano nazwy zestawu jednostek, wyniki nie mają być śledzone.</param>
        <param name="mergeOption"><see cref="T:System.Data.Objects.MergeOption" /> Do użycia podczas wykonywania zapytania. Wartość domyślna to <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <param name="parameters">Tablica parametrów do przekazania do polecenia.</param>
        <summary>Wykonuje zapytanie bezpośrednio w odniesieniu do źródła danych, a następnie zwraca sekwencję wpisane wyników. Określ zestaw jednostek i opcji scalania, aby wyniki zapytania mogą być śledzone jako jednostki.</summary>
        <returns>Wyliczenie obiektów typu <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> Metoda wykorzystuje istniejące połączenie, wykonać dowolne polecenie bezpośrednio w odniesieniu do źródła danych. Polecenie magazynu jest wykonywane w kontekście bieżącej transakcji, jeśli istnieje taki transakcji.  
  
 Wywoływanie <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> metodą jest równoważne z wywoływaniem <xref:System.Data.Common.DbCommand.ExecuteReader%2A> metody <xref:System.Data.Common.DbCommand> klasy tylko <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> zwraca jednostki i <xref:System.Data.Common.DbCommand.ExecuteReader%2A> zwraca wartości właściwości w <xref:System.Data.Common.DbDataReader>.  
  
 Określ zestaw jednostek, nazwy, jeśli chcesz, aby uzyskać wyniki mają być śledzone jako jednostki.  
  
 Wywołaj <xref:System.Data.Objects.ObjectContext.Translate%2A> metody do translacji <xref:System.Data.Common.DbDataReader> na obiekty jednostki, gdy proces czytający zawiera wiersze danych, które mapują do określonego typu jednostek.  
  
 Używanie poleceń sparametryzowanych pomaga zabezpieczyć się przed atakami polegającymi na iniekcji SQL, w których osoba atakująca "wprowadza" polecenie do instrukcji SQL zabezpieczenia naruszeń na serwerze. Poleceń sparametryzowanych zabezpieczyć się przed ataku polegającego na iniekcji SQL przez zagwarantowanie, że wartości odebranych ze źródła zewnętrznego są przekazywane jako tylko wartości i nie jest częścią instrukcji SQL. W wyniku polecenia SQL wstawione do wartości nie są wykonywane w źródle danych. Przeciwnie są oceniane tylko jako wartość parametru. Oprócz zabezpieczeń zapewnianych poleceń sparametryzowanych zapewniają wygodną metodę służący do organizowania wartości przekazane za pomocą instrukcji języka SQL lub procedury składowanej.  
  
 `parameters` Wartość może być tablica <xref:System.Data.Common.DbParameter> obiektów lub tablicę wartości parametrów. Jeśli tylko wartości są dostarczane, tablicę <xref:System.Data.Common.DbParameter> obiekty są tworzone na podstawie kolejności wartości w tablicy.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednie wykonywanie poleceń Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Instrukcje: bezpośrednie wykonywanie poleceń względem źródła danych](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKnownProxyTypes">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Type&gt; GetKnownProxyTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; GetKnownProxyTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetKnownProxyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetKnownProxyTypes () As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ GetKnownProxyTypes();" />
      <MemberSignature Language="F#" Value="static member GetKnownProxyTypes : unit -&gt; seq&lt;Type&gt;" Usage="System.Data.Objects.ObjectContext.GetKnownProxyTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie istniejące typy serwera proxy.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" /> Wszystkich istniejących typów serwera proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.GetKnownProxyTypes%2A> Metoda jest używana podczas generowania obiektu serwera proxy jest włączona dla obiektów POCO. Aby uzyskać więcej informacji, zobacz [wymagania dotyczące tworzenia obiektów POCO proxy](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) i [Praca z jednostkami obiektów POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectByKey">
      <MemberSignature Language="C#" Value="public object GetObjectByKey (System.Data.EntityKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetObjectByKey(class System.Data.EntityKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectByKey(System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObjectByKey (key As EntityKey) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetObjectByKey(System::Data::EntityKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.GetObjectByKey : System.Data.EntityKey -&gt; obj" Usage="objectContext.GetObjectByKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz obiektu, który ma zostać odnaleziona.</param>
        <summary>Zwraca obiekt, który ma określony klucz.</summary>
        <returns><see cref="T:System.Object" /> Oznacza to wystąpienie typu jednostki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> próbuje pobrać obiekt, który ma określony <xref:System.Data.EntityKey> z <xref:System.Data.Objects.ObjectStateManager>. Jeśli obiekt nie jest aktualnie załadowana do kontekstu obiektów, zapytanie jest wykonywane w celu podjęcia próby zwrócić obiekt ze źródła danych. Aby uzyskać więcej informacji, zobacz [zapytań dotyczących obiektów](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> wywołuje <xref:System.Data.ObjectNotFoundException> kiedy nie można odnaleźć obiektu. Aby uniknąć obsługi tego wyjątku, zamiast tego użyć <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> metody.  
  
 Ta metoda zwróci obiektów w <xref:System.Data.EntityState.Deleted> stanu.  
  
 Klucz tymczasowy nie można zwrócić obiektu ze źródła danych.  
  
   
  
## Examples  
 Ten przykład jest oparty na [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie jest tworzony <xref:System.Data.EntityKey> dla danego typu jednostki, a następnie pobiera jednostek według klucza.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_getobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_getobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Data.ObjectNotFoundException">Nie można odnaleźć obiektu albo <see cref="T:System.Data.Objects.ObjectStateManager" /> lub źródła danych.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Wykonywanie zapytania o dane jako obiekty (Entity Framework)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObjectType">
      <MemberSignature Language="C#" Value="public static Type GetObjectType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetObjectType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetObjectType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetObjectType : Type -&gt; Type" Usage="System.Data.Objects.ObjectContext.GetObjectType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> Obiektu serwera proxy.</param>
        <summary>Zwraca typ jednostki jednostki POCO skojarzony obiekt serwera proxy o określonym typie.</summary>
        <returns><see cref="T:System.Type" /> Skojarzone jednostki POCO.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.GetObjectType%2A> Metoda jest używana podczas generowania obiektu serwera proxy jest włączona dla obiektów POCO. Aby uzyskać więcej informacji, zobacz [wymagania dotyczące tworzenia obiektów POCO proxy](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) i [Praca z jednostkami obiektów POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadProperty">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Jawnie ładuje powiązanego obiektu, korzystając z POCO danych niestandardowych klas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas używania klas danych niestandardowych POCO, powiązane obiekty nie jawnie załadować, takich jak wystąpień typów jednostek, które są generowane przez narzędzia modelu Entity Data Model. Jest to spowodowane narzędzia generowane właściwości nawigacji, które zwracają <xref:System.Data.Objects.DataClasses.EntityCollection%601> lub <xref:System.Data.Objects.DataClasses.EntityReference%601> powiązanych obiektów podczas <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> jest wywoływana w <xref:System.Data.Objects.DataClasses.RelatedEnd>. Jednostki POCO nadal mogą być ładowane przy użyciu ładowania z opóźnieniem, ustawiając <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> właściwości `true` w wystąpieniu programu <xref:System.Data.Objects.ObjectContextOptions> zwracanym przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwości lub za pomocą wczesne ładowanie z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metody <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty (entity As Object, navigationProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="navigationProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka, do którego mają zostać załadowane powiązanych obiektów.</param>
        <param name="navigationProperty">Nazwa właściwości nawigacji zwracającej powiązane obiekty do załadowania.</param>
        <summary>Jawnie ładuje związane z dostarczonego obiektu przez właściwość określonej nawigacji i przy użyciu opcji scalania domyślnego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Można wywołać metody, aby osiągnąć jawne ładowanie, korzystając z POCO danych niestandardowych klas.  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, powiązany obiekt jest możliwy za pośrednictwem właściwości nawigacji jednostki źródłowej.  
  
 Podczas używania klas danych niestandardowych POCO, powiązane obiekty nie jawnie załadować, takich jak wystąpień typów jednostek, które są generowane przez narzędzia modelu Entity Data Model. Jest to spowodowane narzędzia generowane właściwości nawigacji, które zwracają <xref:System.Data.Objects.DataClasses.EntityCollection%601> lub <xref:System.Data.Objects.DataClasses.EntityReference%601> powiązanych obiektów podczas <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> jest wywoływana w <xref:System.Data.Objects.DataClasses.RelatedEnd>. Jednostki POCO nadal mogą być ładowane przy użyciu ładowania z opóźnieniem, ustawiając <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> właściwości `true` w wystąpieniu programu <xref:System.Data.Objects.ObjectContextOptions> zwracanym przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwości lub za pomocą wczesne ładowanie z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metody <xref:System.Data.Objects.ObjectQuery%601>.  
  
 Gdy <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> metoda jest wywoływana, obiekty są ładowane do <xref:System.Data.Objects.ObjectContext> przy użyciu domyślnej <xref:System.Data.Objects.MergeOption> wartość <xref:System.Data.Objects.MergeOption.AppendOnly>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="entity" /> Znajduje się w <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> lub <see cref="F:System.Data.EntityState.Deleted" /> stanu 
—lub— 
<paramref name="entity" /> Jest dołączona do innego wystąpienia programu <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="navigationProperty" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="entity">Jednostka, do którego mają zostać załadowane powiązanych obiektów.</param>
        <param name="navigationProperty">Nazwa właściwości nawigacji zwracającej powiązane obiekty do załadowania.</param>
        <param name="mergeOption"><see cref="T:System.Data.Objects.MergeOption" /> Wartość używaną podczas ładowania powiązanych obiektów.</param>
        <summary>Jawnie ładuje obiekt, który jest powiązany z dostarczonego obiektu przez właściwość określonej nawigacji i przy użyciu opcji scalania określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Można wywołać metody, aby osiągnąć jawne ładowanie, korzystając z POCO danych niestandardowych klas.  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, powiązany obiekt jest możliwy za pośrednictwem właściwości nawigacji jednostki źródłowej.  
  
 Podczas używania klas danych niestandardowych POCO, powiązane obiekty nie jawnie załadować, takich jak wystąpień typów jednostek, które są generowane przez narzędzia modelu Entity Data Model. Jest to spowodowane narzędzia generowane właściwości nawigacji, które zwracają <xref:System.Data.Objects.DataClasses.EntityCollection%601> lub <xref:System.Data.Objects.DataClasses.EntityReference%601> powiązanych obiektów podczas <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> jest wywoływana w <xref:System.Data.Objects.DataClasses.RelatedEnd>. Jednostki POCO nadal mogą być ładowane przy użyciu ładowania z opóźnieniem, ustawiając <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> właściwości `true` w wystąpieniu programu <xref:System.Data.Objects.ObjectContextOptions> zwracanym przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwości lub za pomocą wczesne ładowanie z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metody <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="entity" /> Znajduje się w <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> lub <see cref="F:System.Data.EntityState.Deleted" /> stanu 
—lub— 
<paramref name="entity" /> Jest dołączona do innego wystąpienia programu <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty(Of TEntity) (entity As TEntity, selector As Expression(Of Func(Of TEntity, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; -&gt; unit" Usage="objectContext.LoadProperty (entity, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="entity">Obiekt źródłowy, do którego mają zostać załadowane powiązanych obiektów.</param>
        <param name="selector">Wyrażenie LINQ, które definiuje powiązane obiekty do załadowania.</param>
        <summary>Jawnie ładuje obiekt, który jest powiązany z dostarczonego obiektu, według określonego zapytania LINQ i przy użyciu opcji scalania domyślne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Można wywołać metody, aby osiągnąć jawne ładowanie, korzystając z POCO danych niestandardowych klas.  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, powiązany obiekt jest możliwy za pośrednictwem właściwości nawigacji jednostki źródłowej.  
  
 Właściwość załadować jest określona przez wyrażenie LINQ, która musi być w formie właściwości prostej dostęp do elementu członkowskiego, podobnie jak w `(entity) => entity.PropertyName`, gdzie *PropertyName* jest właściwość nawigacji, która zwraca powiązane obiekty do załadowania. Wyjątek wystąpi, jeśli używane są inne formy wyrażenie LINQ.  
  
 Podczas używania klas danych niestandardowych POCO, powiązane obiekty nie jawnie załadować, takich jak wystąpień typów jednostek, które są generowane przez narzędzia modelu Entity Data Model. Jest to spowodowane narzędzia generowane właściwości nawigacji, które zwracają <xref:System.Data.Objects.DataClasses.EntityCollection%601> lub <xref:System.Data.Objects.DataClasses.EntityReference%601> powiązanych obiektów podczas <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> jest wywoływana w <xref:System.Data.Objects.DataClasses.RelatedEnd>. Jednostki POCO nadal mogą być ładowane przy użyciu ładowania z opóźnieniem, ustawiając <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> właściwości `true` w wystąpieniu programu <xref:System.Data.Objects.ObjectContextOptions> zwracanym przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwości lub za pomocą wczesne ładowanie z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metody <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="selector" /> nie zapewnia prawidłowego parametru wejściowego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="selector" /> ma wartość null.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="entity" /> Znajduje się w <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> lub <see cref="F:System.Data.EntityState.Deleted" /> stanu 
—lub— 
<paramref name="entity" /> Jest dołączona do innego wystąpienia programu <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, selector, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="entity">Obiekt źródłowy, do którego mają zostać załadowane powiązanych obiektów.</param>
        <param name="selector">Wyrażenie LINQ, które definiuje powiązane obiekty do załadowania.</param>
        <param name="mergeOption"><see cref="T:System.Data.Objects.MergeOption" /> Wartość używaną podczas ładowania powiązanych obiektów.</param>
        <summary>Jawnie ładuje obiekt, który jest powiązany z dostarczonego obiektu, według określonego zapytania LINQ i przy użyciu opcji scalania określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> Można wywołać metody, aby osiągnąć jawne ładowanie, korzystając z POCO danych niestandardowych klas.  
  
 Po wywołaniu <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, powiązany obiekt jest możliwy za pośrednictwem właściwości nawigacji jednostki źródłowej.  
  
 Właściwość załadować jest określona przez wyrażenie LINQ, która musi być w formie właściwości prostej dostęp do elementu członkowskiego, podobnie jak w `(entity) => entity.PropertyName` gdzie *PropertyName* jest właściwość nawigacji, która zwraca powiązane obiekty do załadowania. Wyjątek wystąpi, jeśli używane są inne formy wyrażenie LINQ.  
  
 Podczas używania klas danych niestandardowych POCO, powiązane obiekty nie jawnie załadować, takich jak wystąpień typów jednostek, które są generowane przez narzędzia modelu Entity Data Model. Jest to spowodowane narzędzia generowane właściwości nawigacji, które zwracają <xref:System.Data.Objects.DataClasses.EntityCollection%601> lub <xref:System.Data.Objects.DataClasses.EntityReference%601> powiązanych obiektów podczas <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> jest wywoływana w <xref:System.Data.Objects.DataClasses.RelatedEnd>. Jednostki POCO nadal mogą być ładowane przy użyciu ładowania z opóźnieniem, ustawiając <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> właściwości `true` w wystąpieniu programu <xref:System.Data.Objects.ObjectContextOptions> zwracanym przez <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> właściwości lub za pomocą wczesne ładowanie z <xref:System.Data.Objects.ObjectQuery%601.Include%2A> metody <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="selector" /> nie zapewnia prawidłowego parametru wejściowego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="selector" /> ma wartość null.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="entity" /> Znajduje się w <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> lub <see cref="F:System.Data.EntityState.Deleted" /> stanu 
—lub— 
<paramref name="entity" /> Jest dołączona do innego wystąpienia programu <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetadataWorkspace">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MetadataWorkspace As MetadataWorkspace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Metadata::Edm::MetadataWorkspace ^ MetadataWorkspace { System::Data::Metadata::Edm::MetadataWorkspace ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataWorkspace : System.Data.Metadata.Edm.MetadataWorkspace" Usage="System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.MetadataWorkspace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obszar roboczy metadanych używane przez kontekst.</summary>
        <value><see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /> Obiekt skojarzony z tym <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Metadata.Edm.MetadataWorkspace> Klas to centralna środowisko uruchomieniowe interfejsu API, który służy do interakcji z metadanych modelu Entity Data Model (EDM) w kontekście aplikacji. Aby uzyskać więcej informacji, zobacz [obszar roboczy metadanych](https://msdn.microsoft.com/library/601aee56-3eda-4caa-9082-a01df76c5e84).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ObjectMaterialized">
      <MemberSignature Language="C#" Value="public event System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.ObjectMaterialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ObjectMaterialized As ObjectMaterializedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::Objects::ObjectMaterializedEventHandler ^ ObjectMaterialized;" />
      <MemberSignature Language="F#" Value="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " Usage="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectMaterializedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy tworzony jest nowy obiekt jednostki, dane w źródle danych w ramach operacji zapytania lub obciążenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane po wykonaniu wszystkich skalarną, złożonych, i zostały ustawione właściwości odwołania do obiektu, ale przed kolekcje są ładowane. Jeśli istnieje obiekt o tej samej wartości klucza w kontekście obiektu, platformy Entity Framework nie będzie ponownie utworzyć obiekt, a to zdarzenie nie zostanie wygenerowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectStateManager">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectStateManager ObjectStateManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectStateManager ObjectStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ObjectStateManager As ObjectStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectStateManager ^ ObjectStateManager { System::Data::Objects::ObjectStateManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ObjectStateManager : System.Data.Objects.ObjectStateManager" Usage="System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectStateManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera menedżera stanu obiektów, które są używane przez kontekst do śledzenia zmian obiektu.</summary>
        <value><see cref="T:System.Data.Objects.ObjectStateManager" /> Używanych przez to <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Te przykłady są oparte na [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W tym przykładzie pobiera <xref:System.Data.Objects.ObjectStateManager> z <xref:System.Data.Objects.ObjectContext> i używa Menedżera stanu, aby uzyskać dostęp do obiektu w kontekście.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectstatemanager)]
 [!code-vb[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectstatemanager)]  
  
 W tym przykładzie użyto <xref:System.Data.Objects.ObjectStateManager.TryGetObjectStateEntry%2A> zwracanego metody <xref:System.Data.Objects.ObjectStateManager> pobierania obiektu na podstawie jego klucza jednostki.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdates)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdates)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="QueryProvider">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryProvider QueryProvider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.IQueryProvider QueryProvider" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property QueryProvider As IQueryProvider" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Linq::IQueryProvider ^ QueryProvider { System::Linq::IQueryProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryProvider : System.Linq.IQueryProvider" Usage="System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dostawcę zapytań LINQ, które są skojarzone z tym kontekstem obiektu.</summary>
        <value><see cref="T:System.Linq.IQueryProvider" /> Wystąpienie używane w tym kontekście obiektu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualizuje określone obiekty w kontekście obiektu z danymi ze źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność, w których obiekty są odświeżane jest niedeterministyczny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="objectContext.Refresh (refreshMode, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="refreshMode">A <see cref="T:System.Data.Objects.RefreshMode" /> wartość, która wskazuje, czy zmiany właściwości w kontekście obiektu są zastępowane wartościami właściwości ze źródła danych.</param>
        <param name="collection"><see cref="T:System.Collections.IEnumerable" /> Kolekcji obiektów do odświeżenia.</param>
        <summary>Aktualizuje zbiór obiektów w kontekście obiektu z danymi ze źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma podwójną rolę polegającą umożliwiając obiektów w kontekście obiektu, aby zostać odświeżone przy użyciu danych ze źródła danych i jest mechanizm, za pomocą którego można rozwiązać konflikty. Aby uzyskać więcej informacji, zobacz [zapisywanie zmian i zarządzanie współbieżnością](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 Kolejność, w których obiekty są odświeżane jest niedeterministyczny.  
  
 Po <xref:System.Data.Objects.ObjectContext.Refresh%2A> jest wywoływana, obiekt oryginalnych wartości zawsze zostanie zaktualizowana wartość źródła danych, ale bieżące wartości mogą lub mogły nie zostać zaktualizowane przy użyciu wartości źródła danych. Zależy to od <xref:System.Data.Objects.RefreshMode> wartość. <xref:System.Data.Objects.RefreshMode.StoreWins> Tryb oznacza, że obiekty w kolekcji, powinien zostać zaktualizowany do pasuje do wartości źródła danych. <xref:System.Data.Objects.RefreshMode.ClientWins> oznacza, że zostaną utrwalone zmiany w kontekście obiektu, nawet jeśli były inne zmiany w źródle danych.  
  
 Aby upewnić się, że obiekty zostały zaktualizowane przez logikę po stronie źródła danych, możesz wywołać <xref:System.Data.Objects.ObjectContext.Refresh%2A> z <xref:System.Data.Objects.RefreshMode.StoreWins> po wywołaniu metody <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="refreshMode" /> nie jest prawidłowy.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="collection" /> jest pusty.  
  
—lub— 
Obiekt nie jest dołączony do kontekstu.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * obj -&gt; unit" Usage="objectContext.Refresh (refreshMode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Jedną z <see cref="T:System.Data.Objects.RefreshMode" /> wartości, które określa tryb, który na potrzeby odświeżania <see cref="T:System.Data.Objects.ObjectStateManager" />.</param>
        <param name="entity">Obiekt do odświeżenia.</param>
        <summary>Aktualizuje obiekt w kontekście obiektu z danymi ze źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.Refresh%2A> ma podwójną rolę polegającą pozwalając obiektu można go odświeżyć przy użyciu danych ze źródła danych i jest mechanizm, za pomocą którego można rozwiązać konflikty. Aby uzyskać więcej informacji, zobacz [zapisywanie zmian i zarządzanie współbieżnością](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 Kolejność, w których obiekty są odświeżane jest niedeterministyczny.  
  
 Po <xref:System.Data.Objects.ObjectContext.Refresh%2A> metoda jest wywoływana, oryginalne wartości obiektu zawsze zostanie zaktualizowana wartość źródła danych, ale bieżące wartości mogą lub mogły nie zostać zaktualizowane przy użyciu wartości źródła danych. Zależy to od <xref:System.Data.Objects.RefreshMode>. <xref:System.Data.Objects.RefreshMode.StoreWins> Tryb oznacza, że obiekt powinien zostać zaktualizowany do dopasowania wartości źródła danych. <xref:System.Data.Objects.RefreshMode.ClientWins> Wartość oznacza, że zostaną utrwalone zmiany w kontekście obiektu, nawet jeśli były inne zmiany w źródle danych.  
  
 Aby upewnić się, że obiekt został zaktualizowany przez logikę po stronie źródła danych, możesz wywołać <xref:System.Data.Objects.ObjectContext.Refresh%2A> metody z <xref:System.Data.Objects.RefreshMode.StoreWins> wartość po wywołaniu metody <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metody.  
  
   
  
## Examples  
 Ten przykład jest oparty na [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Przykład próbuje zapisać zmiany, a to może spowodować konflikt współbieżności. Następnie przedstawia sposób rozwiązywania konfliktów współbieżności, odświeżając kontekst przed ponownie zapisać zmiany.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="refreshMode" /> nie jest prawidłowy.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="collection" /> jest pusty.  
  
—lub— 
Obiekt nie jest dołączony do kontekstu.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Utrzymuje wszystkie aktualizacje w źródle danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges();" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : unit -&gt; int" Usage="objectContext.SaveChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Będzie się powtarzać, wszystkie aktualizacje w źródle danych i resetuje Zmień śledzenie w kontekście obiektu.</summary>
        <returns>Liczba obiektów w <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" />, lub <see cref="F:System.Data.EntityState.Deleted" /> Jeśli <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> została wywołana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby upewnić się, że obiekty na komputerze klienckim zostały zaktualizowane przez logikę po stronie źródła danych, możesz wywołać <xref:System.Data.Objects.ObjectContext.Refresh%2A> metody z <xref:System.Data.Objects.RefreshMode.StoreWins> wartość po wywołaniu metody <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Aby uzyskać więcej informacji, zobacz [zapisywanie zmian i zarządzanie współbieżnością](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> działa w obrębie transakcji. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> będzie wycofać transakcji i zgłosić wyjątek, jeśli dowolny z pyta <xref:System.Data.Objects.ObjectStateEntry> obiektów nie może zostać utrwalona.  
  
 Jeśli nastąpiło naruszenie zasad optymistycznej współbieżności, <xref:System.Data.OptimisticConcurrencyException> zgłaszany. Naruszenie zasad optymistycznej współbieżności można rozwiązać przez przechwytywanie, wywołanie <xref:System.Data.Objects.ObjectContext.Refresh%2A> metody z <xref:System.Data.Objects.RefreshMode.StoreWins> lub <xref:System.Data.Objects.RefreshMode.ClientWins> wartości, a następnie wywoływania <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> ponownie. Aby uzyskać więcej informacji, zobacz [porady: Zarządzanie współbieżność danych w kontekście obiektu](https://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a).  
  
   
  
## Examples  
 Ten przykład jest oparty na [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W tym przykładzie próbuje zapisać zmiany, które mogą powodować konflikt współbieżności. Następnie pokazuje sposób rozwiązywania konfliktów współbieżności, odświeżając kontekst przed ponownie zapisać zmiany.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Wystąpiło naruszenie optymistycznej współbieżności w źródle danych.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges (bool acceptChangesDuringSave);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges(bool acceptChangesDuringSave) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges (acceptChangesDuringSave As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges(bool acceptChangesDuringSave);" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : bool -&gt; int" Usage="objectContext.SaveChanges acceptChangesDuringSave" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use SaveChanges(SaveOptions options) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptChangesDuringSave" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="acceptChangesDuringSave">Ten parametr jest wymagany przez obsługę transakcji po stronie klienta. Jeśli <see langword="true" />, śledzenia zmian dla wszystkich obiektów jest resetowany po <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" /> zakończy się. Jeśli <see langword="false" />, należy wywołać <see cref="M:System.Data.Objects.ObjectContext.AcceptAllChanges" /> metody <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />.</param>
        <summary>Będzie się powtarzać, wszystkie aktualizacje w źródle danych, i opcjonalnie resetuje zmiany w kontekście obiektu.</summary>
        <returns>Liczba obiektów w <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" />, lub <see cref="F:System.Data.EntityState.Deleted" /> Jeśli <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> została wywołana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Data.Objects.ObjectContext.SaveChanges%28System.Data.Objects.SaveOptions%29> metody zamiast tego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Wystąpiło naruszenie optymistycznej współbieżności.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public virtual int SaveChanges (System.Data.Objects.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 SaveChanges(valuetype System.Data.Objects.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Data.Objects.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChanges (options As SaveOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int SaveChanges(System::Data::Objects::SaveOptions options);" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : System.Data.Objects.SaveOptions -&gt; int&#xA;override this.SaveChanges : System.Data.Objects.SaveOptions -&gt; int" Usage="objectContext.SaveChanges options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Data.Objects.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Data.Objects.SaveOptions" /> wartość, która określa zachowanie operacji.</param>
        <summary>Będzie się powtarzać, wszystkie aktualizacje w źródle danych o określonej <see cref="T:System.Data.Objects.SaveOptions" />.</summary>
        <returns>Liczba obiektów w <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" />, lub <see cref="F:System.Data.EntityState.Deleted" /> Jeśli <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" /> została wywołana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego określonego przeciążenia <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> do albo upewnij się, że <xref:System.Data.Objects.ObjectContext.DetectChanges%2A> jest wywoływana przed zapisaniem zmian źródła danych lub który <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> jest wywoływana po zapisaniu zmian w źródle danych.  
  
 To wyliczenie ma <xref:System.FlagsAttribute> umożliwiającą bitową kombinację jego wartości składowych.  
  
 Aby upewnić się, że obiekty na komputerze klienckim zostały zaktualizowane przez logikę po stronie źródła danych, można wywołać <xref:System.Data.Objects.ObjectContext.Refresh%2A> metody z <xref:System.Data.Objects.RefreshMode.StoreWins> wartość po wywołaniu metody <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> Metoda działa w ramach transakcji. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> będzie wycofać transakcji i zgłosić wyjątek, jeśli jeden z pyta <xref:System.Data.Objects.ObjectStateEntry> obiektów nie może zostać utrwalona.  
  
 Jeśli nastąpiło naruszenie zasad optymistycznej współbieżności, <xref:System.Data.OptimisticConcurrencyException> zgłaszany. Naruszenie zasad optymistycznej współbieżności można rozwiązać przez przechwytywanie, wywołanie <xref:System.Data.Objects.ObjectContext.Refresh%2A> metody z <xref:System.Data.Objects.RefreshMode.StoreWins> lub <xref:System.Data.Objects.RefreshMode.ClientWins> wartości, a następnie wywoływania <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> ponownie metodą. Aby uzyskać więcej informacji, zobacz [porady: Zarządzanie współbieżność danych w kontekście obiektu](https://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Wystąpiło naruszenie optymistycznej współbieżności.</exception>
      </Docs>
    </Member>
    <Member MemberName="SavingChanges">
      <MemberSignature Language="C#" Value="public event EventHandler SavingChanges;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SavingChanges" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.SavingChanges" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SavingChanges As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SavingChanges;" />
      <MemberSignature Language="F#" Value="member this.SavingChanges : EventHandler " Usage="member this.SavingChanges : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmiany są zapisywane do źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.SavingChanges> Zdarzenie jest zgłaszane na początku <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> operacja <xref:System.Data.Objects.ObjectContext>. To zdarzenie jest zazwyczaj używany do weryfikacji zmienionych obiektów, zanim nowe wartości są zapisywane w bazie danych.  
  
   
  
## Examples  
 Ten przykład jest oparty na [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Rejestruje to program obsługi <xref:System.Data.Objects.ObjectContext.SavingChanges> zdarzeń, który wykonuje sprawdzanie poprawności stanu jednostki.  
  
 [!code-csharp[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savingchanges)]
 [!code-vb[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savingchanges)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; Translate&lt;TElement&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; Translate&lt;TElement&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TElement) (reader As DbDataReader) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">To be added.</typeparam>
        <param name="reader"><see cref="T:System.Data.Common.DbDataReader" /> Zawierający dane jednostki do tłumaczenia na obiekty jednostki.</param>
        <summary>Wykonuje translację <see cref="T:System.Data.Common.DbDataReader" /> zawierający wiersze danych jednostki, do obiektów tego typu żądanej jednostki.</summary>
        <returns>Wyliczenie obiektów typu <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.Translate%2A> Metoda jest używana do translacji dane jednostki z <xref:System.Data.Common.DbDataReader> w obiektach żądanego typu. Ten proces odbywa się automatycznie po <xref:System.Data.Objects.ObjectQuery%601> jest wykonywane w celu zwracania danych jednostki. <xref:System.Data.Objects.ObjectContext.Translate%2A> Metoda umożliwia wykonywanie standardowej kwerendy ADO.NET w odniesieniu do źródła danych i tłumaczenie wierszy zwracanych danych na obiekty jednostki.  
  
 Podane <xref:System.Data.Common.DbDataReader> musi zawierać dane, która mapuje do typu żądanej jednostki.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednie wykonywanie poleceń Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Instrukcje: bezpośrednie wykonywanie poleceń względem źródła danych](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Gdy <paramref name="reader" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; Translate&lt;TEntity&gt; (System.Data.Common.DbDataReader reader, string entitySetName, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; Translate&lt;TEntity&gt;(class System.Data.Common.DbDataReader reader, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader * string * System.Data.Objects.MergeOption -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.Translate (reader, entitySetName, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="reader"><see cref="T:System.Data.Common.DbDataReader" /> Zawierający dane jednostki do tłumaczenia na obiekty jednostki.</param>
        <param name="entitySetName">Zestaw jednostek <c>TResult</c> typu.</param>
        <param name="mergeOption"><see cref="T:System.Data.Objects.MergeOption" /> Do użycia podczas translacji obiekty są dodawane do kontekstu obiektów. Wartość domyślna to <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <summary>Wykonuje translację <see cref="T:System.Data.Common.DbDataReader" /> zawierający wiersze danych jednostki do obiektów typu Żądana jednostka, w zestawie określonej jednostki i przy użyciu opcji scalania określony.</summary>
        <returns>Wyliczenie obiektów typu <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.Translate%2A> Metoda jest używana do translacji dane jednostki z <xref:System.Data.Common.DbDataReader> w obiektach żądanego typu. Ten proces odbywa się automatycznie po <xref:System.Data.Objects.ObjectQuery%601> jest wykonywane w celu zwracania danych jednostki. <xref:System.Data.Objects.ObjectContext.Translate%2A> Metoda umożliwia wykonywanie standardowej kwerendy ADO.NET w odniesieniu do źródła danych i tłumaczenie wierszy zwracanych danych na obiekty jednostki.  
  
 Podane <xref:System.Data.Common.DbDataReader> musi zawierać dane, która mapuje do typu żądanej jednostki.  
  
 Aby uzyskać więcej informacji, zobacz:  
  
 [Bezpośrednie wykonywanie poleceń Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) i  
  
 [Instrukcje: bezpośrednie wykonywanie poleceń względem źródła danych](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Gdy <paramref name="reader" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Gdy podane <paramref name="mergeOption" /> nie jest prawidłowym <see cref="T:System.Data.Objects.MergeOption" /> wartość.</exception>
        <exception cref="T:System.InvalidOperationException">Gdy podane <paramref name="entitySetName" /> ustawiono prawidłową jednostkę dla <paramref name="TResult" /> typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetObjectByKey">
      <MemberSignature Language="C#" Value="public bool TryGetObjectByKey (System.Data.EntityKey key, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetObjectByKey(class System.Data.EntityKey key, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.TryGetObjectByKey(System.Data.EntityKey,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetObjectByKey (key As EntityKey, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetObjectByKey(System::Data::EntityKey ^ key, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetObjectByKey : System.Data.EntityKey *  -&gt; bool" Usage="objectContext.TryGetObjectByKey (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
        <Parameter Name="value" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Klucz obiektu, który ma zostać odnaleziona.</param>
        <param name="value">Po powrocie z tej metody zawiera obiekt.</param>
        <summary>Zwraca obiekt, który ma określony klucz.</summary>
        <returns><see langword="true" /> Jeśli obiekt został pobrany pomyślnie. <see langword="false" /> Jeśli <paramref name="key" /> jest tymczasowe, połączenie jest <see langword="null" />, lub <paramref name="value" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> próbuje pobrać obiekt, który ma określony <xref:System.Data.EntityKey> z <xref:System.Data.Objects.ObjectStateManager>. Jeśli obiekt nie jest aktualnie załadowana do kontekstu obiektów, zapytanie jest wykonywane w celu podjęcia próby zwrócić obiekt ze źródła danych. Aby uzyskać więcej informacji, zobacz [zapytań dotyczących obiektów](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 Użyj <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> metody w celu uniknięcia obsługi <xref:System.Data.ObjectNotFoundException> wygenerowane przez <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> kiedy nie można odnaleźć obiektu.  
  
 Ta metoda zwróci obiektów w <xref:System.Data.EntityState.Deleted> stanu.  
  
 Klucz tymczasowy nie można zwrócić obiektu ze źródła danych.  
  
 <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> Metoda stosowana standard .NET `TryParse` wzorca dla <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> metody, zwracając `false` podczas <xref:System.Data.ObjectNotFoundException> zostanie przechwycony.  
  
   
  
## Examples  
 W przykładzie w tym temacie opiera się na [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie jest tworzony <xref:System.Data.EntityKey> jednostki danego typu, a następnie próbuje pobrać jednostki według klucza.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_trygetobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_trygetobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Niezgodne metadanych dla <paramref name="key" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Praca z obiektami (Entity Framework)</related>
      </Docs>
    </Member>
  </Members>
</Type>
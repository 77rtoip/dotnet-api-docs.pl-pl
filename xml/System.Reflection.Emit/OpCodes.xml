<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a136bc8fb48fe619f1be21928afbfcd9094d7463" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30562912" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia pole reprezentacje instrukcji Microsoft języka pośredniego (MSIL) emisji przez <see cref="T:System.Reflection.Emit.ILGenerator" /> elementy członkowskie klasy (takie jak <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowy opis używa elementu członkowskiego w dokumentacji infrastruktury języka wspólnego (CLI), szczególnie "III: CIL instrukcji zestawu partycji" i "Partycji II: metadane definicji i semantyki". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano konstrukcji przy użyciu metody dynamicznej <xref:System.Reflection.Emit.ILGenerator> można wyemitować `OpCodes` do <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dodaje dwie wartości, a wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|58|add|Dodaje dwie wartości liczbowe, zwracając wartość liczbową.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest dodawany do `value2`.  
  
4.  Wynik spoczywa na stosie.  
  
 Nie wykryto przepełnienia dla operacji liczba całkowita (przepełnienie prawidłowego obsługi, zobacz <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Liczba całkowita dodanie zawijany, a nie zmienia nasycenie. Na przykład przy założeniu, 8-bitowych liczb całkowitych gdzie `value1` wynosi 255 i `value2` jest ustawiona na 1, opakowana wynik jest 0, a nie do 256.  
  
 Przepełnienie zmiennoprzecinkowej zwraca `+inf` (`PositiveInfinity`) lub `-inf` (`NegativeInfinity`).  
  
 Operand dopuszczalne typy i ich odpowiedni typ danych wyników są wymienione w poniższej tabeli. Jeśli brak wpisu dla kombinacji określonego typu (na przykład `int32` i `float`; `int32` i `int64`), jest nieprawidłowy Microsoft pośredniego Language (MSIL) i generuje błąd.  
  
|argument operacji|Typ wartość1|Typ wartość2|Typ wyniku|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `add` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dodaje dwie liczb całkowitych, przeprowadza sprawdzanie przepełnienia, a wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D6|add.ovf|Dodaje dwie wartości liczb całkowitych ze sprawdzaniem przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest dodawany do `value2` z sprawdzaj przepełnienie.  
  
4.  Wynik spoczywa na stosie.  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie jest uwzględniona w typie wyniku.  
  
 Można wykonać tej operacji na liczb całkowitych ze znakiem. Użyj wartości zmiennoprzecinkowych <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Operand dopuszczalne typy i ich odpowiedni typ danych wyników są wymienione w poniższej tabeli. Jeśli brak wpisu dla kombinacji określonego typu (na przykład `int32` i `float`; `int32` i `int64`), jest nieprawidłowa instrukcja Microsoft języka pośredniego (MSIL) i generuje błąd.  
  
|argument operacji|Typ wartość1|Typ wartość2|Typ wyniku|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `add.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dodaje dwie wartości całkowitej bez znaku, przeprowadza sprawdzanie przepełnienia, a wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|Dodaje dwie wartości całkowitej bez znaku z kontroli przeciążenia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest dodawany do `value2` z sprawdzaj przepełnienie.  
  
4.  Wynik spoczywa na stosie.  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie jest uwzględniona w typie wyniku.  
  
 Można wykonać tej operacji na liczb całkowitych ze znakiem. Użyj wartości zmiennoprzecinkowych <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Operand dopuszczalne typy i ich odpowiedni typ danych wyników są wymienione w poniższej tabeli. Jeśli brak wpisu dla kombinacji określonego typu (na przykład `int32` i `float`; `int32` i `int64`), jest nieprawidłowa instrukcja Microsoft języka pośredniego (MSIL) i generuje błąd.  
  
|argument operacji|Typ wartość1|Typ wartość2|Typ wyniku|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `add.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oblicza iloczynu bitowego AND z dwóch wartości i umieszcza wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Instrukcja|Opis|  
|------------|-----------------|-----------------|  
|5F|and|Określa iloczynu bitowego AND z dwóch wartości całkowitych.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value1` i `value2` są zdjęte ze stosu ze stosu; jest obliczana iloczynu bitowego AND dwóch wartości.  
  
4.  Wynik spoczywa na stosie.  
  
 `and` Instrukcji oblicza iloczynu bitowego AND dwóch pierwszych wartości na stosie i pozostawienie wynik na stosie.  
  
 `And` jest operacją określonej liczby całkowitej.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `and` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca niezarządzanego wskaźnika do listy argumentów bieżącej metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 00|arglist|Zwraca dojście listy argumentów dla bieżącej metody.|  
  
 Nie zachowania stosu oceny są wykonywane przez tę operację.  
  
 `arglist` Instrukcji zwraca nieprzezroczystego uchwyt (niezarządzanego wskaźnika typu `native int`) reprezentujący listy argumentów bieżącej metody. Ta dojścia jest prawidłowy tylko w czasie trwania bieżącej metody. Można jednak przekazać dojście do innych metod, tak długo, jak jest bieżąca metoda w wątku kontroli. Można wykonywać tylko `arglist` instrukcji w metodę, która przyjmuje zmienną liczbę argumentów.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `arglist` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfer kontroli instrukcji docelowych, jeśli dwie wartości są równe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|Gałąź do instrukcji docelowy o przesunięciu `target` Jeśli dwie wartości są równe.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest równa `value2`, jest wykonywane gałęzi.  
  
 `beq` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest równa `value2`. Efekt jest taki sam jak wykonywanie `ceq` instrukcji następuje `brtrue` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Operand dopuszczalne typy znajdują się poniżej:  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami.  
  
 Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji (przeniesienie są znacznie ograniczone i musi być <xref:System.Reflection.Emit.OpCodes.Leave> instrukcji zamiast niego).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `beq` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontroli docelowych instrukcji (forma krótka /), jeśli dwie wartości są równe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq.s `target`|Gałąź do instrukcji docelowy o przesunięciu `target` przypadku równości, krótka|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest równa `value2`, jest wykonywane gałęzi.  
  
 `beq.s` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest równa `value2`. Efekt jest taki sam jak wykonywanie `ceq` instrukcji następuje `brtrue` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 1-bajtowy od początku instrukcji po bieżącej instrukcji.  
  
 Operand dopuszczalne typy znajdują się poniżej:  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami.  
  
 Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji (przeniesienie są znacznie ograniczone i musi być <xref:System.Reflection.Emit.OpCodes.Leave> instrukcji zamiast niego).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `beq.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontroli instrukcji docelowych, jeśli pierwsza wartość jest większa niż lub równa drugiej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|Gałęzi docelowych instrukcji od wskazanego przesunięcia, jeśli pierwsza wartość jest większa niż lub równa drugiej wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż lub równa `value2`, jest wykonywane gałęzi.  
  
 `bge` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest większa niż lub równa `value2`. Efekt jest taki sam jak wykonywanie `clt.un` instrukcji następuje `brfalse` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `bge` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontroli docelowych instrukcji (forma krótka /), jeśli pierwsza wartość jest większa niż lub równa drugiej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge.s `target`|Gałęzi docelowych instrukcji od wskazanego przesunięcia, jeśli pierwsza wartość jest większa lub równa wartości drugiego Krótka forma.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż lub równa `value2`, jest wykonywane gałęzi.  
  
 `bge.s` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest większa niż lub równa `value2`. Efekt jest taki sam jak wykonywanie `clt.un` instrukcji następuje `brfalse` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 1-bajtowy od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `bge.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontroli instrukcji docelowych, jeśli pierwsza wartość jest większa niż wartość drugiej podczas porównywania wartości całkowitej bez znaku lub nieuporządkowaną float.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.UN `target`|Gałęzi docelowych instrukcji od określonego przesunięcia, jeśli pierwsza wartość jest większa lub równa wartości drugiego (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż lub równa `value2`, jest wykonywane gałęzi.  
  
 `bge.un` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest większa niż lub równa `value2`, w porównaniu za pomocą liczby całkowitej bez znaku lub wartości nieuporządkowaną float. Efekt jest taki sam jak wykonywanie `clt` instrukcji następuje `brfalse` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `bge.un` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontroli docelowych instrukcji (forma krótka /), jeśli pierwsza wartość jest większa niż wartość drugiej podczas porównywania wartości całkowitej bez znaku lub nieuporządkowaną float.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s `target`|Gałęzi docelowych instrukcji od wskazanego przesunięcia, jeśli pierwsza wartość jest większa lub równa wartości (wartości bez znaku), drugi krótkich fragmentów.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż lub równa `value2`, jest wykonywane gałęzi.  
  
 `bge.un.s` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest większa niż lub równa `value2`, w porównaniu za pomocą liczby całkowitej bez znaku lub wartości nieuporządkowaną float. Efekt jest taki sam jak wykonywanie `clt` instrukcji następuje `brfalse` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 1-bajtowy od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `bge.un.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontroli instrukcji docelowych, jeśli pierwsza wartość jest większa od drugiej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3D < `int32` >|BGT `target`|Gałęzi docelowych instrukcji od wskazanego przesunięcia, jeśli pierwsza wartość jest większa od drugiej wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż `value2`, jest wykonywane gałęzi.  
  
 `bgt` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest większa niż `value2`. Efekt jest taki sam jak wykonywanie `cgt` instrukcji następuje `brtrue` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `bgt` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontroli docelowych instrukcji (forma krótka /), jeśli pierwsza wartość jest większa od drugiej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|30 < `int8` >|BGT.s `target`|Gałęzi docelowych instrukcji od wskazanego przesunięcia, jeśli pierwsza wartość jest większa niż wartość drugiej krótkich fragmentów.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż `value2`, jest wykonywane gałęzi.  
  
 `bgt.s` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest większa niż `value2`. Efekt jest taki sam jak wykonywanie `cgt` instrukcji następuje `brtrue` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 1-bajtowy od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `bgt.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontroli instrukcji docelowych, jeśli pierwsza wartość jest większa niż wartość drugiej podczas porównywania wartości całkowitej bez znaku lub nieuporządkowaną float.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|42 < `int32` >|BGT.UN `target`|Gałęzi docelowych instrukcji od określonego przesunięcia, jeśli pierwsza wartość jest większa niż wartość drugiej (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż `value2`, jest wykonywane gałęzi.  
  
 `bgt.un` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest większa niż `value2`, w porównaniu za pomocą liczby całkowitej bez znaku lub wartości nieuporządkowaną float. Efekt jest taki sam jak wykonywanie `cgt.un` instrukcji następuje `brtrue` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `bgt.un` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontroli docelowych instrukcji (forma krótka /), jeśli pierwsza wartość jest większa niż wartość drugiej podczas porównywania wartości całkowitej bez znaku lub nieuporządkowaną float.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|35 < `int8` >|BGT.UN.s `target`|Gałęzi docelowych instrukcji od wskazanego przesunięcia, jeśli pierwsza wartość jest większa niż wartość drugiej (wartości bez znaku), krótka forma.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż `value2`, jest wykonywane gałęzi.  
  
 `bgt.un.s` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest większa niż `value2`, w porównaniu za pomocą liczby całkowitej bez znaku lub wartości nieuporządkowaną float. Efekt jest taki sam jak wykonywanie `cgt.un` instrukcji następuje `brtrue` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 1-bajtowy od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `bgt.un.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontroli instrukcji docelowy Jeśli pierwsza wartość jest mniejsza lub równa wartości drugiego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3E `<int32>`|Cz `target`|Gałęzi docelowych instrukcji od wskazanego przesunięcia, jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż lub równa `value2`, jest wykonywane gałęzi.  
  
 `ble` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest mniejsza niż lub równa `value2`. Efekt jest taki sam jak wykonywanie `cgt` instrukcji (`cgt.un` w przypadku elementów przestawnych) następuje `brfalse` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ble` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontroli docelowych instrukcji (forma krótka /), jeśli pierwsza wartość jest mniejsza niż wartość drugiego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|31 `<int8>`|BLE.s `target`|Gałęzi docelowych instrukcji od wskazanego przesunięcia, jeśli pierwsza wartość jest mniejsza lub równa wartości drugiego Krótka forma.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż lub równa `value2`, jest wykonywane gałęzi.  
  
 `ble.s` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest mniejsza niż lub równa `value2`. Efekt jest taki sam jak wykonywanie `cgt` instrukcji (`cgt.un` w przypadku elementów przestawnych) instrukcji następuje`brfalse` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 1-bajtowy od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ble.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontroli instrukcji docelowych, jeśli pierwsza wartość jest mniejsza lub równa wartości drugiego podczas porównanie niepodpisane nieuporządkowaną float wartości lub wartości całkowite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|43 `<int32>`|BLE.UN `target`|Gałęzi docelowych instrukcji od określonego przesunięcia, jeśli pierwsza wartość jest mniejsza niż lub równa wartości drugiego (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż lub równa `value2`, jest wykonywane gałęzi.  
  
 `ble.un` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest mniejsza niż lub równa `value2`, w porównaniu za pomocą liczby całkowitej bez znaku lub wartości nieuporządkowaną float. Efekt jest taki sam jak wykonywanie `cgt.un` instrukcji (`cgt` w przypadku elementów przestawnych) następuje `brfalse` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ble.un` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontroli docelowych instrukcji (forma krótka), jeśli pierwsza wartość jest mniejsza lub równa wartości drugiego podczas porównanie niepodpisane nieuporządkowaną float wartości lub wartości całkowite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|36 `<int8>`|BLE.UN.s `target`|Gałęzi docelowych instrukcji od wskazanego przesunięcia, jeśli pierwsza wartość jest mniejsza lub równa wartości (wartości bez znaku), drugi krótkich fragmentów.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż lub równa `value2`, jest wykonywane gałęzi.  
  
 `ble.un.s` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest mniejsza niż lub równa `value2`, w porównaniu za pomocą liczby całkowitej bez znaku lub wartości nieuporządkowaną float. Efekt jest taki sam jak wykonywanie `cgt.un` instrukcji (`cgt` w przypadku elementów przestawnych) następuje `brfalse` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 1-bajtowy od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ble.un.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Formant transferu do instrukcji docelowych, jeśli pierwsza wartość jest mniejsza od drugiej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3F < `int32` >|Blt `target`|Rozgałęzienie do instrukcji docelowego na określone przesunięcie, jeśli pierwsza wartość jest mniejsza od drugiej wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż `value2`, jest wykonywane gałęzi.  
  
 `blt` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest mniejsza niż lub równa `value2`. Efekt jest taki sam jak wykonywanie `clt` instrukcji następuje `brtrue` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `blt` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie instrukcję docelowego (forma krótka /), jeśli pierwsza wartość jest mniejsza niż wartość drugiej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|32 < `int8` >|Blt.s `target`|Gałęzi docelowych instrukcji na określone przesunięcie, jeśli pierwsza wartość jest mniejsza od drugiej wartości Krótka forma.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż `value2`, jest wykonywane gałęzi.  
  
 `blt.s` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest mniejsza niż `value2`. Efekt jest taki sam jak wykonywanie `clt` instrukcji następuje `brtrue` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 1-bajtowy od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `blt.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Formant transferu do instrukcji docelowych, jeśli pierwsza wartość jest mniejsza niż wartość drugiej, podczas porównywania wartości całkowitej bez znaku lub nieuporządkowaną float.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|44 < `int32` >|Blt.UN `target`|Rozgałęzienie do instrukcji docelowego na określone przesunięcie, jeśli pierwsza wartość jest mniejsza od drugiej wartości (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż `value2`, jest wykonywane gałęzi.  
  
 `blt.un` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest mniejsza niż `value2`, w porównaniu za pomocą liczby całkowitej bez znaku lub wartości nieuporządkowaną float. Efekt jest taki sam jak wykonywanie `clt.un` instrukcji następuje `brtrue` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `blt.un` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontrolować instrukcję docelowego (forma krótka /), jeśli pierwsza wartość mniejsza od drugiego jest wartość, przy porównanie niepodpisane wartości całkowitych lub wartości zmiennoprzecinkowych nieuporządkowaną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|37 < `int8` >|Blt.UN.s `target`|Rozgałęzienie do instrukcji docelowego na określone przesunięcie, jeśli pierwsza wartość jest mniejsza niż wartość drugiej (wartości bez znaku), krótka forma.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż `value2`, jest wykonywane gałęzi.  
  
 `blt.un` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` jest mniejsza niż `value2`, w porównaniu za pomocą liczby całkowitej bez znaku lub wartości nieuporządkowaną float. Efekt jest taki sam jak wykonywanie `clt.un` instrukcji następuje `brtrue` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `blt.un.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontrolować instrukcji docelowych nie są takie same wartości nieuporządkowaną float lub dwie wartości całkowitej bez znaku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|40 < `int32` >|BNE.UN `target`|Gałąź z obiektem docelowym instrukcji od wskazanego przesunięcia, jeśli dwa podpisane liczby całkowite są nierówne (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` nie jest równa `value2`, jest wykonywane gałęzi.  
  
 `bne.un` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` nie jest równa `value2`, w porównaniu za pomocą liczby całkowitej bez znaku lub wartości nieuporządkowaną float. Efekt jest taki sam jak wykonywanie `ceq` instrukcji następuje `brfalse` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `bne.un` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie do instrukcję docelowego (forma krótka) po dwóch niepodpisane nieuporządkowaną float wartości lub wartości całkowite nie są takie same.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s `target`|Gałąź z obiektem docelowym instrukcji od wskazanego przesunięcia, jeśli dwa podpisane liczby całkowite są nie równa się (wartości bez znaku), krótka wersja.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` nie jest równa `value2`, jest wykonywane gałęzi.  
  
 `bne.un` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value1` nie jest równa `value2`, w porównaniu za pomocą liczby całkowitej bez znaku lub wartości nieuporządkowaną float. Efekt jest taki sam jak wykonywanie `ceq` instrukcji następuje `brfalse` gałąź do instrukcji określonych docelowych. Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `bne.un.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje odwołanie do obiektu typu wartości (typu <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8C < `T` >|Pole `valTypeToken`|Konwertuj typu wartość (typu określonego w `valTypeToken`) odwołania do obiektu wartość true.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Typ wartości spoczywa na stosie.  
  
2.  Typ wartości jest zdjęte ze stosu ze stosu; `box` operacja została wykonana.  
  
3.  Odwołanie obiektu do wynikowy typ wartości "spakowanej" spoczywa na stosie.  
  
 Typ wartości ma dwa oddzielne reprezentacje w ramach wspólnej infrastruktury języka (CLI):  
  
-   "Raw" formularz używany, gdy typ wartości jest osadzony w innym obiekcie lub na stosie.  
  
-   Formy "opakowanej", gdzie dane w typ wartości jest opakowana (opakowany) do obiektu, może istnieć jako niezależne jednostki.  
  
 `box` Instrukcji konwertuje odwołanie do obiektu typu "raw" (rozpakowany) wartość (typu `O`). Jest to osiągane przez utworzenie nowego obiektu i kopiowanie danych z typ wartości do nowoprzydzielonych obiektu. `valTypeToken` token metadanych jest i wskazujący rodzaj typu wartości na stosie.  
  
 <xref:System.OutOfMemoryException> jest generowany, jeśli jest za mało pamięci do spełnienia żądania.  
  
 <xref:System.TypeLoadException> jest generowany, jeśli nie można znaleźć klasy. To zwykle wykryto po przekonwertowaniu Microsoft języka pośredniego (MSIL) do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `box` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezwarunkowo przekazuje sterowanie do instrukcji docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|Gałęzie, które mają instrukcję docelowy od wskazanego przesunięcia.|  
  
 Nie zachowania stosu oceny są wykonywane przez tę operację.  
  
 `br` Instrukcji bezwarunkowo przekazuje sterowanie do instrukcji docelowej. Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `br` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezwarunkowo przekazuje sterowanie do instrukcję docelowego (forma krótka /).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br.s `target`|Gałęzie, które mają instrukcję docelowy od wskazanego przesunięcia krótkich fragmentów.|  
  
 Nie zachowania stosu oceny są wykonywane przez tę operację.  
  
 `br.s` Instrukcji bezwarunkowo przekazuje sterowanie do instrukcji docelowej. Instrukcja docelowy jest reprezentowany jako offset podpisem 1-bajtowy od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `br.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sygnały infrastruktury języka wspólnego (CLI) informują debugera o tym, że punkt przerwania został uruchomiony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|01|break|Poinformuj debugera punkt przerwania został osiągnięty.|  
  
 Nie zachowania stosu oceny są wykonywane przez tę operację.  
  
 `break` Instrukcja to debugowanie pomocy technicznej. Powiadamia interfejsu wiersza polecenia, aby informować debugera, czy punkt przerwania został uruchomiony. Go nie ma innych wpływu na stan interpreter.  
  
 `break` Instrukcji ma najmniejszą możliwe instrukcji rozmiar Włączanie kod poprawki z punktem przerwania i generowania minimalnego zakłóceń otaczającego kodu.  
  
 `break` Instrukcji można debugera, nic nie rób lub Zgłoś wyjątek zabezpieczeń. Dokładne jest zdefiniowane w implementacji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `break` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie do instrukcji docelowych, jeśli <paramref name="value" /> jest <see langword="false" />, odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), lub wartość zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|Gałęzi docelowych instrukcji w określonym if przesunięcia `false`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie przez poprzednią operację.  
  
2.  `value` jest zdjęte ze stosu ze stosu; Jeśli `value` jest `false`, gałęzi do `target`.  
  
 `brfalse` Instrukcji (i jego aliasy `brnull` i `brzero`) przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value` (typu `int32`, `int64`, obiekt odwołania `O`zarządzane wskaźnika `&`, wskaźnik przejściowa `*`, `native int`) wynosi zero (`false`). Jeśli `value` jest niezerowa (`true`) wykonywania jest kontynuowane od następnej instrukcji.  
  
 Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `brfalse` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie do instrukcji docelowych, jeśli <paramref name="value" /> jest <see langword="false" />, odwołanie o wartości null lub zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|Gałęzi docelowych instrukcji w określonym if przesunięcia `false`, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie przez poprzednią operację.  
  
2.  `value` jest zdjęte ze stosu ze stosu; Jeśli `value` jest `false`, gałęzi do `target`.  
  
 `brfalse.s` Instrukcji (i jego aliasy `brnull` i `brzero`) przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value` (typu `int32`, `int64`, obiekt odwołania `O`zarządzane wskaźnika `&`, wskaźnik przejściowa `*`, `native int`) wynosi zero (`false`). Jeśli `value` jest niezerowa (`true`) wykonywania jest kontynuowane od następnej instrukcji.  
  
 Instrukcja docelowy jest reprezentowany jako offset podpisem 1-bajtowy od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `brfalse.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie do instrukcji docelowych, jeśli <paramref name="value" /> jest <see langword="true" />, nie wartość null lub inną niż zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|Gałęzi do instrukcję docelowy od wskazanego przesunięcia, jeśli różna od zera (`true`).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie przez poprzednią operację.  
  
2.  `value` jest zdjęte ze stosu ze stosu; Jeśli `value` jest `true`, gałęzi do `target`.  
  
 `brtrue` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value` (typ `native int`) jest różna od zera (`true`). Jeśli `value` wynosi zero (`false`) wykonywania jest kontynuowane od następnej instrukcji.  
  
 Jeśli `value` jest odwołanie do obiektu (typ `O`) następnie `brinst` (alias `brtrue`) przesyła formantu, jeśli reprezentuje wystąpienie obiektu (na przykład, jeśli nie jest odwołanie do obiektu null; zobacz <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Instrukcja docelowy jest reprezentowany jako offset podpisem 4-bajtowych od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `brtrue` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie instrukcję docelowego (forma krótka /), jeśli <paramref name="value" /> jest <see langword="true" />, nie wartość null lub inną niż zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|Gałęzi do instrukcję docelowy od wskazanego przesunięcia, jeśli różna od zera (`true`), krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie przez poprzednią operację.  
  
2.  `value` jest zdjęte ze stosu ze stosu; Jeśli `value` jest `true`, gałęzi do `target`.  
  
 `brtrue.s` Instrukcji przekazuje sterowanie do instrukcji określonych docelowych, jeśli `value` (typ `native int`) jest różna od zera (`true`). Jeśli `value` wynosi zero (`false`) wykonywania jest kontynuowane od następnej instrukcji.  
  
 Jeśli `value` jest odwołanie do obiektu (typ `O`) następnie `brinst` (alias `brtrue`) przesyła formantu, jeśli reprezentuje wystąpienie obiektu (na przykład, jeśli nie jest odwołanie do obiektu null; zobacz <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Instrukcja docelowy jest reprezentowany jako offset podpisem 1-bajtowy od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami. Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `brtrue.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wywołuje metodę wskazywanym przez deskryptor metody przekazany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|28 < `T` >|Wywołania `methodDesc`|Wywołaj metodę opisanego przez `methodDesc`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Argumenty metody `arg1` za pośrednictwem `argN` są przenoszone na stosie.  
  
2.  Argumenty metody `arg1` za pośrednictwem `argN` są zdjęte ze stosu ze stosu; wywołania metody, które jest wykonywane z tymi argumentami i sterowanie jest przekazywane do metody odwołuje się deskryptor metody. Po zakończeniu wartości zwracanej jest generowany przez metodę wywoływany i wysyłane do obiektu wywołującego.  
  
3.  Wartość zwracana spoczywa na stosie.  
  
 `call` Instrukcji wywołuje metodę wskazywanym przez deskryptor metody przekazaną za pomocą instrukcji. Deskryptor metody jest token metadanych, który wskazuje metodę do wywołania oraz liczbę, typ i kolejność argumentów, które zostały umieszczone na stosie, które mają być przekazane do tej metody, a także konwencji wywołania do użycia. `call` Instrukcji może być od razu poprzedzony `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefiksu instrukcji, aby określić, że bieżący stan metody powinny zostać zwolnione przed przeniesieniem formantu. Jeśli wywołanie przekazuje sterowanie metodę zaufania wyższe niż metoda źródła, nie jest zwalniany ramki stosu. Zamiast tego kontynuuje wykonywanie dyskretnie tak, jakby `tail` nie został podany. Token metadanych zawiera wystarczających informacji do ustalenia, czy połączenie ma metody statycznej metody wystąpienia, metoda wirtualna albo funkcją globalną. We wszystkich tych przypadkach adres docelowy zależy całkowicie od deskryptor metody (kontrastu to z <xref:System.Reflection.Emit.OpCodes.Callvirt> instrukcji do wywoływania metody wirtualne, gdzie adres docelowy również zależy od typu środowiska uruchomieniowego wystąpienia Odwołanie wypychana przed <xref:System.Reflection.Emit.OpCodes.Callvirt>).  
  
 Argumenty są umieszczane na stosie w kolejności od lewej do prawej. Oznacza to, że pierwszy argument jest obliczana i umieszczane na stosie, drugi argument, a następnie innych, dopóki wszystkie niezbędne argumenty mają nad stosu w kolejności malejącej. Istnieją trzy ważne szczególnych przypadkach:  
  
 1. Wywołania do wystąpienia (lub wirtualnymi) metoda musi push odwołania do tego wystąpienia przed każdą argumentów widoczny dla użytkownika. Odwołania do wystąpienia nie może być odwołaniem o wartości zerowej. Podpis w metadanych nie zawiera wpis na liście parametrów dla `this` wskaźnika; zamiast tego wskazująca, czy metoda wymaga przekazywanie używa bit `this` wskaźnika.  
  
 2. Nieprawidłowe wywołanie metody wirtualnej przy użyciu jest `call` (zamiast `callvirt`); oznacza to, że metoda jest można rozwiązać za pomocą klasy określonej przez metodę, a nie jako określony obiekt wywoływany z.  
  
 3. Należy pamiętać, że delegata `Invoke` metodę można wywołać przy użyciu jednej `call` lub `callvirt` instrukcji.  
  
 <xref:System.Security.SecurityException> może zostać zgłoszony, gdy zabezpieczenia systemu nie powoduje przyznania dostępu wywołującego do wywołaną metodę. Kontrola zabezpieczeń może wystąpić, gdy instrukcje Microsoft języka pośredniego (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
> [!NOTE]
>  Podczas wywoływania metody System.Object w typach wartości, należy rozważyć użycie `constrained` prefiks z `callvirt` instrukcji zamiast emitowanie `call` instrukcji. Spowoduje to usunięcie potrzebę Emituj IL różne w zależności od tego, czy typ wartości zastępuje metodę, unikając potencjalny problem z kontroli wersji. Należy rozważyć użycie `constrained` prefiks podczas wywoływania metody interfejsu dla typów wartości, ponieważ metodzie typu wartości implementacja metody interfejsu można zmienić za pomocą `MethodImpl`. Te problemy opisane bardziej szczegółowo w <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `call` opcode:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode, MethodInfo, Type[])  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> Przewidziana metoda `varargs` wywołania. Użyj <xref:System.Reflection.Emit.ILGenerator.Emit%2A> normalne wywołanie metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wywołuje metodę sygnalizowane na stosie oceny (jako wskaźnik do punktu wejścia) z argumentami opisanego przez Konwencję wywołania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|Wywołuje metodę wskazywał z argumentami opisanego przez Konwencję wywołania.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Argumenty metody `arg1` za pośrednictwem `argN` są przenoszone na stosie.  
  
2.  Metoda wskaźnika wejścia spoczywa na stosie.  
  
3.  Argumenty metody `arg1` za pośrednictwem `argN` i wskaźnika wejścia metody są zdjęte ze stosu ze stosu, jest wykonywane wywołanie do metody. Po zakończeniu wartości zwracanej jest generowany przez metodę wywoływany i wysyłane do obiektu wywołującego.  
  
4.  Wartość zwracana spoczywa na stosie.  
  
 `calli` Instrukcji wywołuje wskaźnika wejścia metody z argumentami `arg1` za pośrednictwem `argN`. Typy tych argumentów, których dotyczą określonych konwencji wywołania (`callSiteDesc`). `calli` Instrukcji może być od razu poprzedzony `tail` prefiksu (<xref:System.Reflection.Emit.OpCodes.Tailcall>) do określenia, że bieżący stan metody powinny zostać zwolnione przed przeniesieniem formantu. Wywołanie spowoduje transfer kontroli do metody zaufania wyższe niż metoda pochodzenia ramki stosu nie zostanie zwolnione; Zamiast tego wykonywania będzie dyskretnie tak, jakby `tail` nie został podany.  
  
 Metoda wskaźnika wejścia zakłada się, że określonych wskaźnik do kodu natywnego (of na docelowym komputerze), które może być legalnie wywołane z argumentami opisanego przez Konwencję wywołania (token metadanych dla autonomicznego podpis). Wskaźnik takie mogą być tworzone przy użyciu <xref:System.Reflection.Emit.OpCodes.Ldftn> lub <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instrukcje, lub przekazaną z kodu macierzystego.  
  
 Konwencja wywoływania nie jest zaznaczone dynamicznie, więc kod używa tego `calli` instrukcji nie działa prawidłowo, jeśli miejsce docelowe nie są rzeczywiście używane określonej konwencji wywoływania.  
  
 Argumenty są umieszczane na stosie w kolejności od lewej do prawej. Oznacza to, że pierwszy argument jest obliczana i umieszczane na stosie, drugi argument, a następnie innych, dopóki wszystkie niezbędne argumenty mają nad stosu w kolejności malejącej. Kompilowanie argument sekwencji kodu dla wystąpień lub metody wirtualnej musi push odwołania do tego wystąpienia (który nie może być odwołaniem o wartości zerowej) przed każdą argumentów widoczny dla użytkownika.  
  
 <xref:System.Security.SecurityException> może zostać zgłoszony, gdy zabezpieczenia systemu nie powoduje przyznania dostępu wywołującego do wywołaną metodę. Kontrola zabezpieczeń może wystąpić, gdy instrukcje Microsoft języka pośredniego (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> metod można użyć do wykonania `calli` instrukcji na stosie. Należy pamiętać, że `calli` powinna być wywoływana za pomocą poniższych metod, a nie za pomocą <xref:System.Reflection.Emit.ILGenerator.Emit%2A> klasy można umieścić instrukcję bezpośrednio na stosie.  
  
-   ILGenerator.EmitCalli (Opcode, CallingConventions, typu Type [], Type[]) dla połączeń przy użyciu zarządzanego konwencję wywołania.  
  
-   ILGenerator.EmitCalli (Opcode Type[]) CallingConvention, typ, dla połączeń przy użyciu niezarządzana konwencja wywołania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wywołuje metodę późnym wiązaniem dla obiekt wypychanie wartości zwracanej na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|Wywołuje metodę określonej skojarzone z `obj`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `obj` spoczywa na stosie.  
  
2.  Argumenty metody `arg1` za pośrednictwem `argN` są przenoszone na stosie.  
  
3.  Argumenty metody `arg1` za pośrednictwem `argN` i odwołanie do obiektu `obj` są zdjęte ze stosu ze stosu; wywołania metody, które jest wykonywane z tymi argumentami i sterowanie jest przekazywane do metody w `obj` odwołuje się do metody token metadanych. Po zakończeniu wartości zwracanej jest generowany przez metodę wywoływany i wysyłane do obiektu wywołującego.  
  
4.  Wartość zwracana spoczywa na stosie.  
  
 `callvirt` Instrukcji wywołuje metodę późnym wiązaniem dla obiekt. Oznacza to, że metoda jest wybierany zależności od typu środowiska uruchomieniowego `obj` zamiast widoczne we wskaźniku metody klasy kompilacji. `Callvirt` można wywołać metodę wirtualnych do wystąpienia metody. `callvirt` Instrukcji może być od razu poprzedzony `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefiksu, aby określić, że bieżącej ramki stosu, powinny zostać zwolnione przed przeniesieniem formantu. Wywołania spowoduje transfer kontroli do metody zaufania wyższe niż oryginalnej metody ramki stosu nie zostanie zwolnione.  
  
 Metoda token metadanych zawiera nazwę, klasy i podpis metody do wywołania. Skojarzonej z klasy `obj` jest klasa, który jest wystąpieniem. Jeśli klasa definiuje Metoda niestatyczna, zgodny z nazwą metody wskazanej i podpis, ta metoda jest wywoływana. W przeciwnym razie wszystkie klasy w łańcuchu klasy podstawowej tej klasy są sprawdzane w kolejności. Jeśli nie jest znaleziono metody, występuje błąd.  
  
 `Callvirt` POP obiekt i argumenty skojarzone z poszczególnymi stosu oceny przed wywołaniem metody. Jeśli metoda ma wartość zwracaną, spoczywa na stosie po zakończeniu metody. Na stronie wywoływanej `obj` parametru jest dostępny jako argument 0, `arg1` jako argument 1 i tak dalej.  
  
 Argumenty są umieszczane na stosie w kolejności od lewej do prawej. Oznacza to, że pierwszy argument jest obliczana i umieszczane na stosie, drugi argument, a następnie innych, dopóki wszystkie niezbędne argumenty mają nad stosu w kolejności malejącej. Odwołanie do wystąpienia `obj` (zawsze wymagany do `callvirt`) musi zostać przesunięta przed każdą argumentów widoczny dla użytkownika. Podpis (odbywa się w tokenie metadanych) nie musi zawierać wpis na liście parametrów dla tego wskaźnika.  
  
 Należy pamiętać, że metoda wirtualna można także wywoływać za pomocą <xref:System.Reflection.Emit.OpCodes.Call> instrukcji.  
  
 <xref:System.MissingMethodException> jest generowany, jeśli nie można odnaleźć metody niestatycznej z określoną nazwę i sygnaturę w skojarzonej z klasy `obj` ani dla żadnej z jej klas podstawowych. To jest zwykle wykrycie instrukcje Microsoft języka pośredniego (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli obj ma wartość null.  
  
 <xref:System.Security.SecurityException> jest generowany, jeśli zabezpieczenia systemu nie powoduje przyznania dostępu wywołującego do wywołaną metodę. Kontrola zabezpieczeń może wystąpić po przekonwertowaniu listę CIL do kodu natywnego, a nie w czasie wykonywania.  
  
> [!NOTE]
>  Podczas wywoływania metody System.Object w typach wartości, należy rozważyć użycie `constrained` prefiks z `callvirt` instrukcji. Spowoduje to usunięcie potrzebę Emituj IL różne w zależności od tego, czy typ wartości zastępuje metodę, unikając potencjalny problem z kontroli wersji. Należy rozważyć użycie `constrained` prefiks podczas wywoływania metody interfejsu dla typów wartości, ponieważ metodzie typu wartości implementacja metody interfejsu można zmienić za pomocą `MethodImpl`. Te problemy opisane bardziej szczegółowo w <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `callvirt` opcode:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode, MethodInfo, Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Próbuje rzutować obiekt przekazywany przez odwołanie do określonej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|Rzutuje obiektu nowy obiekt typu `class`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu spoczywa na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte ze stosu ze stosu; odwołuje się do obiektu jest rzutowane jako określony `class`.  
  
3.  W przypadku powodzenia nowego odwołania do obiektu spoczywa na stosie.  
  
 `castclass` Instrukcji próbuje rzutowania odwołanie do obiektu (typ `O`) nad stosu do określonej klasy. Nowa klasa jest określany przez token metadanych, wskazując odpowiednią klasę. Jeśli klasa obiektu wierzchołku stosu nie implementuje nową klasę (zakładając, że nowa klasa jest interfejsem) i nie jest klasa pochodna nowej klasy, a następnie <xref:System.InvalidCastException> jest generowany. Jeśli odwołanie do obiektu jest odwołanie o wartości null, `castclass` zakończy się pomyślnie i zwraca nowy obiekt jako odwołanie o wartości null.  
  
 <xref:System.InvalidCastException> jest generowany, jeśli obj nie można rzutować klasy.  
  
 <xref:System.TypeLoadException> jest generowany, jeśli nie można odnaleźć klasy. To zwykle wykryto po przekonwertowaniu instrukcji Microsoft języka pośredniego (MSIL) do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `castclass` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje dwie wartości. Czy są równe, liczbę całkowitą wartość 1 <see langword="(int32" />) spoczywa na stosie oceny; w przeciwnym razie wartość 0 (<see langword="int32" />) spoczywa na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 01|ceq|Wypychanie 1, jeśli `value1` jest równe `value2`; w przeciwnym razie wypchnięcia 0.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest porównywany `value2`.  
  
4.  Jeśli `value1` jest równa `value2`, 1 spoczywa na stosie; w przeciwnym razie 0 spoczywa na stosie.  
  
 `ceq` Porównuje instrukcji `value1` i `value2`. Jeśli `value1` jest równa `value2`, następnie 1 (typu `int32`) spoczywa na stosie. W przeciwnym razie wartość 0 (typu `int32`) spoczywa na stosie.  
  
 Dla liczba zmiennoprzecinkowa `ceq` zwróci 0, jeśli są nieuporządkowane liczby (NaN są jednego lub obu). Nieskończone wartości są równe do siebie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ceq` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje dwie wartości. Jeśli pierwsza wartość jest większa od drugiej, liczbę całkowitą wartość 1 <see langword="(int32" />) spoczywa na stosie oceny; w przeciwnym razie wartość 0 (<see langword="int32" />) spoczywa na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 02|cgt|Wypychanie 1, jeśli `value1` jest większa niż `value2`; w przeciwnym razie wypchnięcia 0.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `cgt` testów, jeśli `value1` jest większa niż `value2`.  
  
4.  Jeśli `value1` jest większa niż `value2`, 1 spoczywa na stosie; w przeciwnym razie 0 spoczywa na stosie.  
  
 `cgt` Porównuje instrukcji `value1` i `value2`. Jeśli `value1` jest większa niż `value2`, a następnie `int32` wartość 1 spoczywa na stosie. W przeciwnym razie `int32` wartość 0 spoczywa na stosie.  
  
-   Na liczby zmiennoprzecinkowe `cgt` zwraca wartość 0, jeśli liczby są nieuporządkowaną (to znaczy, jeśli co najmniej jeden z argumentów jest wartością typu NaN).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `cgt` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje dwie wartości bez znaku lub nieuporządkowane. Jeśli pierwsza wartość jest większa od drugiej, liczbę całkowitą wartość 1 <see langword="(int32" />) spoczywa na stosie oceny; w przeciwnym razie wartość 0 (<see langword="int32" />) spoczywa na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|Wypychanie 1, jeśli `value1` jest większa niż `value2`; w przeciwnym razie wypchnięcia 0 (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `cgt.un` testów, jeśli `value1` jest większa niż `value2`.  
  
4.  Jeśli `value1` jest większa niż `value2`, 1 spoczywa na stosie; w przeciwnym razie 0 spoczywa na stosie.  
  
 `int32` Wartość 1 spoczywa na stosie, jeśli dowolny z nich jest `true` :  
  
 Na liczby zmiennoprzecinkowe `value1` nie jest określona w odniesieniu do `value2`.  
  
 Dla wartości całkowitych `value1` jest większa niż `value2` rozpatrywane jako liczby bez znaku.  
  
 W przeciwnym razie `int32` wartość 0 spoczywa na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `cgt.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zgłasza wyjątek <see cref="T:System.ArithmeticException" /> Jeśli wartość nie jest wartością skończoną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|C3|ckfinite|throw <xref:System.ArithmeticException> Jeśli wartość nie jest wartością skończoną.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i `ckfinite` instrukcji odbywa się na nim.  
  
3.  `value` spoczywa wstecz na stosie, jeśli nie jest wyjątek.  
  
 `ckfinite instruction` Zgłasza <xref:System.ArithmeticException> Jeśli `value` (liczba zmiennoprzecinkowa) jest albo "not a number" wartość (NaN) lub `+-` wartości nieskończonej. `Ckfinite` pozostawia wartości na stosie, jeśli nie jest wyjątek. Wykonanie nie jest określona, jeśli `value` nie jest liczba zmiennoprzecinkowa.  
  
 <xref:System.ArithmeticException> wygenerowany, jeśli `value` nie jest liczbą "normal".  
  
 Należy pamiętać, że specjalny wyjątek lub klasy pochodnej z <xref:System.ArithmeticException> może być bardziej odpowiednie, przekazywanie niepoprawną wartość do obsługi wyjątków.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ckfinite` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje dwie wartości. Jeśli pierwsza wartość jest mniejsza od drugiej, liczbę całkowitą wartość 1 <see langword="(int32" />) spoczywa na stosie oceny; w przeciwnym razie wartość 0 (<see langword="int32" />) spoczywa na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 04|clt|Wypychanie 1, jeśli `value1` jest mniejsza niż `value2`; w przeciwnym razie wypchnięcia 0.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to: `value1` spoczywa na stosie.  
  
1.  `value2` spoczywa na stosie.  
  
2.  `value2` i `value1` są zdjęte ze stosu ze stosu; `clt` testów, jeśli `value1` jest mniejsza niż `value2`.  
  
3.  Jeśli `value1` jest mniejsza niż `value2`, 1 spoczywa na stosie; w przeciwnym razie 0 spoczywa na stosie.  
  
 `clt` Porównuje instrukcji `value1` i `value2`. Jeśli `value1` jest mniejsza niż `value2`, a następnie `int32` wartość 1 spoczywa na stosie. W przeciwnym razie `int32` wartość 0 spoczywa na stosie.  
  
-   Na liczby zmiennoprzecinkowe `clt` zwraca wartość 0, jeśli liczby są nieuporządkowaną (to znaczy, jeśli co najmniej jeden z argumentów jest wartością typu NaN).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `clt` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje wartości bez znaku lub nieuporządkowaną <paramref name="value1" /> i <paramref name="value2" />. Jeśli <paramref name="value1" /> jest mniejsza niż <paramref name="value2" />, następnie wartość całkowita 1 <see langword="(int32" />) spoczywa na obliczanie stosu; w przeciwnym razie 0 (<see langword="int32" />) spoczywa na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 05|clt.un|Wypychanie 1, jeśli `value1` jest mniejsza niż `value2`; w przeciwnym razie wypchnięcia 0 (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `clt.un` testów, jeśli `value1` jest mniejsza niż `value2`.  
  
4.  Jeśli `value1` jest mniejsza niż `value2`, 1 spoczywa na stosie; w przeciwnym razie 0 spoczywa na stosie.  
  
 `clt.un` Porównuje instrukcji `value1` i `value2`. `int32` Wartość 1 spoczywa na stosie, jeśli jest spełniony jeden z następujących czynności:  
  
-   `value1` jest mniejsza niż `value2` (jak w przypadku `clt`).  
  
-   Na liczby zmiennoprzecinkowe `value1` nie jest określona w odniesieniu do `value2`.  
  
-   Dla wartości całkowitych `value1` jest mniejsza niż `value2` rozpatrywane jako liczby bez znaku.  
  
 W przeciwnym razie `int32` wartość 0 spoczywa na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `clt.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ogranicza typ, na którym jest nawiązane połączenie metoda wirtualna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu język pośredni (MSIL) firmy Microsoft, wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 16 < `T` >|ograniczone. `thisType`|Wywołanie metody wirtualnej dla takiego typu, jest ograniczona do typu `T`.|  
  
 `constrained` Prefiks jest dozwolone tylko w systemie `callvirt` instrukcji.  
  
 Stan, w tym momencie stosu MSIL musi być w następujący sposób:  
  
1.  Wskaźnik zarządzanych, `ptr`, spoczywa na stosie. Typ `ptr` musi być wskaźnikiem zarządzanych (`&`) do `thisType`. Należy pamiętać, że jest inny niż w przypadku unprefixed `callvirt` instrukcji, która oczekuje odwołania do elementu `thisType`.  
  
2.  Argumenty metody `arg1` za pośrednictwem `argN` są przenoszone na stosie, tak jak w przypadku unprefixed `callvirt` instrukcji.  
  
 `constrained` Prefiks umożliwia `callvirt` instrukcje, które ma zostać wykonane w jednolity sposób niezależny od czy `thisType` jest typem wartości lub typem referencyjnym.  
  
 Gdy `callvirt` `method` poprzedzony instrukcji `constrained` `thisType`, instrukcja jest wykonywana w następujący sposób:  
  
-   Jeśli `thisType` jest następnie typu odwołania (w przeciwieństwie do typu wartości) `ptr` jest wyłuskiwany i przekazane jako wskaźnik "this", aby `callvirt` z `method`.  
  
-   Jeśli `thisType` jest typem wartości i `thisType` implementuje `method` następnie `ptr` została przekazana bez modyfikacji jako wskaźnik "this", aby `call` `method` instrukcję do wykonania `method` przez `thisType`.  
  
-   Jeśli `thisType` jest typem wartości i `thisType` nie implementuje `method` następnie `ptr` jest wyłuskiwany, opakowany i przekazane jako wskaźnik "this", aby `callvirt` `method` instrukcji.  
  
 Tym ostatnim przypadku może wystąpić tylko wtedy, gdy `method` została zdefiniowana w <xref:System.Object>, <xref:System.ValueType>, lub <xref:System.Enum> i nie jest zastępowana przez `thisType`. W takim przypadku opakowanie powoduje, że kopia oryginalnego obiektu ma zostać wykonane. Jednak ponieważ żaden z metody <xref:System.Object>, <xref:System.ValueType>, i <xref:System.Enum> zmiany stanu obiektu, nie można wykryć tego faktów.  
  
 `constrained` Prefiks obsługuje generatory IL, tworzonych przez kod rodzajowy. Zwykle `callvirt` instrukcji jest nieprawidłowy dla typów wartości. Zamiast tego jest to wymagane czy kompilatory IL skutecznie na przekształcenie "this" opisanych powyżej w czasie kompilacji, w zależności od typu `ptr` i wywołania metody. Jednakże, gdy `ptr` jest typu ogólnego, który jest nieznany w czasie kompilacji nie jest możliwe tej transformacji w czasie kompilacji.  
  
 `constrained` Opcode umożliwia kompilatory IL do wywoływania funkcji wirtualnych w jednolity sposób niezależny od czy `ptr` jest typem wartości lub typem referencyjnym. Mimo że jest on przeznaczony do sprawę gdzie `thisType` jest zmienną typu ogólnego `constrained` prefiksu również działa dla typów nierodzajowe i może zmniejszyć złożoność Generowanie wywołania wirtualnej w językach, które Ukryj rozróżnienia typów wartości i typy referencyjne.  
  
 Przy użyciu `constrained` prefiks pozwala uniknąć potencjalnych problemów versioning z typami wartości. Jeśli `constrained` prefiks nie jest używany, różnych IL musi wysyłanego w zależności od tego, czy typ wartości zastępuje metodę System.Object. Na przykład, jeśli typ wartości `V` zastępuje metodę Object.ToString() `call` `V.ToString()` wysyłanego instrukcji; Jeśli nie, `box` instrukcji i `callvirt` `Object.ToString()` są emitowane instrukcji. Przechowywanie wersji może wystąpić problem w pierwszym przypadku, jeśli zastąpienie później zostanie usunięty, a w drugim przypadku jeśli zastąpienie później zostanie dodany.  
  
 `constrained` Prefiks można również dla wywołania metody interfejsu dla typów wartości, ponieważ w metodzie typu wartości implementacja metody interfejsu można zmienić za pomocą `MethodImpl`. Jeśli `constrained` prefiks nie jest używany, kompilator wymusza na wybranie wartości typu metody, aby powiązać w czasie kompilacji. Przy użyciu `constrained` prefiks umożliwia MSIL powiązać metodę, która implementuje metody interfejsu w czasie wykonywania, a nie w czasie kompilacji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `constrained` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D3|conv.i|Konwertuj na `native int`, położenia `native int` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.i` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i pozostaw, które konwertowane wartość górnej części stosu. Liczby całkowite z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używany w takim przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych wartości obcina liczbę w kierunku zera. Podczas konwertowania z `float64` do `float32`, dokładność, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatnia) lub negatywną infinity (Jeśli `value` jest ujemna) jest zwracany. Przepełnienie w przypadku konwertowania typu jeden argument do innej, najbardziej znaczących bitów są obcinane. Jeśli wynik jest mniejsza niż `int32`, wartość jest znakiem do wypełnienia gniazda.  
  
 Jeśli wystąpi przepełnienie konwertowanie typ zmiennoprzecinkowy na liczbę całkowitą wartość zwracana jest nieokreślony.  
  
 Wyjątki nie są nigdy generowany, gdy za pomocą tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie można poprawnie reprezentują wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="int8" />, stanowi rozszerzenie (PAD) do <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|67|conv.i1|Konwertuj na `int8`, położenia `int32` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.i1` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i pozostaw, które konwertowane wartość górnej części stosu. Liczby całkowite z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używany w takim przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych wartości obcina liczbę w kierunku zera. Podczas konwertowania z `float64` do `float32`, dokładność, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatnia) lub negatywną infinity (Jeśli `value` jest ujemna) jest zwracany. Przepełnienie w przypadku konwertowania typu jeden argument do innej, najbardziej znaczących bitów są obcinane. Jeśli wynik jest mniejsza niż `int32`, wartość jest znakiem do wypełnienia gniazda.  
  
 Jeśli wystąpi przepełnienie konwertowanie typ zmiennoprzecinkowy na liczbę całkowitą wartość zwracana jest nieokreślony.  
  
 Wyjątki nie są nigdy generowany, gdy za pomocą tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie można poprawnie reprezentują wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="int16" />, stanowi rozszerzenie (PAD) do <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|68|conv.i2|Konwertuj na `int16`, położenia `int32` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.i2` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i pozostaw, które konwertowane wartość górnej części stosu. Liczby całkowite z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używany w takim przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych wartości obcina liczbę w kierunku zera. Podczas konwertowania z `float64` do `float32`, dokładność, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatnia) lub negatywną infinity (Jeśli `value` jest ujemna) jest zwracany. Przepełnienie w przypadku konwertowania typu jeden argument do innej, najbardziej znaczących bitów są obcinane. Jeśli wynik jest mniejsza niż `int32`, wartość jest znakiem do wypełnienia gniazda.  
  
 Jeśli wystąpi przepełnienie konwertowanie typ zmiennoprzecinkowy na liczbę całkowitą wartość zwracana jest nieokreślony.  
  
 Wyjątki nie są nigdy generowany, gdy za pomocą tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie można poprawnie reprezentują wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|69|conv.i4|Konwertuj na `int32`, położenia `int32` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.i4` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i pozostaw, które konwertowane wartość górnej części stosu. Liczby całkowite z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używany w takim przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych wartości obcina liczbę w kierunku zera. Podczas konwertowania z `float64` do `float32`, dokładność, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatnia) lub negatywną infinity (Jeśli `value` jest ujemna) jest zwracany. Przepełnienie w przypadku konwertowania typu jeden argument do innej, najbardziej znaczących bitów są obcinane. Jeśli wynik jest mniejsza niż `int32`, wartość jest znakiem do wypełnienia gniazda.  
  
 Jeśli wystąpi przepełnienie konwertowanie typ zmiennoprzecinkowy na liczbę całkowitą wartość zwracana jest nieokreślony.  
  
 Wyjątki nie są nigdy generowany, gdy za pomocą tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie można poprawnie reprezentują wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6A|conv.i8|Konwertuj na `int64`, położenia `int64` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.i8` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i pozostaw, które konwertowane wartość górnej części stosu. Liczby całkowite z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używany w takim przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych wartości obcina liczbę w kierunku zera. Podczas konwertowania z `float64` do `float32`, dokładność, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatnia) lub negatywną infinity (Jeśli `value` jest ujemna) jest zwracany. Przepełnienie w przypadku konwertowania typu jeden argument do innej, najbardziej znaczących bitów są obcinane. Jeśli wynik jest mniejsza niż `int32`, wartość jest znakiem do wypełnienia gniazda.  
  
 Jeśli wystąpi przepełnienie konwertowanie typ zmiennoprzecinkowy na liczbę całkowitą wartość zwracana jest nieokreślony.  
  
 Wyjątki nie są nigdy generowany, gdy za pomocą tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie można poprawnie reprezentują wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość podpisem na szczycie stosu oceny podpisane <see langword="native int" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|Konwertuj na `native int` (na stosie jako `native int`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.i` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny podpisane <see langword="native int" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|Konwertuje wartość bez znaku `native int` (na stosie jako `native int`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.i.un` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.i.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość podpisem na szczycie stosu oceny podpisane <see langword="int8" /> i rozszerza się <see langword="int32" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|Konwertuj na `int8` (na stosie jako `int32`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.i1` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny podpisane <see langword="int8" /> i rozszerza się <see langword="int32" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|Konwertuje wartość bez znaku `int8` (na stosie jako `int32`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.i1.un` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.i1.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość podpisem na szczycie stosu oceny podpisane <see langword="int16" /> i rozszerzanie jej <see langword="int32" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|Konwertuj na `int16` (na stosie jako `int32`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.i2` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny podpisane <see langword="int16" /> i rozszerza się <see langword="int32" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|Konwertuje wartość bez znaku `int16` (na stosie jako `int32`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.i2.un` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.i2.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość podpisem na szczycie stosu oceny podpisane <see langword="int32" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|Konwertuj na `int32` (na stosie jako `int32`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.i4` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny podpisane <see langword="int32" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|Konwertuje wartość bez znaku `int32` (na stosie jako `int32`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.i4.un` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.i4.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość podpisem na szczycie stosu oceny podpisane <see langword="int64" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|Konwertuj na `int64` (na stosie jako `int64`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.i8` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny podpisane <see langword="int64" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|Konwertuje wartość bez znaku `int64` (na stosie jako `int64`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.i8.un` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.i8.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość podpisem na szczycie stosu oceny do <see langword="unsigned native int" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|Konwertuj na `unsigned native int` (na stosie jako `native int`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.u` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.u` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny do <see langword="unsigned native int" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|Wartość bez znaku un konwertuje `unsigned native int` (na stosie jako `native int`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.u.un` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.uvf.u.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość podpisem na szczycie stosu oceny do <see langword="unsigned int8" /> i rozszerza się <see langword="int32" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|Konwertuj na `unsigned int8` (na stosie jako `int32`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.u1` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny do <see langword="unsigned int8" /> i rozszerza się <see langword="int32" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|Konwertuje wartość bez znaku `unsigned int8` (na stosie jako `int32`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.u1.un` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.u1.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość podpisem na szczycie stosu oceny do <see langword="unsigned int16" /> i rozszerza się <see langword="int32" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|Konwertuj na `unsigned int16` (na stosie jako `int32`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.u2` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny do <see langword="unsigned int16" /> i rozszerza się <see langword="int32" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|Konwertuje wartość bez znaku `unsigned int16` (na stosie jako `int32`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.u2.un` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.u2.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość podpisem na szczycie stosu oceny do <see langword="unsigned int32" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|Konwertuj na `unsigned int32` (na stosie jako `int32`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.u4` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny do <see langword="unsigned int32" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|Konwertuje wartość bez znaku `unsigned int32` (na stosie jako `int32`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.u4.un` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.u4.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość podpisem na szczycie stosu oceny do <see langword="unsigned int64" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|Konwertuj na `unsigned int64` (na stosie jako `int64`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.u8` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.u8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny do <see langword="unsigned int64" />, przerzucane <see cref="T:System.OverflowException" /> na przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|Konwertuje wartość bez znaku `unsigned int64` (na stosie jako `int64`) i zgłosić wyjątek na przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli wystąpi przepełnienie, jest zwracany wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.ovf.u8.un` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i miejsca, które konwertowane wartość górnej części stosu. Jeśli wartość jest za duża albo za mała, aby mogły być reprezentowane przez typ docelowy, jest zwracany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych wartości truncate liczbę w kierunku zera. Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.ovf.u8.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość liczby całkowitej bez znaku na szczycie stosu oceny do <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|76|conv.r.un|Konwertuj liczbę całkowitą bez znaku do liczb zmiennoprzecinkowych, wypychanie `F` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.r.un` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i pozostaw, które konwertowane wartość górnej części stosu. Liczby całkowite z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używany w takim przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych wartości obcina liczbę w kierunku zera. Podczas konwertowania z `float64` do `float32`, dokładność, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatnia) lub negatywną infinity (Jeśli `value` jest ujemna) jest zwracany. Przepełnienie w przypadku konwertowania typu jeden argument do innej, najbardziej znaczących bitów są obcinane. Jeśli wynik jest mniejsza niż `int32`, wartość jest znakiem do wypełnienia gniazda.  
  
 Jeśli wystąpi przepełnienie konwertowanie typ zmiennoprzecinkowy na liczbę całkowitą `result` zwracane jest nieokreślony. `conv.r.un` Operacji przyjmuje całkowitą ze stosu, zinterpretuje ją jako bez znaku i zastępuje je do reprezentowania liczba całkowita liczba zmiennoprzecinkowa: albo `float32`, jeżeli jest dostatecznie szerokie, aby reprezentować liczbę całkowitą bez utraty precyzji lub innego `float64`.  
  
 Wyjątki nie są nigdy generowany, gdy za pomocą tego pola.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.r.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6B|conv.r4|Konwertuj na `float32`, położenia `F` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.r4` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i pozostaw, które konwertowane wartość górnej części stosu. Liczby całkowite z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używany w takim przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych wartości obcina liczbę w kierunku zera. Podczas konwertowania z `float64` do `float32`, dokładność, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatnia) lub negatywną infinity (Jeśli `value` jest ujemna) jest zwracany. Przepełnienie w przypadku konwertowania typu jeden argument do innej, najbardziej znaczących bitów są obcinane. Jeśli wynik jest mniejsza niż `int32`, wartość jest znakiem do wypełnienia gniazda.  
  
 Jeśli wystąpi przepełnienie konwertowanie typ zmiennoprzecinkowy na liczbę całkowitą wartość zwracana jest nieokreślony.  
  
 Wyjątki nie są nigdy generowany, gdy za pomocą tego pola.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6C|conv.r8|Konwertuj na `float64`, położenia `F` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.r8` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i pozostaw, które konwertowane wartość górnej części stosu. Liczby całkowite z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używany w takim przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych wartości obcina liczbę w kierunku zera. Podczas konwertowania z `float64` do `float32`, dokładność, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatnia) lub negatywną infinity (Jeśli `value` jest ujemna) jest zwracany. Przepełnienie w przypadku konwertowania typu jeden argument do innej, najbardziej znaczących bitów są obcinane. Jeśli wynik jest mniejsza niż `int32`, wartość jest znakiem do wypełnienia gniazda.  
  
 Jeśli wystąpi przepełnienie konwertowanie typ zmiennoprzecinkowy na liczbę całkowitą wartość zwracana jest nieokreślony.  
  
 Wyjątki nie są nigdy generowany, gdy za pomocą tego pola.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="unsigned native int" />, i zwiększa się <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|E0|conv.u|Konwertuj na `unsigned native int`, położenia `native int` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.u` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i pozostaw, które konwertowane wartość górnej części stosu. Liczby całkowite z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używany w takim przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych wartości obcina liczbę w kierunku zera. Podczas konwertowania z `float64` do `float32`, dokładność, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatnia) lub negatywną infinity (Jeśli `value` jest ujemna) jest zwracany. Przepełnienie w przypadku konwertowania typu jeden argument do innej, najbardziej znaczących bitów są obcinane. Jeśli wynik jest mniejsza niż `int32`, wartość jest znakiem do wypełnienia gniazda.  
  
 Jeśli wystąpi przepełnienie konwertowanie typ zmiennoprzecinkowy na liczbę całkowitą wartość zwracana jest nieokreślony.  
  
 Wyjątki nie są nigdy generowany, gdy za pomocą tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie można poprawnie reprezentują wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.u` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="unsigned int8" />, i zwiększa się <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D2|conv.U1|Konwertuj na `int8`, położenia `int32` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.u1` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i pozostaw, które konwertowane wartość górnej części stosu. Liczby całkowite z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używany w takim przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych wartości obcina liczbę w kierunku zera. Podczas konwertowania z `float64` do `float32`, dokładność, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatnia) lub negatywną infinity (Jeśli `value` jest ujemna) jest zwracany. Przepełnienie w przypadku konwertowania typu jeden argument do innej, najbardziej znaczących bitów są obcinane. Jeśli wynik jest mniejsza niż `int32`, wartość jest znakiem do wypełnienia gniazda.  
  
 Jeśli wystąpi przepełnienie konwertowanie typ zmiennoprzecinkowy na liczbę całkowitą wartość zwracana jest nieokreślony.  
  
 Wyjątki nie są nigdy generowany, gdy za pomocą tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie można poprawnie reprezentują wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="unsigned int16" />, i zwiększa się <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D1|conv.u2|Konwertuj na `int16`, położenia `int32` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.u2` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i pozostaw, które konwertowane wartość górnej części stosu. Liczby całkowite z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używany w takim przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych wartości obcina liczbę w kierunku zera. Podczas konwertowania z `float64` do `float32`, dokładność, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatnia) lub negatywną infinity (Jeśli `value` jest ujemna) jest zwracany. Przepełnienie w przypadku konwertowania typu jeden argument do innej, najbardziej znaczących bitów są obcinane. Jeśli wynik jest mniejsza niż `int32`, wartość jest znakiem do wypełnienia gniazda.  
  
 Jeśli wystąpi przepełnienie konwertowanie typ zmiennoprzecinkowy na liczbę całkowitą wartość zwracana jest nieokreślony.  
  
 Wyjątki nie są nigdy generowany, gdy za pomocą tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie można poprawnie reprezentują wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="unsigned int32" />, i zwiększa się <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6D|conv.U4|Konwertuj na `unsigned int32`, położenia `int32` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.u4` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i pozostaw, które konwertowane wartość górnej części stosu. Liczby całkowite z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używany w takim przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych wartości obcina liczbę w kierunku zera. Podczas konwertowania z `float64` do `float32`, dokładność, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatnia) lub negatywną infinity (Jeśli `value` jest ujemna) jest zwracany. Przepełnienie w przypadku konwertowania typu jeden argument do innej, najbardziej znaczących bitów są obcinane. Jeśli wynik jest mniejsza niż `int32`, wartość jest znakiem do wypełnienia gniazda.  
  
 Jeśli wystąpi przepełnienie konwertowanie typ zmiennoprzecinkowy na liczbę całkowitą wartość zwracana jest nieokreślony.  
  
 Wyjątki nie są nigdy generowany, gdy za pomocą tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie można poprawnie reprezentują wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="unsigned int64" />, i zwiększa się <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6E|conv.u8|Konwertuj na `int64`, położenia `int64` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wynikową spoczywa na stosie.  
  
 `conv.u8` Konwertuje opcode `value` na szczycie stosu na typ określony w opcode i pozostaw, które konwertowane wartość górnej części stosu. Liczby całkowite z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` , gdy są załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używany w takim przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych wartości obcina liczbę w kierunku zera. Podczas konwertowania z `float64` do `float32`, dokładność, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatnia) lub negatywną infinity (Jeśli `value` jest ujemna) jest zwracany. Przepełnienie w przypadku konwertowania typu jeden argument do innej, najbardziej znaczących bitów są obcinane. Jeśli wynik jest mniejsza niż `int32`, wartość jest znakiem do wypełnienia gniazda.  
  
 Jeśli wystąpi przepełnienie konwertowanie typ zmiennoprzecinkowy na liczbę całkowitą wartość zwracana jest nieokreślony.  
  
 Wyjątki nie są nigdy generowany, gdy za pomocą tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie można poprawnie reprezentują wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `conv.u8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiuje określona liczba bajtów z adresu źródłowego do docelowego adresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Skopiuj dane z bloku pamięci do innego.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres docelowy spoczywa na stosie.  
  
2.  Źródłowy adres spoczywa na stosie.  
  
3.  Liczba bajtów do skopiowania spoczywa na stosie.  
  
4.  Liczba bajtów, adresu źródłowego i docelowego adresu są zdjęte ze stosu ze stosu; określona liczba bajtów są kopiowane z adresu źródłowego do docelowego adresu.  
  
 `cpblk` Instrukcji kopiuje liczbą (typ `unsigned int32`) bajtów z adresem źródłowym (typu `*`, `native int`, lub `&`) do docelowego adresu (typu `*`, `native int`, lub `&`). Zachowanie `cpblk` jest nieokreślony nakładania się obszarów źródłowym i docelowym.  
  
 `cpblk` przyjęto założenie, że źródłowym i docelowym adresowane są wyrównane do fizycznych rozmiaru maszyny. `cpblk` Instrukcji może być od razu poprzedzony `unaligned.<prefix>` instrukcjami, aby wskazać, że źródłowy lub docelowy jest niewyrównany.  
  
 Działanie `cpblk` instrukcji może być zmieniony przez poprzedzającego <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> może zostać zgłoszony, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `cpblk` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Typ wartości znajdujących się pod adresem obiektu kopie (typ <see langword="&amp;" />, <see langword="*" /> lub <see langword="native int" />) adres obiektu docelowego (typ <see langword="&amp;" />, <see langword="*" /> lub <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|Kopiuje wartość typu z obiektu źródłowego do obiektu docelowego.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu docelowego spoczywa na stosie.  
  
2.  Odwołanie do obiektu źródłowego spoczywa na stosie.  
  
3.  Odwołania do dwóch obiektów są zdjęte ze stosu ze stosu; Typ wartości pod adresem obiektu źródłowego jest kopiowany do adresu obiektu docelowego.  
  
 Zachowanie `cpobj` jest nieokreślony, jeśli źródłowy i docelowy obiekt odwołania nie są wskaźnikami do wystąpienia klasy reprezentowany przez class token `classTok` ( `typeref` lub `typedef`), lub jeśli `classTok` nie reprezentuje Typ wartości.  
  
 <xref:System.NullReferenceException> może zostać zgłoszony, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `cpobj` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dzieli dwie wartości i umieszcza wynik w postaci liczb zmiennoprzecinkowych (typ <see langword="F" />) lub iloraz (typ <see langword="int32" />) na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5B|div|Dzieli dwie wartości do zwrócenia iloraz lub wynik zmiennoprzecinkowy.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` przez `value2`.  
  
4.  Wynik spoczywa na stosie.  
  
 `result` = `value1` DIV wartość2 spełnia następujące warunki:  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, oraz:  
  
 znak (`result`) = +, jeśli podpisania (`value1`) = znak (`value2`), lub-, jeśli znak (`value1`) ~ = znak (`value2`)  
  
 `div` Instrukcji oblicza wynik i wypchnięcia jej na stosie.  
  
 Dzielenie liczby całkowitej obcina kierunku zera.  
  
 Dzielenie wartością skończoną przez zero tworzy poprawnie podpisane wartość nieskończona.  
  
 Podzielenie zero przez zero lub infinity w nieskończoność i tworzy wartości NaN (nie-A-liczba). Dowolna liczba rozdzielonych nieskończoności utworzy wartość zero.  
  
 Operacje integralną throw <xref:System.ArithmeticException> Jeśli wynik nie może być reprezentowany w typie wyniku. Może się to zdarzyć, jeśli `value1` maksymalna wartość ujemna, i `value2` wynosi -1.  
  
 Operacje integralną throw <xref:System.DivideByZeroException> Jeśli `value2` wynosi zero.  
  
 Należy pamiętać, że na platformach opartych na Intel <xref:System.OverflowException> jest generowany, gdy obliczeniowych (minint div -1). Operacji zmiennoprzecinkowych nigdy nie zgłaszają wyjątek (wygenerowanie wartości NaN lub infinities zamiast niego).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `div` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dzieli dwie wartości całkowitej bez znaku i umieszcza wynik (<see langword="int32" />) na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5C|div.un|Dzieli dwie wartości, bez znaku, Zwraca iloraz.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` przez `value2`.  
  
4.  Wynik spoczywa na stosie.  
  
 `div.un` Oblicza instrukcji `value1` rozdzielonych `value2`, zarówno jako liczb całkowitych bez znaku i wypchnięć `result` na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `div.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiuje bieżącej wartości znajdujące się najwyżej na stosie oceny, a następnie wypchnięcia kopiowania na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|25|Dup —|Duplikuje wartość górnej części stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` Wylogowuje stosu do duplikacji jest zdjęte ze stosu.  
  
3.  `value` spoczywa wstecz na stosie.  
  
4.  Zduplikowana wartość spoczywa na stosie.  
  
 `dup` Instrukcji duplikaty górnego elementu stosu i pozostawia dwie identyczne wartości nad go.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `dup` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery formantu z <see langword="filter" /> klauzuli wyjątek do obsługi wyjątków infrastruktury języka wspólnego (CLI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 11|elementu Endfilter|Klauzula filtru zakończenia dla obsługi wyjątków SEH.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu; `endfilter` jest wykonywany i sterowanie jest przekazywane do programu obsługi wyjątków.  
  
 `Value` (który musi być typu `int32` i to jedna z określonych wartości) jest zwracana z klauzuli filtru. Powinien być jednym z:  
  
-   `exception_continue_search` (`value` = 0) aby kontynuować wyszukiwanie obsługi wyjątków  
  
-   `exception_execute_handler` (`value` = 1) aby uruchomić drugi znajduje się faza obsługi wyjątków, w której ostatecznie bloki są uruchamiane aż do obsługi skojarzone z tym klauzula filtru. Podczas odnajdywania program obsługi jest wykonywany.  
  
 Inne wartości całkowite da wyniki nieokreślony.  
  
 Punkt wejścia filtru, jak pokazano w tabeli wyjątek metody, musi być pierwsza instrukcja w bloku kodu filtru. `endfilter` Instrukcji musi być ostatnim instrukcji w bloku kodu filtru (dlatego może istnieć tylko jedna `endfilter` dla bloku pojedynczy filtr). Po wykonaniu `endfilter` instrukcji kontroli przepływu logicznie do obsługi mechanizmu wyjątków interfejsu wiersza polecenia.  
  
 Formant nie można przenieść do bloku filtru, z wyjątkiem przez mechanizm wyjątków. Nie można przenieść kontroli z bloku filtru z wyjątkiem za pośrednictwem `throw` instrukcji lub wykonując ostatecznych `endfilter` instrukcji. Nie można osadzić `try` zablokować w `filter` bloku. Jeśli wyjątek wewnątrz `filter` bloku, zostanie przechwycona, a wartość 0 (`exception_continue_search`) jest zwracany.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `endfilter` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery formantu z <see langword="fault" /> lub <see langword="finally" /> klauzuli bloku wyjątków do obsługi wyjątków infrastruktury języka wspólnego (CLI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DC|Endfinally<br /><br /> endfault|Kończy się `finally` lub `fault` klauzuli blokiem wyjątku.|  
  
 Nie ma żadnych stos zachowań przejścia dla tej instrukcji.  
  
 `Endfinally` i `endfault` sygnalizuje koniec `finally` lub `fault` klauzuli dzięki odwijanie stosu można kontynuować do momentu obsługi wyjątków jest wywoływany. `endfinally` Lub `endfault` instrukcji przekazuje sterowanie do mechanizm wyjątków interfejsu wiersza polecenia. Mechanizm, a następnie wyszukuje następne `finally` klauzuli w łańcuchu w przypadku bloku chronionym zostało zakończone przez instrukcję pozostaw. Jeśli bloku chronionym został zakończony z powodu wyjątku, interfejsu wiersza polecenia umożliwia wyszukiwanie następnego `finally` lub `fault`, lub wprowadź obsługi wyjątków podczas pierwszego przejścia programu obsługi wyjątków.  
  
 `endfinally` Instrukcji może występować tylko lexically poziomu `finally` bloku. W odróżnieniu od `endfilter` instrukcji, nie jest wymagane czy bloku kończą się `endfinally` instrukcji i mogą mieć dowolną liczbę `endfinally` instrukcje w bloku zgodnie z potrzebami. Tych samym ograniczeniom `endfault` instrukcji i `fault` bloku.  
  
 Kontrolki nie mogą zostać przeniesione do `finally` (lub `fault`) zablokować z wyjątkiem przez mechanizm wyjątków. Kontrolki nie mogą zostać przeniesione z `finally` (lub `fault`) zablokować z wyjątkiem za pośrednictwem `throw` instrukcji lub wykonywania `endfinally` (lub `endfault`) instrukcji. W szczególności należy "nie mogą zostać objęte" z `finally` (lub `fault`) bloku lub wykonać <xref:System.Reflection.Emit.OpCodes.Ret> lub <xref:System.Reflection.Emit.OpCodes.Leave> instrukcji w `finally` (lub `fault`) bloku.  
  
 Należy pamiętać, że `endfault` i `endfinally` instrukcje są aliasami — odnoszą się do tego samego kodu operacji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `endfinally` (`endfault`) opcode, jak również `ILGenerator` metody <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inicjuje określony blok pamięci pod określonym adresem na dany rozmiar i wartość początkową.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 18|initblk|Ustaw każdej lokalizacji w bloku pamięci do podanej wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres początkowy spoczywa na stosie.  
  
2.  Wartość inicjowania spoczywa na stosie.  
  
3.  Liczba bajtów do zainicjowania spoczywa na stosie.  
  
4.  Liczba bajtów, wartość inicjowania i adres początkowy są zdjęte ze stosu ze stosu, a inicjowanie odbywa się zgodnie z ich wartości.  
  
 `initblk` Instrukcji Ustawia numer (`unsigned int32`) bajtów, zaczynając od określonego adresu (typu `native int`, `&`, lub `*`) na wartość inicjowania (typu `unsigned int8`). `initblk` przyjęto założenie, że adres początkowy jest wyrównany do fizycznych rozmiaru maszyny.  
  
 Działanie `initblk` instrukcje może się zmienić w poprzedzającego <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> może zostać zgłoszony, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `initblk` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inicjuje każdego pola typu wartości na określony adres do odwołanie o wartości null lub 0 odpowiedniego typu pierwotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 15 < `T` >|`initobj``typeTok`|Inicjuje typu wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres typu wartości zainicjować spoczywa na stosie.  
  
2.  Ten adres jest zdjęte ze stosu ze stosu; Typ wartości na określony adres został zainicjowany jako typ `typeTok`.  
  
 `initobj` Instrukcji inicjuje każdego pola typu wartości, określony przez adres wciśnięcia (typu `native int`, `&`, lub `*`) odwołanie o wartości null lub 0 odpowiedniego typu pierwotnego. Po ta metoda jest wywoływana, wystąpienie jest gotowy do metodę można wywołać konstruktora. Jeśli `typeTok` jest typem referencyjnym tej instrukcji ma ten sam efekt co `ldnull` następuje `stind.ref`.  
  
 W odróżnieniu od <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` nie wywołuje metody konstruktora. `Initobj` jest przeznaczony do inicjowania typy wartości, podczas gdy `newobj` służy do przydzielenia i Inicjowanie obiektów.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `initobj` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sprawdza, czy odwołanie do obiektu (typ <see langword="O" />) jest wystąpieniem konkretnej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|Sprawdza, czy odwołanie do obiektu jest wystąpieniem `class`, zwracając odwołanie o wartości null lub wystąpienia tej klasy lub interfejsu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu spoczywa na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte ze stosu ze stosu i przetestowane w celu ustalenia, czy jest wystąpienie klasy przekazano `class`.  
  
3.  Wynik (odwołanie do obiektu lub odwołanie o wartości null) spoczywa na stosie.  
  
 `Class` token metadanych wskazuje odpowiednią klasę. Jeśli implementuje klasy obiektu wierzchołku stosu `class` (Jeśli `class` jest interfejsem) lub klasy pochodnej z `class` (Jeśli `class` jest klasą regularne), a następnie jest rzutowane na typ `class` i wynik spoczywa na stosie, dokładnie tak, jakby <xref:System.Reflection.Emit.OpCodes.Castclass> miał została wywołana. W przeciwnym razie odwołanie o wartości null spoczywa na stosie. Jeśli się odwołanie do obiektu jest odwołanie o wartości null, następnie `isinst` podobnie zwraca odwołanie o wartości null.  
  
 <xref:System.TypeLoadException> jest generowany, jeśli nie można odnaleźć klasy. To jest zwykle wykrycie instrukcje Microsoft języka pośredniego (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `isinst` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamyka bieżącej metody i przejdzie do określonej metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|27 < `T` >|skok `method`|Zakończ bieżącą metodę i przeskoczyć do określonej metody.|  
  
 Nie ma żadnych stos zachowań przejścia dla tej instrukcji.  
  
 `jmp` (Przeskoku) instrukcji przekaże kontrolę z metodą określoną przez `method`, która jest token metadanych odwołania do metody. Bieżące argumenty są przekazywane do metody docelowej.  
  
 Stos oceny musi być pusty, podczas wykonywania tej instrukcji. Wywołania Konwencji, liczba i typ argumentów pod adresem docelowym musi być zgodna z bieżącą metodę.  
  
 `jmp` Nie może być używana przesyłane kontroli z `try`, `filter`, `catch`, lub `finally` bloku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `jmp` opcode:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argumentu (odwołuje się określona wartość indeksu) na stosie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg `index`|Ładowanie argument `index` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość argumentu na `index` spoczywa na stosie.  
  
 `ldarg` Instrukcji wypchnięcia argument w `index`, gdzie argumentami są indeksowane z, 0 na stosie oceny. `ldarg` Instrukcji można załadować typu wartości lub wartością pierwotną na stosie, kopiując je z argumentem przychodzących. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez bieżącą metodę podpisu.  
  
 Dla procedury uwzględniające listy argumentów o zmiennej długości `ldarg` instrukcji mogą służyć tylko do początkowego stałej argumentów, nie wartości w zmiennej części podpisu (zobacz <xref:System.Reflection.Emit.OpCodes.Arglist> instrukcji, aby uzyskać więcej informacji).  
  
 Argumenty, które zawiera wartość całkowitą mniejszą niż 4 bajty zostaną rozwinięte na typ `int32` , gdy są załadowane na stosie. Wartości zmiennoprzecinkowych zostaną rozwinięte ich rozmiar natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldarg` opcode:  
  
-   ILGenerator.Emit (OpCode, krótki)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument pod indeksem 0 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|02|ldarg.0|Ładowanie argument 0 na stosie|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość argumentu pod indeksem 0 spoczywa na stosie.  
  
 `ldarg.0` Instrukcja to efektywne kodowanie ładowania wartość argumentu pod indeksem 0.  
  
 `ldarg.0` Instrukcji wypchnięcia argument w 0 na stosie oceny. `ldarg.0` Instrukcji można załadować typu wartości lub wartością pierwotną na stosie, kopiując je z argumentem przychodzących. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez bieżącą metodę podpisu.  
  
 Argumenty, które zawiera wartość całkowitą mniejszą niż 4 bajty zostaną rozwinięte na typ `int32` , gdy są załadowane na stosie. Wartości zmiennoprzecinkowych zostaną rozwinięte ich rozmiar natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldarg.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument pod indeksem 1 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|03|ldarg.1|Załaduj argumentu 1 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość argumentu pod indeksem 1 spoczywa na stosie.  
  
 `ldarg.1` Instrukcja to efektywne kodowanie ładowania wartość argumentu pod indeksem 1.  
  
 `ldarg.1` Instrukcji wypchnięcia argument w 1 na stosie oceny. `ldarg.1` Instrukcji można załadować typu wartości lub wartością pierwotną na stosie, kopiując je z argumentem przychodzących. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez bieżącą metodę podpisu.  
  
 Argumenty, które zawiera wartość całkowitą mniejszą niż 4 bajty zostaną rozwinięte na typ `int32` , gdy są załadowane na stosie. Wartości zmiennoprzecinkowych zostaną rozwinięte ich rozmiar natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldarg.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument pod indeksem 2 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|04|ldarg.2|Załaduj argumentu 2 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość argumentu pod indeksem 2 spoczywa na stosie.  
  
 `ldarg.2` Instrukcja to efektywne kodowanie ładowania wartość argumentu pod indeksem 2.  
  
 `ldarg.2` Instrukcji wypchnięcia argument w 2 na stosie oceny. `ldarg.2` Instrukcji można załadować typu wartości lub wartością pierwotną na stosie, kopiując je z argumentem przychodzących. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez bieżącą metodę podpisu.  
  
 Argumenty, które zawiera wartość całkowitą mniejszą niż 4 bajty zostaną rozwinięte na typ `int32` , gdy są załadowane na stosie. Wartości zmiennoprzecinkowych zostaną rozwinięte ich rozmiar natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldarg.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument w indeksie 3 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|05|ldarg.3|Załaduj argumentu 3 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość argumentu w indeksie 3 spoczywa na stosie.  
  
 `ldarg.3` Instrukcja to efektywne kodowanie ładowania wartość argumentu w indeksie 3.  
  
 `ldarg.3` Instrukcji wypchnięcia argument w 3 na stosie oceny. `ldarg.3` Instrukcji można załadować typu wartości lub wartością pierwotną na stosie, kopiując je z argumentem przychodzących. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez bieżącą metodę podpisu.  
  
 Argumenty, które zawiera wartość całkowitą mniejszą niż 4 bajty zostaną rozwinięte na typ `int32` , gdy są załadowane na stosie. Wartości zmiennoprzecinkowych zostaną rozwinięte ich rozmiar natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldarg.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argumentu (odwołuje się indeks określonej wydłużone) na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg.s `index`|Ładowanie argument `index` na stosie, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość argumentu na `index` spoczywa na stosie.  
  
 `ldarg.s` Instrukcja to efektywne kodowanie ładowania argumenty indeksowane od 4 do 255.  
  
 `ldarg.s` Instrukcji wypchnięcia argument w `index`, gdzie argumentami są indeksowane z, 0 na stosie oceny. `ldarg.s` Instrukcji można załadować typu wartości lub wartością pierwotną na stosie, kopiując je z argumentem przychodzących. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez bieżącą metodę podpisu.  
  
 Dla procedury uwzględniające listy argumentów o zmiennej długości `ldarg.s` instrukcji mogą służyć tylko do początkowego stałej argumentów, nie wartości w zmiennej części podpisu (zobacz <xref:System.Reflection.Emit.OpCodes.Arglist> instrukcji, aby uzyskać więcej informacji).  
  
 Argumenty, które zawiera wartość całkowitą mniejszą niż 4 bajty zostaną rozwinięte na typ `int32` , gdy są załadowane na stosie. Wartości zmiennoprzecinkowych zostaną rozwinięte ich rozmiar natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldarg.s` opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładowanie adresu argumentu na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga `index`|Pobierz adres argument indeksowane według `index`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres `addr` argumentu indeksowane według `index` spoczywa na stosie.  
  
 `ldarga` Instrukcji pobiera adres (typu `*`) argumentu indeksowane według `index`, gdzie argumentami są indeksowane z zakresu od 0 i jego nowszych wersjach. Adres `addr` zawsze jest wyrównany na granicy fizycznych na komputerze docelowym.  
  
 Dla procedury uwzględniające listy argumentów o zmiennej długości `ldarga` instrukcji mogą służyć tylko do początkowego stałej argumentów, nie wartości w zmiennej części podpisu.  
  
 `ldarga` Służy do przekazywanie parametru-ref. W innych przypadkach <xref:System.Reflection.Emit.OpCodes.Ldarg> i <xref:System.Reflection.Emit.OpCodes.Starg> powinny być używane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldarga` opcode:  
  
-   ILGenerator.Emit (OpCode, krótki)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładowanie adresu argumentu, w krótkich fragmentów na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga.s `index`|Pobierz adres argument indeksowane według `index`, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres `addr` argumentu indeksowane według `index` spoczywa na stosie.  
  
 `ldarga.s` (forma krótka z `ldarga`) ma być używane jako argument cyfry od 0 do 255 i jest bardziej efektywne kodowanie.  
  
 `ldarga.s` Instrukcji pobiera adres (typu`*`) argumentu indeksowane według `index`, gdzie argumentami są indeksowane z zakresu od 0 i jego nowszych wersjach. Adres `addr` zawsze jest wyrównany na granicy fizycznych na komputerze docelowym.  
  
 Dla procedury uwzględniające listy argumentów o zmiennej długości `ldarga.s` instrukcji mogą służyć tylko do początkowego stałej argumentów, nie wartości w zmiennej części podpisu.  
  
 `ldarga.s` Służy do przekazywanie parametru-ref. W innych przypadkach <xref:System.Reflection.Emit.OpCodes.Ldarg_S> i <xref:System.Reflection.Emit.OpCodes.Starg_S> powinny być używane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldarga.s` opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Podana wartość typu wypchnięcia <see langword="int32" /> na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc.I4 `num`|Wypychanie wartości `num` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość `num` spoczywa na stosie.  
  
 Należy pamiętać, że specjalne kodowania krótkich (i dlatego jest bardziej wydajne) liczb całkowitych -128 do 127 i szczególnie krótkich kodowań na potrzeby -1 do 8. Wszystkie rodzaje kodowania krótki push 4-bajtowych liczb całkowitych na stosie. Dłużej kodowania są używane do 8-bajtowych liczb całkowitych i 4 lub 8 bajtów liczb zmiennoprzecinkowych, a także 4-bajtowych wartości, które nie mieszczą się w krótkim formularzy. Istnieją trzy sposoby przekazywania stałej całkowitej 8 bajtów na stosie  
  
 1. Użyj <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instrukcję stałe, które muszą być wyrażone w więcej niż 32-bitowy.  
  
 2. Użyj <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instrukcji następuje <xref:System.Reflection.Emit.OpCodes.Conv_I8> na stałe, które wymagają 9 do 32-bitowy.  
  
 3. Użyj instrukcji Krótka forma, a następnie <xref:System.Reflection.Emit.OpCodes.Conv_I8> na stałe, które mogą być wyrażone w mniej lub 8 bitów.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.i4` opcode:  
  
-   ILGenerator.Emit(OpCode, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcia wartość całkowita 0 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|Wypycha 0 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 0 spoczywa na stosie.  
  
 Jest to specjalne krótkich kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne kodowania krótkich push 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.i4.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypychanie 1 na stosie oceny jako wartość całkowita <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|Wypychanie 1 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 1 spoczywa na stosie.  
  
 Jest to specjalne krótkich kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne kodowania krótkich push 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.i4.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcia wartość całkowita 2 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|Wypycha 2 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 2 spoczywa na stosie.  
  
 Jest to specjalne krótkich kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne kodowania krótkich push 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.i4.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcia wartość całkowita 3 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|Wypycha 3 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 3 spoczywa na stosie.  
  
 Jest to specjalne krótkich kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne kodowania krótkich push 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.i4.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcia wartość całkowita 4 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|Wypycha 4 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 4 spoczywa na stosie.  
  
 Jest to specjalne krótkich kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne kodowania krótkich push 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.i4.4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcia wartość całkowita z 5 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|Wypycha 5 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 5 spoczywa na stosie.  
  
 Jest to specjalne krótkich kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne kodowania krótkich push 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.i4.5` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcia wartość całkowita 6 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1C|ldc.I4.6|Wypycha 6 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 6 spoczywa na stosie.  
  
 Jest to specjalne krótkich kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne kodowania krótkich push 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.i4.6` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcia wartość całkowita 7 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1D|ldc.I4.7|Wypycha 7 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 7 spoczywa na stosie.  
  
 Jest to specjalne krótkich kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne kodowania krótkich push 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.i4.7` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcia wartość całkowita 8 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1E|ldc.I4.8|Wypycha 8 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 8 spoczywa na stosie.  
  
 Jest to specjalne krótkich kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne kodowania krótkich push 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.i4.8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wartość całkowita-1 na stosie oceny jako wypchnięcia <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|Wypycha -1 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość -1 spoczywa na stosie.  
  
 Jest to specjalne krótkich kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne kodowania krótkich push 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.i4.m1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcia podane <see langword="int8" /> wartości na stosie oceny jako <see langword="int32" />, krótka.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1F < `int8` >|ldc.I4.s `num`|Wypchnięcia `num` na stosie jako `int32`, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość `num` spoczywa na stosie.  
  
 `ldc.i4.s` jest bardziej efektywne kodowanie do wypychania liczby całkowite od -128 do 127 na stosie oceny.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.i4.s` opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Podana wartość typu wypchnięcia <see langword="int64" /> na stosie oceny jako <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.I8 `num`|Wypchnięcia `num` na stosie jako `int64`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość `num` spoczywa na stosie.  
  
 Ten typ kodowania wypchnięcia `int64` wartości na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.i8` opcode:  
  
-   ILGenerator.Emit (OpCode, długie)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Podana wartość typu wypchnięcia <see langword="float32" /> na stosie oceny jako typ <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.r4 `num`|Wypchnięcia `num` na stosie jako `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość `num` spoczywa na stosie.  
  
 Ten typ kodowania wypchnięcia `float32` wartości na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.r4` opcode:  
  
-   ILGenerator.Emit (OpCode, pojedynczego)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Podana wartość typu wypchnięcia <see langword="float64" /> na stosie oceny jako typ <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.r8 `num`|Wypchnięcia `num` na stosie jako `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość `num` spoczywa na stosie.  
  
 Ten typ kodowania wypchnięcia `float64` wartości na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldc.r8` opcode:  
  
-   ILGenerator.Emit (OpCode, double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element pod indeksem określonej tablicy na wierzchu stosu oceny jako typ określony w instrukcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu język pośredni (MSIL) firmy Microsoft, wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem `typeTok`|Ładuje elementu `index` na wierzchu stosu jako typ `typeTok`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` spoczywa na stosie.  
  
2.  Wartość indeksu `index` spoczywa na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywana w pozycji `index` w `array` będą wyszukiwane.  
  
4.  Wartość spoczywa na stosie.  
  
 `ldelem` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w liczony od zera jednowymiarową `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Typ wartości zwracanej jest określany przez token `typeTok` w instrukcji.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` jest ujemna ani większa niż górna granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldelem` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typu <see langword="native int" /> od indeksu określonej tablicy na wierzchu stosu oceny jako <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|97|ldelem.i|Ładuje elementu z typu `native int` w `index` na wierzchu stosu jako `native int`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` spoczywa na stosie.  
  
2.  Wartość indeksu `index` spoczywa na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywana w pozycji `index` w `array` będą wyszukiwane.  
  
4.  Wartość spoczywa na stosie.  
  
 `ldelem.i` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w liczony od zera jednowymiarową `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana `ldelem.i` jest `native int`.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldelem.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typu <see langword="int8" /> od indeksu określonej tablicy na wierzchu stosu oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|Ładuje elementu z typu `int8` w `index` na wierzchu stosu jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` spoczywa na stosie.  
  
2.  Wartość indeksu `index` spoczywa na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywana w pozycji `index` w `array` będą wyszukiwane.  
  
4.  Wartość spoczywa na stosie.  
  
 `ldelem.i1` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w liczony od zera jednowymiarową `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana `ldelem.i1` jest `int8`.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldelem.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typu <see langword="int16" /> od indeksu określonej tablicy na wierzchu stosu oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|Ładuje elementu z typu `int16` w `index` na wierzchu stosu jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` spoczywa na stosie.  
  
2.  Wartość indeksu `index` spoczywa na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywana w pozycji `index` w `array` będą wyszukiwane.  
  
4.  Wartość spoczywa na stosie.  
  
 `ldelem.i2` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w liczony od zera jednowymiarową `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana `ldelem.i2` jest `int16`.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldelem.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typu <see langword="int32" /> od indeksu określonej tablicy na wierzchu stosu oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|Ładuje elementu z typu `int32` w `index` na wierzchu stosu jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` spoczywa na stosie.  
  
2.  Wartość indeksu `index` spoczywa na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywana w pozycji `index` w `array` będą wyszukiwane.  
  
4.  Wartość spoczywa na stosie.  
  
 `ldelem.i4` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w liczony od zera jednowymiarową `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana `ldelem.i4` jest `int32`.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldelem.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typu <see langword="int64" /> od indeksu określonej tablicy na wierzchu stosu oceny jako <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|Ładuje elementu z typu `int64` w `index` na wierzchu stosu jako `int64`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` spoczywa na stosie.  
  
2.  Wartość indeksu `index` spoczywa na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywana w pozycji `index` w `array` będą wyszukiwane.  
  
4.  Wartość spoczywa na stosie.  
  
 `ldelem.i8` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w liczony od zera jednowymiarową `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana `ldelem.i8` jest `int64`.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldelem.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typu <see langword="float32" /> od indeksu określonej tablicy na wierzchu stosu oceny jako typ <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|Ładuje elementu z typu `float32` w `index` na wierzchu stosu jako typ `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` spoczywa na stosie.  
  
2.  Wartość indeksu `index` spoczywa na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywana w pozycji `index` w `array` będą wyszukiwane.  
  
4.  Wartość spoczywa na stosie.  
  
 `ldelem.r4` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w liczony od zera jednowymiarową `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana `ldelem.r4` jest `float32`.  
  
 Wartości zmiennoprzecinkowe są konwertowane na typ `F` po załadowaniu na stosie oceny.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldelem.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typu <see langword="float64" /> od indeksu określonej tablicy na wierzchu stosu oceny jako typ <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|Ładuje elementu z typu `float64` w `index` na wierzchu stosu jako typ `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` spoczywa na stosie.  
  
2.  Wartość indeksu `index` spoczywa na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywana w pozycji `index` w `array` będą wyszukiwane.  
  
4.  Wartość spoczywa na stosie.  
  
 `ldelem.r8` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w liczony od zera jednowymiarową `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana `ldelem.r8` jest `float64`.  
  
 Wartości zmiennoprzecinkowe są konwertowane na typ `F` po załadowaniu na stosie oceny.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldelem.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element zawierający odwołanie do obiektu na indeks określonej tablicy na wierzchu stosu oceny jako typ <see langword="O" /> (odwołanie do obiektu).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|Ładuje elementu z odwołania do obiektu w `index` na wierzchu stosu jako typ `O`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` spoczywa na stosie.  
  
2.  Wartość indeksu `index` spoczywa na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywana w pozycji `index` w `array` będą wyszukiwane.  
  
4.  Wartość spoczywa na stosie.  
  
 `ldelem.ref` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w liczony od zera jednowymiarową `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana `ldelem.ref` jest typem `O` (odwołanie do obiektu).  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldelem.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typu <see langword="unsigned int8" /> od indeksu określonej tablicy na wierzchu stosu oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|Ładuje elementu z typu `unsigned int8` w `index` na wierzchu stosu jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` spoczywa na stosie.  
  
2.  Wartość indeksu `index` spoczywa na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywana w pozycji `index` w `array` będą wyszukiwane.  
  
4.  Wartość spoczywa na stosie.  
  
 `ldelem.u1` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w liczony od zera jednowymiarową `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana `ldelem.u1` jest `int8`.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldelem.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typu <see langword="unsigned int16" /> od indeksu określonej tablicy na wierzchu stosu oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|Ładuje elementu z typu `unsigned int16` w indeksie na wierzchu stosu jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` spoczywa na stosie.  
  
2.  Wartość indeksu `index` spoczywa na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywana w pozycji `index` w `array` będą wyszukiwane.  
  
4.  Wartość spoczywa na stosie.  
  
 `ldelem.u2` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w liczony od zera jednowymiarową `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana `ldelem.u2` jest `int16`.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldelem.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typu <see langword="unsigned int32" /> od indeksu określonej tablicy na wierzchu stosu oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|Ładuje elementu z typu `unsigned int32` w indeksie na wierzchu stosu jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` spoczywa na stosie.  
  
2.  Wartość indeksu `index` spoczywa na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywana w pozycji `index` w `array` będą wyszukiwane.  
  
4.  Wartość spoczywa na stosie.  
  
 `ldelem.u4` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w liczony od zera jednowymiarową `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana `ldelem.u4` jest `int32`.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli tablica nie ma elementów typu wymagane.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldelem.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje adresu elementu tablicy, od indeksu określonej tablicy na wierzchu stosu oceny jako typ <see langword="&amp;" /> (wskaźnik zarządzane).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema `class`|Ładuje adresu elementu tablicy w `index` na wierzchu stosu oceny jako typ `&` (wskaźnik zarządzane).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` spoczywa na stosie.  
  
2.  Wartość indeksu `index` spoczywa na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; adres przechowywane na pozycji `index` w `array` będą wyszukiwane.  
  
4.  Adres spoczywa na stosie.  
  
 `ldelema` Służy do pobierania adresu obiektu od określonego indeksu tablicy obiektów (typu `class`). `ldelema` Instrukcji ładuje adres wartości w indeksie `index` (typ `native int`) w liczony od zera jednowymiarową `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Wartość musi być typu `class` przekazaną za pomocą instrukcji.  
  
 Wartość zwracana `ldelema` zarządzanych wskaźnika (typ `&`).  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldelema` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wyszukuje wartość pola w obiekcie, w której odwołanie jest obecnie na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|Wypychanie wartości pola w określony obiekt na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu (lub wskaźnika) spoczywa na stosie.  
  
2.  Odwołanie do obiektu (lub wskaźnika) ze stosu; zdjęte ze stosu jest Znaleziono wartość określonego pola w obiekcie.  
  
3.  Wartość przechowywana w polu spoczywa na stosie.  
  
 `ldfld` Instrukcji wypychanie wartości pola znajdującego się w obiekcie na stosie. Obiekt musi być na stosie jako odwołanie do obiektu (typ `O`), wskaźnika zarządzanych (typu `&`), niezarządzanego wskaźnika (typu `native int`), przejściowa wskaźnika (typu `*`), lub wystąpienia typu wartości. Korzystanie z niezarządzanego wskaźnika nie jest dozwolone w weryfikowalny kod. Pole obiektu jest określone przez token metadanych, który musi odwoływać się do elementu członkowskiego pola. Zwracany typ jest taka sama jak skojarzony z polem. Pole może być polem wystąpienia (w takim przypadku obiekt nie może być odwołaniem o wartości zerowej) lub pola statycznego.  
  
 `ldfld` Instrukcji może być poprzedzone jednego lub obu <xref:System.Reflection.Emit.OpCodes.Unaligned> i <xref:System.Reflection.Emit.OpCodes.Volatile> prefiksy.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli obiekt ma wartość null i nie jest statyczne.  
  
 <xref:System.MissingFieldException> jest generowany, jeśli określone pole nie zostanie znaleziony w metadanych. Jest to zazwyczaj sprawdzana podczas konwertowania instrukcje Microsoft języka pośredniego (MSIL) do kodu macierzystego, nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldfld` opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wyszukuje adresu pola w obiekcie, w której odwołanie jest obecnie na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|Wypchnięcia adres `field` w określony obiekt na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu (lub wskaźnika) spoczywa na stosie.  
  
2.  Odwołanie do obiektu (lub wskaźnika) ze stosu; zdjęte ze stosu jest Znaleziono adres określonego pola w obiekcie.  
  
3.  Adres określone pole spoczywa na stosie.  
  
 `ldflda` Instrukcji wypchnięcia adresu pola znajdującego się w obiekcie na stosie. Obiekt musi być na stosie jako odwołanie do obiektu (typ `O`), wskaźnika zarządzanych (typu `&`), niezarządzanego wskaźnika (typu `native int`), przejściowa wskaźnika (typu `*`), lub wystąpienia typu wartości. Korzystanie z niezarządzanego wskaźnika nie jest dozwolone w weryfikowalny kod. Pole obiektu jest określone przez token metadanych, który musi odwoływać się do elementu członkowskiego pola.  
  
 Wartość zwrócona przez `ldflda` zarządzanych wskaźnika (typ `&`), chyba że obiekt spoczywa na stosie jako niezarządzanego wskaźnika, w którym to przypadku środki adres zwrotny jest również niezarządzanego wskaźnika (typ `native int`).  
  
 `ldflda` Instrukcji może być poprzedzone jednego lub obu <xref:System.Reflection.Emit.OpCodes.Unaligned> i <xref:System.Reflection.Emit.OpCodes.Volatile> prefiksy.  
  
 <xref:System.InvalidOperationException> jest generowany, jeśli obiekt nie jest w domenie aplikacji, z którego jest uzyskiwany. Nie można załadować adresu pola, który nie znajduje się w domenie podczas uzyskiwania dostępu do aplikacji.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli obiekt ma wartość null i nie jest statyczne.  
  
 <xref:System.MissingFieldException> jest generowany, jeśli określone pole nie zostanie znaleziony w metadanych. Jest to zazwyczaj sprawdzana podczas konwertowania instrukcje Microsoft języka pośredniego (MSIL) do kodu macierzystego, nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldflda` opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcia niezarządzanego wskaźnika (typ <see langword="native int" />) do kodu natywnego wykonania określonej metody na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|Elementy ldftn `method`|Wypychanie wskaźnik do metody odwołuje się `method` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Niezarządzany wskaźnik do określonej metody spoczywa na stosie.  
  
 Określona metoda (`method`) można wywoływać za pomocą <xref:System.Reflection.Emit.OpCodes.Calli> instrukcji, jeśli odwołuje się ona zarządzanych — metoda (lub skrótowa, która przejścia z kodu zarządzanego do kodu niezarządzanego).  
  
 Wartość zwracana punktów do kodu natywnego za pomocą konwencji wywoływania środowiska CLR. Wskaźnik tej metody nie powinny być przekazywane do niezarządzanego kodu macierzystego jako procedura wywołania zwrotnego.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldftn` opcode:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="native int" /> jako <see langword="native int" /> na obliczanie pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4D|ldind.i|Ładunki `native int` wartość pod adresem `addr` na stosie jako `native int`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Ten adres jest zdjęte ze stosu ze stosu; wartość znajduje się pod adresem jest pobierane.  
  
3.  Wartość pobranych spoczywa na stosie.  
  
 `ldind.i` Instrukcji pośrednio ładuje `native int` wartości z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `native int`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji określający odpowiadającą klasę wartości wbudowanych.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Nieprawidłowo sformułowany Microsoft pośredniego Language (MSIL) zapewnia, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres przypisany początkowo na stosie muszą być wyrównane do fizycznych rozmiar obiektów na maszynie lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) bezpiecznie są wyrównane. Dla typów danych jest większa niż 1 bajt kolejność bajtów jest zależna od docelowego procesora CPU. Kod, który jest zależny od określanie kolejności bajtów nie może działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldind.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="int8" /> jako <see langword="int32" /> na obliczanie pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|46|ldind.I1|Ładunki `int8` wartość pod adresem `addr` na stosie jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Ten adres jest zdjęte ze stosu ze stosu; wartość znajduje się pod adresem jest pobierane.  
  
3.  Wartość pobranych spoczywa na stosie.  
  
 `ldind.i1` Instrukcji pośrednio ładuje `int8` wartości z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `int32`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji określający odpowiadającą klasę wartości wbudowanych.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Nieprawidłowo sformułowany Microsoft pośredniego Language (MSIL) zapewnia, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres przypisany początkowo na stosie muszą być wyrównane do fizycznych rozmiar obiektów na maszynie lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) bezpiecznie są wyrównane. Dla typów danych jest większa niż 1 bajt kolejność bajtów jest zależna od docelowego procesora CPU. Kod, który jest zależny od określanie kolejności bajtów nie może działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldind.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="int16" /> jako <see langword="int32" /> na obliczanie pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|48|ldind.I2|Ładunki `int16` wartość pod adresem `addr` na stosie jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Ten adres jest zdjęte ze stosu ze stosu; wartość znajduje się pod adresem jest pobierane.  
  
3.  Wartość pobranych spoczywa na stosie.  
  
 `ldind.i2` Instrukcji pośrednio ładuje `int16` wartości z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `int32`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji określający odpowiadającą klasę wartości wbudowanych.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Nieprawidłowo sformułowany Microsoft pośredniego Language (MSIL) zapewnia, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres przypisany początkowo na stosie muszą być wyrównane do fizycznych rozmiar obiektów na maszynie lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) bezpiecznie są wyrównane. Dla typów danych jest większa niż 1 bajt kolejność bajtów jest zależna od docelowego procesora CPU. Kod, który jest zależny od określanie kolejności bajtów nie może działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldind.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="int32" /> jako <see langword="int32" /> na obliczanie pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4A|ldind.I4|Ładunki `int32` wartość pod adresem `addr` na stosie jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Ten adres jest zdjęte ze stosu ze stosu; wartość znajduje się pod adresem jest pobierane.  
  
3.  Wartość pobranych spoczywa na stosie.  
  
 `ldind.i4` Instrukcji pośrednio ładuje `int32` wartości z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `int32`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji określający odpowiadającą klasę wartości wbudowanych.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Nieprawidłowo sformułowany Microsoft pośredniego Language (MSIL) zapewnia, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres przypisany początkowo na stosie muszą być wyrównane do fizycznych rozmiar obiektów na maszynie lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) bezpiecznie są wyrównane. Dla typów danych jest większa niż 1 bajt kolejność bajtów jest zależna od docelowego procesora CPU. Kod, który jest zależny od określanie kolejności bajtów nie może działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldind.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="int64" /> jako <see langword="int64" /> na obliczanie pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4C|ldind.i8|Ładunki `int64` wartość pod adresem `addr` na stosie jako `int64`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Ten adres jest zdjęte ze stosu ze stosu; wartość znajduje się pod adresem jest pobierane.  
  
3.  Wartość pobranych spoczywa na stosie.  
  
 `ldind.i8` Instrukcji pośrednio ładuje `int64` wartości z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `int64`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji określający odpowiadającą klasę wartości wbudowanych.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Nieprawidłowo sformułowany Microsoft pośredniego Language (MSIL) zapewnia, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres przypisany początkowo na stosie muszą być wyrównane do fizycznych rozmiar obiektów na maszynie lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) bezpiecznie są wyrównane. Dla typów danych jest większa niż 1 bajt kolejność bajtów jest zależna od docelowego procesora CPU. Kod, który jest zależny od określanie kolejności bajtów nie może działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldind.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="float32" /> jako typ <see langword="F" /> (float) na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4E|ldind.r4|Ładunki `float32` wartość pod adresem `addr` na stosie jako typ `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Ten adres jest zdjęte ze stosu ze stosu; wartość znajduje się pod adresem jest pobierane.  
  
3.  Wartość pobranych spoczywa na stosie.  
  
 `ldind.r4` Instrukcji pośrednio ładuje `float32` wartości z określonego adresu (typu `native int`, `&`, lub *) na stosie jako typ `F`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji określający odpowiadającą klasę wartości wbudowanych.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Nieprawidłowo sformułowany Microsoft pośredniego Language (MSIL) zapewnia, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres przypisany początkowo na stosie muszą być wyrównane do fizycznych rozmiar obiektów na maszynie lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) bezpiecznie są wyrównane. Dla typów danych jest większa niż 1 bajt kolejność bajtów jest zależna od docelowego procesora CPU. Kod, który jest zależny od określanie kolejności bajtów nie może działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldind.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="float64" /> jako typ <see langword="F" /> (float) na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4F|ldind.r8|Ładunki `float64` wartość pod adresem `addr` na stosie jako typ `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Ten adres jest zdjęte ze stosu ze stosu; wartość znajduje się pod adresem jest pobierane.  
  
3.  Wartość pobranych spoczywa na stosie.  
  
 `ldind.r8` Instrukcji pośrednio ładuje `float64` wartości z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `float64`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji określający odpowiadającą klasę wartości wbudowanych.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Nieprawidłowo sformułowany Microsoft pośredniego Language (MSIL) zapewnia, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres przypisany początkowo na stosie muszą być wyrównane do fizycznych rozmiar obiektów na maszynie lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) bezpiecznie są wyrównane. Dla typów danych jest większa niż 1 bajt kolejność bajtów jest zależna od docelowego procesora CPU. Kod, który jest zależny od określanie kolejności bajtów nie może działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldind.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje odwołanie do obiektu o typie <see langword="O" /> (obiektu odwołania) do oceny pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|50|ldind.ref|Ładuje odwołanie do obiektu pod adresem `addr` na stosie jako typu `O`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Ten adres jest zdjęte ze stosu ze stosu; Odwołanie do obiektu znajdujący się pod adresem jest pobierane.  
  
3.  Odwołanie pobranych spoczywa na stosie.  
  
 `ldind.ref` Instrukcji ładuje pośrednie odwołanie do obiektu określony adres (typu `native int`, `&`, lub *) na stosie jako typ `O`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji określający odpowiadającą klasę wartości wbudowanych.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Nieprawidłowo sformułowany Microsoft pośredniego Language (MSIL) zapewnia, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres przypisany początkowo na stosie muszą być wyrównane do fizycznych rozmiar obiektów na maszynie lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) bezpiecznie są wyrównane. Dla typów danych jest większa niż 1 bajt kolejność bajtów jest zależna od docelowego procesora CPU. Kod, który jest zależny od określanie kolejności bajtów nie może działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldind.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="unsigned int8" /> jako <see langword="int32" /> na obliczanie pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|47|ldind.U1|Ładunki `unsigned int8` wartość pod adresem `addr` na stosie jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Ten adres jest zdjęte ze stosu ze stosu; wartość znajduje się pod adresem jest pobierane.  
  
3.  Wartość pobranych spoczywa na stosie.  
  
 `ldind.u1` Instrukcji pośrednio ładuje `unsigned int8` wartości z określonego adresu (typu`native int`, `&`, lub *) na stosie jako `int32`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji określający odpowiadającą klasę wartości wbudowanych.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Nieprawidłowo sformułowany Microsoft pośredniego Language (MSIL) zapewnia, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres przypisany początkowo na stosie muszą być wyrównane do fizycznych rozmiar obiektów na maszynie lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) bezpiecznie są wyrównane. Dla typów danych jest większa niż 1 bajt kolejność bajtów jest zależna od docelowego procesora CPU. Kod, który jest zależny od określanie kolejności bajtów nie może działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldind.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="unsigned int16" /> jako <see langword="int32" /> na obliczanie pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|49|ldind.U2|Ładunki `unsigned int16` wartość pod adresem `addr` na stosie jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Ten adres jest zdjęte ze stosu ze stosu; wartość znajduje się pod adresem jest pobierane.  
  
3.  Wartość pobranych spoczywa na stosie.  
  
 `ldind.u2` Instrukcji pośrednio ładuje `unsigned int16` wartości z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `int32`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji określający odpowiadającą klasę wartości wbudowanych.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Nieprawidłowo sformułowany Microsoft pośredniego Language (MSIL) zapewnia, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres przypisany początkowo na stosie muszą być wyrównane do fizycznych rozmiar obiektów na maszynie lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) bezpiecznie są wyrównane. Dla typów danych jest większa niż 1 bajt kolejność bajtów jest zależna od docelowego procesora CPU. Kod, który jest zależny od określanie kolejności bajtów nie może działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldind.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="unsigned int32" /> jako <see langword="int32" /> na obliczanie pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4B|ldind.U4|Ładunki `unsigned int32` wartość pod adresem `addr` na stosie jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Ten adres jest zdjęte ze stosu ze stosu; wartość znajduje się pod adresem jest pobierane.  
  
3.  Wartość pobranych spoczywa na stosie.  
  
 `ldind.u4` Instrukcji pośrednio ładuje `unsigned int32` wartości z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `int32`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji określający odpowiadającą klasę wartości wbudowanych.  
  
 Należy pamiętać, że wartości będące liczbami całkowitymi z mniej niż 4 bajty zostały rozszerzone na potrzeby `int32` (nie `native int`), gdy są załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Nieprawidłowo sformułowany Microsoft pośredniego Language (MSIL) zapewnia, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres przypisany początkowo na stosie muszą być wyrównane do fizycznych rozmiar obiektów na maszynie lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) bezpiecznie są wyrównane. Dla typów danych jest większa niż 1 bajt kolejność bajtów jest zależna od docelowego procesora CPU. Kod, który jest zależny od określanie kolejności bajtów nie może działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldind.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha liczba elementów nieujemną jednowymiarową tablicę na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8E|ldlen|Wypchnięcia długość (typu `natural unsigned int`) tablicy na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy spoczywa na stosie.  
  
2.  Odwołanie do tablicy jest zdjęte ze stosu ze stosu, a długość jest kolumną obliczaną.  
  
3.  Długość spoczywa na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Długość jest zwracana jako `natural unsigned int`.  
  
 <xref:System.NullReferenceException> jest generowany, gdy odwołanie do tablicy jest odwołanie o wartości null.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldlen` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmiennej lokalnej o określonym indeksie na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc `index`|Ładuje zmiennej lokalnej o indeksie `index` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości zmiennej lokalnej pod określonym indeksem spoczywa na stosie.  
  
 `ldloc` Instrukcji wypchnięcia zawartość numer zmiennej lokalnej o indeksie przekazany na stosie oceny, gdzie zmienne lokalne są numerowane 0 lub nowszej. Zmienne lokalne są inicjowane na 0, przed wprowadzeniem metody tylko wtedy, gdy flaga zainicjować metody ma wartość true. Brak 65 535 (2 ^ 16 - 1) zmienne lokalne możliwe (0-65 534). 65 535 indeksu jest nieprawidłowy, ponieważ prawdopodobnie implementacje użyje 2-bajtowych liczb całkowitych do śledzenia indeksu zarówno lokalnych, oraz liczba zmiennych lokalnych dostępnych dla danej metody. Indeks 65535 dokonano prawidłowe, wymagałoby szersze liczby całkowitej w celu śledzenia liczby zmiennych lokalnych w takiej metody.  
  
 `ldloc.0`, `ldloc.1`, `ldloc.2`, I `ldloc.3` instrukcje zapewnić efektywne kodowanie do uzyskiwania dostępu do pierwsze cztery zmiennych lokalnych.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej, która została określona w nagłówku metody. Zobacz partycji I. lokalnych zmiennych, które są mniejsze niż 4 bajty zostaną rozwinięte na typ `int32` , gdy są załadowane na stosie. Wartości zmiennoprzecinkowych zostaną rozwinięte ich rozmiar natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `ldloc` opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, krótki)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmiennej lokalnej pod indeksem 0 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|06|ldloc.0|Ładuje zmiennej lokalnej pod indeksem 0 na stosie oceny.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości zmiennej lokalnej pod indeksem 0 spoczywa na stosie.  
  
 `ldloc.0` jest szczególnie efektywne kodowanie <xref:System.Reflection.Emit.OpCodes.Ldloc>, umożliwiając dostęp do zmiennej lokalnej pod indeksem 0.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej, która została określona w nagłówku metody. Zmienne lokalne, które są mniejsze niż 4 bajty zostaną rozwinięte na typ `int32` , gdy są załadowane na stosie. Wartości zmiennoprzecinkowych zostaną rozwinięte ich rozmiar natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldloc.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmiennej lokalnej pod indeksem 1 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|07|ldloc.1|Ładuje zmiennej lokalnej pod indeksem 1 na stosie oceny.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości zmiennej lokalnej pod indeksem 1 spoczywa na stosie.  
  
 `ldloc.1` jest szczególnie efektywne kodowanie <xref:System.Reflection.Emit.OpCodes.Ldloc>, umożliwiający dostęp do zmiennej lokalnej pod indeksem 1.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej, która została określona w nagłówku metody. Zmienne lokalne, które są mniejsze niż 4 bajty zostaną rozwinięte na typ `int32` , gdy są załadowane na stosie. Wartości zmiennoprzecinkowych zostaną rozwinięte ich rozmiar natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldloc.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmiennej lokalnej pod indeksem 2 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|08|ldloc.2|Ładuje zmiennej lokalnej pod indeksem 2 na stosie oceny.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości zmiennej lokalnej pod indeksem 2 spoczywa na stosie.  
  
 `ldloc.2` jest szczególnie efektywne kodowanie <xref:System.Reflection.Emit.OpCodes.Ldloc>, umożliwiający dostęp do zmiennej lokalnej pod indeksem 2.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej, która została określona w nagłówku metody. Zmienne lokalne, które są mniejsze niż 4 bajty zostaną rozwinięte na typ `int32` , gdy są załadowane na stosie. Wartości zmiennoprzecinkowych zostaną rozwinięte ich rozmiar natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldloc.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmiennej lokalnej o indeksie 3 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|09|ldloc.3|Ładuje zmiennej lokalnej o indeksie 3 na stosie oceny.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości zmiennej lokalnej w indeksie 3 spoczywa na stosie.  
  
 `ldloc.3` jest szczególnie efektywne kodowanie <xref:System.Reflection.Emit.OpCodes.Ldloc>, umożliwiający dostęp do zmiennej lokalnej o indeksie 3.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej, która została określona w nagłówku metody. Zmienne lokalne, które są mniejsze niż 4 bajty zostaną rozwinięte na typ `int32` , gdy są załadowane na stosie. Wartości zmiennoprzecinkowych zostaną rozwinięte ich rozmiar natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldloc.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmiennej lokalnej o określonym indeksie na stosie oceny, krótka forma.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|Ładuje zmiennej lokalnej o indeksie `index` na stosie, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości zmiennej lokalnej pod określonym indeksem spoczywa na stosie.  
  
 `ldloc.s` Instrukcji wypchnięcia zawartość numer zmiennej lokalnej o indeksie przekazany na stosie oceny, gdzie zmienne lokalne są numerowane 0 lub nowszej. Zmienne lokalne są inicjowane na 0, przed wprowadzeniem metody, jeśli flaga zainicjować metody ma wartość true. Brak 256 (2 ^ 8) zmiennych lokalnych to możliwe (0 – 255) w formie skróconej, który jest bardziej efektywne kodowanie niż `ldloc`.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej, która została określona w nagłówku metody. Zobacz partycji I. lokalnych zmiennych, które są mniejsze niż 4 bajty zostaną rozwinięte na typ `int32` , gdy są załadowane na stosie. Wartości zmiennoprzecinkowych zostaną rozwinięte ich rozmiar natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `ldloc.s` opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje adresu zmiennej lokalnej o określonym indeksie na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE OD &LT; `unsigned int16` >|ldloca `index`|Ładuje adresu zmiennej lokalnej w `index` na stosie oceny.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres przechowywane w zmiennej lokalnej o określonym indeksie spoczywa na stosie.  
  
 `ldloca` Instrukcji wypchnięcia adres numer zmiennej lokalnej o indeksie przekazany na stosie, gdzie zmienne lokalne są numerowane 0 lub nowszej. Wartość wypychana na stosie jest już wyrównane poprawnie do użycia z instrukcjami, jak <xref:System.Reflection.Emit.OpCodes.Ldind_I> i <xref:System.Reflection.Emit.OpCodes.Stind_I>. Wynik jest przejściowy wskaźnika (typ `*`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldloca` opcode:  
  
-   ILGenerator.Emit (OpCode, krótki)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje adresu zmiennej lokalnej o określonym indeksie na stosie oceny, krótka forma.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|Ładuje adresu zmiennej lokalnej w `index` na stosie oceny krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres przechowywane w zmiennej lokalnej o określonym indeksie spoczywa na stosie.  
  
 `ldloca.s` Instrukcji wypchnięcia adres numer zmiennej lokalnej o indeksie przekazany na stosie, gdzie zmienne lokalne są numerowane 0 lub nowszej. Wartość wypychana na stosie jest już wyrównane poprawnie do użycia z instrukcjami, jak <xref:System.Reflection.Emit.OpCodes.Ldind_I> i <xref:System.Reflection.Emit.OpCodes.Stind_I>. Wynik jest przejściowy wskaźnika (typ `*`).  
  
 `ldloca.s` Instrukcji umożliwia efektywne kodowanie do użycia z zmiennych lokalnych 0 do 255.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldloca.s` opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcia odwołanie o wartości null (typ <see langword="O" />) na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|14|elementu ldnull przy|Wypychanie odwołanie o wartości null na stosie|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie obiektu null spoczywa na stosie.  
  
 `ldnull` wypchnięcia odwołanie o wartości null (typ `O`) na stosie. Służy to zainicjować lokalizacje przed ich są wypełniane przy użyciu danych lub stają się one przestarzałe.  
  
 `ldnull` zawiera odwołanie o wartości null, która jest niezależny od rozmiaru.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldnull` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopie obiektu typu wartości wskazywana przez adres na wierzchu stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Kopiuj wystąpienie typu wartości `class` stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres obiektu typu wartościowego spoczywa na stosie.  
  
2.  Ten adres jest zdjęte ze stosu ze stosu i wyszukiwana jest wystąpienie pod tym adresem.  
  
3.  Wartość obiektu przechowywane pod tym adresem spoczywa na stosie.  
  
 `ldobj` Instrukcji jest używany do przekazywania typu wartości jako parametr.  
  
 `ldobj` Instrukcji kopiuje wartość wskazywana przez `addrOfValObj` (typu `&`, `*`, lub `native int`) na wierzchu stosu. Liczba bajtów skopiowanych zależy od rozmiaru klasy (zgodnie z określonym `class` parametru). `class` Parametr jest tokenem metadanych reprezentujący typ wartości.  
  
 Działanie `ldobj` instrukcji może być zmieniony przez poprzedzającego <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.TypeLoadException> jest generowany, jeśli nie można odnaleźć klasy. To zwykle wykryto po przekonwertowaniu instrukcji Microsoft języka pośredniego (MSIL) do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldobj` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha wartość pola statycznego na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7E < `T` >|elementu ldsfld `field`|Wypychanie wartości `field` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość określonego pola spoczywa na stosie.  
  
 `ldsfld` Instrukcji wypchnięcia wartość statyczna (współdzielona przez wszystkie wystąpienia klasy) na stosie. Zwracany typ jest skojarzone z tokenem przekazany metadanych `field`.  
  
 `ldsfld` Instrukcji może mieć <xref:System.Reflection.Emit.OpCodes.Volatile> prefiks.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldsfld` opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha adresu pola statycznego na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|Wypychanie adres `field` na stosie|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres określonego pola spoczywa na stosie.  
  
 `ldsflda` Instrukcji wypchnięcia adres statycznego (współdzielona przez wszystkie wystąpienia klasy) na stosie. Adres może być reprezentowane jako wskaźnik przejściowy (typ `*`) Jeśli token metadanych `field` odwołuje się do typu, w których pamięci jest zarządzana. W przeciwnym razie wartość odpowiada do niezarządzanego wskaźnika (typ `native int`). Należy pamiętać, że `field` może być statyczna globalnych z przypisanego adresu wirtualnego względnych (przesunięcie pola z adres podstawowy, w którym jego zawierającego plik PE jest ładowany do pamięci) pamięci w przypadku niezarządzanych.  
  
 `ldsflda` Instrukcji może mieć <xref:System.Reflection.Emit.OpCodes.Volatile> prefiks.  
  
 <xref:System.MissingFieldException> jest generowany, jeśli nie można odnaleźć pola w metadanych. Jest to zazwyczaj sprawdzana podczas konwertowania instrukcje Microsoft języka pośredniego (MSIL) do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldsflda` opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha nowe odwołanie obiektu do literału ciągu przechowywany w metadanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|Wypchnięcia obiekt ciągu dla tokenu ciągu metadanych `mdToken`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu na ciąg spoczywa na stosie.  
  
 `ldstr` Instrukcji wypchnięcia odwołanie do obiektu (typ `O`) na obiekt ciągu reprezentujący określony ciąg literału przechowywany w metadanych. `ldstr` Instrukcji przydziela wymagane ilość pamięci i wykonuje wszystkie Konwersja formatu wymaganego do konwertowania literału ciągu z formularza w pliku formatu ciągu wymagane w czasie wykonywania.  
  
 Infrastruktura języka wspólnego (CLI) gwarantuje, że wynik dwóch `ldstr` instrukcje odwołujące się do dwóch tokenów metadanych, które mają taką samą sekwencję znaków zwracać dokładnie tego samego ciągu obiektu (proces znany jako "interning ciąg").  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldstr` opcode:  
  
-   ILGenerator.Emit (OpCode, ciąg)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje token metadanych na jej reprezentację środowiska uruchomieniowego, wypychanie go na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D0 < `T` >|Ldtoken `token`|Konwertuje token metadanych na jej reprezentację środowiska wykonawczego.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Przekazany token jest konwertowana na `RuntimeHandle` i wypychana na stosie.  
  
 `ldtoken` Wypchnięć instrukcji `RuntimeHandle` dla tokenu określonych metadanych. A `RuntimeHandle` może być `fieldref/fielddef`, `methodref/methoddef`, lub `typeref/typedef`.  
  
 Wartość, o których wypychana na stosie, może być używana w wywołaniach `Reflection` metody w bibliotece klas systemu.  
  
 Uzyskać informacji na temat środowiska uruchomieniowego dojść, zobacz następujące klasy: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, i <xref:System.RuntimeMethodHandle>.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `ldtoken` opcode:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcia niezarządzanego wskaźnika (typ <see langword="native int" />) do kodu natywnego wykonania określonej metody wirtualnej skojarzone z określonego obiektu na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn `method`|Wypychanie wskaźnik do obiektu metody wirtualnej `method` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu spoczywa na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte ze stosu ze stosu i adres punktu wejścia do metody (określone przez token metadanych `method`) będą wyszukiwane.  
  
3.  Wskaźnik do `method` spoczywa na stosie.  
  
 Wynikowa niezarządzanego wskaźnika wypychana na stosie przez `ldvirtftn` instrukcji można wywołać za pomocą <xref:System.Reflection.Emit.OpCodes.Calli> instrukcji, jeśli odwołuje się ona zarządzanych — metoda (lub skrótowa, która przejścia z kodu zarządzanego do kodu niezarządzanego).  
  
 Niezarządzany wskaźnik wskazuje kodu natywnego za pomocą konwencji wywoływania środowiska CLR. Wskaźnik tej metody nie powinny być przekazywane do niezarządzanego kodu macierzystego jako procedura wywołania zwrotnego.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ldvirtftn` opcode:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kończy działanie chronionego obszaru kodu bezwarunkowo transferowanie formantu do instrukcji określonych docelowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DD < `int32` >|Pozostaw `target`|Kończy działanie chronionego obszaru kodu.|  
  
 Brak zachowania przejścia stosu określony dla tej instrukcji.  
  
 `leave` Instrukcji bezwarunkowo przekazuje sterowanie do instrukcji określonych docelowych, reprezentowane jako 4-bajtowych offset podpisem od początku instrukcji po bieżącej instrukcji.  
  
 `leave` Jest podobna do instrukcji `br` instrukcji, ale można używać do kończenia `try`, `filter`, lub `catch` zablokować instrukcje gałęzi zwykłej tylko mogą być używane w takich bloku do przekazywania kontroli w ramach go. `leave` Instrukcji opróżnia stosu oceny i upewnia się, że odpowiednie otaczającego `finally` bloki są wykonywane.  
  
 Nie można użyć `leave` instrukcji, aby zakończyć `finally` bloku. Aby ułatwić generowanie kodu dla obsługi wyjątków jest nieprawidłowy z wnętrza bloku catch do użycia `leave` instrukcji na transfer kontroli do żadnych instrukcji w skojarzonych `try` bloku.  
  
 Jeśli instrukcja zawiera jeden lub więcej kodów prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `leave` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kończy działanie chronionego obszaru kodu bezwarunkowo transferowanie formantu do instrukcję docelowego (forma krótka /).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DE < `int8` >|instrukcją Leave.s `target`|Zamknij chronionego obszaru krótkich fragmentów kodu.|  
  
 Brak zachowania przejścia stosu określony dla tej instrukcji.  
  
 `leave.s` Instrukcji bezwarunkowo przekazuje sterowanie instrukcji przekazany docelowej, reprezentowane jako 1-bajtowy offset podpisem od początku instrukcji po bieżącej instrukcji.  
  
 `leave.s` Jest podobna do instrukcji `br` instrukcji, ale można używać do kończenia `try`, `filter`, lub `catch` zablokować instrukcje gałęzi zwykłej tylko mogą być używane w takich bloku do przekazywania kontroli w ramach go. `leave.s` Instrukcji opróżnia stosu oceny i upewnia się, że odpowiednie otaczającego `finally` bloki są wykonywane.  
  
 Nie można użyć `leave.s` instrukcji, aby zakończyć `finally` bloku. Aby ułatwić generowanie kodu dla obsługi wyjątków jest nieprawidłowy z wnętrza bloku catch do użycia `leave.s` instrukcji na transfer kontroli do żadnych instrukcji w skojarzonych `try` bloku.  
  
 Jeśli instrukcja zawiera jeden lub więcej kodów prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `leave.s` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przydziela określoną liczbę bajtów z puli pamięci dynamicznej lokalnej i wypchnięcia adres (wskaźnik przejściowy, typ <see langword="*" />) pierwszego bajtu przydzielony na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0F|operacji localloc|Przydziel miejsca z lokalnego stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Liczba bajtów do przydzielenia spoczywa na stosie.  
  
2.  Liczba bajtów jest zdjęte ze stosu ze stosu; ilość pamięci odpowiadający rozmiar jest przydzielony z lokalnego stosu.  
  
3.  Wskaźnik do pierwszego bajtu alokacji pamięci spoczywa na stosie.  
  
 `localloc` Przydziela instrukcji `size` (typ `natural unsigned int`) bajtów z lokalnej pamięci dynamicznej puli i zwraca adres (wskaźnik przejściowy, typ `*`) pierwszego bajtu przydzielone. Blok pamięci zwracane jest ustawiana na 0, tylko wtedy, gdy flaga zainicjować metody `true`. Podczas wykonywania bieżącej metody <xref:System.Reflection.Emit.OpCodes.Ret>, puli pamięci lokalnej jest udostępniana do ponownego użycia.  
  
 Otrzymany adres jest wyrównywany tak, aby dowolny typ danych pierwotnych mogą znajdować się za pomocą `stind` instrukcje (takie jak <xref:System.Reflection.Emit.OpCodes.Stind_I4>) i ładowane przy użyciu `ldind` instrukcje (takie jak <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  
  
 `localloc` Instrukcji nie mogą występować w `filter`, `catch`, `finally`, lub `fault` bloku.  
  
 <xref:System.StackOverflowException> jest generowany, jeśli jest za mało pamięci do obsługi żądania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `localloc` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha typu odwołania do wystąpienia określonego typu na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|C6 < `T` >|Operacja Mkrefany `class`|Wypchnięcia typu odwołanie typu `class` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wskaźnik do elementu danych spoczywa na stosie.  
  
2.  Wskaźnik jest zdjęte ze stosu i konwertowana do typu odwołania typu `class`.  
  
3.  Odwołanie do typu spoczywa na stosie.  
  
 `mkrefany` Instrukcji obsługuje przekazywanie o typach określanych dynamicznie odwołań. Wskaźnik musi być typu `&`, `*`, lub `native int`i przytrzymaj prawidłowy adres elementu danych. `Class` jest token klasy opisujące typ danych odwołuje się wskaźnik myszy. `Mkrefany` wypchnięcia typu odwołania na stosie, zapewniając nieprzezroczyste deskryptora wskaźnik i typ `class`.  
  
 Jedyne prawidłowe operacja dozwolone na odwołanie do typu jest przekazywany do metody, która wymaga odwołania typu jako parametr. Wywoływany można następnie użyć <xref:System.Reflection.Emit.OpCodes.Refanytype> i <xref:System.Reflection.Emit.OpCodes.Refanyval> instrukcjami, aby pobrać odpowiednio typu (klasa) oraz adres.  
  
 <xref:System.TypeLoadException> wygenerowany, jeśli `class` nie można odnaleźć. To jest zwykle wykrycie instrukcje Microsoft języka pośredniego (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `mkrefany` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Mnoży dwie wartości i umieszcza wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5A|mul|Mnoży dwie wartości na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest mnożona przez `value2`.  
  
4.  Wynik spoczywa na stosie.  
  
 `mul` Mnoży instrukcji `value1` przez `value2` i umieszcza wynik na stosie. Operacje całkowitą obciąć dyskretnie górny usługi bits na przepełnienia.  
  
 Zobacz <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> określonych całkowitą mnożenia działania z obsługą przepełnienia.  
  
 Dla typów zmiennoprzecinkowych 0 * nieskończoności = NaN.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `mul` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Mnoży dwie liczby całkowite, przeprowadza sprawdzanie przepełnienia, a wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|Mnoży dwie wartości całkowite na stosie ze sprawdzaniem przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest mnożona przez `value2`, ze sprawdzaniem przepełnienia.  
  
4.  Wynik spoczywa na stosie.  
  
 `mul.ovf` Instrukcji mnoży całkowitą `value1` przez całkowitą `value2` i umieszcza wynik na stosie. Jeśli wynik nie mieści się w typie wyniku, jest zgłaszany wyjątek.  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `mul.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Mnoży dwie wartości całkowitej bez znaku, przeprowadza sprawdzanie przepełnienia, a wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|Mnoży dwie wartości bez znaku na stosie ze sprawdzaniem przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest mnożona przez `value2`, ze sprawdzaniem przepełnienia.  
  
4.  Wynik spoczywa na stosie.  
  
 `mul.ovf.un` Instrukcji mnoży liczbę całkowitą bez znaku `value1` przez liczbę całkowitą bez znaku `value2` i umieszcza wynik na stosie. Jeśli wynik nie mieści się w typie wyniku, jest zgłaszany wyjątek.  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `mul.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Negacja wartości i umieszcza wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|65|neg|Negacja wartości obecnie na szczycie stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość spoczywa na stosie.  
  
2.  Wartość jest zdjęte ze stosu ze stosu i zanegowane.  
  
3.  Wynik spoczywa na stosie.  
  
 `neg` Negacja wartości i umieszcza wynik na szczycie stosu w instrukcji. Zwracany typ jest taki sam jak typ argumentu.  
  
 Negacja wartości całkowitych na wartości jest standardem w dwóch uzupełniają negacji. W szczególności Negacja najbardziej ujemną (który nie ma odpowiednika dodatnią) daje najbardziej ujemną. Aby wykryć tego użycia przepełnienia <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instrukcji zamiast (to znaczy odjąć od 0).  
  
 Liczba zmiennoprzecinkowa Negacja nie przepełnienie i Negacja NaN zwraca NaN.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `neg` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha odwołanie obiektu do nowego nieujemną jednowymiarową tablicę wartości na stosie oceny określonego typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr `etype`|Tworzy nową macierz elementami typu `etype`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Liczba elementów w tablicy spoczywa na stosie.  
  
2.  Liczba elementów jest zdjęte ze stosu ze stosu i utworzeniu tablicy.  
  
3.  Odwołanie obiektu do nowej tablicy spoczywa na stosie.  
  
 `newarr` Instrukcji wypchnięcia odwołanie do obiektu (typ `O`) do nowej nieujemną jednowymiarową tablicę wartości typu `etype` (opisujące typ tokenu metadanych). Liczba elementów w nowej tablicy powinny być określone jako `native int`. Zakres indeksy tablicy prawidłowy od zera do maksymalnej liczby elementów minus jeden.  
  
 Elementy tablicy mogą być dowolnego typu, łącznie z typami wartości.  
  
 Liczony od zera, jednowymiarowe tablice liczb są tworzone za pomocą tokenu metadanych odwołania do typu odpowiednie wartości (<xref:System.Int32>i tak dalej). Elementy tablicy są inicjowane 0 odpowiedniego typu.  
  
 NonZero-oparte na tablice jednowymiarowe i tablic wielowymiarowych są tworzone przy użyciu <xref:System.Reflection.Emit.OpCodes.Newobj> zamiast `newarr`. Zazwyczaj zostały utworzone przy użyciu metody <xref:System.Array> klasy w programie .NET Framework.  
  
 <xref:System.OutOfMemoryException> jest generowany, jeśli jest za mało pamięci do spełnienia żądania.  
  
 <xref:System.OverflowException> wygenerowany, jeśli `numElems` jest mniejszy niż 0.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `newarr` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tworzy nowy obiekt lub nowe wystąpienie typu wartości wypychanie odwołanie do obiektu (typ <see langword="O" />) na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Przydziela Niezainicjowany obiekt lub wartość typu i wywołuje metodę konstruktora `ctor`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Argumenty `arg1` za pośrednictwem `argn` są przenoszone na stosie w sekwencji.  
  
2.  Argumenty `argn` za pośrednictwem `arg1` zdjęte ze stosu ze stosu i przekazywane do `ctor` do utworzenia obiektu.  
  
3.  Odwołanie do nowego obiektu spoczywa na stosie.  
  
 `newobj` Instrukcji tworzy nowy obiekt lub nowe wystąpienie typu wartości. `Ctor` jest token metadanych ( `methodref` lub `methoddef` muszą być oznaczone jako konstruktora) wskazująca nazw, klasy i sygnatury konstruktora do wywołania.  
  
 `newobj` Instrukcji przydziela nowe wystąpienie klasy skojarzone z `ctor` i inicjuje wszystkie pola w tym nowym wystąpieniu na 0 (obiektem właściwego typu) lub puste odwołania zależnie od potrzeb. Następnie wywołuje konstruktor `ctor` z argumentami danego wraz z nowo utworzone wystąpienie. Po wywołaniu konstruktora obecnie zainicjować odwołania do obiektu (typ `O`) spoczywa na stosie.  
  
 Z punktu widzenia konstruktora Niezainicjowany obiekt jest argumentem 0 i inne argumenty przekazane do zastosować element newobj wykonaj w kolejności.  
  
 Wszystkie tablice liczony od zera, jednowymiarowa są tworzone przy użyciu <xref:System.Reflection.Emit.OpCodes.Newarr>, a nie `newobj`. Z drugiej strony wszystkie tablice (więcej niż jednym wymiarze lub w jednowymiarowa ale nie liczony od zera) są tworzone przy użyciu `newobj`.  
  
 Typy wartości nie są zwykle tworzone przy użyciu `newobj`. Zazwyczaj są przydzielane jako argumentów lub zmiennych lokalnych, za pomocą `newarr` (dla tablic jednowymiarową, liczony od zera), lub jako pola obiektów. Gdy przydzielone, są one inicjowane przy użyciu <xref:System.Reflection.Emit.OpCodes.Initobj>. Jednak `newobj` instrukcji może służyć do utworzenia nowego wystąpienia typu wartości na stosie, które następnie mogą być przekazywane jako argument, przechowywane lokalnie i tak dalej.  
  
 <xref:System.OutOfMemoryException> jest generowany, jeśli jest za mało pamięci do spełnienia żądania.  
  
 <xref:System.MissingMethodException> jest generowany, jeśli metoda konstruktora `ctor` z określoną nazwą, klasy i podpis nie można odnaleźć. To jest zwykle wykrycie instrukcje Microsoft języka pośredniego (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `newobj` opcode:  
  
-   ILGenerator.Emit(OpCode, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypełnia miejsce, jeśli używa się poprawkami. Nie łatwy do rozpoznania operacja została wykonana, mimo że cykl przetwarzania, które mogą być używane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|00|NOP|Wykonuje operację bez zachowania.|  
  
 Brak zachowania przejściowe stosu zdefiniowane dla tej instrukcji.  
  
 `nop` Operacja nie przynosi żadnego efektu. Jest on przeznaczony do Wypełnij miejsce, jeśli są poprawiono kody operacji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `nop` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oblicza dopełnienia bitowego wartości całkowitej na szczycie stosu i wynik na stosie oceny jako tego samego typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|66|not|Oblicza dopełnienia bitowego wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` spoczywa na stosie.  
  
2.  `value` jest zdjęte ze stosu ze stosu i jego bitowe dopełnienia obliczana.  
  
3.  Wynik spoczywa na stosie.  
  
 `not` Instrukcji oblicza dopełnienia bitowego liczb całkowitych i umieszcza wynik na stosie. Zwracany typ jest taki sam jak typ argumentu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `not` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obliczenia bazy danych dopełnienia bitowego z dwóch liczb całkowitych wartości na szczycie stosu i umieszcza wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|60|lub|Oblicza bitowe lub z dwóch wartości całkowitych, zwraca liczbę całkowitą.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu i ich bitowe lub obliczana.  
  
4.  Wynik spoczywa na stosie.  
  
 `or` Instrukcji oblicza bitowe lub dwie wartości nad stosu, wypychanie wyników na stosie.  
  
 `Or` jest operacją określonej liczby całkowitej.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `or` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usuwa wartość aktualnie na szczycie stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|26|POP|POP wysokiej wartości ze stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość top jest zdjęte ze stosu ze stosu.  
  
 `pop` Instrukcji usuwa górnego elementu ze stosu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `pop` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zarezerwowana instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zarezerwowana instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zarezerwowana instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zarezerwowana instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zarezerwowana instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zarezerwowana instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zarezerwowana instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zarezerwowana instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy operacja adres kolejnych tablicy sprawdza nie typu w czasie wykonywania i którego zmienność go zwraca wskaźnik zarządzanych jest ograniczony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu język pośredni (MSIL) firmy Microsoft, wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 1E|tylko do odczytu.|Określ, czy operacja adres kolejnych tablicy sprawdza nie typu w czasie wykonywania i zwraca wskaźnik zarządzanych, z ograniczeniami zmienność.|  
  
 Ten prefiks może występować tylko bezpośrednio poprzednie `ldelema` instrukcji i wywołania specjalną `Address` metody dla tablic. Jego wpływ na kolejne działanie ma dwa cele:  
  
1.  W czasie wykonywania wykonywana jest operacja wyboru nie typu. Należy pamiętać, że zwykle typu niejawnego sprawdzaj `ldelema` i `stelem` instrukcje stosowania na odwołanie do typu tablic. Nigdy nie jest typu run-time Wyszukaj klasy wartości, więc `readonly` w takim przypadku jest pusta.  
  
2.  Kontroler traktuje wynik operacji adresu jako wskaźnik zarządzanego z ograniczeniami zmienność.  
  
 Wskaźnik jest nazywany ograniczono zmienność, ponieważ typ definiujący kontroluje, czy wartość może ulegać mutacjom. Dla klas wartość, które udostępniają nie pola publiczne lub metod, które zaktualizuj tę wartość w miejscu, kursor jest tylko do odczytu (stąd nazwa prefiksu). W szczególności klas reprezentujących typy pierwotne (na przykład System.Int32) nie ujawniaj metod ustawiających i w związku z tym są tylko do odczytu.  
  
 Wskaźnik zarządzanych ograniczony w ten sposób mogą być używane tylko w następujący sposób:  
  
-   Jako `object` parametr `ldfld`, `ldflda`, `stfld`, `call`, lub`constrained callvirt` instrukcje.  
  
-   Jako `pointer` parametr `ldobj` instrukcji lub do jednego z `ldind` instrukcje.  
  
-   Jako `source` parametr `cpobj` instrukcji.  
  
 Wszystkie inne operacje niedozwolone w tym `stobj`, `initobj`, lub `mkrefany` operacji lub dowolnym `stind` instrukcje.  
  
 Celem `readonly` prefiks jest uniknięcie Sprawdzanie typu podczas pobierania elementu z tablicy w kodzie rodzajowym. Na przykład, wyrażenie `arr[i].m()`, gdzie typ elementu tablicy `arr` jest typem ogólnym, która została ograniczona do ma interfejsu z metodą `m`, może być kompilacji do następującego MSIL.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Bez `readonly` prefiksu, `ldelema` instrukcji przeprowadza sprawdzanie typu w przypadku których! 0 był typem referencyjnym. Nie tylko jest nieefektywne ten test typu, ale jest semantycznie nieprawidłowy. Sprawdzanie typu `ldelema` jest dokładnym odpowiednikiem, który jest za silne. Jeżeli tablica podklasy typu! 0, powyższy kod spowoduje niepowodzenie sprawdzania typu.  
  
 Adresu elementu tablicy jest pobierana, zamiast elementu, aby uzyskać dojścia do `arr[i]` działa w przypadku oba typy wartości i typy referencyjne i w związku z tym mogą zostać przekazane do `constrained callvirt` instrukcji.  
  
 Ogólnie jest niebezpieczne pomijania sprawdzania czasu wykonywania, jeśli tablica przechowywać elementów typu referencyjnego. Jest jest niezbędne do zapewnienia, że żadnych zmian do tablicy są nawiązywane przy użyciu ten wskaźnik. Reguły weryfikatora upewnij się, to. Ograniczone wskaźnika zarządzane mogą być przekazywane jako obiekt wywołania metody wystąpienia, tak nie jest mówiąc ściślej tylko do odczytu dla typów wartości, ale nie ma problemów bezpieczeństwa typu dla typów wartości.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `readonly` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera token typu osadzonego w odwołaniu typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|Wypycha tokenu typu przechowywane w odwołaniu typu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do typu wartości spoczywa na stosie.  
  
2.  Odwołanie do typu jest zdjęte ze stosu ze stosu i pobrać jego odpowiedniego tokenu typu.  
  
3.  Token typu spoczywa na stosie.  
  
 Odwołanie do typu zawiera token typu i adres na wystąpienie obiektu.  
  
 `refanytype` Instrukcji pobiera token typu osadzonego typu odwołania. Zobacz <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrukcji, aby uzyskać informacje na temat tworzenia typu odwołania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `refanytype` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres (typ <see langword="&amp;" />) osadzonego w odwołaniu typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|Wypycha dane przechowywane w odwołaniu do typu adresu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do typu wartości spoczywa na stosie.  
  
2.  Odwołanie do typu jest zdjęte ze stosu ze stosu i pobrać odpowiedni adres.  
  
3.  Adres spoczywa na stosie.  
  
 Odwołanie do typu zawiera token typu i adres na wystąpienie obiektu.  
  
 `refanyval` Instrukcji pobiera adres osadzone w typu odwołania. Typu osadzonego w typizowanych odwołania podane na stosie musi być zgodna z typem określonym przez `type` (token metadanych, albo `typedef` lub `typeref`). Zobacz <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrukcję powiązanej zawartości.  
  
 <xref:System.InvalidCastException> wygenerowany, jeśli `type` nie jest taki sam jak typ przechowywane w odwołaniu typu (w tym przypadku `type` jest klasa dostarczonego do <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrukcji skonstruowany powiedział typu odwołania).  
  
 <xref:System.TypeLoadException> wygenerowany, jeśli `type` nie można odnaleźć.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `refanyval` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dzieli dwie wartości i wypchnięcia pozostałe na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5D|rem|Wypchnięcia resztę z dzielenia `value1` przez `value2` na stosie.|  
  
> [!NOTE]
>  ReplaceThisText  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  A `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu i pozostałej części `value1` `div` `value2` obliczana.  
  
4.  Wynik spoczywa na stosie.  
  
 `result` = `value1` `rem` `value2` spełnia następujące warunki:  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`), oraz:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;, logowania (`result`) = znak (`value1`), gdzie `div` jest instrukcji dzielenia obcina kierunku zera.  
  
 Jeśli `value2` wynosi zero lub `value1` jest nieskończoność wynik jest wartością typu NaN. Jeśli `value2` jest nieskończoność, wynikiem jest `value1` (zanegowane dla `-infinity`).  
  
 Operacje integralną throw <xref:System.DivideByZeroException> Jeśli `value2` wynosi zero.  
  
 Należy pamiętać, że na platformach opartych na Intel <xref:System.OverflowException> jest generowany, gdy obliczeniowych (minint `rem` -1).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `rem` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dzieli dwie wartości bez znaku i wypchnięcia pozostałe na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5E|rem.un|Wypchnięcia resztę z dzielenia niepodpisane `value1` przez niepodpisane `value2` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu i pozostałej części `value1` `div` `value2` obliczana.  
  
4.  Wynik spoczywa na stosie.  
  
 `result` = `value1` `rem.un` `value2` spełnia następujące warunki:  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`), oraz:  
  
 0 = `result`  <  `value2`, gdzie `div.un` jest instrukcją dzielenia bez znaku.  
  
 `rem.un` Oblicza instrukcji `result` i wypchnięcia jej na stosie. `Rem.un` traktuje argumenty jak liczb całkowitych bez znaku, podczas gdy <xref:System.Reflection.Emit.OpCodes.Rem> traktowane jako podpisane liczby całkowite.  
  
 `Rem.un` określono liczb zmiennoprzecinkowych.  
  
 Operacje integralną throw <xref:System.DivideByZeroException> Jeśli `value2` wynosi zero.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `rem.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca z bieżącej metody wypychanie wartości zwracanej (jeśli istnieje) ze stosu oceny wywołującej na stos oceny obiektu wywołującego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2A|RET|Zwraca metodę, prawdopodobnie zwracanie wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość zwracana jest zdjęte ze stosu ze stosu oceny wywoływany.  
  
2.  Zwracana wartość uzyskaną w kroku 1 spoczywa na stosie oceny wywołującego.  
  
 Jeśli na stosie oceny wywoływanego nie ma wartości zwracanej, zwracana jest wartość nie (Brak stosu zachowania wywoływany albo obiekt wywołujący metody).  
  
 Typ zwracanej wartości, bieżącej metody Określa typ wartości do pobrania z góry stosu i skopiowany na stosie metody, która wywołuje bieżącej metody. Stos oceny dla bieżącej metody może być pusta, z wyjątkiem wartość zwracaną.  
  
 `ret` Nie może być używana do przekazywania kontroli z`try`, `filter`, `catch`, lub `finally` bloku. Z poziomu `try` lub `catch`, użyj <xref:System.Reflection.Emit.OpCodes.Leave> instrukcji, których miejscem docelowym `ret` instrukcji znajdującego się poza otaczającego wszystkie bloki wyjątków. Ponieważ `filter` i `finally` bloki są logicznie część wyjątków i nie metody, w którym ich kod jest osadzony, poprawnie wygenerowany instrukcje Microsoft języka pośredniego (MSIL) nie należy wykonywać zwrócone z wewnątrz metody `filter` lub `finally`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `ret` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ponownie zgłasza bieżącego wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 1A|rethrow|Ponownie zgłasza bieżący wyjątek|  
  
 Nie zachowania przejścia stosu jest zdefiniowany dla tej instrukcji.  
  
 `rethrow` Instrukcji jest dozwolona tylko w treści `catch` obsługi. Zgłasza ten sam wyjątek, który został zgłoszony przez ten program obsługi.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `rethrow` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przesuwa całkowitą w lewo (w zera) przez określoną liczbę bitów, wypychanie wyników na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|62|shl|Przesuwa całkowitą w lewo (przesunięcie w zera).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość spoczywa na stosie.  
  
2.  Liczba bitów, które mają zostać przesunięte spoczywa na stosie.  
  
3.  Liczba bitów lekkie i wartości ze stosu; zdjęte ze stosu są wartość zostanie przesunięty w lewo przez określoną liczbę bitów.  
  
4.  Wynik spoczywa na stosie.  
  
 `shl` Instrukcji przewiduje wartość (typu `int32`, `int64` lub `native int`) przez określoną liczbę bitów w lewo. Liczba bitów jest wartością typu `int32` lub `native int`. Wartość zwracana jest nieokreślony, jeśli liczba bitów lekkie jest większa niż lub równa szerokość (w bitach) podana wartość.  
  
 `Shl` Wstawia zero bit najniżej na każdej zmianie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `shl` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi całkowitą (w znak) po prawej stronie przez określoną liczbę bitów, wypychanie wyników na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|63|shr|Przenosi całkowitą w prawo (zmiany w znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość spoczywa na stosie.  
  
2.  Liczba bitów, które mają zostać przesunięte spoczywa na stosie.  
  
3.  Liczba bitów lekkie i wartości ze stosu; zdjęte ze stosu są wartość zostanie przesunięty w prawo o określoną liczbę bitów.  
  
4.  Wynik spoczywa na stosie.  
  
 `shr.un` Instrukcji przewiduje wartość (typu `int32`, `int64` lub `native int`) bezpośrednio przez określoną liczbę bitów. Liczba bitów jest wartością typu `int32` lub `native int`. Wartość zwracana jest nieokreślony, jeśli liczba bitów lekkie jest większa niż lub równa szerokość (w bitach) podana wartość.  
  
 `Shr` replikowane najbardziej znaczących bitów na każdej zmiany, zachowując znak oryginalnej wartości w `result`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `shr` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi wartość całkowitą bez znaku (w zera) po prawej stronie przez określoną liczbę bitów, wypychanie wyników na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|64|shr.UN|Przenosi całkowitą w prawo (przesunięcie w zera).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość spoczywa na stosie.  
  
2.  Liczba bitów, które mają zostać przesunięte spoczywa na stosie.  
  
3.  Liczba bitów lekkie i wartości ze stosu; zdjęte ze stosu są wartość zostanie przesunięty w prawo o określoną liczbę bitów.  
  
4.  Wynik spoczywa na stosie.  
  
 `shr.un` Instrukcji przewiduje wartość (typu `int32`, `int64` lub `native int`) bezpośrednio przez określoną liczbę bitów. Liczba bitów jest wartością typu `int32`, `int64` lub `native int`. Wartość zwracana jest nieokreślony, jeśli liczba bitów lekkie jest większa niż lub równa szerokość (w bitach) podana wartość.  
  
 `Shr.un` Wstawia zero bit na szczycie każdej zmiany.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `shr.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha rozmiar w bajtach, podana wartość typu na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|sizeof `valType`|Wypychanie rozmiar w bajtach typu wartości jako `unsigned int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Rozmiar (w bajtach) typu podana wartość (`valType`) spoczywa na stosie.  
  
 `valType` musi być token metadanych ( `typeref` lub `typedef`), który określa typ wartości, typu odwołania lub parametr typu ogólnego.  
  
 Dla typu odwołania rozmiar zwrócony jest rozmiar wartości odwołania odpowiadającego wpisz (4 bajty w systemie 32-bitowym), nie rozmiar danych przechowywanych w obiektach określone przez wartość odniesienia. Parametr typu ogólnego może służyć tylko w treści typu lub metody definiującej go. W przypadku wystąpienia tego typu lub metody parametr typu ogólnego jest zastępowany przez wartość typu lub typów referencyjnych.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `sizeof` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość na szczycie stosu oceny w gnieździe argument pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` >|starg `num`|POP wysokiej wartości ze stosu i zapisuje go w miejscu argument `num`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość aktualnie na szczycie stosu jest zdjęte ze stosu i umieścić w gnieździe argument `num`.  
  
 `starg` Instrukcji będzie wyświetlana wartość ze stosu i umieszcza je w gnieździe argument `num`. Typ wartości musi odpowiadać typowi argumentu, jak określono w podpisie metody bieżącej.  
  
 Dla procedury uwzględniające listy zmiennych argumentów `starg` instrukcji mogą służyć tylko do początkowego stałej argumentów, nie wartości w zmiennej części podpisu.  
  
 Wykonywanie magazynem do argumentów zawierających wartość całkowitą mniejszą niż 4 bajty obcina wartość przesyłane do argumentu ze stosu. Zmiennoprzecinkowe wartości są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `starg` opcode:  
  
-   ILGenerator.Emit (OpCode, krótki)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość na szczycie stosu oceny w gnieździe argument od określonego indeksu, krótka forma.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|POP wysokiej wartości ze stosu i zapisuje go w miejscu argument `num`, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość aktualnie na szczycie stosu jest zdjęte ze stosu i umieścić w gnieździe argument `num`.  
  
 `starg.s` Instrukcji będzie wyświetlana wartość ze stosu i umieszcza je w gnieździe argument `num`. Typ wartości musi odpowiadać typowi argumentu, jak określono w podpisie metody bieżącej.  
  
 `starg.s` Instrukcji umożliwia efektywne kodowanie do użycia z argumentami najpierw 256.  
  
 Dla procedury uwzględniające listy zmiennych argumentów `starg.s` instrukcji mogą służyć tylko do początkowego stałej argumentów, nie wartości w zmiennej części podpisu.  
  
 Wykonywanie magazynem do argumentów zawierających wartość całkowitą mniejszą niż 4 bajty obcina wartość przesyłane do argumentu ze stosu. Zmiennoprzecinkowe wartości są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `starg.s` opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy pod danym indeksem o wartości na stosie oceny, którego typ jest określony w instrukcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu język pośredni (MSIL) firmy Microsoft, wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem `typeTok`|Zamienia wartości typu elementu tablicy w indeksie dostarczony `typeTok` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, spoczywa na stosie.  
  
2.  Wartość indeksu `index`, aby element `array` spoczywa na stosie.  
  
3.  Wartość typu określonego w instrukcji spoczywa na stosie.  
  
4.  Wartość indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartości są umieszczane w elemencie tablicy pod danym indeksem.  
  
 `stelem` Instrukcji zastępuje wartość elementu podany liczony od zera indeks w tablicy jednowymiarowej tablicy `array` o wartości. Wartość ma typ określony token `typeTok` w instrukcji.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typu `native int`.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stelem` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy w danym indeksie z <see langword="native int" /> wartości na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9B|stelem.i|Zamienia element tablicy w indeksie dostarczonego z `native int` wartości na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, spoczywa na stosie.  
  
2.  Nieprawidłowy indeks do elementu `array` spoczywa na stosie.  
  
3.  Wartość spoczywa na stosie.  
  
4.  Wartość indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartości są umieszczane w elemencie tablicy pod danym indeksem.  
  
 `stelem.i` Instrukcji zastępuje wartość elementu `index` w Jednowymiarowa tablica `array` z `native int` wartość wypychana na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typu `native int`.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stelem.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy w danym indeksie z <see langword="int8" /> wartości na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|Zamienia element tablicy w indeksie dostarczonego z `int8` wartości na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, spoczywa na stosie.  
  
2.  Nieprawidłowy indeks do elementu `array` spoczywa na stosie.  
  
3.  Wartość spoczywa na stosie.  
  
4.  Wartość indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartości są umieszczane w elemencie tablicy pod danym indeksem.  
  
 `stelem.i1` Instrukcji zastępuje wartość elementu `index` w Jednowymiarowa tablica `array` z `int8` wartość wypychana na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typu `native int`.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stelem.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy w danym indeksie z <see langword="int16" /> wartości na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|Zamienia element tablicy w indeksie dostarczonego z `int16` wartości na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, spoczywa na stosie.  
  
2.  Nieprawidłowy indeks do elementu `array` spoczywa na stosie.  
  
3.  Wartość spoczywa na stosie.  
  
4.  Wartość indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartości są umieszczane w elemencie tablicy pod danym indeksem.  
  
 `stelem.i2` Instrukcji zastępuje wartość elementu `index` w Jednowymiarowa tablica `array` z `int16` wartość wypychana na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typu `native int`.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stelem.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy w danym indeksie z <see langword="int32" /> wartości na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|Zamienia element tablicy w indeksie dostarczonego z `int32` wartości na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, spoczywa na stosie.  
  
2.  Nieprawidłowy indeks do elementu `array` spoczywa na stosie.  
  
3.  Wartość spoczywa na stosie.  
  
4.  Wartość indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartości są umieszczane w elemencie tablicy pod danym indeksem.  
  
 `stelem.i4` Instrukcji zastępuje wartość elementu `index` w Jednowymiarowa tablica `array` z `int32` wartość wypychana na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typu `native int`.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stelem.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy w danym indeksie z <see langword="int64" /> wartości na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|Zamienia element tablicy w indeksie dostarczonego z `int64` wartości na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, spoczywa na stosie.  
  
2.  Nieprawidłowy indeks do elementu `array` spoczywa na stosie.  
  
3.  Wartość spoczywa na stosie.  
  
4.  Wartość indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartości są umieszczane w elemencie tablicy pod danym indeksem.  
  
 `stelem.i8` Instrukcji zastępuje wartość elementu `index` w Jednowymiarowa tablica `array` z `int64` wartość wypychana na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typu `native int`.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stelem.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy w danym indeksie z <see langword="float32" /> wartości na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|Zamienia element tablicy w indeksie dostarczonego z `float32` wartości na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, spoczywa na stosie.  
  
2.  Nieprawidłowy indeks do elementu `array` spoczywa na stosie.  
  
3.  Wartość spoczywa na stosie.  
  
4.  Wartość indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartości są umieszczane w elemencie tablicy pod danym indeksem.  
  
 `stelem.r4` Instrukcji zastępuje wartość elementu `index` w Jednowymiarowa tablica `array` z `float32` wartość wypychana na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typu `native int`.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stelem.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy w danym indeksie z <see langword="float64" /> wartości na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|Zamienia element tablicy w indeksie dostarczonego z `float64` wartości na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, spoczywa na stosie.  
  
2.  Nieprawidłowy indeks do elementu `array` spoczywa na stosie.  
  
3.  Wartość spoczywa na stosie.  
  
4.  Wartość indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartości są umieszczane w elemencie tablicy pod danym indeksem.  
  
 `stelem.r8` Instrukcji zastępuje wartość elementu `index` w Jednowymiarowa tablica `array` z `float64` wartość wypychana na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typu `native int`.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stelem.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy w danym indeksie wartość ref obiektu (typ <see langword="O" />) na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|Zamienia element tablicy w indeksie dostarczonego z `ref` wartość (typu `O`) na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, spoczywa na stosie.  
  
2.  Nieprawidłowy indeks do elementu `array` spoczywa na stosie.  
  
3.  Wartość spoczywa na stosie.  
  
4.  Wartość indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartości są umieszczane w elemencie tablicy pod danym indeksem.  
  
 `stelem.ref` Instrukcji zastępuje wartość elementu podany indeks w tablicy jednowymiarowej tablicy `array` z `ref` (typ `O`) wartość wypychana na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typu `native int`.  
  
 Należy pamiętać, że `stelem.ref` niejawnie rzutuje podana wartość do typu elementu `array` przed przypisanie wartości do elementu tablicy. To rzutowanie może zakończyć się niepowodzeniem, nawet w przypadku Zweryfikowano kod. W związku z tym `stelem.ref` instrukcji może zgłosić <xref:System.InvalidCastException>. Tablice jednowymiarowe, które nie są liczony od zera i tablice wielowymiarowe <xref:System.Array> klasa udostępnia <xref:System.Array.SetValue%2A> metody.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> wygenerowany, jeśli `index` ma ujemną lub większą niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> wygenerowany, jeśli `array` nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stelem.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia wartość przechowywana w polu odwołania do obiektu lub wskaźnik z nową wartością.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|Zamienia wartości `field` obiektu na nową wartość.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu lub wskaźnikiem spoczywa na stosie.  
  
2.  Wartość spoczywa na stosie.  
  
3.  Wartość i odwołanie/wskaźnika obiektu ze stosu; zdjęte ze stosu są wartość `field` w obiekcie jest zastępowany podana wartość.  
  
 `stfld` Instrukcji zastępuje wartość pola obiektu (typ `O`) lub za pomocą wskaźnika (typ `native int`, `&`, lub `*`) z danej wartości. `Field` to token metadanych, który odwołuje się do odwołania elementu członkowskiego pola. `stfld` Instrukcji może mieć prefiks z jednego lub obu <xref:System.Reflection.Emit.OpCodes.Unaligned> i <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli odwołania do obiektu lub wskaźnika jest odwołanie o wartości null i pola nie jest statyczne.  
  
 <xref:System.MissingFieldException> wygenerowany, jeśli `field` nie znaleziono w metadanych. Jest to zazwyczaj sprawdzana po przekonwertowaniu do kodu natywnego, a nie w czasie wykonywania instrukcji Microsoft języka pośredniego (MSIL).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stfld` opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="native int" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DF|stind.i|Magazyny `native int` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Wartość spoczywa na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.i` Magazynów instrukcji `native int` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.i` instrukcji można użyć w sposób zgodny z typem wskaźnika. Działanie `stind.i` instrukcji może być zmieniony przez poprzedzającego <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu niejawnego sufiksem instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stind.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="int8" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|52|stind.i1|Magazyny `int8` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Wartość spoczywa na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.i1` Magazynów instrukcji `int8` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.i1` instrukcji można użyć w sposób zgodny z typem wskaźnika. Działanie `stind.i1` instrukcji może być zmieniony przez poprzedzającego <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu niejawnego sufiksem instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stind.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="int16" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|53|stind.i2|Magazyny `int16` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Wartość spoczywa na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.i2` Magazynów instrukcji `int16` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.2i` instrukcji można użyć w sposób zgodny z typem wskaźnika. Działanie `stind.i2` instrukcji może być zmieniony przez poprzedzającego <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu niejawnego sufiksem instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stind.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="int32" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|54|stind.i4|Magazyny `int32` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Wartość spoczywa na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.i4` Magazynów instrukcji `int32` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.i4` instrukcji można użyć w sposób zgodny z typem wskaźnika. Działanie `stind.i4` instrukcji może być zmieniony przez poprzedzającego <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu niejawnego sufiksem instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stind.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="int64" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|55|stind.i8|Magazyny `int64` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Wartość spoczywa na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.i8` Magazynów instrukcji `int64` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.i8` instrukcji można użyć w sposób zgodny z typem wskaźnika. Działanie `stind.i` instrukcji może być zmieniony przez poprzedzającego <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu niejawnego sufiksem instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stind.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="float32" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|56|stind.r4|Magazyny `float32` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Wartość spoczywa na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.r4` Magazynów instrukcji `float32` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.r4` instrukcji można użyć w sposób zgodny z typem wskaźnika. Działanie `stind.r4` instrukcji może być zmieniony przez poprzedzającego <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu niejawnego sufiksem instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stind.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="float64" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|57|stind.r8|Magazyny `float64` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Wartość spoczywa na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.r8` Magazynów instrukcji `float64` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.r8` instrukcji można użyć w sposób zgodny z typem wskaźnika. Działanie `stind.r8` instrukcji może być zmieniony przez poprzedzającego <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu niejawnego sufiksem instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stind.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość odwołanie do obiektu na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|51|stind.ref|Przechowuje odwołanie do obiektu (typ `O`) wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Wartość spoczywa na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.ref` Instrukcji przechowuje wartość odwołania obiektu na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.ref` instrukcji można użyć w sposób zgodny z typem wskaźnika. Działanie `stind.ref` instrukcji może być zmieniony przez poprzedzającego <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu niejawnego sufiksem instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stind.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bieżąca wartość z góry stosu oceny POP i zapisuje je w zmiennej lokalnej listy od określonego indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|stloc `index`|POP wartość ze stosu i zapisuje go w zmiennej lokalnej `index`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość jest zdjęte ze stosu wylogowuje na stosie i umieszczane w zmiennej lokalnej `index`.  
  
 `stloc` Instrukcji będzie wyświetlana wartość top stosu oceny i przenosi ją do numer zmiennej lokalnej `index`, gdzie zmienne lokalne są numerowane 0 lub nowszej. Typ wartości musi odpowiadać typowi zmiennej lokalnej zgodnie z bieżącą metodę podpisu lokalnego.  
  
 Zapisywanie do zmiennych lokalnych, zawierających wartość całkowitą mniejszą niż 4 bajty obcina wartość przesyłane ze stosu do zmiennej lokalnej. Zmiennoprzecinkowe wartości są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Poprawne instrukcje Microsoft języka pośredniego (MSIL) wymaga, aby `index` jest prawidłowym indeksem lokalnego. Dla `stloc` instrukcji `index` musi znajdować się w zakresie od 0 do 65534 włącznie (w szczególności 65535 jest nieprawidłowy). Z wyjątkiem 65535 przyczyna to pragmatyczne: implementacje prawdopodobnie użyje 2-bajtowych liczb całkowitych do śledzenia zarówno indeksu na komputerze lokalnym, a także łączna liczba zmiennych lokalnych dostępnych dla danej metody. Indeks 65535 dokonano prawidłowe, wymagałoby szersze liczby całkowitej w celu śledzenia liczby zmiennych lokalnych w takiej metody.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `stloc` opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, krótki)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bieżąca wartość z góry stosu oceny POP i zapisuje je w zmiennej lokalnej listy pod indeksem 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0A|stloc.0|Do zmiennej lokalnej 0 będzie wyświetlana wartość ze stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość jest zdjęte ze stosu wylogowuje na stosie i umieszczane w zmiennej lokalnej indeksowany przez 0.  
  
 `stloc.0` Instrukcji będzie wyświetlana wartość top stosu oceny i przenosi ją do zmiennej lokalnej indeksowany przez 0. Typ wartości musi odpowiadać typowi zmiennej lokalnej zgodnie z bieżącą metodę podpisu lokalnego.  
  
 `stloc.0` jest szczególnie efektywne kodowanie do przechowywania wartości w zmiennej lokalnej 0.  
  
 Zapisywanie do zmiennych lokalnych, zawierających wartość całkowitą mniejszą niż 4 bajty obcina wartość przesyłane ze stosu do zmiennej lokalnej. Zmiennoprzecinkowe wartości są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stloc.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bieżąca wartość z góry stosu oceny POP i zapisuje je w zmiennej lokalnej listy pod indeksem 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0B|stloc.1|Do zmiennej lokalnej 1 będzie wyświetlana wartość ze stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość jest zdjęte ze stosu wylogowuje na stosie i umieszczane w zmiennej lokalnej indeksowane według 1.  
  
 `stloc.1` Instrukcji będzie wyświetlana wartość top stosu oceny i przenosi ją do zmiennej lokalnej indeksowane według 1. Typ wartości musi odpowiadać typowi zmiennej lokalnej zgodnie z bieżącą metodę podpisu lokalnego.  
  
 `stloc.1` jest szczególnie efektywne kodowanie do przechowywania wartości w zmiennej lokalnej 1.  
  
 Zapisywanie do zmiennych lokalnych, zawierających wartość całkowitą mniejszą niż 4 bajty obcina wartość przesyłane ze stosu do zmiennej lokalnej. Zmiennoprzecinkowe wartości są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stloc.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bieżąca wartość z góry stosu oceny POP i zapisuje je w zmiennej lokalnej listy pod indeksem 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0C|stloc.2|POP wartość ze stosu do zmiennej lokalnej 2|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość jest zdjęte ze stosu wylogowuje na stosie i umieszczane w zmiennej lokalnej indeksowane według 2.  
  
 `stloc.2` Instrukcji będzie wyświetlana wartość top stosu oceny i przenosi ją do zmiennej lokalnej indeksowane według 2. Typ wartości musi odpowiadać typowi zmiennej lokalnej zgodnie z bieżącą metodę podpisu lokalnego.  
  
 `stloc.2` jest szczególnie efektywne kodowanie do przechowywania wartości w zmiennej lokalnej 2.  
  
 Zapisywanie do zmiennych lokalnych, zawierających wartość całkowitą mniejszą niż 4 bajty obcina wartość przesyłane ze stosu do zmiennej lokalnej. Zmiennoprzecinkowe wartości są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stloc.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bieżąca wartość z góry stosu oceny POP i przechowuje ją w liście zmiennych lokalnych w indeksie 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0D|stloc.3|Do zmiennej lokalnej 3 będzie wyświetlana wartość ze stosu|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość jest zdjęte ze stosu wylogowuje na stosie i umieszczane w zmiennej lokalnej indeksowany przez 3.  
  
 `stloc.3` Instrukcji będzie wyświetlana wartość top stosu oceny i przenosi ją do zmiennej lokalnej indeksowany przez 3. Typ wartości musi odpowiadać typowi zmiennej lokalnej zgodnie z bieżącą metodę podpisu lokalnego.  
  
 `stloc.3` jest szczególnie efektywne kodowanie do przechowywania wartości w zmiennej lokalnej 3.  
  
 Zapisywanie do zmiennych lokalnych, zawierających wartość całkowitą mniejszą niż 4 bajty obcina wartość przesyłane ze stosu do zmiennej lokalnej. Zmiennoprzecinkowe wartości są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stloc.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bieżąca wartość z góry stosu oceny POP i przechowuje ją w liście zmiennych lokalnych w <paramref name="index" /> (forma krótka).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|POP wartość ze stosu i zapisuje go w zmiennej lokalnej `index`, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość jest zdjęte ze stosu wylogowuje na stosie i umieszczane w zmiennej lokalnej `index`.  
  
 `stloc.s` Instrukcji będzie wyświetlana wartość top stosu oceny i przenosi ją do numer zmiennej lokalnej `index`, gdzie zmienne lokalne są numerowane 0 lub nowszej. Typ wartości musi odpowiadać typowi zmiennej lokalnej zgodnie z bieżącą metodę podpisu lokalnego.  
  
 `stloc.s` Instrukcji zapewnia wydajne kodowania dla zmiennych lokalnych 0 do 255.  
  
 Zapisywanie do zmiennych lokalnych, zawierających wartość całkowitą mniejszą niż 4 bajty obcina wartość przesyłane ze stosu do zmiennej lokalnej. Zmiennoprzecinkowe wartości są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `stloc.s` opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiuje wartość o określonym typie ze stosu oceny na adres podany pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Przechowuje wartość typu `class` ze stosu w pamięci.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
2.  Obiekt typu wartości typu `class` spoczywa na stosie.  
  
3.  Obiekt i adres ze stosu; zdjęte ze stosu są obiekt typu wartość znajduje się pod adresem.  
  
 `stobj` Instrukcji kopiuje obiekt typu wartości na adres określony adres (wskaźnik typu `native int`, `*`, lub `&`). Liczba bajtów skopiowanych zależy od rozmiaru klasy reprezentowany przez `class`, token metadanych reprezentujący typ wartości.  
  
 Działanie `stobj` instrukcji może być zmieniony przez poprzedzającego <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.TypeLoadException> jest generowany, jeśli nie można odnaleźć klasy. To jest zwykle wykrycie instrukcje Microsoft języka pośredniego (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stobj` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia wartość pola statycznego wartość ze stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|Zamienia wartość `field` o podanej wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość spoczywa na stosie.  
  
2.  Wartość jest zdjęte ze stosu ze stosu i przechowywane w `field`.  
  
 `stsfld` Instrukcji zamienia wartość pola statycznego wartość ze stosu. `field` to token metadanych, który musi odwoływać się do pola statycznego elementu członkowskiego.  
  
 `stsfld` Instrukcji może być poprzedzony <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.MissingFieldException> jest generowany, jeśli nie można odnaleźć pola w metadanych. Jest to zazwyczaj sprawdzana podczas konwertowania instrukcje Microsoft języka pośredniego (MSIL) do kodu macierzystego, nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `stsfld` opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Odejmuje jedną wartość z innej i umieszcza wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|59|Sub|Odejmuje jedną wartość z innej zwraca wartość liczbową.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value2` jest odejmowany od `value1`.  
  
4.  Wynik spoczywa na stosie.  
  
 Nie wykryto przepełnienia dla operacji liczba całkowita (przepełnienie prawidłowego obsługi, zobacz <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Liczba całkowita odejmowania zawijany, a nie zmienia nasycenie. Na przykład: przy założeniu, 8-bitowych liczb całkowitych, gdzie `value1` jest równa 0 i `value2` jest ustawiona na 1, "zawinięty" wynik będzie 255.  
  
 Przepełnienie zmiennoprzecinkowej zwraca `+inf` (`PositiveInfinity`) lub `-inf` (`NegativeInfinity`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `sub` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Odejmuje jedną liczbę całkowitą z innego, przeprowadza sprawdzanie przepełnienia, a wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DA|sub.ovf|Odejmuje jedną liczbę całkowitą z innego ze sprawdzaniem przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value2` jest odejmowany od `value1` z sprawdzaj przepełnienie.  
  
4.  Wynik spoczywa na stosie.  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Ta operacja jest wykonywana na liczb całkowitych ze znakiem; Użyj wartości zmiennoprzecinkowych <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `sub.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Odejmuje jedną wartość całkowitą bez znaku od siebie, przeprowadza sprawdzanie przepełnienia i wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|Odejmuje jedną wartość całkowitą bez znaku od siebie ze sprawdzaniem przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value2` jest odejmowany od `value1` z sprawdzaj przepełnienie.  
  
4.  Wynik spoczywa na stosie.  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie można przedstawić w typie wyniku.  
  
 Ta operacja jest wykonywana na liczb całkowitych ze znakiem; Użyj wartości zmiennoprzecinkowych <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `sub.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implementuje tabeli przeskoku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|Przełącz (`N`, `t1`, `t2`... `tN`)|Przechodzi do jednego z `N` wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość spoczywa na stosie.  
  
2.  Wartość jest zdjęte ze stosu ze stosu i wykonywania jest przekazywany do instrukcji przy przesunięciu indeksowane według wartości, gdy wartość jest mniejsza niż `N`.  
  
 `switch` Instrukcji implementuje tabeli przeskoku. Format instrukcji jest `unsigned int32` reprezentujący liczbę elementów docelowych `N`, a następnie `N` określania wartości int32 przejść elementów docelowych. Te cele są reprezentowane jako przesunięcia (dodatnie lub ujemne) od początku instrukcji czynności opisane w tym `switch` instrukcji.  
  
 `switch` Instrukcji będzie wyświetlana wartość ze stosu i porównuje, liczbą całkowitą bez znaku do `N`. Jeśli wartość jest mniejsza niż `N`, wykonanie jest przenoszona do docelowego indeksowane według wartości, której elementy docelowe są ponumerowane od 0 (na przykład pierwszy element docelowy ma wartość 0, przyjmuje wartość 1, drugi docelowych i tak dalej). Jeśli wartość jest większa niż lub równa `N`, wykonywanie będzie kontynuowane przy następnej instrukcji (poniżej).  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, formantu można przesłać tylko jako pierwszy z tymi prefiksami.  
  
 Kontroli transferu do i z `try`, `catch`, `filter`, i `finally` bloków nie może zostać wykonana przez tej instrukcji. (Przeniesienie są znacznie ograniczone i musi użyć instrukcji pozostaw).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `switch` opcode. `Label[]` Argument jest tablicą reprezentujący 32-bitowe przesunięcia etykiety.  
  
-   ILGenerator.Emit(OpCode, Label[])  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia użycie `Switch` opcode, aby wygenerować skok użycie tablicy <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wykonuje instrukcję wywołania metody mieć sufiks taki sposób, że metoda bieżącej ramki stosu zostanie usunięty przed wykonaniem instrukcji rzeczywistego wywołania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 14|tail.|Kolejne wywołania kończy bieżącej metody|  
  
 Brak zachowania przejścia stosu zdefiniowane dla tej instrukcji.  
  
 `tail` Instrukcji prefiksu musi bezpośrednio poprzedzać <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, lub <xref:System.Reflection.Emit.OpCodes.Callvirt> instrukcji. Oznacza to, że ramka stosu bieżącej metody powinny zostać usunięte przed wykonaniem instrukcji wywołania. On również oznacza to, że wartość zwracana z wywołania następujące jest również wartość zwracaną przez metodę bieżącego, wywołanie może zostać przekształcone skoku cross-method.  
  
 Stos musi być pusty, z wyjątkiem argumenty przesyłanych przez następujące wywołanie. Instrukcja według instrukcji wywołania musi być ret. W związku z tym jest tylko prawidłowy kod sekwencji `tail. call` (lub `calli` lub `callvirt`). Poprawne instrukcje Microsoft języka pośredniego (MSIL) nie musi utworzyć gałąź do `call` instrukcji, ale może tworzyć gałęzi do kolejnego <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 Nie można odrzucić bieżącej ramki, gdy formant jest przenoszone z kodzie niezaufanym zaufanego kodu, ponieważ może to zagrozić kodu tożsamości zabezpieczeń. Sprawdza zabezpieczeń .NET Framework, w związku z tym może spowodować `tail` mają być ignorowane, pozostawiając standard <xref:System.Reflection.Emit.OpCodes.Call> instrukcji. Podobnie, aby umożliwić zakończenia zsynchronizowane regionu wykonywane po wywołaniu zwraca, `tail` prefiks jest ignorowane w przypadku używać do kończenia metodę, która jest oznaczony jako zsynchronizowane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `tail` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Wystąpienie obiektu Opcode.</param>
        <summary>Zwraca wartość PRAWDA lub FAŁSZ, jeśli podany kod operacji przyjmuje argument pojedynczy bajt.</summary>
        <returns>
          <see langword="True" /> lub <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można znaleźć, które używa MSIL są "Krótka forma", do użycia w zoptymalizowanym kodzie.  
  
 `TakesSingleByteArgument` Zwraca `true` Jeśli <xref:System.Reflection.Emit.OpCode> wystąpienia pobiera argument jednobajtowych w następujących przypadkach:  
  
-   Kod operacji wykonuje instrukcję gałęzi adresu o rozmiarze bajtów (na przykład <xref:System.Reflection.Emit.OpCodes.Br_S> i <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   Kod operacji wypchnięcia wartość bajtu na stosie (na przykład <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   Kod operacji odwołuje się do zmiennej lub argumentu za pośrednictwem o rozmiarze bajtów "Krótka forma" (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloc_S> i <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 W przeciwnym razie zwraca `false`.  
  
 Na poniższym przykładzie przedstawiono użycie `TakesSingleByteArgument` w czasie wykonywania odbicia do `OpCodes` klasy i przetestowania czy każdego `OpCode` pola przyjmuje argument jednobajtowe.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obecnie zwraca obiekt wyjątku na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7A|throw|Zgłasza wyjątek.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu (w celu wyjątek) spoczywa na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte ze stosu ze stosu i został zwrócony wyjątek.  
  
 `throw` Instrukcji zgłasza obiekt wyjątku (typ `O`) aktualnie na stosie.  
  
 <xref:System.NullReferenceException> jest generowany, gdy odwołanie do obiektu jest odwołanie o wartości null.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `throw` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy adres obecnie nad stosu oceny nie może być wyrównane fizycznych rozmiar bezpośrednio po <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, lub <see langword="cpblk" /> instrukcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 12 < `unsigned int8` >|niewyrównany. `alignment`|Wskazuje, że kolejne wskaźnik instrukcji może być niewyrównany.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
 `Unaligned` Określa, że adres (niezarządzany wskaźnik `native int`) na stosie nie może być wyrównany do fizycznych rozmiar bezpośrednio po `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, lub `cpblk` instrukcji. Oznacza to aby uzyskać <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instrukcji wyrównanie adres nie może być do granicy 4-bajtowych. Aby uzyskać `initblk` i `cpblk` domyślne wyrównanie to architektura zależne (4-bajtowych na 32-bitowych procesorach, 8-bajtowych na 64-bitowych procesorach). Generatory kodu, które nie ograniczają ich dane wyjściowe do rozmiaru 32-bitowego programu word, należy użyć `unaligned` Jeśli wyrównanie nie jest znane w czasie kompilacji z 8-bajtowych.  
  
 Wartość wyrównania musi być 1, 2 lub 4 i oznacza, że wygenerowany kod powinien wniosku, że adres jest byte, znaków dwubajtowych lub odpowiednio quad bajtowych wyrównane. Należy pamiętać, że przejściowy wskaźników (typ `*`) zawsze są wyrównane.  
  
 Podczas wyrównanie `cpblk` instrukcji logicznie wymaga dwóch liczb (jeden dla źródła) i jeden dla miejsca docelowego, nie ma żadnego zauważalnego wpływu na wydajność jeśli tylko określono liczby.  
  
 `unaligned` i `volatile` prefiksy można łączyć w jednej kolejności. Musi bezpośrednio poprzedzać `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, lub `cpblk` instrukcji. Tylko <xref:System.Reflection.Emit.OpCodes.Volatile> prefiks jest dozwolony dla <xref:System.Reflection.Emit.OpCodes.Ldsfld> i <xref:System.Reflection.Emit.OpCodes.Stsfld> instrukcje.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `unaligned` opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
-   ILGenerator.Emit (Opcode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje opakowanego reprezentacja typu wartości do postaci rozpakowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|79 < `T` >|unbox — `valType`|Wyodrębnia dane typu wartość z `obj`, jego reprezentacja ramce.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu spoczywa na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte ze stosu ze stosu i rozpakowany do wskaźnika typu wartości.  
  
3.  Wartość wskaźnika typu spoczywa na stosie.  
  
 Typ wartości ma dwa oddzielne reprezentacje w ramach wspólnej infrastruktury języka (CLI):  
  
-   "Raw" formularz używany, gdy typ wartości jest osadzony w innym obiekcie.  
  
-   Formy "opakowanej", gdzie dane w typ wartości jest opakowana (opakowany) do obiektu, może istnieć jako niezależne jednostki.  
  
 `unbox` Instrukcji konwertuje odwołanie do obiektu (typ `O`), opakowany reprezentacja typu wartości na wartość typu wskaźnik (wskaźnik zarządzanego typu `&`), jego rozpakowany formularza. Podana wartość typu (`valType`) jest token metadanych wskazujący typ zawartych w ramce obiektu typu wartości.  
  
 W odróżnieniu od <xref:System.Reflection.Emit.OpCodes.Box>, wymaganego do skopiowania typu wartości do użycia w obiekcie, `unbox` nie jest wymagane do skopiowania na wartość typu obiektu. Zwykle po prostu oblicza adresu typu wartości, który jest już obecny w ramce obiektu.  
  
 <xref:System.InvalidCastException> jest generowany, jeśli obiekt nie jest opakowany jako `valType`.  
  
 <xref:System.NullReferenceException> jest generowany, gdy odwołanie do obiektu jest odwołanie o wartości null.  
  
 <xref:System.TypeLoadException> jest generowany, jeśli typ wartości `valType` nie można odnaleźć. To jest zwykle wykrycie instrukcje Microsoft języka pośredniego (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `unbox` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje opakowanego reprezentacja typu określonego w instrukcji do postaci rozpakowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu język pośredni (MSIL) firmy Microsoft, wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A5 < `T` >|unbox.any `typeTok`|Wyodrębnianie danych z `obj`, jego reprezentacja ramce.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `obj` spoczywa na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte ze stosu ze stosu i rozpakowany na typ określony w instrukcji.  
  
3.  Wynikowy typ odwołanie lub wartość obiektu spoczywa na stosie.  
  
 Gdy jest stosowany do formy opakowanej typu wartości `unbox.any` instrukcji wyodrębnianie wartości zawartych w `obj` (typu `O`) i dlatego jest odpowiednikiem `unbox` następuje `ldobj`.  
  
 Gdy jest stosowany do typu odwołania `unbox.any` instrukcji ma ten sam efekt co `castclass` `typeTok`.  
  
 Jeśli argument `typeTok` jest parametr typu ogólnego, a następnie zachowania w czasie wykonywania jest określana przez typ określony dla parametru typu ogólnego.  
  
 <xref:System.InvalidCastException> wygenerowany, jeśli `obj` nie jest typem ramce.  
  
 <xref:System.NullReferenceException> wygenerowany, jeśli `obj` jest odwołanie o wartości null.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `unbox.any` opcode:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że adres obecnie nad stosu oceny może być nietrwałe i wyników odczytu lokalizacji nie można buforować lub w wielu sklepach do tej lokalizacji nie można pominąć.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 13|volatile.|Wskazuje, że odwołanie do wskaźnika kolejnych jest nietrwały.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres spoczywa na stosie.  
  
 `volatile`. Określa, czy adres jest adresem volatile (to znaczy go można odwoływać się zewnętrznie w bieżącym wątku wykonywania) oraz wynikiem odczytu lokalizacji nie można buforować lub w wielu sklepach do tej lokalizacji nie można pominąć. Oznaczenie dostępu zgodnie z `volatile` ma wpływ tylko z jednym dostępu; innych operacji uzyskania dostępu do tej samej lokalizacji, które muszą być oznaczone oddzielnie. Dostęp do lokalizacji nietrwałe nie trzeba przeprowadzać atomowo.  
  
 <xref:System.Reflection.Emit.OpCodes.Unaligned> i `volatile` prefiksy można łączyć w jednej kolejności. Musi bezpośrednio poprzedzać `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, lub `cpblk` instrukcji. Tylko `volatile` prefiks jest dozwolony dla <xref:System.Reflection.Emit.OpCodes.Ldsfld> i <xref:System.Reflection.Emit.OpCodes.Stsfld> instrukcje.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `volatile` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oblicza iloczynu bitowego XOR górnej wartości na stosie oceny wypychanie wyników na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowy instrukcję i plik formatu zestawu Microsoft języka pośredniego (MSIL), wraz z podsumowaniem krótki odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|61|xor|Oblicza iloczynu bitowego XOR z dwóch wartości liczby całkowitej i zwraca liczbę całkowitą.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` spoczywa na stosie.  
  
2.  `value2` spoczywa na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu i ich bitowego XOR obliczana.  
  
4.  Iloczynu bitowego XOR z `value2` i `value1` spoczywa na stosie.  
  
 `xor` Instrukcji oblicza iloczynu bitowego XOR z dwóch pierwszych wartości na stosie i pozostawienie wynik na stosie.  
  
 `Xor` jest operacją określonej liczby całkowitej.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenie metody można użyć `xor` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
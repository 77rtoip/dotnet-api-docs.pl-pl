<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d6d2cd6f31cc97089037cf8c47853b3dd6d37d7e" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="58875583" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia reprezentujących pola instrukcji Microsoft Intermediate Language (MSIL) emisji przez <see cref="T:System.Reflection.Emit.ILGenerator" /> elementy członkowskie klasy (taki jak <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowy opis rozkazów elementu członkowskiego, zobacz dokumentację Common Language Infrastructure (CLI), szczególnie "partycji III: Ustaw CIL instrukcji"oraz" Partition II: Definicja metadanych i semantyka". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w witrynie Ecma International w sieci Web.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano metodę dynamiczną za pomocą konstrukcji <xref:System.Reflection.Emit.ILGenerator> do emitowania `OpCodes` do <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dodaje dwie wartości, a następnie wypycha wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|58|add|Dodaje dwóch wartości liczbowych, zwracając wartość liczbową.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest dodawany do `value2`.  
  
4.  Wyniki są wypychane na stosie.  
  
 Nie wykryto przepełnienia liczby całkowitej operacji (do obsługi właściwego przepełnienie zobacz <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Dodanie liczby całkowitej opakowuje, a nie zmienia nasycenie. Na przykład przy założeniu 8-bitowych liczb całkowitych gdzie `value1` jest ustawiona na wartość 255 i `value2` jest ustawiona na 1, opakowaną wynikiem jest 0, a nie na 256.  
  
 Przepełnienie zmiennoprzecinkowej zwraca `+inf` (`PositiveInfinity`) lub `-inf` (`NegativeInfinity`).  
  
 W poniższej tabeli wymieniono typy operand dopuszczalne i ich odpowiedni typ danych wyniku. Jeśli brak wpisu dla kombinacji określonego typu (na przykład `int32` i `float`; `int32` i `int64`), jest nieprawidłowy Microsoft Intermediate Language (MSIL) i generuje błąd.  
  
|argument operacji|Typ wartość1|Typ wartość2|Typ wyniku|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `add` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dodanie dwóch liczb całkowitych, przeprowadza sprawdzanie przepełnienia i umieszcza wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D6|add.ovf|Dodaje dwie wartości liczby całkowitej ze znakiem ze sprawdzeniem przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest dodawany do `value2` ze sprawdzaniem dla przepełnienia.  
  
4.  Wyniki są wypychane na stosie.  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie jest reprezentowana w typie wyniku.  
  
 Można wykonać tej operacji na liczby całkowite ze znakiem. W przypadku wartości zmiennoprzecinkowe, użyj <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 W poniższej tabeli wymieniono typy operand dopuszczalne i ich odpowiedni typ danych wyniku. Jeśli brak wpisu dla kombinacji określonego typu (na przykład `int32` i `float`; `int32` i `int64`), jest nieprawidłowy instrukcji Microsoft Intermediate Language (MSIL) i generuje błąd.  
  
|argument operacji|Typ wartość1|Typ wartość2|Typ wyniku|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `add.ovf` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dodaje dwie wartości liczb całkowitych bez znaku, przeprowadza sprawdzanie przepełnienia i umieszcza wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|Dodaje dwie wartości liczb całkowitych bez znaku ze sprawdzeniem przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest dodawany do `value2` ze sprawdzaniem dla przepełnienia.  
  
4.  Wyniki są wypychane na stosie.  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie jest reprezentowana w typie wyniku.  
  
 Można wykonać tej operacji na liczby całkowite ze znakiem. W przypadku wartości zmiennoprzecinkowe, użyj <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 W poniższej tabeli wymieniono typy operand dopuszczalne i ich odpowiedni typ danych wyniku. Jeśli brak wpisu dla kombinacji określonego typu (na przykład `int32` i `float`; `int32` i `int64`), jest nieprawidłowy instrukcji Microsoft Intermediate Language (MSIL) i generuje błąd.  
  
|argument operacji|Typ wartość1|Typ wartość2|Typ wyniku|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `add.ovf.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oblicza dwie wartości bitowe AND i umieszcza wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Instrukcja|Opis|  
|------------|-----------------|-----------------|  
|5F|and|Określa bitowe AND dwóch wartości całkowitych.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value1` i `value2` są zdjęte ze stosu ze stosu; dwie wartości bitowe AND jest obliczany.  
  
4.  Wyniki są wypychane na stosie.  
  
 `and` Instrukcja oblicza iloczynu bitowego AND wartości dwóch pierwszych na stosie i pozostawia wynik na stosie.  
  
 `And` jest operacją specyficzne dla liczby całkowitej.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `and` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca niezarządzany wskaźnik do listy argumentów bieżącej metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 00|lista_argumentów|Zwraca uchwyt listy argumentów dla bieżącej metody.|  
  
 Nie zachowania stosu oceny są wykonywane przez tę operację.  
  
 `arglist` Instrukcja zwraca uchwyt nieprzezroczyste (niezarządzany wskaźnik typu `native int`) reprezentujący listy argumentów bieżącej metody. Tego dojścia jest prawidłowy tylko w trakcie okresu istnienia bieżącej metody. Można jednak przekazać dojście do innych metod, tak długo, jak bieżąca metoda znajduje się na wątek kontroli. Można wykonać tylko `arglist` instrukcji w metodzie, która przyjmuje zmienną liczbę argumentów.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `arglist` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfer kontroli do instrukcji docelowej, jeśli dwie wartości są równe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|Gałąź do instrukcji docelowej przesunięciem `target` Jeśli dwie wartości są równe.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest równa `value2`, gałąź jest wykonywane.  
  
 `beq` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest równa `value2`. Efekt jest taki sam jak wykonywanie `ceq` instrukcji, następuje `brtrue` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Typy operand dopuszczalne są hermetyzowane poniżej:  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów.  
  
 Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji (Przeniesienie takie są znacznie ograniczone i musi być <xref:System.Reflection.Emit.OpCodes.Leave> instrukcji zamiast tego).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `beq` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontrolę instrukcję target (krótka), jeśli dwie wartości są równe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq.s `target`|Gałąź do instrukcji docelowej przesunięciem `target` przypadku równości, krótka|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest równa `value2`, gałąź jest wykonywane.  
  
 `beq.s` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest równa `value2`. Efekt jest taki sam jak wykonywanie `ceq` instrukcji, następuje `brtrue` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 1-bajtowe oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Typy operand dopuszczalne są hermetyzowane poniżej:  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów.  
  
 Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji (Przeniesienie takie są znacznie ograniczone i musi być <xref:System.Reflection.Emit.OpCodes.Leave> instrukcji zamiast tego).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `beq.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfer kontroli do instrukcji docelowej, jeśli pierwsza wartość jest większa lub równa wartości drugiego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|Gałąź do instrukcji docelowej od określonego przesunięcia, jeśli pierwsza wartość jest większa lub równa wartości drugiego.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż lub równa `value2`, gałąź jest wykonywane.  
  
 `bge` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest większa niż lub równa `value2`. Efekt jest taka sama jak wykonywanie `clt.un` instrukcji, następuje `brfalse` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `bge` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontrolę instrukcję target (krótka), jeśli pierwsza wartość jest większa lub równa wartości drugiego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge.s `target`|Gałąź do instrukcji docelowej od określonego przesunięcia, jeśli pierwsza wartość jest większa lub równa wartości drugiego, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż lub równa `value2`, gałąź jest wykonywane.  
  
 `bge.s` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest większa niż lub równa `value2`. Efekt jest taka sama jak wykonywanie `clt.un` instrukcji, następuje `brfalse` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 1-bajtowe oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `bge.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfer kontroli do instrukcji docelowej, jeśli pierwsza wartość jest większa niż wartość drugiego podczas porównywania wartości liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.UN `target`|Gałąź do instrukcji docelowej od określonego przesunięcia, jeśli pierwsza wartość jest większa lub równa wartości drugiego (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż lub równa `value2`, gałąź jest wykonywane.  
  
 `bge.un` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest większa niż lub równa `value2`, w porównaniu z przy użyciu liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane. Efekt jest taka sama jak wykonywanie `clt` instrukcji, następuje `brfalse` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `bge.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontrolę instrukcję target (krótka), jeśli pierwsza wartość jest większa niż wartość drugiego podczas porównywania wartości liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.UN.s `target`|Gałąź do instrukcji docelowej od określonego przesunięcia, jeśli pierwsza wartość jest większa lub równa wartości (wartości bez znaku), drugi krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż lub równa `value2`, gałąź jest wykonywane.  
  
 `bge.un.s` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest większa niż lub równa `value2`, w porównaniu z przy użyciu liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane. Efekt jest taka sama jak wykonywanie `clt` instrukcji, następuje `brfalse` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 1-bajtowe oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `bge.un.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfer kontroli do instrukcji docelowej, jeśli pierwsza wartość jest większa niż wartość drugiego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3D < `int32` >|BGT `target`|Gałąź do instrukcji docelowej od określonego przesunięcia, jeśli pierwsza wartość jest większa niż wartość drugiego.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż `value2`, gałąź jest wykonywane.  
  
 `bgt` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest większa niż `value2`. Efekt jest taka sama jak wykonywanie `cgt` instrukcji, następuje `brtrue` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `bgt` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontrolę instrukcję target (krótka), jeśli pierwsza wartość jest większa niż wartość drugiego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|30 < `int8` >|BGT.s `target`|Gałąź do instrukcji docelowej od określonego przesunięcia, jeśli pierwsza wartość jest większa niż wartość drugiego krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż `value2`, gałąź jest wykonywane.  
  
 `bgt.s` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest większa niż `value2`. Efekt jest taka sama jak wykonywanie `cgt` instrukcji, następuje `brtrue` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 1-bajtowe oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `bgt.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfer kontroli do instrukcji docelowej, jeśli pierwsza wartość jest większa niż wartość drugiego podczas porównywania wartości liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|42 < `int32` >|BGT.UN `target`|Gałąź do instrukcji docelowej od określonego przesunięcia, jeśli pierwsza wartość jest większa od drugiej wartości (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż `value2`, gałąź jest wykonywane.  
  
 `bgt.un` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest większa niż `value2`, w porównaniu z przy użyciu liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane. Efekt jest taka sama jak wykonywanie `cgt.un` instrukcji, następuje `brtrue` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `bgt.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontrolę instrukcję target (krótka), jeśli pierwsza wartość jest większa niż wartość drugiego podczas porównywania wartości liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s `target`|Gałąź do instrukcji docelowej od określonego przesunięcia, jeśli pierwsza wartość jest większa od drugiej wartości (wartości bez znaku), krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest większa niż `value2`, gałąź jest wykonywane.  
  
 `bgt.un.s` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest większa niż `value2`, w porównaniu z przy użyciu liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane. Efekt jest taka sama jak wykonywanie `cgt.un` instrukcji, następuje `brtrue` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 1-bajtowe oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `bgt.un.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontrolki do instrukcji docelowej Jeżeli pierwsza wartość jest mniejsza lub równa wartości drugiego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3E `<int32>`|Włącz `target`|Gałąź do instrukcji docelowej od określonego przesunięcia, jeśli pierwsza wartość jest mniejsza lub równa wartości drugiego.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż lub równa `value2`, gałąź jest wykonywane.  
  
 `ble` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest mniejsza niż lub równa `value2`. Efekt jest taka sama jak wykonywanie `cgt` instrukcji (`cgt.un` dla wartości zmiennoprzecinkowe) następuje `brfalse` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ble` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontrolę instrukcję target (krótka), jeśli pierwsza wartość jest mniejsza niż wartość drugiego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|31 `<int8>`|BLE.s `target`|Gałąź do instrukcji docelowej od określonego przesunięcia, jeśli pierwsza wartość jest mniejsza lub równa wartości drugiego, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż lub równa `value2`, gałąź jest wykonywane.  
  
 `ble.s` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest mniejsza niż lub równa `value2`. Efekt jest taka sama jak wykonywanie `cgt` instrukcji (`cgt.un` dla wartości zmiennoprzecinkowe) instrukcji, następuje`brfalse` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 1-bajtowe oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ble.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfer kontroli do instrukcji docelowej, jeśli pierwsza wartość jest mniejsza lub równa wartości drugiego podczas porównywania niepodpisanych liczb całkowitych lub wartości zmiennoprzecinkowych nieuporządkowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|43 `<int32>`|BLE.UN `target`|Gałąź do instrukcji docelowej od określonego przesunięcia, jeśli pierwsza wartość jest mniejsza niż lub równa wartości drugiego (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż lub równa `value2`, gałąź jest wykonywane.  
  
 `ble.un` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest mniejsza niż lub równa `value2`, w porównaniu z przy użyciu liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane. Efekt jest taka sama jak wykonywanie `cgt.un` instrukcji (`cgt` dla wartości zmiennoprzecinkowe) następuje `brfalse` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ble.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery kontrolę instrukcję target (krótka), jeśli pierwsza wartość jest mniejsza lub równa wartości drugiego podczas porównywania niepodpisanych liczb całkowitych lub wartości zmiennoprzecinkowych nieuporządkowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|36 `<int8>`|BLE.UN.s `target`|Gałąź do instrukcji docelowej od określonego przesunięcia, jeśli pierwsza wartość jest mniejsza lub równa wartości (wartości bez znaku), drugi krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż lub równa `value2`, gałąź jest wykonywane.  
  
 `ble.un.s` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest mniejsza niż lub równa `value2`, w porównaniu z przy użyciu liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane. Efekt jest taka sama jak wykonywanie `cgt.un` instrukcji (`cgt` dla wartości zmiennoprzecinkowe) następuje `brfalse` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 1-bajtowe oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ble.un.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kontrolka transferu do instrukcji docelowej, jeśli pierwsza wartość jest mniejsza od drugiej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3F < `int32` >|Blt `target`|Gałąź do instrukcji docelowej w określone przesunięcie, jeśli pierwsza wartość jest mniejsza od drugiej wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż `value2`, gałąź jest wykonywane.  
  
 `blt` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest mniejsza niż lub równa `value2`. Efekt jest taka sama jak wykonywanie `clt` instrukcji, następuje `brtrue` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `blt` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie do instrukcji docelowej (krótka), jeśli pierwsza wartość jest mniejsza niż wartość drugiego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|32 < `int8` >|Blt.s `target`|Gałąź do instrukcji docelowej w określone przesunięcie, jeśli pierwsza wartość jest mniejsza niż wartość drugiego krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż `value2`, gałąź jest wykonywane.  
  
 `blt.s` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest mniejsza niż `value2`. Efekt jest taka sama jak wykonywanie `clt` instrukcji, następuje `brtrue` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 1-bajtowe oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `blt.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kontrolka transferu do instrukcji docelowej, jeśli pierwsza wartość jest mniejsza od drugiej wartości podczas porównywania wartości liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|44 < `int32` >|Blt.UN `target`|Gałąź do instrukcji docelowej w określone przesunięcie, jeśli pierwsza wartość jest mniejsza od drugiej wartości (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż `value2`, gałąź jest wykonywane.  
  
 `blt.un` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest mniejsza niż `value2`, w porównaniu z przy użyciu liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane. Efekt jest taka sama jak wykonywanie `clt.un` instrukcji, następuje `brtrue` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `blt.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfer kontroli instrukcję target (krótka), jeśli pierwsza wartość jest mniejszy od drugiego wartości podczas porównywania niepodpisanych liczb całkowitych lub wartości zmiennoprzecinkowych nieuporządkowaną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s `target`|Gałąź do instrukcji docelowej w określone przesunięcie, jeśli pierwsza wartość jest mniejsza od drugiej wartości (wartości bez znaku), krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` jest mniejsza niż `value2`, gałąź jest wykonywane.  
  
 `blt.un` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` jest mniejsza niż `value2`, w porównaniu z przy użyciu liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane. Efekt jest taka sama jak wykonywanie `clt.un` instrukcji, następuje `brtrue` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `blt.un.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfery sterowania instrukcji docelowej w przypadku dwóch wartości całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowaną nie są takie same.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|40 < `int32` >|BNE.UN `target`|Gałąź z obiektem docelowym instrukcji od określonego przesunięcia, jeśli dwa niepodpisanych liczb całkowitych są nierówne (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` nie jest równa `value2`, gałąź jest wykonywane.  
  
 `bne.un` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` nie jest równa `value2`, w porównaniu z przy użyciu liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane. Efekt jest taka sama jak wykonywanie `ceq` instrukcji, następuje `brfalse` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `bne.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie do instrukcji docelowej (krótka) po dwóch niepodpisanych liczb całkowitych lub wartości zmiennoprzecinkowych nieuporządkowaną nie są takie same.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|33 < `int8` >|BNE.UN.s `target`|Gałąź z obiektem docelowym instrukcji od określonego przesunięcia, jeśli dwa niepodpisanych liczb całkowitych są nie równa się (wartości bez znaku), krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; Jeśli `value1` nie jest równa `value2`, gałąź jest wykonywane.  
  
 `bne.un` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value1` nie jest równa `value2`, w porównaniu z przy użyciu liczb całkowitych bez znaku lub wartości zmiennoprzecinkowych nieuporządkowane. Efekt jest taka sama jak wykonywanie `ceq` instrukcji, następuje `brfalse` gałąź do instrukcji określony element docelowy. Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `bne.un.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje typ wartości na odwołanie do obiektu (typ <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8C < `T` >|Pole `valTypeToken`|Konwertuj typ wartości (typu określonego w `valTypeToken`) na odwołanie do obiektu wartość true.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Typ wartości są wypychane na stosie.  
  
2.  Typ wartości zostanie zdjęte ze stosu; `box` operacja została wykonana.  
  
3.  Odwołanie do obiektu na wynikowy typ wartości "spakowane" są wypychane na stosie.  
  
 Typ wartości ma dwa oddzielne reprezentacje w ramach Common Language Infrastructure (CLI):  
  
-   Formularz "raw" używany, gdy typ wartości jest osadzony w innym obiekcie lub na stosie.  
  
-   Formularz "spakowane", gdzie dane w typ wartości opakowany jest (opakowany) obiektu, dzięki czemu może istnieć jako niezależne jednostki.  
  
 `box` Instrukcji konwertuje typ wartości (rozpakowany) "raw" na odwołanie do obiektu (typ `O`). Jest to realizowane przez utworzenie nowego obiektu i kopiowanie danych z typu wartości do nowo przydzielonego obiektu. `valTypeToken` jest token metadanych wskazującą rodzaj typu wartości na stosie.  
  
 <xref:System.OutOfMemoryException> jest generowany, jeśli pamięć jest niewystarczająca do spełnienia żądania.  
  
 <xref:System.TypeLoadException> jest generowany, jeśli nie można odnaleźć klasy. To jest zwykle wykrycie Microsoft Intermediate Language (MSIL) jest konwertowana do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `box` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezwarunkowo przekazuje sterowanie do instrukcji docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|Gałęzie, które mają instrukcję docelowy od określonego przesunięcia.|  
  
 Nie zachowania stosu oceny są wykonywane przez tę operację.  
  
 `br` Instrukcji bezwarunkowo przekazuje sterowanie do instrukcji docelowej. Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `br` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezwarunkowo przekazuje sterowanie do instrukcji docelowej (krótka).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br.s `target`|Gałęzie, które mają instrukcję docelowy od określonego przesunięcia krótka.|  
  
 Nie zachowania stosu oceny są wykonywane przez tę operację.  
  
 `br.s` Instrukcji bezwarunkowo przekazuje sterowanie do instrukcji docelowej. Instrukcji docelowej jest reprezentowany jako 1-bajtowe oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `br.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sygnały Common Language Infrastructure (CLI) informuje debuger, że punkt przerwania został uruchomiony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|01|break|informuje debuger został osiągnięty punkt przerwania.|  
  
 Nie zachowania stosu oceny są wykonywane przez tę operację.  
  
 `break` Instrukcja to do obsługi debugowania. Sygnały go interfejs wiersza polecenia i informuje debuger, że punkt przerwania został uruchomiony. Go nie ma innych wpływu na stan interpretera.  
  
 `break` Instrukcji ma taki najmniejsza możliwa instrukcji rozmiar Włączanie kod stosowanie poprawek do punktu przerwania i generuje minimalne zakłóceń w otaczającym kodem.  
  
 `break` Instrukcji może pułapek do debugera, nic nie rób lub zgłosić wyjątek zabezpieczeń. Dokładne zachowanie zależy od implementacji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `break` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie do instrukcji docelowej, jeśli <paramref name="value" /> jest <see langword="false" />, odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), lub wartość zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|Gałęzie, które mają instrukcji docelowej, w określonym przesunięciu if `false`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie przez poprzednią operację.  
  
2.  `value` zostanie zdjęte ze stosu; Jeśli `value` jest `false`, rozgałęzić `target`.  
  
 `brfalse` Instrukcji (i jego aliasy `brnull` i `brzero`) przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value` (typu `int32`, `int64`, odwołanie do obiektu `O`, zarządzana wskaźnika `&`, przejściowe wskaźnika `*`, `native int`) ma wartość zero (`false`). Jeśli `value` jest różna od zera (`true`) program kontynuuje wykonywanie następnej instrukcji.  
  
 Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `brfalse` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie do instrukcji docelowej, jeśli <paramref name="value" /> jest <see langword="false" />, odwołanie o wartości null lub wartość zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|Gałęzie, które mają instrukcji docelowej, w określonym przesunięciu if `false`, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie przez poprzednią operację.  
  
2.  `value` zostanie zdjęte ze stosu; Jeśli `value` jest `false`, rozgałęzić `target`.  
  
 `brfalse.s` Instrukcji (i jego aliasy `brnull` i `brzero`) przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value` (typu `int32`, `int64`, odwołanie do obiektu `O`, zarządzana wskaźnika `&`, przejściowe wskaźnika `*`, `native int`) ma wartość zero (`false`). Jeśli `value` jest różna od zera (`true`) program kontynuuje wykonywanie następnej instrukcji.  
  
 Instrukcji docelowej jest reprezentowany jako 1-bajtowe oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `brfalse.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie do instrukcji docelowej, jeśli <paramref name="value" /> jest <see langword="true" />, nie ma wartości null lub różna od zera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|Rozgałęzić do instrukcji docelowej, od określonego przesunięcia, jeśli różna od zera (`true`).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie przez poprzednią operację.  
  
2.  `value` zostanie zdjęte ze stosu; Jeśli `value` jest `true`, rozgałęzić `target`.  
  
 `brtrue` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value` (typ `native int`) jest różna od zera (`true`). Jeśli `value` wynosi zero (`false`) program kontynuuje wykonywanie następnej instrukcji.  
  
 Jeśli `value` jest odwołanie do obiektu (typ `O`) następnie `brinst` (alias `brtrue`) przekazuje sterowanie, jeśli termin reprezentuje wystąpienie obiektu (na przykład, jeśli nie jest odwołanie do obiektu o wartości null; zobacz <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Instrukcji docelowej jest reprezentowany jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `brtrue` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie do instrukcji docelowej (krótka), jeśli <paramref name="value" /> jest <see langword="true" />, nie ma wartości null lub różna od zera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|Rozgałęzić do instrukcji docelowej, od określonego przesunięcia, jeśli różna od zera (`true`), krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie przez poprzednią operację.  
  
2.  `value` zostanie zdjęte ze stosu; Jeśli `value` jest `true`, rozgałęzić `target`.  
  
 `brtrue.s` Instrukcji przekazuje sterowanie do instrukcji określonego obiektu docelowego, jeśli `value` (typ `native int`) jest różna od zera (`true`). Jeśli `value` wynosi zero (`false`) program kontynuuje wykonywanie następnej instrukcji.  
  
 Jeśli `value` jest odwołanie do obiektu (typ `O`) następnie `brinst` (alias `brtrue`) przekazuje sterowanie, jeśli termin reprezentuje wystąpienie obiektu (na przykład, jeśli nie jest odwołanie do obiektu o wartości null; zobacz <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Instrukcji docelowej jest reprezentowany jako 1-bajtowe oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów. Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `brtrue.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wywołuje metodę wskazywanym przez deskryptor metody sukces.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|28 < `T` >|Wywołania `methodDesc`|Wywołaj metodę opisanego przez `methodDesc`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Argumenty metody `arg1` za pośrednictwem `argN` są wypychane na stosie.  
  
2.  Argumenty metody `arg1` za pośrednictwem `argN` są zdjęte ze stosu ze stosu; wywołania metody które odbywa się z tymi argumentami i kontrola jest przekazywana do metody odwołuje się deskryptor metody. Po zakończeniu wartość zwracana jest generowany przez metodę obiekt wywoływany i wysłane do obiektu wywołującego.  
  
3.  Wartość zwracana jest wypychane na stosie.  
  
 `call` Instrukcja wywołuje metodę, wskazywanym przez deskryptor metody przekazaną za pomocą instrukcji. Deskryptor metody jest token metadanych, który wskazuje metodę do wywołania i liczbę, typ i kolejność argumentów, które zostały umieszczone w stosie, które mają być przekazane do tej metody, a także konwencja wywołania, które ma być używany. `call` Instrukcji może być od razu poprzedzona przez `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefiks instrukcji, aby określić, że bieżący stan metody powinny zostać opublikowane przed przeniesieniem kontroli. Jeśli wywołanie przekazuje sterowanie do metody zaufania wyższe niż metoda pochodzenia, ramka stosu nie jest zwalniana. Zamiast tego kontynuuje wykonywanie dyskretnie tak, jakby `tail` nie został podany. Token metadanych niesie ze sobą wystarczających informacji do ustalenia, czy połączenie ma metodę statyczną, metoda wystąpienia, metody wirtualnej lub funkcją globalną. We wszystkich tych przypadkach adres docelowy jest określana wyłącznie z deskryptor metody (natomiast to za pomocą <xref:System.Reflection.Emit.OpCodes.Callvirt> instrukcji wywoływania metod wirtualnych, gdzie adres docelowy również zależy od środowiska uruchomieniowego typu wystąpienia Odwołanie do wypychania przed <xref:System.Reflection.Emit.OpCodes.Callvirt>).  
  
 Argumenty są umieszczane na stosie, w kolejności od lewej do prawej. Oznacza to, że pierwszy argument jest obliczane i umieszczone na stosie, drugi argument, a następnie trzeci, dopóki wszystkie wymagane argumenty nie zostaną na jego podstawie stosu w kolejności malejącej. Istnieją trzy ważne przypadki specjalne:  
  
 1. Wywołania na wystąpienie (lub wirtualny) — metoda wypchnąć tego odwołania do wystąpienia przed którykolwiek z argumentów widoczny dla użytkownika. Odwołania do wystąpienia nie może być odwołaniem do wartości null. Podpis w metadanych nie zawiera wpisu na liście parametrów dla `this` wskaźnika; zamiast tego używa bitu do wskazania, czy metoda, która wymaga przekazywanie `this` wskaźnika.  
  
 2. Jest on prawidłowy, aby wywołać metodę wirtualną za pomocą `call` (zamiast `callvirt`); oznacza to, że metoda jest rozwiązany, za pomocą klasy określonej przez metodę, a nie jako określony dynamicznie z wywoływanego obiektu.  
  
 3. Należy pamiętać, że obiekt delegowany `Invoke` metoda może być wywoływana z oboma `call` lub `callvirt` instrukcji.  
  
 <xref:System.Security.SecurityException> może zostać wygenerowany, jeśli zabezpieczenia systemu nie powoduje przyznania dostępu do obiektu wywołującego wywoływanej metody. Kontrola zabezpieczeń może wystąpić, gdy instrukcji Microsoft Intermediate Language (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
> [!NOTE]
>  Podczas wywoływania metody System.Object w przypadku typów wartości, należy wziąć pod uwagę przy użyciu `constrained` prefiks z `callvirt` instrukcji zamiast emitowania `call` instrukcji. Eliminuje to konieczność, aby emitować IL różne w zależności od tego, czy typ wartości zastępuje metodę unikanie potencjalny problem przechowywania wersji. Należy rozważyć użycie `constrained` prefiksu podczas wywoływania metody interfejsu dla typów wartości, ponieważ metody typu wartości implementacja metody interfejsu można zmienić za pomocą `MethodImpl`. Te problemy są opisane bardziej szczegółowo w <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `call` kod operacji:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode, MethodInfo, Type[])  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> Metoda jest przewidziana `varargs` wywołania. Użyj <xref:System.Reflection.Emit.ILGenerator.Emit%2A> normalne wywołanie metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wywołuje metodę wskazane w stosie oceny (jako wskaźnik do punktu wejścia) z argumentami opisanego przez Konwencję wywoływania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|Wywołuje metodę wskazywał z argumentami opisanego przez Konwencję wywołania.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Argumenty metody `arg1` za pośrednictwem `argN` są wypychane na stosie.  
  
2.  Wskaźnik wejścia metody są wypychane na stosie.  
  
3.  Argumenty metody `arg1` za pośrednictwem `argN` i wskaźnik wejścia metody są zdjęte ze stosu ze stosu, wywołanie do metody jest wykonywane. Po zakończeniu wartość zwracana jest generowany przez metodę obiekt wywoływany i wysłane do obiektu wywołującego.  
  
4.  Wartość zwracana jest wypychane na stosie.  
  
 `calli` Instrukcja wywołuje wskaźnik wejścia metody z argumentami `arg1` za pośrednictwem `argN`. Typy tych argumentów są opisane przez określonych konwencji wywoływania (`callSiteDesc`). `calli` Instrukcji może być od razu poprzedzony `tail` prefiksu (<xref:System.Reflection.Emit.OpCodes.Tailcall>) do określenia, czy bieżący stan metody powinny zostać opublikowane przed przeniesieniem kontroli. Wywołanie może przenieść formant do metody zaufania wyższe niż metoda źródła ramek stosu nie zostanie zwolnione; Zamiast tego, wykonywanie będzie kontynuowane dyskretnie tak, jakby `tail` nie został podany.  
  
 Wskaźnik wejścia metoda zakłada się, że określone wskaźnik do kodu natywnego (komputera docelowego), który rzeczywiście można wywołać z argumentami opisanego przez Konwencja wywoływania (token metadanych dla podpisu autonomicznej). Taki wskaźnik mogą być tworzone za pomocą <xref:System.Reflection.Emit.OpCodes.Ldftn> lub <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instrukcje lub przekazaną z kodu natywnego.  
  
 Konwencja wywoływania nie jest zaznaczone pole dynamicznie, więc kod używającego `calli` instrukcji nie działa prawidłowo, jeśli miejsce docelowe nie faktycznie używa określonej konwencji wywoływania.  
  
 Argumenty są umieszczane na stosie, w kolejności od lewej do prawej. Oznacza to, że pierwszy argument jest obliczane i umieszczone na stosie, drugi argument, a następnie trzeci, dopóki wszystkie wymagane argumenty nie zostaną na jego podstawie stosu w kolejności malejącej. Sekwencję kodu budynku argument dla wystąpienia lub metodę wirtualną wypchnąć odwołania do tego wystąpienia (który nie może być odwołaniem do wartości null) przed którykolwiek z argumentów widoczny dla użytkownika.  
  
 <xref:System.Security.SecurityException> może zostać wygenerowany, jeśli zabezpieczenia systemu nie powoduje przyznania dostępu do obiektu wywołującego wywoływanej metody. Kontrola zabezpieczeń może wystąpić, gdy instrukcji Microsoft Intermediate Language (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> metody może służyć do wykonywania `calli` instrukcji na stosie. Należy pamiętać, że `calli` powinna być wywoływana przy użyciu poniższych metod, a nie przy użyciu <xref:System.Reflection.Emit.ILGenerator.Emit%2A> klasy, aby umieścić instrukcję bezpośrednio na stosie.  
  
-   ILGenerator.EmitCalli (Opcode, CallingConventions, typ, typ [], Type[]) dla wywołań przy użyciu Konwencją zarządzanego wywoływania.  
  
-   ILGenerator.EmitCalli (Opcode Type[]) CallingConvention, typ, dla wywołań przy użyciu konwencji wywoływania niezarządzanego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wywołuje metodę z późnym wiązaniem do obiektu, wypychanie wartość zwracaną na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|Wywołuje metodę określonej skojarzone z `obj`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `obj` są wypychane na stosie.  
  
2.  Argumenty metody `arg1` za pośrednictwem `argN` są wypychane na stosie.  
  
3.  Argumenty metody `arg1` za pośrednictwem `argN` i odwołanie do obiektu `obj` są zdjęte ze stosu ze stosu; wywołania metody które odbywa się z tymi argumentami i kontrola jest przekazywana do metody w `obj` określonych przez metodę token metadanych. Po zakończeniu wartość zwracana jest generowany przez metodę obiekt wywoływany i wysłane do obiektu wywołującego.  
  
4.  Wartość zwracana jest wypychane na stosie.  
  
 `callvirt` Instrukcja wywołuje metody z późnym wiązaniem do obiektu. Oznacza to, że metoda jest wybierany zależnie od typu środowiska uruchomieniowego `obj` zamiast widoczne we wskaźniku metody klasy kompilacji. `Callvirt` można wywołać wirtualne i wystąpienia metody. `callvirt` Instrukcji może być od razu poprzedzony `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefiks, aby określić, że bieżącej ramki stosu, powinny zostać opublikowane przed przeniesieniem kontroli. Jeśli wywołania będą transfer kontroli do metody zaufania wyższe niż pierwotną metodą ramki stosu nie zostaną wydane.  
  
 Token metadanych metody zawiera nazwę, klasy i podpis metody do wywołania. Klasy skojarzonej z `obj` jest klasą, który jest wystąpieniem. Jeśli klasa definiuje metodę niestatyczna, która pasuje do nazwy metody wskazanej i podpis, ta metoda jest wywoływana. W przeciwnym razie wszystkie klasy w łańcuchu klasa bazowa tej klasy są sprawdzane w kolejności. Jeśli metoda nie zostanie znaleziony, występuje błąd.  
  
 `Callvirt` pobiera obiekt i argumenty skojarzone z poszczególnymi stosu oceny przed wywołaniem metody. Jeśli metoda nie zwraca wartości, spoczywa na stosie po zakończeniu metody. Na stronie / / wywoływany `obj` parametr jest dostępny jako argument 0, `arg1` jako argumentu 1 i tak dalej.  
  
 Argumenty są umieszczane na stosie, w kolejności od lewej do prawej. Oznacza to, że pierwszy argument jest obliczane i umieszczone na stosie, drugi argument, a następnie trzeci, dopóki wszystkie wymagane argumenty nie zostaną na jego podstawie stosu w kolejności malejącej. Odwołania do wystąpienia `obj` (zawsze wymagane dla `callvirt`) musi zostać wypchnięty przed którykolwiek z argumentów widoczny dla użytkownika. Podpis (przenoszone w tokenie metadanych) nie muszą zawierać wpis na liście parametrów dla tego wskaźnika.  
  
 Należy pamiętać, że metoda wirtualna mogą być również wywoływane przy użyciu <xref:System.Reflection.Emit.OpCodes.Call> instrukcji.  
  
 <xref:System.MissingMethodException> jest generowany, jeśli nie można odnaleźć metody niestatycznej o wskazanym nazwę i podpis w klasy skojarzonej z `obj` lub dowolny z jej klas podstawowych. Jest to zazwyczaj wykrywany, po instrukcji Microsoft Intermediate Language (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli obiekt ma wartość null.  
  
 <xref:System.Security.SecurityException> jest generowany, jeśli zabezpieczenia systemu nie powoduje przyznania dostępu do obiektu wywołującego wywoływanej metody. Kontrola zabezpieczeń może wystąpić po przekonwertowaniu CIL do kodu natywnego, a nie w czasie wykonywania.  
  
> [!NOTE]
>  Podczas wywoływania metody System.Object w przypadku typów wartości, należy wziąć pod uwagę przy użyciu `constrained` prefiks z `callvirt` instrukcji. Eliminuje to konieczność, aby emitować IL różne w zależności od tego, czy typ wartości zastępuje metodę unikanie potencjalny problem przechowywania wersji. Należy rozważyć użycie `constrained` prefiksu podczas wywoływania metody interfejsu dla typów wartości, ponieważ metody typu wartości implementacja metody interfejsu można zmienić za pomocą `MethodImpl`. Te problemy są opisane bardziej szczegółowo w <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `callvirt` kod operacji:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode, MethodInfo, Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Próbuje rzutować obiekt przekazywany przez odwołanie do określonej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|Obiekt, do nowego obiektu typu rzutuje `class`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu są wypychane na stosie.  
  
2.  Odwołanie do obiektu zostanie zdjęte ze stosu; przywoływanego obiektu jest rzutowany jako określony `class`.  
  
3.  Jeśli to się powiedzie, nowe odwołanie do obiektu są wypychane na stosie.  
  
 `castclass` Instrukcji podejmuje próbę rzutowania odwołanie do obiektu (typ `O`) na jego podstawie stosu do określonej klasy. Nowa klasa jest określony za pomocą tokenu metadanych wskazujący odpowiednią klasę. Jeśli klasa obiektu górze stosu nie implementuje nową klasę (zakładając, że nowa klasa jest interfejsem) i nie jest klasę pochodną nowej klasy, a następnie <xref:System.InvalidCastException> zgłaszany. Jeśli odwołanie do obiektu jest odwołanie o wartości null, `castclass` zakończy się pomyślnie i zwraca nowy obiekt jako odwołanie o wartości null.  
  
 <xref:System.InvalidCastException> jest generowany, jeśli obj nie można rzutować klasy.  
  
 <xref:System.TypeLoadException> jest generowany, jeśli nie można odnaleźć klasy. Jest to zazwyczaj wykrywany, po instrukcji Microsoft Intermediate Language (MSIL) jest konwertowana do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `castclass` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje dwie wartości. Czy są równe, liczbę całkowitą wartość 1 <see langword="(int32" />) są wypychane na stosie oceny; w przeciwnym razie 0 (<see langword="int32" />) są wypychane na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 01|ceq|Wypychanie 1, jeśli `value1` jest równa `value2`; w przeciwnym razie wypycha 0.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest porównywany z `value2`.  
  
4.  Jeśli `value1` jest równa `value2`, 1 są wypychane na stosie; w przeciwnym razie 0 są wypychane na stosie.  
  
 `ceq` Porównuje instrukcji `value1` i `value2`. Jeśli `value1` jest równa `value2`, następnie 1 (typu `int32`) są wypychane na stosie. W przeciwnym razie 0 (typu `int32`) są wypychane na stosie.  
  
 Zmiennoprzecinkowa numer `ceq` zwróci wartość 0 w przypadku liczb nieuporządkowaną (jeden lub oba są NaN). Nieskończona wartości są równe do siebie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ceq` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje dwie wartości. Jeśli pierwsza wartość jest większa od drugiej, liczbę całkowitą wartość 1 <see langword="(int32" />) są wypychane na stosie oceny; w przeciwnym razie 0 (<see langword="int32" />) są wypychane na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 02|cgt|Wypychanie 1, jeśli `value1` jest większa niż `value2`; w przeciwnym razie wypycha 0.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `cgt` sprawdza, czy `value1` jest większa niż `value2`.  
  
4.  Jeśli `value1` jest większa niż `value2`, 1 są wypychane na stosie; w przeciwnym razie 0 są wypychane na stosie.  
  
 `cgt` Porównuje instrukcji `value1` i `value2`. Jeśli `value1` jest większa niż `value2`, a następnie `int32` wartość 1 są wypychane na stosie. W przeciwnym razie `int32` wartość 0 są wypychane na stosie.  
  
-   W przypadku liczb zmiennoprzecinkowych `cgt` zwraca wartość 0, jeśli liczby są nieuporządkowane (to znaczy, jeśli co najmniej jeden argument jest NaN).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `cgt` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje dwie wartości bez znaku lub nieuporządkowane. Jeśli pierwsza wartość jest większa od drugiej, liczbę całkowitą wartość 1 <see langword="(int32" />) są wypychane na stosie oceny; w przeciwnym razie 0 (<see langword="int32" />) są wypychane na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|Wypychanie 1, jeśli `value1` jest większa niż `value2`; w przeciwnym razie wypycha 0 (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `cgt.un` sprawdza, czy `value1` jest większa niż `value2`.  
  
4.  Jeśli `value1` jest większa niż `value2`, 1 są wypychane na stosie; w przeciwnym razie 0 są wypychane na stosie.  
  
 `int32` Wartość 1 są wypychane na stosie, jeśli dowolny z następujących `true` :  
  
 W przypadku liczb zmiennoprzecinkowych `value1` nie są porządkowane w odniesieniu do `value2`.  
  
 Dla wartości całkowitych `value1` jest większa niż `value2` podczas traktowane jako liczb bez znaku.  
  
 W przeciwnym razie `int32` wartość 0 są wypychane na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `cgt.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zgłasza <see cref="T:System.ArithmeticException" /> Jeśli wartość nie jest liczbą skończoną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|C3|ckfinite|throw <xref:System.ArithmeticException> Jeśli wartość nie jest liczbą skończoną.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie. 
  
2.  `value` zostanie zdjęte ze stosu i `ckfinite` instrukcji odbywa się na nim.  
  
3.  `value` jest przesunięty na stosie, jeśli jest zgłaszany żaden wyjątek.  
  
 `ckfinite instruction` Zgłasza <xref:System.ArithmeticException> Jeśli `value` (liczba zmiennoprzecinkowa) ma wartość "nie jest liczbą" wartości (NaN) lub `+-` wartości nieskończonej. `Ckfinite` pozostawia wartość na stosie, jeśli jest zgłaszany żaden wyjątek. Wykonanie jest nieokreślony, jeżeli `value` nie jest liczbą zmiennoprzecinkową.  
  
 <xref:System.ArithmeticException> jest generowany, jeśli `value` nie jest liczbą "normal".  
  
 Należy pamiętać, że specjalny wyjątek lub klasy pochodnej <xref:System.ArithmeticException> może być bardziej odpowiednie, przekazując niepoprawną wartość do obsługi wyjątków.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ckfinite` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje dwie wartości. Jeśli pierwsza wartość jest mniejsza od drugiej, liczbę całkowitą wartość 1 <see langword="(int32" />) są wypychane na stosie oceny; w przeciwnym razie 0 (<see langword="int32" />) są wypychane na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 04|ClT|Wypychanie 1, jeśli `value1` jest mniejsza niż `value2`; w przeciwnym razie wypycha 0.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest: 

1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `clt` sprawdza, czy `value1` jest mniejsza niż `value2`.  
  
4.  Jeśli `value1` jest mniejsza niż `value2`, 1 są wypychane na stosie; w przeciwnym razie 0 są wypychane na stosie.  
  
 `clt` Porównuje instrukcji `value1` i `value2`. Jeśli `value1` jest mniejsza niż `value2`, a następnie `int32` wartość 1 są wypychane na stosie. W przeciwnym razie `int32` wartość 0 są wypychane na stosie.  
  
-   W przypadku liczb zmiennoprzecinkowych `clt` zwraca wartość 0, jeśli liczby są nieuporządkowane (to znaczy, jeśli co najmniej jeden argument jest NaN).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `clt` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje wartości bez znaku lub nieuporządkowane <paramref name="value1" /> i <paramref name="value2" />. Jeśli <paramref name="value1" /> jest mniej niż <paramref name="value2" />, następnie wartość całkowita 1 <see langword="(int32" />) są wypychane na ocenę stosu; w przeciwnym razie 0 (<see langword="int32" />) są wypychane na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 05|ClT.UN|Wypychanie 1, jeśli `value1` jest mniejsza niż `value2`; w przeciwnym razie wypycha 0 (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `clt.un` sprawdza, czy `value1` jest mniejsza niż `value2`.  
  
4.  Jeśli `value1` jest mniejsza niż `value2`, 1 są wypychane na stosie; w przeciwnym razie 0 są wypychane na stosie.  
  
 `clt.un` Porównuje instrukcji `value1` i `value2`. `int32` Wartość 1 są wypychane na stosie, jeśli spełniony jest dowolny z następujących czynności:  
  
-   `value1` jest mniejsza niż `value2` (jak w przypadku `clt`).  
  
-   W przypadku liczb zmiennoprzecinkowych `value1` nie są porządkowane w odniesieniu do `value2`.  
  
-   Dla wartości całkowitych `value1` jest mniejsza niż `value2` podczas traktowane jako liczb bez znaku.  
  
 W przeciwnym razie `int32` wartość 0 są wypychane na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `clt.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ogranicza typu, na którym wykonano wywołanie wirtualnej metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format programu Microsoft intermediate language (MSIL) zestawu, wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 16 < `T` >|ograniczone. `thisType`|Wywołanie wirtualnej metody w typie ograniczonym do typ `T`.|  
  
 `constrained` Prefiks jest dozwolona tylko w systemach `callvirt` instrukcji.  
  
 Stan w tym momencie stos MSIL musi być w następujący sposób:  
  
1.  Wskaźnik zarządzanego `ptr`, są wypychane na stosie. Typ `ptr` musi być wskaźnikiem zarządzanych (`&`) do `thisType`. Należy pamiętać, że to różni się od przypadku unprefixed `callvirt` instrukcji, która oczekuje odwołania do elementu `thisType`.  
  
2.  Argumenty metody `arg1` za pośrednictwem `argN` są wypychane na stosie, podobnie jak w przypadku unprefixed `callvirt` instrukcji.  
  
 `constrained` Prefiks umożliwia `callvirt` instrukcje, które ma zostać wykonane w jednolity sposób niezależny od czy `thisType` jest typem wartości lub typem referencyjnym.  
  
 Gdy `callvirt` `method` poprzedzony instrukcji `constrained` `thisType`, instrukcja jest wykonywana w następujący sposób:  
  
-   Jeśli `thisType` jest typem odwołania (w przeciwieństwie do typu wartości) `ptr` jest wyłuskiwany i przekazywane jako wskaźnik "this", aby `callvirt` z `method`.  
  
-   Jeśli `thisType` jest typem wartości i `thisType` implementuje `method` następnie `ptr` jest przekazywany niezmodyfikowanego jako wskaźnik "this", aby `call` `method` instrukcji do wykonania `method` przez `thisType`.  
  
-   Jeśli `thisType` jest typem wartości i `thisType` nie implementuje `method` następnie `ptr` jest wyłuskiwany opakowany i przekazywane jako wskaźnik "this", aby `callvirt` `method` instrukcji.  
  
 Ostatnim przypadku może wystąpić tylko wtedy, gdy `method` została zdefiniowana w <xref:System.Object>, <xref:System.ValueType>, lub <xref:System.Enum> i nie jest zastępowana przez `thisType`. W tym przypadku pakowania powoduje, że kopia oryginalnego obiektu, który ma zostać wykonane. Jednak ponieważ żaden z metody <xref:System.Object>, <xref:System.ValueType>, i <xref:System.Enum> zmiany stanu obiektu, ten fakt nie może zostać wykryty.  
  
 `constrained` Prefiks obsługuje generatorów języka IL, tworzonych w kodzie rodzajowym. Zwykle `callvirt` instrukcja jest nieprawidłowa dla typów wartości. Zamiast tego jest to wymagane, kompilatory IL skutecznie na przekształcenie "this" opisanych powyżej w czasie kompilacji, w zależności od typu `ptr` i wywołania metody. Jednak gdy `ptr` jest typ ogólny, który jest nieznany w czasie kompilacji nie jest możliwe zapewnienie tej transformacji, w czasie kompilacji.  
  
 `constrained` Opcode umożliwia kompilatory IL do wywoływania funkcji wirtualnej w jednolity sposób niezależny od czy `ptr` jest typem wartości lub typem referencyjnym. Mimo że jest on przeznaczony do przypadku gdzie `thisType` jest zmienną typu rodzajowego `constrained` prefiks również działa w przypadku nierodzajowymi typami i mogą zmniejszyć złożoność generowania wywołania wirtualnej w językach, które ukryć różnicy między typami wartości i Typy odwołań.  
  
 Za pomocą `constrained` prefiks pozwala uniknąć potencjalne problemy z wersjonowaniem z typami wartości. Jeśli `constrained` prefiks nie jest używany, IL różnych musi być emitowane w zależności od tego, czy typ wartości zastępuje metodę System.Object. Na przykład, jeśli typ wartości `V` zastępuje metodę Object.ToString() `call` `V.ToString()` instrukcji jest emitowane; Jeśli nie, `box` instrukcji i `callvirt` `Object.ToString()` są emitowane instrukcji. Przechowywanie wersji może wystąpić problem w pierwszym przypadku, jeśli zastąpienie później zostanie usunięty, a w drugim przypadku jeśli zastąpienie później zostanie dodany.  
  
 `constrained` Prefiks można również dla wywołania metody interfejsu dla typów wartości, ponieważ metody typu wartości implementacja metody interfejsu można zmienić za pomocą `MethodImpl`. Jeśli `constrained` prefiks nie jest używany, kompilator jest zmuszony do wyboru, którego wartość metody typu, aby powiązać w czasie kompilacji. Za pomocą `constrained` prefiks umożliwia MSIL powiązać metodę, która implementuje metodę interfejsu, w czasie wykonywania, a nie w czasie kompilacji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `constrained` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D3|conv.i|Konwertuj na `native int`, wypychania `native int` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.i` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i pozostaw, których przekonwertować wartości na górze stosu. Wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używana, w którym to przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych obcina liczbę w kierunku zera. Podczas konwersji z `float64` do `float32`, dokładności, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub minus nieskończoność (Jeśli `value` ma wartość ujemną) jest zwracany. Jeśli występuje przepełnienie konwersji typu jeden argument do innej, najbardziej znaczące bity są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest rozszerzona o znak do wypełnienia gniazda.  
  
 Jeśli występuje przepełnienie konwersja typu zmiennoprzecinkowego na liczbę całkowitą, wartość zwracana jest nieokreślona.  
  
 Nigdy nie są zgłaszane nie wyjątki, korzystając z tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie może poprawnie reprezentować wartość wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.i` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="int8" />, następnie rozszerza (okienka) do <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|67|conv.i1|Konwertuj na `int8`, wypychania `int32` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.i1` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i pozostaw, których przekonwertować wartości na górze stosu. Wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używana, w którym to przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych obcina liczbę w kierunku zera. Podczas konwersji z `float64` do `float32`, dokładności, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub minus nieskończoność (Jeśli `value` ma wartość ujemną) jest zwracany. Jeśli występuje przepełnienie konwersji typu jeden argument do innej, najbardziej znaczące bity są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest rozszerzona o znak do wypełnienia gniazda.  
  
 Jeśli występuje przepełnienie konwersja typu zmiennoprzecinkowego na liczbę całkowitą, wartość zwracana jest nieokreślona.  
  
 Nigdy nie są zgłaszane nie wyjątki, korzystając z tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie może poprawnie reprezentować wartość wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.i1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="int16" />, następnie rozszerza (okienka) do <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|68|conv.i2|Konwertuj na `int16`, wypychania `int32` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.i2` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i pozostaw, których przekonwertować wartości na górze stosu. Wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używana, w którym to przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych obcina liczbę w kierunku zera. Podczas konwersji z `float64` do `float32`, dokładności, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub minus nieskończoność (Jeśli `value` ma wartość ujemną) jest zwracany. Jeśli występuje przepełnienie konwersji typu jeden argument do innej, najbardziej znaczące bity są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest rozszerzona o znak do wypełnienia gniazda.  
  
 Jeśli występuje przepełnienie konwersja typu zmiennoprzecinkowego na liczbę całkowitą, wartość zwracana jest nieokreślona.  
  
 Nigdy nie są zgłaszane nie wyjątki, korzystając z tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie może poprawnie reprezentować wartość wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.i2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|69|conv.i4|Konwertuj na `int32`, wypychania `int32` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.i4` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i pozostaw, których przekonwertować wartości na górze stosu. Wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używana, w którym to przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych obcina liczbę w kierunku zera. Podczas konwersji z `float64` do `float32`, dokładności, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub minus nieskończoność (Jeśli `value` ma wartość ujemną) jest zwracany. Jeśli występuje przepełnienie konwersji typu jeden argument do innej, najbardziej znaczące bity są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest rozszerzona o znak do wypełnienia gniazda.  
  
 Jeśli występuje przepełnienie konwersja typu zmiennoprzecinkowego na liczbę całkowitą, wartość zwracana jest nieokreślona.  
  
 Nigdy nie są zgłaszane nie wyjątki, korzystając z tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie może poprawnie reprezentować wartość wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.i4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6A|conv.I8|Konwertuj na `int64`, wypychania `int64` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.i8` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i pozostaw, których przekonwertować wartości na górze stosu. Wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używana, w którym to przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych obcina liczbę w kierunku zera. Podczas konwersji z `float64` do `float32`, dokładności, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub minus nieskończoność (Jeśli `value` ma wartość ujemną) jest zwracany. Jeśli występuje przepełnienie konwersji typu jeden argument do innej, najbardziej znaczące bity są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest rozszerzona o znak do wypełnienia gniazda.  
  
 Jeśli występuje przepełnienie konwersja typu zmiennoprzecinkowego na liczbę całkowitą, wartość zwracana jest nieokreślona.  
  
 Nigdy nie są zgłaszane nie wyjątki, korzystając z tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie może poprawnie reprezentować wartość wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.i8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość ze znakiem na szczycie stosu oceny podpisane <see langword="native int" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|Konwertuj na `native int` (na stosie jako `native int`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.i` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.i` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartości bez znaku na szczycie stosu oceny podpisane <see langword="native int" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|Konwertuje wartość niepodpisane `native int` (na stosie jako `native int`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.i.un` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.i.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość ze znakiem na szczycie stosu oceny podpisane <see langword="int8" /> i rozszerza je do <see langword="int32" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|Konwertuj na `int8` (na stosie jako `int32`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.i1` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.i1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartości bez znaku na szczycie stosu oceny podpisane <see langword="int8" /> i rozszerza je do <see langword="int32" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|Konwertuje wartość niepodpisane `int8` (na stosie jako `int32`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.i1.un` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.i1.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość ze znakiem na szczycie stosu oceny podpisane <see langword="int16" /> i rozszerzania jej do <see langword="int32" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|Konwertuj na `int16` (na stosie jako `int32`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.i2` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.i2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartości bez znaku na szczycie stosu oceny podpisane <see langword="int16" /> i rozszerza je do <see langword="int32" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|Konwertuje wartość niepodpisane `int16` (na stosie jako `int32`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.i2.un` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.i2.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość ze znakiem na szczycie stosu oceny podpisane <see langword="int32" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|Konwertuj na `int32` (na stosie jako `int32`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.i4` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.i4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartości bez znaku na szczycie stosu oceny podpisane <see langword="int32" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|Konwertuje wartość niepodpisane `int32` (na stosie jako `int32`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.i4.un` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.i4.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość ze znakiem na szczycie stosu oceny podpisane <see langword="int64" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|Konwertuj na `int64` (na stosie jako `int64`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.i8` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.i8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartości bez znaku na szczycie stosu oceny podpisane <see langword="int64" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|Konwertuje wartość niepodpisane `int64` (na stosie jako `int64`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.i8.un` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.i8.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość ze znakiem na szczycie stosu oceny do <see langword="unsigned native int" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|Konwertuj na `unsigned native int` (na stosie jako `native int`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.u` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.u` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartości bez znaku na szczycie stosu oceny do <see langword="unsigned native int" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|Konwertuje un niepodpisane wartość `unsigned native int` (na stosie jako `native int`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.u.un` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.uvf.u.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość ze znakiem na szczycie stosu oceny do <see langword="unsigned int8" /> i rozszerza je do <see langword="int32" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|Konwertuj na `unsigned int8` (na stosie jako `int32`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.u1` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.u1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartości bez znaku na szczycie stosu oceny do <see langword="unsigned int8" /> i rozszerza je do <see langword="int32" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|Konwertuje wartość niepodpisane `unsigned int8` (na stosie jako `int32`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.u1.un` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.u1.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość ze znakiem na szczycie stosu oceny do <see langword="unsigned int16" /> i rozszerza je do <see langword="int32" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|Konwertuj na `unsigned int16` (na stosie jako `int32`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.u2` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.u2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartości bez znaku na szczycie stosu oceny do <see langword="unsigned int16" /> i rozszerza je do <see langword="int32" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|Konwertuje wartość niepodpisane `unsigned int16` (na stosie jako `int32`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.u2.un` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.u2.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość ze znakiem na szczycie stosu oceny do <see langword="unsigned int32" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|Konwertuj na `unsigned int32` (na stosie jako `int32`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.u4` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.u4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartości bez znaku na szczycie stosu oceny do <see langword="unsigned int32" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|Konwertuje wartość niepodpisane `unsigned int32` (na stosie jako `int32`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.u4.un` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.u4.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość ze znakiem na szczycie stosu oceny do <see langword="unsigned int64" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|Konwertuj na `unsigned int64` (na stosie jako `int64`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.u8` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.u8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartości bez znaku na szczycie stosu oceny do <see langword="unsigned int64" />, zgłaszanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|Konwertuje wartość niepodpisane `unsigned int64` (na stosie jako `int64`) i zgłosić wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji. Jeśli występuje przepełnienie, jest zgłaszany wyjątek.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.ovf.u8.un` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i miejsc, w których przekonwertować wartości na górze stosu. Jeśli wartość jest zbyt duży lub za mały, aby mogły być reprezentowane przez typ docelowy, jest zgłaszany wyjątek.  
  
 Konwersje z liczby zmiennoprzecinkowe do całkowitych obciąć liczbę w kierunku zera. Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.ovf.i` lub `conv.ovf.u` są używane, w którym to przypadku wynik jest również `native int`).  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.ovf.u8.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość liczby całkowitej bez znaku na szczycie stosu oceny do <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|76|conv.r.un|Konwertuj liczbę całkowitą bez znaku do zmiennoprzecinkowych, wypychanie `F` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.r.un` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i pozostaw, których przekonwertować wartości na górze stosu. Wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używana, w którym to przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych obcina liczbę w kierunku zera. Podczas konwersji z `float64` do `float32`, dokładności, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub minus nieskończoność (Jeśli `value` ma wartość ujemną) jest zwracany. Jeśli występuje przepełnienie konwersji typu jeden argument do innej, najbardziej znaczące bity są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest rozszerzona o znak do wypełnienia gniazda.  
  
 Jeśli występuje przepełnienie konwersja typu zmiennoprzecinkowego na liczbę całkowitą `result` zwracany jest nieokreślona. `conv.r.un` Operacji przyjmuje liczbę całkowitą ze stosu, zinterpretuje ją jako bez znaku i zastępuje go znakiem liczba zmiennoprzecinkowa do przedstawienia wartości całkowitej: albo `float32`, jeżeli jest dostatecznie szerokie, aby reprezentować liczby całkowitej bez utraty precyzji lub innego `float64`.  
  
 Nigdy nie są zgłaszane nie wyjątki, korzystając z tego pola.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.r.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6B|conv.r4|Konwertuj na `float32`, wypychania `F` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.r4` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i pozostaw, których przekonwertować wartości na górze stosu. Wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używana, w którym to przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych obcina liczbę w kierunku zera. Podczas konwersji z `float64` do `float32`, dokładności, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub minus nieskończoność (Jeśli `value` ma wartość ujemną) jest zwracany. Jeśli występuje przepełnienie konwersji typu jeden argument do innej, najbardziej znaczące bity są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest rozszerzona o znak do wypełnienia gniazda.  
  
 Jeśli występuje przepełnienie konwersja typu zmiennoprzecinkowego na liczbę całkowitą, wartość zwracana jest nieokreślona.  
  
 Nigdy nie są zgłaszane nie wyjątki, korzystając z tego pola.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.r4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6C|conv.r8|Konwertuj na `float64`, wypychania `F` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.r8` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i pozostaw, których przekonwertować wartości na górze stosu. Wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używana, w którym to przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych obcina liczbę w kierunku zera. Podczas konwersji z `float64` do `float32`, dokładności, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub minus nieskończoność (Jeśli `value` ma wartość ujemną) jest zwracany. Jeśli występuje przepełnienie konwersji typu jeden argument do innej, najbardziej znaczące bity są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest rozszerzona o znak do wypełnienia gniazda.  
  
 Jeśli występuje przepełnienie konwersja typu zmiennoprzecinkowego na liczbę całkowitą, wartość zwracana jest nieokreślona.  
  
 Nigdy nie są zgłaszane nie wyjątki, korzystając z tego pola.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.r8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="unsigned native int" />, i rozszerza je do <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|E0|conv.u|Konwertuj na `unsigned native int`, wypychania `native int` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.u` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i pozostaw, których przekonwertować wartości na górze stosu. Wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używana, w którym to przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych obcina liczbę w kierunku zera. Podczas konwersji z `float64` do `float32`, dokładności, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub minus nieskończoność (Jeśli `value` ma wartość ujemną) jest zwracany. Jeśli występuje przepełnienie konwersji typu jeden argument do innej, najbardziej znaczące bity są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest rozszerzona o znak do wypełnienia gniazda.  
  
 Jeśli występuje przepełnienie konwersja typu zmiennoprzecinkowego na liczbę całkowitą, wartość zwracana jest nieokreślona.  
  
 Nigdy nie są zgłaszane nie wyjątki, korzystając z tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie może poprawnie reprezentować wartość wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.u` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="unsigned int8" />, i rozszerza je do <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D2|conv.U1|Konwertuj na `int8`, wypychania `int32` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.u1` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i pozostaw, których przekonwertować wartości na górze stosu. Wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używana, w którym to przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych obcina liczbę w kierunku zera. Podczas konwersji z `float64` do `float32`, dokładności, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub minus nieskończoność (Jeśli `value` ma wartość ujemną) jest zwracany. Jeśli występuje przepełnienie konwersji typu jeden argument do innej, najbardziej znaczące bity są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest rozszerzona o znak do wypełnienia gniazda.  
  
 Jeśli występuje przepełnienie konwersja typu zmiennoprzecinkowego na liczbę całkowitą, wartość zwracana jest nieokreślona.  
  
 Nigdy nie są zgłaszane nie wyjątki, korzystając z tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie może poprawnie reprezentować wartość wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.u1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="unsigned int16" />, i rozszerza je do <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D1|conv.u2|Konwertuj na `int16`, wypychania `int32` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.u2` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i pozostaw, których przekonwertować wartości na górze stosu. Wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używana, w którym to przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych obcina liczbę w kierunku zera. Podczas konwersji z `float64` do `float32`, dokładności, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub minus nieskończoność (Jeśli `value` ma wartość ujemną) jest zwracany. Jeśli występuje przepełnienie konwersji typu jeden argument do innej, najbardziej znaczące bity są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest rozszerzona o znak do wypełnienia gniazda.  
  
 Jeśli występuje przepełnienie konwersja typu zmiennoprzecinkowego na liczbę całkowitą, wartość zwracana jest nieokreślona.  
  
 Nigdy nie są zgłaszane nie wyjątki, korzystając z tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie może poprawnie reprezentować wartość wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.u2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="unsigned int32" />, i rozszerza je do <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6D|conv.u4|Konwertuj na `unsigned int32`, wypychania `int32` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.u4` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i pozostaw, których przekonwertować wartości na górze stosu. Wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używana, w którym to przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych obcina liczbę w kierunku zera. Podczas konwersji z `float64` do `float32`, dokładności, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub minus nieskończoność (Jeśli `value` ma wartość ujemną) jest zwracany. Jeśli występuje przepełnienie konwersji typu jeden argument do innej, najbardziej znaczące bity są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest rozszerzona o znak do wypełnienia gniazda.  
  
 Jeśli występuje przepełnienie konwersja typu zmiennoprzecinkowego na liczbę całkowitą, wartość zwracana jest nieokreślona.  
  
 Nigdy nie są zgłaszane nie wyjątki, korzystając z tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie może poprawnie reprezentować wartość wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.u4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na szczycie stosu oceny do <see langword="unsigned int64" />, i rozszerza je do <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6E|conv.u8|Konwertuj na `int64`, wypychania `int64` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i konwersji nastąpi próba wykonania operacji.  
  
3.  Jeśli konwersja się powiedzie, wartość wynikowa są wypychane na stosie.  
  
 `conv.u8` Konwertuje opcode `value` na szczycie stosu do typu określonego w opcode i pozostaw, których przekonwertować wartości na górze stosu. Wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` , gdy są one załadowane na stosie oceny (chyba że `conv.i` lub `conv.u` jest używana, w którym to przypadku wynik jest również `native int`). Wartości zmiennoprzecinkowe są konwertowane na `F` typu.  
  
 Konwersja z liczby zmiennoprzecinkowe do całkowitych obcina liczbę w kierunku zera. Podczas konwersji z `float64` do `float32`, dokładności, mogą zostać utracone. Jeśli `value` jest zbyt duży, aby zmieścić ją w `float32 (F)`, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub minus nieskończoność (Jeśli `value` ma wartość ujemną) jest zwracany. Jeśli występuje przepełnienie konwersji typu jeden argument do innej, najbardziej znaczące bity są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest rozszerzona o znak do wypełnienia gniazda.  
  
 Jeśli występuje przepełnienie konwersja typu zmiennoprzecinkowego na liczbę całkowitą, wartość zwracana jest nieokreślona.  
  
 Nigdy nie są zgłaszane nie wyjątki, korzystając z tego pola. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> i <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> równoważne instrukcje, które spowoduje zgłoszenie wyjątku, gdy typ wyniku nie może poprawnie reprezentować wartość wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `conv.u8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiuje określony, liczba bajtów z adresu źródłowego do docelowego adresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Kopiowanie danych z bloku pamięci z jednego do drugiego.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres docelowy są wypychane na stosie.  
  
2.  Źródłowy adres są wypychane na stosie.  
  
3.  Liczba bajtów do skopiowania są wypychane na stosie.  
  
4.  Liczba bajtów, adres źródłowy i docelowy adres są zdjęte ze stosu ze stosu; określoną liczbę bajtów są kopiowane z adresu źródłowego do docelowego adresu.  
  
 `cpblk` Instrukcji kopiuje numer (typ `unsigned int32`) bajtów ze źródłowego adresu (typu `*`, `native int`, lub `&`) do docelowego adresu (typu `*`, `native int`, lub `&`). Zachowanie `cpblk` jest nieokreślony, jeżeli obszary źródłowe i docelowe nakładają się.  
  
 `cpblk` przyjęto założenie, że źródłowym i docelowym, które zostały rozwiązane są wyrównane do naturalnym rozmiaru maszyny. `cpblk` Instrukcji może być od razu poprzedzona przez `unaligned.<prefix>` instrukcjami, aby wskazać, że źródło lub miejsce docelowe jest niewyrównanych.  
  
 Działanie `cpblk` instrukcji może być zmienione przez bezpośrednio poprzedzający <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `cpblk` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Typ wartości znajdujące się pod adresem obiektu kopii (typ <see langword="&amp;" />, <see langword="*" /> lub <see langword="native int" />) adres obiektu docelowego (typ <see langword="&amp;" />, <see langword="*" /> lub <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|Kopiuje wartość typu z obiektu źródłowego do obiektu docelowego.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu docelowego są wypychane na stosie.  
  
2.  Odwołanie do obiektu źródłowego są wypychane na stosie.  
  
3.  Odwołania do dwóch obiektów są zdjęte ze stosu ze stosu; Typ wartości pod adresem obiektu źródłowego jest kopiowany do adresu obiektu docelowego.  
  
 Zachowanie `cpobj` jest nieokreślony, jeśli źródłowy i docelowy obiekt odwołania nie są wskaźnikami do wystąpienia klasy reprezentowane przez token klasy `classTok` ( `typeref` lub `typedef`), lub jeśli `classTok` nie reprezentuje Typ wartości.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `cpobj` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dzieli dwie wartości, a następnie wypycha wynik w postaci liczb zmiennoprzecinkowych (typ <see langword="F" />) lub iloraz (typ <see langword="int32" />) na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5B|div|Dzieli dwie wartości do zwrócenia iloraz lub wyników zmiennoprzecinkowych.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest dzielona przez `value2`.  
  
4.  Wyniki są wypychane na stosie.  
  
 `result` = `value1` DIV wartość2 spełnia następujące warunki:  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, oraz:  
  
 logowania (`result`) = +, jeśli Zaloguj (`value1`) = logowanie (`value2`), lub-, jeśli znak (`value1`) ~ = logowanie (`value2`)  
  
 `div` Instrukcja oblicza wynik a następnie wypycha go na stosie.  
  
 Dzielenie całkowitoliczbowe obcina w kierunku zera.  
  
 Dzielenie liczby ograniczone przez zero tworzy poprawnie podpisane wartość nieskończona.  
  
 Podzielenie zero przez zero lub tworzy nieskończoność, nieskończoność wartości NaN (nie-A-liczba). Dowolna liczba podzielona przez nieskończoności generuje wartość zero.  
  
 Operacje typu całkowitego throw <xref:System.ArithmeticException> Jeśli wynik nie może być przedstawiony w typie wyniku. Może się to zdarzyć, jeśli `value1` maksymalna wartość ujemna, i `value2` wynosi -1.  
  
 Operacje typu całkowitego throw <xref:System.DivideByZeroException> Jeśli `value2` wynosi zero.  
  
 Należy pamiętać, że na platformach opartych na Intel <xref:System.OverflowException> jest zgłaszany, gdy obliczeń (minint div -1). Operacji zmiennoprzecinkowych nigdy nie zgłasza wyjątku (produkują NaNs lub nieskończoności zamiast).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `div` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dzieli dwie wartości liczb całkowitych bez znaku, a następnie wypycha wynik (<see langword="int32" />) na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5C|div.un|Dzieli dwie wartości, bez znaku, zwracając ilorazu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest dzielona przez `value2`.  
  
4.  Wyniki są wypychane na stosie.  
  
 `div.un` Oblicza instrukcji `value1` podzielona przez `value2`, zarówno jako liczb całkowitych bez znaku i wypchnięć `result` na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `div.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiuje bieżącą wartość najwyższego poziomu w stosie oceny, a następnie wypycha kopiowania na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|25|dup|Duplikuje wartość górnej części stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zniżki w stosunku do stosu pod kątem duplikatów, jest zdjęte ze stosu.  
  
3.  `value` jest przesunięty na stosie.  
  
4.  Zduplikowane wartości są wypychane na stosie.  
  
 `dup` Instrukcji duplikuje górnego elementu stosu i pozostawia dwie identyczne wartości na jego podstawie go.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `dup` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie z <see langword="filter" /> klauzuli wyjątek do obsługi wyjątków Common Language Infrastructure (CLI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 11|elementu Endfilter|Koniec klauzula filtru dla obsługi wyjątków SEH.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu; `endfilter` jest wykonywane i kontrola jest przekazywana do obsługi wyjątków.  
  
 `Value` (który musi być typu `int32` i jest jednym z określonych wartości) jest zwracany z klauzuli filtru. Powinna to być jeden z:  
  
-   `exception_continue_search` (`value` = 0) aby kontynuować wyszukiwanie aparatu obsługi wyjątków  
  
-   `exception_execute_handler` (`value` = 1) można uruchomić drugi znajduje się faza obsługi wyjątków, w którym na koniec bloki są uruchamiane, dopóki program obsługi skojarzone z tym klauzula filtru. Podczas odnajdywania program obsługi jest wykonywana.  
  
 Inne wartości całkowitych generuje nieokreślony wyników.  
  
 Punkt wejścia filtru, jak pokazano w tabeli wyjątek metody, musi być pierwsza instrukcja w bloku kodu filtru. `endfilter` Instrukcji musi być ostatnim instrukcji w bloku kodu filtru (dlatego może mieć tylko jedną `endfilter` dla bloku jeden filtr). Po wykonaniu `endfilter` instrukcji, kontrola logicznie przepływy do mechanizm obsługi wyjątków interfejsu wiersza polecenia.  
  
 Kontrolki nie można przenieść do bloku filtru, z wyjątkiem za pośrednictwem mechanizmu wyjątku. Kontrolki nie mogą zostać przeniesione z bloku filtru z wyjątkiem za pośrednictwem `throw` instrukcji lub wykonując końcowe `endfilter` instrukcji. Nie można osadzić `try` blokowania w ramach `filter` bloku. Jeśli wyjątek jest generowany wewnątrz `filter` bloku, zostanie przechwycona i wartość 0 (`exception_continue_search`) jest zwracany.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `endfilter` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przekazuje sterowanie z <see langword="fault" /> lub <see langword="finally" /> klauzuli bloku wyjątków do obsługi wyjątków Common Language Infrastructure (CLI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DC|Endfinally<br /><br /> endfault|Kończy się `finally` lub `fault` klauzuli bloku wyjątków.|  
  
 Nie ma żadnych stosu zachowania w tej instrukcji.  
  
 `Endfinally` i `endfault` sygnał koniec `finally` lub `fault` klauzuli dzięki odwijanie stosu można kontynuować, dopóki nie zostanie wywołana procedura obsługi wyjątków. `endfinally` Lub `endfault` instrukcji przekazuje sterowanie do mechanizm wyjątków interfejsu wiersza polecenia. Mechanizm, a następnie wyszukuje następne `finally` klauzuli w łańcuchu w przypadku chronionego bloku zakończył się przy użyciu instrukcji pozostaw. Jeśli chronionego bloku został zakończony z powodu wyjątku, interfejsu wiersza polecenia wyszuka następnego `finally` lub `fault`, lub wprowadź wybrany podczas pierwszego przejścia dla obsługi wyjątków programu obsługi wyjątków.  
  
 `endfinally` Instrukcji mogą się pojawiać jedynie leksykalnie poziomu `finally` bloku. W odróżnieniu od `endfilter` instrukcji, nie jest wymagane, kończyć bloku `endfinally` instrukcji i mogą mieć dowolną liczbę `endfinally` instrukcje w bloku zgodnie z potrzebami. Te ograniczenia dotyczą `endfault` instrukcji i `fault` bloku.  
  
 Kontrolki nie mogą zostać przeniesione do `finally` (lub `fault`) blokowania z wyjątkiem za pośrednictwem mechanizmu wyjątku. Kontrolki nie mogą zostać przeniesione z `finally` (lub `fault`) blokowania z wyjątkiem za pośrednictwem `throw` instrukcji lub wykonywanie `endfinally` (lub `endfault`) instrukcji. W szczególności należy "nie mogą zostać objęte" z `finally` (lub `fault`) bloku lub wykonać <xref:System.Reflection.Emit.OpCodes.Ret> lub <xref:System.Reflection.Emit.OpCodes.Leave> instrukcji w ramach `finally` (lub `fault`) bloku.  
  
 Należy pamiętać, że `endfault` i `endfinally` instrukcje są aliasami — odpowiadają one ten sam kod operacji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `endfinally` (`endfault`) opcode, jak również `ILGenerator` metoda <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inicjuje określony blok pamięć pod określonym adresem na dany rozmiar, a wartość początkową.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 18|initblk|W bloku pamięci dla danej wartości, należy ustawić każdej lokalizacji.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres początkowy są wypychane na stosie.  
  
2.  Wartość inicjalizacji są wypychane na stosie.  
  
3.  Liczba bajtów do zainicjowania są wypychane na stosie.  
  
4.  Liczba bajtów, wartość inicjalizacji i adres początkowy są zdjęte ze stosu ze stosu i inicjalizacja jest wykonywana zgodnie z ich wartości.  
  
 `initblk` Instrukcja Ustawia numer (`unsigned int32`) bajtów, zaczynając od określonego adresu (typu `native int`, `&`, lub `*`) na wartość inicjalizacji (typu `unsigned int8`). `initblk` przyjęto założenie, że adres początkowy jest wyrównany do naturalnym rozmiar maszyny.  
  
 Działanie `initblk` instrukcji może być zmienione przez bezpośrednio poprzedzający <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `initblk` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inicjuje każdego pola typu wartości pod określonym adresem odwołanie o wartości null lub 0 odpowiedniego typu pierwotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 15 < `T` >|`initobj``typeTok`|Inicjuje typu wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres typu wartości do zainicjowania są wypychane na stosie.  
  
2.  Adres zostanie zdjęte ze stosu; Typ wartości pod podanym adresem jest inicjowany jako typ `typeTok`.  
  
 `initobj` Instrukcji inicjuje każdego pola typu wartości określone przez wypychanie adresu (typu `native int`, `&`, lub `*`) odwołanie o wartości null lub 0 odpowiedniego typu pierwotnego. Po ta metoda jest wywoływana, wystąpienie jest gotowy do wywoływanej metody konstruktora. Jeśli `typeTok` jest typem referencyjnym tej instrukcji działa tak samo jak `ldnull` następuje `stind.ref`.  
  
 W odróżnieniu od <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` nie wywołuje metody konstruktora. `Initobj` jest przeznaczony dla inicjowania typów wartości, podczas gdy `newobj` służy do przydzielania i Inicjowanie obiektów.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `initobj` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sprawdza, czy odwołanie do obiektu (typ <see langword="O" />) jest instancją konkretnej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|Sprawdza, czy odwołanie do obiektu jest wystąpieniem `class`, zwraca odwołanie o wartości null lub wystąpienie tej klasy lub interfejsu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu są wypychane na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte ze stosu ze stosu i przetestowany w celu ustalenia, czy jest wystąpienie klasy przekazanej `class`.  
  
3.  Wynik (odwołanie do obiektu lub odwołanie o wartości null) są wypychane na stosie.  
  
 `Class` token metadanych wskazuje odpowiednią klasę. Jeśli implementuje klasę obiektu, w górnej części stosu `class` (Jeśli `class` jest interfejsem) lub klasę pochodną z `class` (Jeśli `class` jest zwykłej klasy), a następnie jest rzutowany na typ `class` i wyniki są wypychane na stos, dokładnie tak, jakby <xref:System.Reflection.Emit.OpCodes.Castclass> jakby została ona wywołana. W przeciwnym razie odwołanie o wartości null są wypychane na stosie. Jeśli odwołanie do obiektu, sama jest odwołanie o wartości null, następnie `isinst` podobnie zwraca odwołanie o wartości null.  
  
 <xref:System.TypeLoadException> jest generowany, jeśli nie można odnaleźć klasy. Jest to zazwyczaj wykrywany, po instrukcji Microsoft Intermediate Language (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `isinst` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamyka bieżącą metodę i przechodzi do określonej metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|27 < `T` >|Element jmp `method`|Zamknij bieżącą metodę i przeskoczyć do określonej metody.|  
  
 Nie ma żadnych stosu zachowania w tej instrukcji.  
  
 `jmp` (Szybkie) instrukcji przekaże kontrolę metodą określoną przez `method`, który jest token metadanych dla odwołania do metody. Bieżące argumenty są przekazywane do metody docelowej.  
  
 Stos oceny może być pusty, podczas wykonywania tej instrukcji. Konwencji wywoływania, liczby i typu argumentów, pod adresem docelowy musi być zgodna z bieżącą metodę.  
  
 `jmp` Nie może być używana do przenieść kontroli poza `try`, `filter`, `catch`, lub `finally` bloku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `jmp` kod operacji:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argumentu (odwołuje się określona wartość indeksu) na stosie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg `index`|Ładowanie argumentu w `index` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość argumentu w `index` są wypychane na stosie.  
  
 `ldarg` Instrukcji wypycha argument w `index`, gdzie argumenty są indeksowane z zakresu od 0 lub nowszy, na stosie oceny. `ldarg` Instrukcji można załadować typu wartości lub wartością pierwotną na stosie, kopiując je z argumentem przychodzących. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez bieżącą metodę podpisu.  
  
 Procedury, które przyjmują listy argumentów o zmiennej długości `ldarg` instrukcji może służyć tylko w przypadku wstępnego stałej argumentów, wyklucza te w zmiennej część podpisu (zobacz <xref:System.Reflection.Emit.OpCodes.Arglist> instrukcji, aby uzyskać więcej informacji).  
  
 Argumenty, zawierających wartość całkowitą mniejszą niż 4 bajty są rozszerzane do typu `int32` , gdy są one załadowane na stosie. Wartości zmiennoprzecinkowe są rozszerzane do ich rozmiaru natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldarg` kod operacji:  
  
-   ILGenerator.Emit (OpCode, krótki)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument pod indeksem 0 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|02|ldarg.0|Ładowanie argument 0 na stosie|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość argumentu pod indeksem 0 są wypychane na stosie.  
  
 `ldarg.0` Instrukcja jest efektywne kodowanie do ładowania wartość argumentu pod indeksem 0.  
  
 `ldarg.0` Instrukcji wypycha argument indeksowane w lokalizacji 0 na stosie oceny. `ldarg.0` Instrukcji można załadować typu wartości lub wartością pierwotną na stosie, kopiując je z argumentem przychodzących. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez bieżącą metodę podpisu.  
  
 Argumenty, zawierających wartość całkowitą mniejszą niż 4 bajty są rozszerzane do typu `int32` , gdy są one załadowane na stosie. Wartości zmiennoprzecinkowe są rozszerzane do ich rozmiaru natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldarg.0` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument pod indeksem 1 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|03|ldarg.1|Załaduj argumentu 1 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość argumentu pod indeksem 1 są wypychane na stosie.  
  
 `ldarg.1` Instrukcja jest efektywne kodowanie do ładowania wartość argumentu pod indeksem 1.  
  
 `ldarg.1` Instrukcji wypycha argument indeksowane 1 na stosie oceny. `ldarg.1` Instrukcji można załadować typu wartości lub wartością pierwotną na stosie, kopiując je z argumentem przychodzących. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez bieżącą metodę podpisu.  
  
 Argumenty, zawierających wartość całkowitą mniejszą niż 4 bajty są rozszerzane do typu `int32` , gdy są one załadowane na stosie. Wartości zmiennoprzecinkowe są rozszerzane do ich rozmiaru natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldarg.1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument pod indeksem 2 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|04|ldarg.2|Załaduj argumentu 2 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość argumentu pod indeksem 2 są wypychane na stosie.  
  
 `ldarg.2` Instrukcja jest efektywne kodowanie do ładowania wartość argumentu pod indeksem 2.  
  
 `ldarg.2` Instrukcji wypycha argument indeksowane w 2 na stosie oceny. `ldarg.2` Instrukcji można załadować typu wartości lub wartością pierwotną na stosie, kopiując je z argumentem przychodzących. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez bieżącą metodę podpisu.  
  
 Argumenty, zawierających wartość całkowitą mniejszą niż 4 bajty są rozszerzane do typu `int32` , gdy są one załadowane na stosie. Wartości zmiennoprzecinkowe są rozszerzane do ich rozmiaru natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldarg.2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument w indeksie 3 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|05|ldarg.3|Załaduj argumentu 3 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość argumentu indeksu 3 są wypychane na stosie.  
  
 `ldarg.3` Instrukcja jest efektywne kodowanie do ładowania wartość argumentu pod indeksem 3.  
  
 `ldarg.3` Instrukcji wypycha argument w 3 na stosie oceny. `ldarg.3` Instrukcji można załadować typu wartości lub wartością pierwotną na stosie, kopiując je z argumentem przychodzących. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez bieżącą metodę podpisu.  
  
 Argumenty, zawierających wartość całkowitą mniejszą niż 4 bajty są rozszerzane do typu `int32` , gdy są one załadowane na stosie. Wartości zmiennoprzecinkowe są rozszerzane do ich rozmiaru natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldarg.3` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argumentu (do których odwołuje się za pomocą indeksu określonego krótka) na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg.s `index`|Ładowanie argumentu w `index` na stosie, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość argumentu w `index` są wypychane na stosie.  
  
 `ldarg.s` Instrukcja jest efektywne kodowanie ładowania argumenty indeksowane od 4 do 255.  
  
 `ldarg.s` Instrukcji wypycha argument w `index`, gdzie argumenty są indeksowane z zakresu od 0 lub nowszy, na stosie oceny. `ldarg.s` Instrukcji można załadować typu wartości lub wartością pierwotną na stosie, kopiując je z argumentem przychodzących. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez bieżącą metodę podpisu.  
  
 Procedury, które przyjmują listy argumentów o zmiennej długości `ldarg.s` instrukcji może służyć tylko w przypadku wstępnego stałej argumentów, wyklucza te w zmiennej część podpisu (zobacz <xref:System.Reflection.Emit.OpCodes.Arglist> instrukcji, aby uzyskać więcej informacji).  
  
 Argumenty, zawierających wartość całkowitą mniejszą niż 4 bajty są rozszerzane do typu `int32` , gdy są one załadowane na stosie. Wartości zmiennoprzecinkowe są rozszerzane do ich rozmiaru natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldarg.s` kod operacji:  
  
-   ILGenerator.Emit (OpCode, bajtów)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Załaduj adresie argumentu na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0A &LT; `unsigned int16` >|ldarga `index`|Pobrać adres indeksowane przez argument `index`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres `addr` argumentu indeksowane przez `index` są wypychane na stosie.  
  
 `ldarga` Instrukcji pobiera adres (typu `*`) argumentu indeksowane przez `index`, gdzie argumenty są indeksowane z zakresu od 0 i nowszych wersjach. Adres `addr` zawsze będzie wyrównany do naturalnym granic na komputerze docelowym.  
  
 Procedury, które przyjmują listy argumentów o zmiennej długości `ldarga` instrukcji może służyć tylko w przypadku wstępnego stałej argumentów, wyklucza te w zmiennej część podpisu.  
  
 `ldarga` Służy do przekazywanie parametru przez odwołanie. W pozostałych przypadkach <xref:System.Reflection.Emit.OpCodes.Ldarg> i <xref:System.Reflection.Emit.OpCodes.Starg> powinny być używane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldarga` kod operacji:  
  
-   ILGenerator.Emit (OpCode, krótki)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Załaduj adresie argumentu w krótkiej formy, na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga.s `index`|Pobrać adres indeksowane przez argument `index`, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres `addr` argumentu indeksowane przez `index` są wypychane na stosie.  
  
 `ldarga.s` (krótkiej formy `ldarga`) powinna być używana dla argumentu cyfry od 0 do 255 i jest bardziej efektywne kodowanie.  
  
 `ldarga.s` Instrukcji pobiera adres (typu`*`) argumentu indeksowane przez `index`, gdzie argumenty są indeksowane z zakresu od 0 i nowszych wersjach. Adres `addr` zawsze będzie wyrównany do naturalnym granic na komputerze docelowym.  
  
 Procedury, które przyjmują listy argumentów o zmiennej długości `ldarga.s` instrukcji może służyć tylko w przypadku wstępnego stałej argumentów, wyklucza te w zmiennej część podpisu.  
  
 `ldarga.s` Służy do przekazywanie parametru przez odwołanie. W pozostałych przypadkach <xref:System.Reflection.Emit.OpCodes.Ldarg_S> i <xref:System.Reflection.Emit.OpCodes.Starg_S> powinny być używane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldarga.s` kod operacji:  
  
-   ILGenerator.Emit (OpCode, bajtów)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha podanej wartości typu <see langword="int32" /> na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc.i4 `num`|Wypychanie wartości `num` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość `num` są wypychane na stosie.  
  
 Należy pamiętać, że nie istnieją specjalne kodowania krótki (i dlatego jest bardziej wydajne) liczby całkowite od -128 do 127, a szczególnie krótkie kodowanie scalanych -1 do 8. Wszystkie krótkie kodowanie 4-bajtowych liczb całkowitych są wypychane na stosie. Dłużej kodowania są używane dla 8-bajtowe liczby całkowite i 4 lub 8 bajtów liczb zmiennoprzecinkowych, a także wartości 4-bajtowych, które nie mieszczą się w formularzach krótki. Istnieją trzy sposoby wypychania stała liczba całkowita 8 bajtów na stosie  
  
 1. Użyj <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instrukcji dla stałych, które muszą być wyrażone w więcej niż 32-bitowy.  
  
 2. Użyj <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instrukcji, następuje <xref:System.Reflection.Emit.OpCodes.Conv_I8> dla stałych, które wymagają usługi bits 9 do 32.  
  
 3. Użyj instrukcji krótka, następuje <xref:System.Reflection.Emit.OpCodes.Conv_I8> dla stałych, które mogą być wyrażone w bitach 8 lub mniej.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.i4` kod operacji:  
  
-   ILGenerator.Emit (OpCode, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypychanie wartości liczby całkowitej 0 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|Wypycha 0 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 0 są wypychane na stosie.  
  
 Są to specjalne krótkie kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne krótkie kodowanie Wypchnij 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.i4.0` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypychanie 1 na stosie oceny jako wartość całkowitą <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|Wypychanie 1 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 1 są wypychane na stosie.  
  
 Są to specjalne krótkie kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne krótkie kodowanie Wypchnij 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.i4.1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha wartość całkowitą 2 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|Wypycha 2 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 2 są wypychane na stosie.  
  
 Są to specjalne krótkie kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne krótkie kodowanie Wypchnij 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.i4.2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha wartość całkowitą 3 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|Wypycha 3 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 3 są wypychane na stosie.  
  
 Są to specjalne krótkie kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne krótkie kodowanie Wypchnij 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.i4.3` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha wartość całkowitą 4 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|Wypycha 4 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 4 są wypychane na stosie.  
  
 Są to specjalne krótkie kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne krótkie kodowanie Wypchnij 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.i4.4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha wartość całkowitą, 5 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|Wypycha 5 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 5 są wypychane na stosie.  
  
 Są to specjalne krótkie kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne krótkie kodowanie Wypchnij 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.i4.5` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha wartość całkowitą, 6 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|Wypycha 6 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 6 są wypychane na stosie.  
  
 Są to specjalne krótkie kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne krótkie kodowanie Wypchnij 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.i4.6` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha wartość całkowitą 7 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|Wypycha 7 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 7 są wypychane na stosie.  
  
 Są to specjalne krótkie kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne krótkie kodowanie Wypchnij 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.i4.7` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha wartość całkowita 8 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|Wypycha 8 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość 8 są wypychane na stosie.  
  
 Są to specjalne krótkie kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne krótkie kodowanie Wypchnij 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.i4.8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha wartość całkowitą,-1 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|Wypycha -1 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość -1 są wypychane na stosie.  
  
 Są to specjalne krótkie kodowanie do wypychania wartości całkowitej 0. Wszystkie specjalne krótkie kodowanie Wypchnij 4-bajtowych liczb całkowitych na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.i4.m1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha podane <see langword="int8" /> wartość na stosie oceny jako <see langword="int32" />, krótka.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1F < `int8` >|ldc.i4.s `num`|Wypycha `num` na stosie jako `int32`, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość `num` są wypychane na stosie.  
  
 `ldc.i4.s` jest bardziej efektywne kodowanie wypychania liczby całkowite od -128 do 127 na stosie oceny.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.i4.s` kod operacji:  
  
-   ILGenerator.Emit (OpCode, bajtów)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha podanej wartości typu <see langword="int64" /> na stosie oceny jako <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.i8 `num`|Wypycha `num` na stosie jako `int64`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość `num` są wypychane na stosie.  
  
 To kodowanie wypycha `int64` wartość na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.i8` kod operacji:  
  
-   ILGenerator.Emit (OpCode, długi)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha podanej wartości typu <see langword="float32" /> na stosie oceny jako typ <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.r4 `num`|Wypycha `num` na stosie jako `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość `num` są wypychane na stosie.  
  
 To kodowanie wypycha `float32` wartość na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.r4` kod operacji:  
  
-   ILGenerator.Emit (OpCode, pojedynczy)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha podanej wartości typu <see langword="float64" /> na stosie oceny jako typ <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.r8 `num`|Wypycha `num` na stosie jako `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość `num` są wypychane na stosie.  
  
 To kodowanie wypycha `float64` wartość na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldc.r8` kod operacji:  
  
-   ILGenerator.Emit (OpCode, double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element w indeksie określonej tablicy, na szczycie stosu oceny jako typ określony w instrukcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format programu Microsoft intermediate language (MSIL) zestawu, wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem `typeTok`|Ładuje element przy `index` na górze stosu jako typ `typeTok`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` są wypychane na stosie.  
  
2.  Wartość indeksu `index` są wypychane na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywaną w położeniu `index` w `array` będą wyszukiwane.  
  
4.  Wartości są wypychane na stosie.  
  
 `ldelem` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w tablicy jednowymiarowej liczony od zera `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Typ wartości zwracanej jest określany przez token `typeTok` w instrukcji.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większa niż górna granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldelem` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typem <see langword="native int" /> indeksem określonej tablicy na górze stosu oceny jako <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|97|ldelem.i|Ładuje elementu z typem `native int` na `index` na górze stosu jako `native int`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` są wypychane na stosie.  
  
2.  Wartość indeksu `index` są wypychane na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywaną w położeniu `index` w `array` będą wyszukiwane.  
  
4.  Wartości są wypychane na stosie.  
  
 `ldelem.i` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w tablicy jednowymiarowej liczony od zera `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana dla `ldelem.i` jest `native int`.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldelem.i` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typem <see langword="int8" /> indeksem określonej tablicy na górze stosu oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|Ładuje elementu z typem `int8` na `index` na górze stosu jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` są wypychane na stosie.  
  
2.  Wartość indeksu `index` są wypychane na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywaną w położeniu `index` w `array` będą wyszukiwane.  
  
4.  Wartości są wypychane na stosie.  
  
 `ldelem.i1` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w tablicy jednowymiarowej liczony od zera `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana dla `ldelem.i1` jest `int8`.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldelem.i1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typem <see langword="int16" /> indeksem określonej tablicy na górze stosu oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|Ładuje elementu z typem `int16` na `index` na górze stosu jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` są wypychane na stosie.  
  
2.  Wartość indeksu `index` są wypychane na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywaną w położeniu `index` w `array` będą wyszukiwane.  
  
4.  Wartości są wypychane na stosie.  
  
 `ldelem.i2` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w tablicy jednowymiarowej liczony od zera `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana dla `ldelem.i2` jest `int16`.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldelem.i2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typem <see langword="int32" /> indeksem określonej tablicy na górze stosu oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|Ładuje elementu z typem `int32` na `index` na górze stosu jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` są wypychane na stosie.  
  
2.  Wartość indeksu `index` są wypychane na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywaną w położeniu `index` w `array` będą wyszukiwane.  
  
4.  Wartości są wypychane na stosie.  
  
 `ldelem.i4` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w tablicy jednowymiarowej liczony od zera `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana dla `ldelem.i4` jest `int32`.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldelem.i4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typem <see langword="int64" /> indeksem określonej tablicy na górze stosu oceny jako <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|Ładuje elementu z typem `int64` na `index` na górze stosu jako `int64`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` są wypychane na stosie.  
  
2.  Wartość indeksu `index` są wypychane na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywaną w położeniu `index` w `array` będą wyszukiwane.  
  
4.  Wartości są wypychane na stosie.  
  
 `ldelem.i8` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w tablicy jednowymiarowej liczony od zera `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana dla `ldelem.i8` jest `int64`.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldelem.i8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typem <see langword="float32" /> indeksem określonej tablicy na górze stosu oceny jako typ <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|Ładuje elementu z typem `float32` na `index` na górze stosu jako typ `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` są wypychane na stosie.  
  
2.  Wartość indeksu `index` są wypychane na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywaną w położeniu `index` w `array` będą wyszukiwane.  
  
4.  Wartości są wypychane na stosie.  
  
 `ldelem.r4` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w tablicy jednowymiarowej liczony od zera `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana dla `ldelem.r4` jest `float32`.  
  
 Wartości zmiennoprzecinkowe są konwertowane na typ `F` po załadowaniu na stosie oceny.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldelem.r4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typem <see langword="float64" /> indeksem określonej tablicy na górze stosu oceny jako typ <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|Ładuje elementu z typem `float64` na `index` na górze stosu jako typ `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` są wypychane na stosie.  
  
2.  Wartość indeksu `index` są wypychane na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywaną w położeniu `index` w `array` będą wyszukiwane.  
  
4.  Wartości są wypychane na stosie.  
  
 `ldelem.r8` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w tablicy jednowymiarowej liczony od zera `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana dla `ldelem.r8` jest `float64`.  
  
 Wartości zmiennoprzecinkowe są konwertowane na typ `F` po załadowaniu na stosie oceny.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldelem.r8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu zawierający odwołanie do obiektu w określonego indeksu tablicy na górze stosu oceny jako typ <see langword="O" /> (odwołanie do obiektu).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|Ładuje elementu z odwołania do obiektu w `index` na górze stosu jako typ `O`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` są wypychane na stosie.  
  
2.  Wartość indeksu `index` są wypychane na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywaną w położeniu `index` w `array` będą wyszukiwane.  
  
4.  Wartości są wypychane na stosie.  
  
 `ldelem.ref` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w tablicy jednowymiarowej liczony od zera `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana dla `ldelem.ref` jest typem `O` (odwołanie do obiektu).  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldelem.ref` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typem <see langword="unsigned int8" /> indeksem określonej tablicy na górze stosu oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|Ładuje elementu z typem `unsigned int8` na `index` na górze stosu jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` są wypychane na stosie.  
  
2.  Wartość indeksu `index` są wypychane na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywaną w położeniu `index` w `array` będą wyszukiwane.  
  
4.  Wartości są wypychane na stosie.  
  
 `ldelem.u1` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w tablicy jednowymiarowej liczony od zera `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana dla `ldelem.u1` jest `int8`.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldelem.u1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typem <see langword="unsigned int16" /> indeksem określonej tablicy na górze stosu oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|Ładuje elementu z typem `unsigned int16` pod indeksem na górze stosu jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` są wypychane na stosie.  
  
2.  Wartość indeksu `index` są wypychane na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywaną w położeniu `index` w `array` będą wyszukiwane.  
  
4.  Wartości są wypychane na stosie.  
  
 `ldelem.u2` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w tablicy jednowymiarowej liczony od zera `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana dla `ldelem.u2` jest `int16`.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldelem.u2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje elementu z typem <see langword="unsigned int32" /> indeksem określonej tablicy na górze stosu oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|Ładuje elementu z typem `unsigned int32` pod indeksem na górze stosu jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` są wypychane na stosie.  
  
2.  Wartość indeksu `index` są wypychane na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; wartość przechowywaną w położeniu `index` w `array` będą wyszukiwane.  
  
4.  Wartości są wypychane na stosie.  
  
 `ldelem.u4` Instrukcji ładuje wartość elementu o indeksie `index` (typ `native int`) w tablicy jednowymiarowej liczony od zera `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`.  
  
 Wartość zwracana dla `ldelem.u4` jest `int32`.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli tablica nie zawiera elementów typu wymagane.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldelem.u4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje adres elementu tablicy indeksem określonej tablicy na górze stosu oceny jako typ <see langword="&amp;" /> (wskaźnik zarządzanego).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema `class`|Ładuje adres elementu tablicy w `index` na górze stosu oceny jako typ `&` (wskaźnik zarządzanego).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `array` są wypychane na stosie.  
  
2.  Wartość indeksu `index` są wypychane na stosie.  
  
3.  `index` i `array` są zdjęte ze stosu ze stosu; adresem przechowywanym w położeniu `index` w `array` będą wyszukiwane.  
  
4.  Adres są wypychane na stosie.  
  
 `ldelema` Służy do pobierania adresu obiektu od określonego indeksu tablicy obiektów (typu `class`). `ldelema` Instrukcji ładuje adres wartość indeksu `index` (typ `native int`) w tablicy jednowymiarowej liczony od zera `array` i umieszcza je w górnej części stosu. Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Wartość musi być typu `class` przekazaną za pomocą instrukcji.  
  
 Wartość zwracana dla `ldelema` jest wskaźnikiem typu zarządzanego (typ `&`).  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldelema` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wyszukuje wartość pola w obiekcie, do której odwołanie znajduje się obecnie w stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|Wypychanie wartości pola w określonym obiekcie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu (lub wskaźnik) są wypychane na stosie.  
  
2.  Odwołanie do obiektu (lub wskaźnik) zostanie zdjęte ze stosu; Znaleziono wartość określonego pola w obiekcie.  
  
3.  Wartość przechowywana w polu są wypychane na stosie.  
  
 `ldfld` Instrukcji wypycha wartości pola, znajdujące się w obiekcie na stosie. Obiekt musi być na stosie jako odwołanie do obiektu (typ `O`), wskaźnika zarządzanych (typ `&`), niezarządzanym wskaźnikiem (typ `native int`), przejściowe wskaźnika (typu `*`), lub wystąpienie typu wartości. Używanie wskaźników niezarządzanych nie jest dozwolona w weryfikowalny kod. Pola obiektu jest określony za pomocą tokenu metadanych, który musi odwoływać się do elementu członkowskiego pola. Typ zwracany jest taka sama jak skojarzony z polem. Pole może być pole statyczne lub pola wystąpienia (w takim przypadku obiekt nie może być odwołaniem do wartości null).  
  
 `ldfld` Instrukcji może być poprzedzona przez jeden lub oba <xref:System.Reflection.Emit.OpCodes.Unaligned> i <xref:System.Reflection.Emit.OpCodes.Volatile> prefiksy.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli obiekt ma wartość null i nie jest statyczne.  
  
 <xref:System.MissingFieldException> jest generowany, jeśli określone pole nie zostanie znaleziony w metadanych. Jest to zazwyczaj sprawdzana po instrukcji Microsoft Intermediate Language (MSIL) są konwertowane do kodu macierzystego, nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldfld` kod operacji:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Umożliwia znalezienie adresu pola w obiekcie, do której odwołanie znajduje się obecnie w stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|Wypycha adres `field` w określonym obiekcie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu (lub wskaźnik) są wypychane na stosie.  
  
2.  Odwołanie do obiektu (lub wskaźnik) zostanie zdjęte ze stosu; Znaleziono adres określone pole w obiekcie.  
  
3.  Adres określonego pola są wypychane na stosie.  
  
 `ldflda` Instrukcji wypycha adresu pola znajdujące się w obiekcie na stosie. Obiekt musi być na stosie jako odwołanie do obiektu (typ `O`), wskaźnika zarządzanych (typ `&`), niezarządzanym wskaźnikiem (typ `native int`), przejściowe wskaźnika (typu `*`), lub wystąpienie typu wartości. Używanie wskaźników niezarządzanych nie jest dozwolona w weryfikowalny kod. Pola obiektu jest określony za pomocą tokenu metadanych, który musi odwoływać się do elementu członkowskiego pola.  
  
 Wartość zwrócona przez obiekt `ldflda` jest wskaźnikiem typu zarządzanego (typ `&`), chyba że obiekt są wypychane na stosie jako niezarządzany wskaźnik, w którym to przypadku środki adres zwrotny jest również niezarządzany wskaźnik (typ `native int`).  
  
 `ldflda` Instrukcji może być poprzedzona przez jeden lub oba <xref:System.Reflection.Emit.OpCodes.Unaligned> i <xref:System.Reflection.Emit.OpCodes.Volatile> prefiksy.  
  
 <xref:System.InvalidOperationException> jest generowany, jeśli obiekt nie mieści się w domenie aplikacji, z którego jest uzyskiwany. Nie można załadować adresu pola, które nie znajduje się wewnątrz uzyskiwania dostępu do domeny aplikacji.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli obiekt ma wartość null i nie jest statyczne.  
  
 <xref:System.MissingFieldException> jest generowany, jeśli określone pole nie zostanie znaleziony w metadanych. Jest to zazwyczaj sprawdzana po instrukcji Microsoft Intermediate Language (MSIL) są konwertowane do kodu macierzystego, nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldflda` kod operacji:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Umieszcza niezarządzany wskaźnik (typ <see langword="native int" />) do kodu natywnego wykonywania określonej metody na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|instrukce Ldftn `method`|Umieszcza wskaźnik do metody odwołuje się `method` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Niezarządzany wskaźnik do określonej metody są wypychane na stosie.  
  
 Określonej metody (`method`) może być wywoływany przy użyciu <xref:System.Reflection.Emit.OpCodes.Calli> instrukcji, jeśli odwołuje się zarządzaną metodą (lub procedurę zastępczą, przejście z kodu zarządzanego do kodu niezarządzanego).  
  
 Wartość zwracana punktów do kodu natywnego za pomocą konwencji wywoływania środowiska CLR. This, wskaźnik metody nie powinny być przekazywane do niezarządzanego kodu natywnego jako procedura wywołania zwrotnego.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldftn` kod operacji:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="native int" /> jako <see langword="native int" /> na ocenę pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4D|ldind.i|Ładunki `native int` wartość pod adresem `addr` na stosie jako `native int`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Adres zostanie zdjęte ze stosu; wartość znajduje się pod adresem zostanie pobrany.  
  
3.  Pobrano wartość są wypychane na stosie.  
  
 `ldind.i` Instrukcji pośrednio ładuje `native int` wartość z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `native int`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji, która określa odpowiednią klasę wartości wbudowanej.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Poprawnie sformułowany Microsoft Intermediate Language (MSIL), masz pewność, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres początkowo są wypychane na stosie, muszą być wyrównane do naturalnym rozmiar obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. Typy danych jest większy niż 1 bajt kolejność bajtów jest zależny od docelowy adres CPU. Kod, który jest zależny od określanie kolejności bajtów może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldind.i` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="int8" /> jako <see langword="int32" /> na ocenę pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|46|ldind.i1|Ładunki `int8` wartość pod adresem `addr` na stosie jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Adres zostanie zdjęte ze stosu; wartość znajduje się pod adresem zostanie pobrany.  
  
3.  Pobrano wartość są wypychane na stosie. 
  
 `ldind.i1` Instrukcji pośrednio ładuje `int8` wartość z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `int32`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji, która określa odpowiednią klasę wartości wbudowanej.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Poprawnie sformułowany Microsoft Intermediate Language (MSIL), masz pewność, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres początkowo są wypychane na stosie, muszą być wyrównane do naturalnym rozmiar obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. Typy danych jest większy niż 1 bajt kolejność bajtów jest zależny od docelowy adres CPU. Kod, który jest zależny od określanie kolejności bajtów może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldind.i1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="int16" /> jako <see langword="int32" /> na ocenę pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|48|ldind.i2|Ładunki `int16` wartość pod adresem `addr` na stosie jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Adres zostanie zdjęte ze stosu; wartość znajduje się pod adresem zostanie pobrany.  
  
3.  Pobrano wartość są wypychane na stosie.  
  
 `ldind.i2` Instrukcji pośrednio ładuje `int16` wartość z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `int32`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji, która określa odpowiednią klasę wartości wbudowanej.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Poprawnie sformułowany Microsoft Intermediate Language (MSIL), masz pewność, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres początkowo są wypychane na stosie, muszą być wyrównane do naturalnym rozmiar obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. Typy danych jest większy niż 1 bajt kolejność bajtów jest zależny od docelowy adres CPU. Kod, który jest zależny od określanie kolejności bajtów może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldind.i2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="int32" /> jako <see langword="int32" /> na ocenę pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|Ładunki `int32` wartość pod adresem `addr` na stosie jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Adres zostanie zdjęte ze stosu; wartość znajduje się pod adresem zostanie pobrany.  
  
3.  Pobrano wartość są wypychane na stosie.  
  
 `ldind.i4` Instrukcji pośrednio ładuje `int32` wartość z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `int32`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji, która określa odpowiednią klasę wartości wbudowanej.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Poprawnie sformułowany Microsoft Intermediate Language (MSIL), masz pewność, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres początkowo są wypychane na stosie, muszą być wyrównane do naturalnym rozmiar obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. Typy danych jest większy niż 1 bajt kolejność bajtów jest zależny od docelowy adres CPU. Kod, który jest zależny od określanie kolejności bajtów może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldind.i4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="int64" /> jako <see langword="int64" /> na ocenę pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4C|ldind.i8|Ładunki `int64` wartość pod adresem `addr` na stosie jako `int64`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Adres zostanie zdjęte ze stosu; wartość znajduje się pod adresem zostanie pobrany.  
  
3.  Pobrano wartość są wypychane na stosie.  
  
 `ldind.i8` Instrukcji pośrednio ładuje `int64` wartość z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `int64`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji, która określa odpowiednią klasę wartości wbudowanej.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Poprawnie sformułowany Microsoft Intermediate Language (MSIL), masz pewność, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres początkowo są wypychane na stosie, muszą być wyrównane do naturalnym rozmiar obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. Typy danych jest większy niż 1 bajt kolejność bajtów jest zależny od docelowy adres CPU. Kod, który jest zależny od określanie kolejności bajtów może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldind.i8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="float32" /> jako typ <see langword="F" /> (float) na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4E|ldind.r4|Ładunki `float32` wartość pod adresem `addr` na stosie jako typ `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Adres zostanie zdjęte ze stosu; wartość znajduje się pod adresem zostanie pobrany.  
  
3.  Pobrano wartość są wypychane na stosie.  
  
 `ldind.r4` Instrukcji pośrednio ładuje `float32` wartość z określonego adresu (typu `native int`, `&`, lub *) na stosie jako typ `F`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji, która określa odpowiednią klasę wartości wbudowanej.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Poprawnie sformułowany Microsoft Intermediate Language (MSIL), masz pewność, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres początkowo są wypychane na stosie, muszą być wyrównane do naturalnym rozmiar obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. Typy danych jest większy niż 1 bajt kolejność bajtów jest zależny od docelowy adres CPU. Kod, który jest zależny od określanie kolejności bajtów może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldind.r4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="float64" /> jako typ <see langword="F" /> (float) na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4F|ldind.r8|Ładunki `float64` wartość pod adresem `addr` na stosie jako typ `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Adres zostanie zdjęte ze stosu; wartość znajduje się pod adresem zostanie pobrany.  
  
3.  Pobrano wartość są wypychane na stosie.  
  
 `ldind.r8` Instrukcji pośrednio ładuje `float64` wartość z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `float64`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji, która określa odpowiednią klasę wartości wbudowanej.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Poprawnie sformułowany Microsoft Intermediate Language (MSIL), masz pewność, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres początkowo są wypychane na stosie, muszą być wyrównane do naturalnym rozmiar obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. Typy danych jest większy niż 1 bajt kolejność bajtów jest zależny od docelowy adres CPU. Kod, który jest zależny od określanie kolejności bajtów może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldind.r8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje odwołanie do obiektu o typie <see langword="O" /> (odwołanie do obiektu) do oceny pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|50|ldind.ref|Ładuje odwołanie do obiektu pod adresem `addr` na stosie jako typ `O`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Adres zostanie zdjęte ze stosu; Odwołanie do obiektu znajdujący się pod adresem zostanie pobrany.  
  
3.  Pobrano odwołania są wypychane na stosie.  
  
 `ldind.ref` Instrukcji pośrednio ładuje odwołanie do obiektu określony adres (typu `native int`, `&`, lub *) na stosie jako typ `O`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji, która określa odpowiednią klasę wartości wbudowanej.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Poprawnie sformułowany Microsoft Intermediate Language (MSIL), masz pewność, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres początkowo są wypychane na stosie, muszą być wyrównane do naturalnym rozmiar obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. Typy danych jest większy niż 1 bajt kolejność bajtów jest zależny od docelowy adres CPU. Kod, który jest zależny od określanie kolejności bajtów może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldind.ref` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="unsigned int8" /> jako <see langword="int32" /> na ocenę pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|47|ldind.u1|Ładunki `unsigned int8` wartość pod adresem `addr` na stosie jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Adres zostanie zdjęte ze stosu; wartość znajduje się pod adresem zostanie pobrany.  
  
3.  Pobrano wartość są wypychane na stosie.  
  
 `ldind.u1` Instrukcji pośrednio ładuje `unsigned int8` wartość z określonego adresu (typu`native int`, `&`, lub *) na stosie jako `int32`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji, która określa odpowiednią klasę wartości wbudowanej.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Poprawnie sformułowany Microsoft Intermediate Language (MSIL), masz pewność, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres początkowo są wypychane na stosie, muszą być wyrównane do naturalnym rozmiar obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. Typy danych jest większy niż 1 bajt kolejność bajtów jest zależny od docelowy adres CPU. Kod, który jest zależny od określanie kolejności bajtów może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldind.u1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="unsigned int16" /> jako <see langword="int32" /> na ocenę pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|49|ldind.u2|Ładunki `unsigned int16` wartość pod adresem `addr` na stosie jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Adres zostanie zdjęte ze stosu; wartość znajduje się pod adresem zostanie pobrany.  
  
3.  Pobrano wartość są wypychane na stosie.  
  
 `ldind.u2` Instrukcji pośrednio ładuje `unsigned int16` wartość z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `int32`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji, która określa odpowiednią klasę wartości wbudowanej.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Poprawnie sformułowany Microsoft Intermediate Language (MSIL), masz pewność, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres początkowo są wypychane na stosie, muszą być wyrównane do naturalnym rozmiar obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. Typy danych jest większy niż 1 bajt kolejność bajtów jest zależny od docelowy adres CPU. Kod, który jest zależny od określanie kolejności bajtów może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldind.u2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartości typu <see langword="unsigned int32" /> jako <see langword="int32" /> na ocenę pośrednio stosu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4B|ldind.u4|Ładunki `unsigned int32` wartość pod adresem `addr` na stosie jako `int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Adres zostanie zdjęte ze stosu; wartość znajduje się pod adresem zostanie pobrany.  
  
3.  Pobrano wartość są wypychane na stosie.  
  
 `ldind.u4` Instrukcji pośrednio ładuje `unsigned int32` wartość z określonego adresu (typu `native int`, `&`, lub *) na stosie jako `int32`.  
  
 Wszystkie `ldind` instrukcje są skróty klawiaturowe <xref:System.Reflection.Emit.OpCodes.Ldobj> instrukcji, która określa odpowiednią klasę wartości wbudowanej.  
  
 Należy pamiętać, że wartości całkowitych o mniej niż 4 bajty zostają rozszerzone, aby `int32` (nie `native int`), gdy są one załadowane na stosie oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` wpisz po załadowaniu na stosie oceny.  
  
 Poprawnie sformułowany Microsoft Intermediate Language (MSIL), masz pewność, że `ldind` instrukcje są używane w sposób zgodny z typem wskaźnika.  
  
 Adres początkowo są wypychane na stosie, muszą być wyrównane do naturalnym rozmiar obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić (zobacz <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcję środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresów (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. Typy danych jest większy niż 1 bajt kolejność bajtów jest zależny od docelowy adres CPU. Kod, który jest zależny od określanie kolejności bajtów może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException> może zostać wygenerowany, jeśli zostanie wykryty nieprawidłowy adres.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldind.u4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha liczby elementów nieujemną jednowymiarową tablicę na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8E|ldlen|Wypycha długość (typu `natural unsigned int`) tablicy na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy są wypychane na stosie.  
  
2.  Odwołanie do tablicy zostanie zdjęte ze stosu i długość jest kolumną obliczaną.  
  
3.  Długość są wypychane na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Długość jest zwracana jako `natural unsigned int`.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli odwołanie do tablicy jest odwołanie o wartości null.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldlen` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmienna lokalna o określonym indeksie na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc `index`|Ładuje zmienna lokalna o indeksie `index` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości zmiennej lokalnej o określonym indeksie są wypychane na stosie.  
  
 `ldloc` Instrukcji wypycha zawartość numer zmiennej lokalnej o indeksie przekazany na stosie oceny gdzie zmienne lokalne są numerowane 0 lub nowszy. Zmienne lokalne są inicjowane na wartość 0, przed wprowadzeniem metody tylko wtedy, gdy flaga zainicjować metody ma wartość true. Istnieją 65 535 (2 ^ 16 - 1) zmienne lokalne możliwe (0-65,534). 65 535 indeksu jest nieprawidłowy, ponieważ implementacje prawdopodobnie będzie używać 2-bajtowych liczb całkowitych do śledzenia indeksu zarówno lokalnych, wraz z łączną liczbę zmiennych lokalnych dla danej metody. Indeks 65535 dokonano prawidłowe, wymagałoby na liczbę całkowitą szersze śledzić liczbę zmiennych lokalnych w takiej metody.  
  
 `ldloc.0`, `ldloc.1`, `ldloc.2`, I `ldloc.3` instrukcje stanowią efektywne kodowanie do uzyskiwania dostępu do zmiennych lokalnych pierwsze cztery.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej jest określony w nagłówku metody. Zobacz partycji I. lokalnych zmiennych, które są mniejsze niż 4 bajty są rozszerzane do typu `int32` , gdy są one załadowane na stosie. Wartości zmiennoprzecinkowe są rozszerzane do ich rozmiaru natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `ldloc` kod operacji:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, krótki)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmienna lokalna o indeksie 0 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|06|ldloc.0|Ładuje zmienna lokalna o indeksie 0 na stosie oceny.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości zmiennej lokalnej o indeksie 0 są wypychane na stosie.  
  
 `ldloc.0` jest szczególnie wydajne kodowania dla <xref:System.Reflection.Emit.OpCodes.Ldloc>, zezwalając na dostęp do zmiennej lokalnej o indeksie 0.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej jest określony w nagłówku metody. Zmienne lokalne, które są mniejsze niż 4 bajty są rozszerzane do typu `int32` , gdy są one załadowane na stosie. Wartości zmiennoprzecinkowe są rozszerzane do ich rozmiaru natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldloc.0` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmienna lokalna pod indeksem 1 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|07|ldloc.1|Ładuje zmienna lokalna pod indeksem 1 na stosie oceny.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości zmiennej lokalnej pod indeksem 1 są wypychane na stosie.  
  
 `ldloc.1` jest szczególnie wydajne kodowania dla <xref:System.Reflection.Emit.OpCodes.Ldloc>, zezwalając na dostęp do zmiennej lokalnej pod indeksem 1.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej jest określony w nagłówku metody. Zmienne lokalne, które są mniejsze niż 4 bajty są rozszerzane do typu `int32` , gdy są one załadowane na stosie. Wartości zmiennoprzecinkowe są rozszerzane do ich rozmiaru natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldloc.1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmienna lokalna pod indeksem 2 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|08|ldloc.2|Ładuje zmienna lokalna pod indeksem 2 na stosie oceny.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości zmiennej lokalnej pod indeksem 2 są wypychane na stosie.  
  
 `ldloc.2` jest szczególnie wydajne kodowania dla <xref:System.Reflection.Emit.OpCodes.Ldloc>, zezwalając na dostęp do zmiennej lokalnej pod indeksem 2.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej jest określony w nagłówku metody. Zmienne lokalne, które są mniejsze niż 4 bajty są rozszerzane do typu `int32` , gdy są one załadowane na stosie. Wartości zmiennoprzecinkowe są rozszerzane do ich rozmiaru natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldloc.2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmienna lokalna o indeksie 3 na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|09|ldloc.3|Ładuje zmienna lokalna o indeksie 3 na stosie oceny.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości zmiennej lokalnej o indeksie 3 są wypychane na stosie.  
  
 `ldloc.3` jest szczególnie wydajne kodowania dla <xref:System.Reflection.Emit.OpCodes.Ldloc>, zezwalając na dostęp do zmiennej lokalnej o indeksie 3.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej jest określony w nagłówku metody. Zmienne lokalne, które są mniejsze niż 4 bajty są rozszerzane do typu `int32` , gdy są one załadowane na stosie. Wartości zmiennoprzecinkowe są rozszerzane do ich rozmiaru natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldloc.3` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmienna lokalna o określonym indeksie na stosie oceny, krótka.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|Ładuje zmienna lokalna o indeksie `index` na stosie, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości zmiennej lokalnej o określonym indeksie są wypychane na stosie.  
  
 `ldloc.s` Instrukcji wypycha zawartość numer zmiennej lokalnej o indeksie przekazany na stosie oceny gdzie zmienne lokalne są numerowane 0 lub nowszy. Zmienne lokalne są inicjowane na wartość 0, przed wprowadzeniem metody, jeśli flaga zainicjować metody ma wartość true. Istnieją 256 (2 ^ 8) zmiennych lokalnych możliwe (0 – 255) w krótkiej formy, która jest bardziej efektywne kodowanie niż `ldloc`.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej jest określony w nagłówku metody. Zobacz partycji I. lokalnych zmiennych, które są mniejsze niż 4 bajty są rozszerzane do typu `int32` , gdy są one załadowane na stosie. Wartości zmiennoprzecinkowe są rozszerzane do ich rozmiaru natywnego (typ `F`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `ldloc.s` kod operacji:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, bajtów)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje adres zmiennej lokalnej o określonym indeksie na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE OD &LT; `unsigned int16` >|ldloca `index`|Ładuje adres zmiennej lokalnej o `index` na stosie oceny.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres przechowywany w zmiennej lokalnej o określonym indeksie są wypychane na stosie.  
  
 `ldloca` Instrukcji wypycha adres numer zmiennej lokalnej o indeksie przekazany na stosie, gdy zmienne lokalne są numerowane 0 lub nowszy. Wartość wypychane na stos jest już powiązana poprawnie do użytku z instrukcji takich jak <xref:System.Reflection.Emit.OpCodes.Ldind_I> i <xref:System.Reflection.Emit.OpCodes.Stind_I>. Wynik jest wskaźnikiem przejściowy (typ `*`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldloca` kod operacji:  
  
-   ILGenerator.Emit (OpCode, krótki)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje adres zmiennej lokalnej o określonym indeksie na stosie oceny, krótka.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|Ładuje adres zmiennej lokalnej o `index` na stosie oceny krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres przechowywany w zmiennej lokalnej o określonym indeksie są wypychane na stosie.  
  
 `ldloca.s` Instrukcji wypycha adres numer zmiennej lokalnej o indeksie przekazany na stosie, gdy zmienne lokalne są numerowane 0 lub nowszy. Wartość wypychane na stos jest już powiązana poprawnie do użytku z instrukcji takich jak <xref:System.Reflection.Emit.OpCodes.Ldind_I> i <xref:System.Reflection.Emit.OpCodes.Stind_I>. Wynik jest wskaźnikiem przejściowy (typ `*`).  
  
 `ldloca.s` Instrukcji zapewnia efektywne kodowanie do użycia ze zmiennymi lokalnymi od 0 do 255.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldloca.s` kod operacji:  
  
-   ILGenerator.Emit (OpCode, bajtów)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha odwołanie o wartości null (typ <see langword="O" />) na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|14|ldnull|Wypychanie odwołanie o wartości null na stosie|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu o wartości null są wypychane na stosie.  
  
 `ldnull` wypycha odwołanie o wartości null (typ `O`) na stosie. Służy to do zainicjowania lokalizacje przed wypełniony danymi lub mogą stać się przestarzałe.  
  
 `ldnull` zawiera odwołanie o wartości null, który jest niezależny od rozmiaru.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldnull` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopie obiektu typu wartościowego wskazywana przez adres na górze stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Kopiuj wystąpienie typu wartości `class` stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres obiektu typu wartościowego są wypychane na stosie.  
  
2.  Adres zostanie zdjęte ze stosu i wyszukiwane są wystąpienia pod tym adresem.  
  
3.  Wartość obiektu przechowywane pod tym adresem są wypychane na stosie.  
  
 `ldobj` Instrukcji jest używany do przekazywania typu wartości jako parametr.  
  
 `ldobj` Instrukcji kopiuje wartość wskazywana przez `addrOfValObj` (typu `&`, `*`, lub `native int`) na górze stosu. Liczbą bajtów skopiowanych zależy od rozmiaru klasy (zgodnie z określonym `class` parametru). `class` Parametr jest token metadanych reprezentujący typ wartości.  
  
 Działanie `ldobj` instrukcji może być zmienione przez bezpośrednio poprzedzający <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.TypeLoadException> jest generowany, jeśli nie można odnaleźć klasy. Jest to zazwyczaj wykrywany, po instrukcji Microsoft Intermediate Language (MSIL) jest konwertowana do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldobj` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha wartość pola statycznego na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|Wypychanie wartości `field` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość określonego pola są wypychane na stosie.  
  
 `ldsfld` Instrukcji wypycha wartość statyczne (współużytkowane przez wszystkie wystąpienia klasy) pola na stosie. Typ zwracany jest skojarzone z tokenem przekazany metadanych `field`.  
  
 `ldsfld` Instrukcji może mieć <xref:System.Reflection.Emit.OpCodes.Volatile> prefiks.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldsfld` kod operacji:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha adresu statycznego pola na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|Wypychanie adres `field` na stosie|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres określonego pola są wypychane na stosie.  
  
 `ldsflda` Instrukcji wypycha adres statyczne (współużytkowane przez wszystkie wystąpienia klasy) pola na stosie. Adres może być reprezentowana jako przejściowe wskaźnika (typ `*`) Jeśli token metadanych `field` odwołuje się do typu, którego pamięć jest zarządzana. W przeciwnym razie odpowiadający mu niezarządzany wskaźnik (typ `native int`). Należy pamiętać, że `field` statycznego mogą być globalne przy użyciu przypisanych względny adres wirtualny (przesunięcia z pola Adres podstawowy, w którym jego zawierającego plik PE jest ładowany do pamięci) pamięci w przypadku niezarządzanych.  
  
 `ldsflda` Instrukcji może mieć <xref:System.Reflection.Emit.OpCodes.Volatile> prefiks.  
  
 <xref:System.MissingFieldException> jest generowany, jeśli pole nie zostanie znaleziony w metadanych. Jest to zazwyczaj sprawdzana po instrukcji Microsoft Intermediate Language (MSIL) są konwertowane do kodu macierzystego, nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldsflda` kod operacji:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha nowe odwołanie do obiektu, do literału ciągu przechowywany w metadanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|Obiekt ciągu dla token ciągu metadanych wypycha `mdToken`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu na ciąg są wypychane na stosie.  
  
 `ldstr` Instrukcji wypycha odwołanie do obiektu (typ `O`) na obiekt ciągu reprezentujący określony ciąg znaków literału przechowywany w metadanych. `ldstr` Instrukcji przydziela wymaganego ilość pamięci i wykonuje żadnych konwersji formatów, wymaganych do przekonwertowania literału ciągu w formularzu, który został użyty w pliku formatu ciągu wymagane w czasie wykonywania.  
  
 Common Language Infrastructure (CLI) gwarantuje, że wynik dwa `ldstr` instrukcje odwołujące się do dwa tokeny metadanych, które mają taką samą sekwencję znaków przywrócić dokładnie tego samego ciągu obiektu (proces znany jako "wewnętrzne przygotowanie ciągu").  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldstr` kod operacji:  
  
-   ILGenerator.Emit (OpCode, ciąg)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje token metadanych na jego reprezentację środowiska uruchomieniowego, wypychając ją na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D0 < `T` >|Ldtoken `token`|Konwertuje token metadanych na jego reprezentację środowiska uruchomieniowego.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Token przekazany jest konwertowany na `RuntimeHandle` i wypychane na stosie.  
  
 `ldtoken` Wypchnięć instrukcji `RuntimeHandle` dla tokenu określonych metadanych. A `RuntimeHandle` może być `fieldref/fielddef`, `methodref/methoddef`, lub `typeref/typedef`.  
  
 Wartość wypychane na stos może służyć w wywołaniach `Reflection` metody w bibliotece klas systemowych.  
  
 Aby uzyskać informacji na temat obsługi środowiska uruchomieniowego, zobacz następujące klasy: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, i <xref:System.RuntimeMethodHandle>.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `ldtoken` kod operacji:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Umieszcza niezarządzany wskaźnik (typ <see langword="native int" />) do kodu natywnego wykonywania określonej metody wirtualnej skojarzone z określonego obiektu na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 07 &LT; `T` >|ldvirtftn `method`|Wypychanie wskaźnik do obiektu metodę wirtualną `method` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu są wypychane na stosie.  
  
2.  Odwołanie do obiektu zostanie zdjęte ze stosu i adres punktu wejścia do metody (określone przez token metadanych `method`) będą wyszukiwane.  
  
3.  Wskaźnik do `method` są wypychane na stosie.  
  
 Niezarządzany wskaźnik wynikowy wypychane na stosie przez `ldvirtftn` instrukcji można wywoływać za pomocą <xref:System.Reflection.Emit.OpCodes.Calli> instrukcji, jeśli odwołuje się zarządzaną metodą (lub procedurę zastępczą, przejście z kodu zarządzanego do kodu niezarządzanego).  
  
 Niezarządzany wskaźnik wskazuje kodu natywnego za pomocą konwencji wywoływania środowiska CLR. This, wskaźnik metody nie powinny być przekazywane do niezarządzanego kodu natywnego jako procedura wywołania zwrotnego.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ldvirtftn` kod operacji:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamyka chronione regionów kodu, bezwarunkowo transferowanie formantu do instrukcji określony element docelowy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DD < `int32` >|Pozostaw `target`|Zamyka chronione regionów kodu.|  
  
 Nie ma żadnych stosu przejścia nieaktywności dla tej instrukcji.  
  
 `leave` Instrukcji bezwarunkowo przekazuje sterowanie do instrukcji określonych docelowych, reprezentowane jako 4-bajtowych oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 `leave` Instrukcji jest podobna do `br` instrukcji, ale można zamknąć `try`, `filter`, lub `catch` blokowania, natomiast instrukcji gałęzi zwykłych należy używać tylko w tych bloku do przekazywania kontroli w ramach go. `leave` Instrukcji opróżnia stosu oceny i zapewnia, że odpowiednie otaczającego `finally` bloki są wykonywane.  
  
 Nie można użyć `leave` instrukcji, aby zakończyć działanie `finally` bloku. Do generowania kodu dla obsługi wyjątków jest prawidłowy z wnętrza bloku catch służące do jej obsługi ułatwiają `leave` kontrola jest przekazywana do żadnych instrukcji w skojarzonej instrukcji `try` bloku.  
  
 Jeśli instrukcja zawiera co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `leave` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamyka chronione regionów kodu, bezwarunkowo transferowanie formantu do instrukcji docelowej (krótka).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DE < `int8` >|Leave.s `target`|Zamknij chronione regionów kodu, krótka.|  
  
 Nie ma żadnych stosu przejścia nieaktywności dla tej instrukcji.  
  
 `leave.s` Instrukcji bezwarunkowo przekazuje sterowanie do instrukcji docelowej przekazany, reprezentowane jako 1-bajtowe oznaczone przesunięcie od początku instrukcji zgodnie z bieżącej instrukcji.  
  
 `leave.s` Instrukcji jest podobna do `br` instrukcji, ale można zamknąć `try`, `filter`, lub `catch` blokowania, natomiast instrukcji gałęzi zwykłych należy używać tylko w tych bloku do przekazywania kontroli w ramach go. `leave.s` Instrukcji opróżnia stosu oceny i zapewnia, że odpowiednie otaczającego `finally` bloki są wykonywane.  
  
 Nie można użyć `leave.s` instrukcji, aby zakończyć działanie `finally` bloku. Do generowania kodu dla obsługi wyjątków jest prawidłowy z wnętrza bloku catch służące do jej obsługi ułatwiają `leave.s` kontrola jest przekazywana do żadnych instrukcji w skojarzonej instrukcji `try` bloku.  
  
 Jeśli instrukcja zawiera co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `leave.s` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przydziela określoną liczbę bajtów z puli lokalnej pamięci dynamicznej, a następnie wypycha adres (wskaźnik przejściowym, typ <see langword="*" />) pierwszego bajtu przydzielony na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0F|operacji localloc|Przydzielanie miejsca z lokalnej sterty.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Liczba bajtów do przydzielenia, są wypychane na stosie.  
  
2.  Liczba bajtów zostanie zdjęte ze stosu; ilość pamięci, odpowiadający rozmiar jest przydzielany z lokalnej sterty.  
  
3.  Wskaźnik do pierwszego bajtu ilość przydzielonej pamięci są wypychane na stosie.  
  
 `localloc` Przydziela instrukcji `size` (typ `natural unsigned int`) bajtów z lokalnej pamięci dynamicznej w puli i zwraca adres (wskaźnik przejściowym, typ `*`) pierwszego bajtu przydzielone. Blok pamięci zwracany jest inicjowana wartością 0 tylko wtedy, gdy flaga inicjowania w metodzie `true`. Po wykonaniu bieżącej metody <xref:System.Reflection.Emit.OpCodes.Ret>, puli pamięci lokalnej jest udostępniana do ponownego użycia.  
  
 Otrzymany adres jest wyrównywany tak, aby dowolnego typu danych pierwotnych może znajdować się za pomocą `stind` instrukcje (takie jak <xref:System.Reflection.Emit.OpCodes.Stind_I4>) i załadowany przy użyciu `ldind` instrukcje (takie jak <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  
  
 `localloc` Instrukcji nie mogą występować w `filter`, `catch`, `finally`, lub `fault` bloku.  
  
 <xref:System.StackOverflowException> jest generowany, jeśli pamięć jest niewystarczająca do obsługi żądania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `localloc` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha wpisane odwołania do wystąpienia określonego typu na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|C6 < `T` >|Operacja Mkrefany `class`|Wypycha wpisane odwołanie typu `class` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wskaźnik do elementu danych są wypychane na stosie.  
  
2.  Wskaźnik jest zdjęte ze stosu i konwertowana do typizowanych odwołanie typu `class`.  
  
3.  Wpisane odwołania są wypychane na stosie.  
  
 `mkrefany` Instrukcji obsługuje przekazywanie odwołania o typach określanych dynamicznie. Wskaźnik musi być typu `&`, `*`, lub `native int`i przytrzymaj prawidłowy adres elementu danych. `Class` jest token klasy opisujące typ danych odwołuje się wskaźnik myszy. `Mkrefany` wypycha wpisane odwołania na stosie, zapewniając deskryptora nieprzezroczyste wskaźnika i typ `class`.  
  
 Jedyne prawidłowe Operacja dozwolona po wpisane odwołania jest przekazywany do metody, która wymaga to dodania odwołania typizowane jako parametr. Obiekt wywoływany może następnie użyć <xref:System.Reflection.Emit.OpCodes.Refanytype> i <xref:System.Reflection.Emit.OpCodes.Refanyval> instrukcjami, aby pobrać typ (klasa) oraz adres, odpowiednio.  
  
 <xref:System.TypeLoadException> jest generowany, jeśli `class` nie można odnaleźć. Jest to zazwyczaj wykrywany, po instrukcji Microsoft Intermediate Language (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `mkrefany` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Mnoży dwie wartości, a następnie wypycha wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5A|mul|Mnoży dwie wartości na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest mnożony przez `value2`.  
  
4.  Wyniki są wypychane na stosie.  
  
 `mul` Mnoży instrukcji `value1` przez `value2` i umieszcza wynik na stosie. Operacje całkowitą obciąć dyskretnie górny usługi bits przy przepełnieniu.  
  
 Zobacz <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> dla określonej liczby całkowitej, należy pomnożyć operację, podając obsługi przepełnienia.  
  
 Dla typów zmiennopozycyjnych 0 * nieskończoności = NaN.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `mul` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Mnoży dwie liczby całkowite, przeprowadza sprawdzanie przepełnienia, a wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|Mnoży dwie wartości liczby całkowitej na stosie ze sprawdzeniem przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest mnożony przez `value2`, ze sprawdzeniem przepełnienia.  
  
4.  Wyniki są wypychane na stosie.  
  
 `mul.ovf` Instrukcji mnoży liczbę całkowitą `value1` przez liczbę całkowitą `value2` i umieszcza wynik na stosie. Wyjątek jest generowany, jeśli wynik nie zmieści się w typie wyniku.  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `mul.ovf` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Mnoży dwie wartości liczb całkowitych bez znaku, przeprowadza sprawdzanie przepełnienia i umieszcza wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|Mnoży dwie wartości nieoznaczone na stosie ze sprawdzeniem przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value1` jest mnożony przez `value2`, ze sprawdzeniem przepełnienia.  
  
4.  Wyniki są wypychane na stosie.  
  
 `mul.ovf.un` Instrukcji mnoży liczbę całkowitą bez znaku `value1` przez liczbę całkowitą bez znaku `value2` i umieszcza wynik na stosie. Wyjątek jest generowany, jeśli wynik nie zmieści się w typie wyniku.  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `mul.ovf.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Neguje wartości, a następnie wypycha wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|65|neg|Zmienia znak wartości obecnie na górze stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości są wypychane na stosie.  
  
2.  Wartość jest zdjęte ze stosu ze stosu i ujemna.  
  
3.  Wyniki są wypychane na stosie.  
  
 `neg` Instrukcji neguje wartość i umieszcza wynik na górze stosu. Zwracany typ jest taki sam jak typ operandu.  
  
 Negacja wartości całkowitych jest standardowa dwójki uzupełniają negacji. W szczególności Negacja liczbę najbardziej ujemną, (która nie ma odpowiednika dodatni) daje najbardziej ujemną. Wykrywa to użycie przepełnienie <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instrukcji zamiast (czyli odjęcia od 0).  
  
 Negacja liczba zmiennoprzecinkowa przepełnienie nie jest możliwe, a Negacja NaN zwraca NaN.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `neg` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha odwołanie do obiektu na nową tablicę indeksowaną od zera, jednowymiarową której elementy są określonego typu na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr `etype`|Tworzy nową tablicę z elementami typu `etype`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Liczba elementów w tablicy są wypychane na stosie.  
  
2.  Liczba elementów, które zostanie zdjęte ze stosu i utworzeniu tablicy.  
  
3.  Odwołanie do obiektu do nowej tablicy są wypychane na stosie.  
  
 `newarr` Instrukcji wypycha odwołanie do obiektu (typ `O`) do nowej tablicy liczony od zera, jednowymiarową której elementy są typu `etype` (opisujące typ tokenu metadanych). Liczba elementów w nowej tablicy, powinien być określony jako `native int`. Prawidłową tablicą zakres indeksy od zera do maksymalną liczbę elementów minus jeden.  
  
 Elementy tablicy mogą być dowolnego typu, łącznie z typami wartości.  
  
 Liczony od zera, jednowymiarową. tablice liczb są tworzone za pomocą tokenu metadanych odwołuje się do typu odpowiednie wartości (<xref:System.Int32>i tak dalej). Elementy tablicy są inicjowane na wartość 0 odpowiedniego typu.  
  
 Tablice jednowymiarowe NonZero-zależności i tablice wielowymiarowe są tworzone przy użyciu <xref:System.Reflection.Emit.OpCodes.Newobj> zamiast `newarr`. Więcej często są one tworzone, za pomocą metody <xref:System.Array> klasy w .NET Framework.  
  
 <xref:System.OutOfMemoryException> jest generowany, jeśli pamięć jest niewystarczająca do spełnienia żądania.  
  
 <xref:System.OverflowException> jest generowany, jeśli `numElems` jest mniejszy niż 0.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `newarr` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tworzy nowy obiekt lub nowe wystąpienie typu wartości wypychanie odwołanie do obiektu (typ <see langword="O" />) na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Przydziela niezainicjowanego obiektu lub typu wartości i wywołuje metodę konstruktora `ctor`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Argumenty `arg1` za pośrednictwem `argn` są wypychane na stos w sekwencji.  
  
2.  Argumenty `argn` za pośrednictwem `arg1` zdjęte ze stosu ze stosu i przekazywane do `ctor` do tworzenia obiektów.  
  
3.  Odwołanie do nowego obiektu są wypychane na stosie.  
  
 `newobj` Instrukcja tworzy nowy obiekt lub nowe wystąpienie typu wartości. `Ctor` jest to token metadanych ( `methodref` lub `methoddef` muszą być oznaczone jako Konstruktor) oznacza to nazwa, klasa i sygnatury konstruktora do wywołania.  
  
 `newobj` Instrukcji przydziela nowe wystąpienie klasy skojarzonej z `ctor` i inicjalizuje wszystkie pola w nowym wystąpieniu na 0 (właściwego typu) lub odwołania o wartości null, zgodnie z potrzebami. Następnie wywołuje on Konstruktor `ctor` danego argumentów wraz z nowo utworzone wystąpienie. Po wywołaniu konstruktora teraz inicjowane odwołanie do obiektu (typ `O`) są wypychane na stosie.  
  
 Z punktu widzenia Konstruktor niezainicjowanego obiektu jest argumentem 0, a inne argumenty przekazane do NowyObiekt wykonaj w kolejności.  
  
 Wszystkie tablice liczony od zera, jednowymiarową są tworzone przy użyciu <xref:System.Reflection.Emit.OpCodes.Newarr>, a nie `newobj`. Z drugiej strony wszystkie tablice (więcej niż jednym wymiarze, lub w jednowymiarowa ale nie od zera) są tworzone przy użyciu `newobj`.  
  
 Typy wartości nie są zwykle tworzone przy użyciu `newobj`. Zazwyczaj są przydzielane jako argumenty lub zmiennych lokalnych za pomocą `newarr` (dla tablic liczony od zera, jednowymiarową), lub jako pola obiektów. Po przydzieleniu, są inicjowanie przy użyciu <xref:System.Reflection.Emit.OpCodes.Initobj>. Jednak `newobj` instrukcji może służyć do tworzenia nowego wystąpienia typu wartości na stosie, który może być następnie przekazywany jako argument, przechowywane w lokalnej i tak dalej.  
  
 <xref:System.OutOfMemoryException> jest generowany, jeśli pamięć jest niewystarczająca do spełnienia żądania.  
  
 <xref:System.MissingMethodException> jest generowany, jeśli metoda konstruktora `ctor` o nazwie wskazanej klasy i podpis nie został odnaleziony. Jest to zazwyczaj wykrywany, po instrukcji Microsoft Intermediate Language (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `newobj` kod operacji:  
  
-   ILGenerator.Emit(OpCode, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypełnia miejsce, jeśli rozkazów są poprawek. Nie znaczących operacja została wykonana, mimo że cyklu przetwarzania, które mogą być używane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|00|NOP|Wykonuje operację bez zachowania.|  
  
 Nie ma żadnych stosu przejściowe zachowanie zdefiniowane w tej instrukcji.  
  
 `nop` Operacji nic nie robi. Jest on przeznaczony do Wypełnij miejsce, jeśli rozkazów są poprawek.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `nop` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oblicza bitowe uzupełnienie wartość całkowitą na szczycie stosu, a następnie wypycha wynik na stosie oceny tego samego typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|66|not|Oblicza uzupełnienie bitowe wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value` są wypychane na stosie.  
  
2.  `value` zostanie zdjęte ze stosu i jego bitowe uzupełnienie obliczane.  
  
3.  Wyniki są wypychane na stosie.  
  
 `not` Instrukcja oblicza bitowe uzupełnienie wartością całkowitą z zakresu i umieszcza wynik na stosie. Zwracany typ jest taki sam jak typ operandu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `not` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obliczenia bitowe uzupełnienie dwóch liczb całkowitych wartości na szczycie stosu i umieszcza wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|60|lub|Oblicza operatora testu koniunkcji lub z dwóch wartości całkowitych, zwraca liczbę całkowitą.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu i ich bitowe OR obliczane.  
  
4.  Wyniki są wypychane na stosie.  
  
 `or` Instrukcja oblicza logiczną lub dwie wartości na jego podstawie stosu, wypychanie wynik na stosie.  
  
 `Or` jest operacją specyficzne dla liczby całkowitej.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `or` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usuwa wartość obecnie na szczycie stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|26|POP|Pobiera najwyższą wartość ze stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Najwyższą wartość zostanie zdjęte ze stosu.  
  
 `pop` Instrukcji usuwa górny element ze stosu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `pop` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zastrzeżony instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zastrzeżony instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zastrzeżony instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zastrzeżony instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zastrzeżony instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zastrzeżony instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zastrzeżony instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to zastrzeżony instrukcji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że kolejne tablicę adresów są wykonywane żadne sprawdzenie typu w czasie wykonywania i którego zmienność go zwraca wskaźnik zarządzanego jest ograniczona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format programu Microsoft intermediate language (MSIL) zestawu, wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 1E|tylko do odczytu.|Określ, czy kolejnych tablicy adresu są wykonywane żadne sprawdzenie typu w czasie wykonywania i zwraca wskaźnik zarządzanego, z ograniczeniami zmienność.|  
  
 Ten prefiks może się pojawić tylko bezpośrednio poprzedzającego `ldelema` instrukcji i wywołania do specjalnej `Address` metody na tablicach. Jego wpływ na kolejna operacja ma dwa cele:  
  
1.  W czasie wykonywania odbywa się żadna operacja sprawdzania typu. Należy pamiętać, że zwykle niejawnego typu Wyszukaj `ldelema` i `stelem` instrukcje stosowania na odwołanie do typu tablic. Nigdy nie jest typu run-time Wyszukaj klasy wartości, więc `readonly` w takiej sytuacji jest pusta.  
  
2.  Weryfikator wynik operacji adresu jest traktuje jako wskaźnika zarządzanych z ograniczeniami zmienność.  
  
 Wskaźnik jest nazywany ograniczono zmienność, ponieważ typ definiujący kontroluje, czy można zmutować wartość. Dla klas wartości, które ujawniają nie pola publiczne lub metody, które zaktualizuj tę wartość w miejscu, wskaźnik jest tylko do odczytu (stąd nazwa prefiks). W szczególności klas reprezentujących typy pierwotne (na przykład System.Int32) nie ujawniaj metody ustawiającej, a zatem będą tylko do odczytu.  
  
 Wskaźnika zarządzanych z ograniczeniami w ten sposób może służyć tylko w następujący sposób:  
  
-   Jako `object` parametr `ldfld`, `ldflda`, `stfld`, `call`, lub`constrained callvirt` instrukcje.  
  
-   Jako `pointer` parametr `ldobj` instrukcji lub do jednego z `ldind` instrukcje.  
  
-   Jako `source` parametr `cpobj` instrukcji.  
  
 Wszystkie pozostałe operacje niedozwolone w tym `stobj`, `initobj`, lub `mkrefany` operacji lub dowolny z `stind` instrukcje.  
  
 Celem `readonly` prefiks jest aby uniknąć sprawdzania typu podczas pobierania elementu z tablicy w kodzie rodzajowym. Na przykład, wyrażenie `arr[i].m()`, w którym typ elementu tablicy `arr` jest typem ogólnym, która została ograniczona do interfejs za pomocą metody `m`, może być kompilowana do następujących MSIL.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Bez `readonly` prefiksu, `ldelema` instrukcji wykona sprawdzenie typu w przypadku których! 0 był typem referencyjnym. Nie tylko jest to sprawdzenie typu nieefektywne, ale jest semantycznie nieprawidłowe. Sprawdzanie typu `ldelema` dokładne dopasowanie, który jest zbyt silne. Jeżeli tablica podklasy typu! 0, powyższy kod może zakończyć się niepowodzeniem sprawdzanie typów.  
  
 Adres elementu tablicy jest pobierana, zamiast elementu, aby uzyskać dojścia do `arr[i]` działa zarówno typy wartości i typy odwołań i dlatego może być przekazywany do `constrained callvirt` instrukcji.  
  
 Ogólnie rzecz biorąc byłoby niebezpieczne pominąć sprawdzanie w czasie wykonania, jeśli tablicy przechowywane elementy typu odwołania. Jest to niezbędne do zapewnienia, że nie do tablicy modyfikacje za pomocą tego wskaźnika. Reguły weryfikatora warunek ten był spełniony. Ograniczone wskaźnika zarządzanych mogą być przekazywane jako obiekt wywołaniach metod wystąpień, co nie jest ściśle rzecz ujmując tylko do odczytu dla typów wartości, ale nie problemu bezpieczeństwa typu dla typów wartości.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `readonly` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera token typu osadzonego w wpisane odwołania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|Wypycha tokenu typu przechowywane w wpisane odwołania.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do typu wartości są wypychane na stosie.  
  
2.  Wpisane odwołania zostanie zdjęte ze stosu i pobrać jego odpowiedniego tokenu typu.  
  
3.  Token typu są wypychane na stosie.  
  
 Wpisane odwołania zawiera token typu i adres na wystąpienie obiektu.  
  
 `refanytype` Instrukcji pobiera tokenu typu osadzonego w wpisane odwołania. Zobacz <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrukcji, aby uzyskać informacje na temat tworzenia wpisane odwołania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `refanytype` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres (typ <see langword="&amp;" />) osadzonego w wpisane odwołania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|Wypycha adresem przechowywanym w odwołania typizowane.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do typu wartości są wypychane na stosie.  
  
2.  Wpisane odwołania zostanie zdjęte ze stosu i pobrać odpowiedni adres.  
  
3.  Adres są wypychane na stosie.  
  
 Wpisane odwołania zawiera token typu i adres na wystąpienie obiektu.  
  
 `refanyval` Instrukcji pobiera adres osadzone w wpisane odwołania. Typ osadzone w wpisane odwołania podane na stosie musi być zgodna z typem określonym przez `type` (metadane token albo `typedef` lub `typeref`). Zobacz <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrukcję powiązanej zawartości.  
  
 <xref:System.InvalidCastException> jest generowany, jeśli `type` nie jest identyczny z ich typem w odwołaniu do typu (w tym przypadku `type` jest klasa dostarczony do <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrukcji, która skonstruowany powiedział wpisane odwołania).  
  
 <xref:System.TypeLoadException> jest generowany, jeśli `type` nie można odnaleźć.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `refanyval` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dzieli dwie wartości, a następnie wypycha resztę na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5D|rem|Wypycha resztę z dzielenia `value1` przez `value2` na stosie.|  
  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  A `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu i pozostałą część `value1` `div` `value2` obliczane.  
  
4.  Wyniki są wypychane na stosie.  
  
 `result` = `value1` `rem` `value2` spełnia następujące warunki:  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`), oraz:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;, logowania (`result`) = logowanie (`value1`), gdzie `div` jest instrukcji podziału, która obcina w kierunku zera.  
  
 Jeśli `value2` ma wartość zero lub `value1` jest nieskończoność, wynik jest wartością typu NaN. Jeśli `value2` jest nieskończoność, wynik jest `value1` (ujemna dla `-infinity`).  
  
 Operacje typu całkowitego throw <xref:System.DivideByZeroException> Jeśli `value2` wynosi zero.  
  
 Należy pamiętać, że na platformach opartych na architekturze Intel <xref:System.OverflowException> jest zgłaszany, gdy obliczeń (minint `rem` -1).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `rem` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dzieli dwie wartości nieoznaczone, a następnie wypycha resztę na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5E|rem.un|Wypycha resztę z dzielenia bez znaku `value1` przez niepodpisane `value2` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu i pozostałą część `value1` `div` `value2` obliczane.  
  
4.  Wyniki są wypychane na stosie.  
  
 `result` = `value1` `rem.un` `value2` spełnia następujące warunki:  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`), oraz:  
  
 0 = `result`  <  `value2`, gdzie `div.un` jest instrukcją dzielenia bez znaku.  
  
 `rem.un` Oblicza instrukcji `result` a następnie wypycha go na stosie. `Rem.un` traktuje jego argumenty jako liczb całkowitych bez znaku, podczas gdy <xref:System.Reflection.Emit.OpCodes.Rem> traktować je jak oznaczone liczby całkowite.  
  
 `Rem.un` jest podana w przypadku liczb zmiennoprzecinkowych.  
  
 Operacje typu całkowitego throw <xref:System.DivideByZeroException> Jeśli `value2` wynosi zero.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `rem.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca ciąg z bieżącej metody (jeśli istnieje) wypychanie zwracana wartość ze stosu oceny funkcji na stosie oceny obiektu wywołującego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2A|instrukcji|Zwraca metodę, być może zwracać wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość zwracana zostanie zdjęte ze stosu oceny / / wywoływany.  
  
2.  Zwracana wartość uzyskaną w kroku 1 są wypychane na stosie oceny obiektu wywołującego.  
  
 Jeśli wartość zwracana nie jest obecny na stosie oceny / / wywoływany, jest zwracana żadna wartość (nie stosu zachowania dla / / wywoływany lub obiekt wywołujący metody).  
  
 Typ wartości zwracanej, bieżącej metody Określa typ wartości do pobrania z góry stosu i skopiowany na stosie metody, która wywołała bieżącą metodę. Stos oceny dla bieżącej metody musi być pusta, z wyjątkiem wartość zwracaną.  
  
 `ret` Nie może być używana do przekazywania kontroli poza`try`, `filter`, `catch`, lub `finally` bloku. Z poziomu `try` lub `catch`, użyj <xref:System.Reflection.Emit.OpCodes.Leave> instrukcji z miejsca docelowego `ret` instrukcji, która znajduje się poza wszystkich otaczających bloków wyjątków. Ponieważ `filter` i `finally` bloki logicznie to część obsługi wyjątków i nie metody, w której ich kod jest osadzony, poprawnie wygenerowanymi instrukcjami Microsoft Intermediate Language (MSIL), nie należy wykonywać zwrócone z w obrębie metody `filter` lub `finally`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `ret` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ponownie zgłasza wyjątek bieżący.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 1A|Zgłoś ponownie|Ponownie zgłasza wyjątek bieżący|  
  
 Nie zachowania przejścia stosu jest zdefiniowany dla tej instrukcji.  
  
 `rethrow` Instrukcji jest dozwolona tylko w treści `catch` programu obsługi. Wyniku weryfikacji zgłasza wyjątek ten sam wyjątek, który został zgłoszony przez ten program obsługi.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `rethrow` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi wartość całkowitą z lewej strony (w wartości zerowe) przez określoną liczbę bitów, wypychanie wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|62|shl —|Przenosi całkowitą po lewej stronie (przesunięcie w zera).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości są wypychane na stosie.  
  
2.  Liczba bitów, które mają zostać przesunięte są wypychane na stosie.  
  
3.  Liczba bitów jest przesuwany i wartość ze stosu; zdjęte ze stosu są wartość zostanie przesunięty w lewo o określoną liczbę bitów.  
  
4.  Wyniki są wypychane na stosie.  
  
 `shl` Instrukcji przenosi wartości (typu `int32`, `int64` lub `native int`) przez określoną liczbę bitów. Liczba bitów jest wartość typu `int32` lub `native int`. Wartość zwracana jest nieokreślony, jeśli liczba bitów jest przesuwany jest większa lub równa szerokości (w bitach) podanej wartości.  
  
 `Shl` Wstawia zero nieco najniżej na każdej zmianie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `shl` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi wartość całkowitą (w znak) po prawej stronie przez określoną liczbę bitów, wypychanie wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|63|shr|Przenosi całkowitą w prawo (przesunięcie w logowania).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości są wypychane na stosie.  
  
2.  Liczba bitów, które mają zostać przesunięte są wypychane na stosie.  
  
3.  Liczba bitów jest przesuwany i wartość ze stosu; zdjęte ze stosu są wartość zostanie przesunięty w prawo o określoną liczbę bitów.  
  
4.  Wyniki są wypychane na stosie.  
  
 `shr.un` Instrukcji przenosi wartości (typu `int32`, `int64` lub `native int`) bezpośrednio przez określoną liczbę bitów. Liczba bitów jest wartość typu `int32` lub `native int`. Wartość zwracana jest nieokreślony, jeśli liczba bitów jest przesuwany jest większa lub równa szerokości (w bitach) podanej wartości.  
  
 `Shr` replikowane najbardziej znaczących bitów na każdej zmiany zachowania logowania oryginalnej wartości `result`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `shr` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi nieoznaczoną wartość całkowitą (w wartości zerowe) po prawej stronie przez określoną liczbę bitów, wypychanie wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|64|shr.UN|Przenosi całkowitą w prawo (przesunięcie w zera).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości są wypychane na stosie.  
  
2.  Liczba bitów, które mają zostać przesunięte są wypychane na stosie.  
  
3.  Liczba bitów jest przesuwany i wartość ze stosu; zdjęte ze stosu są wartość zostanie przesunięty w prawo o określoną liczbę bitów.  
  
4.  Wyniki są wypychane na stosie.  
  
 `shr.un` Instrukcji przenosi wartości (typu `int32`, `int64` lub `native int`) bezpośrednio przez określoną liczbę bitów. Liczba bitów jest wartość typu `int32`, `int64` lub `native int`. Wartość zwracana jest nieokreślony, jeśli liczba bitów jest przesuwany jest większa lub równa szerokości (w bitach) podanej wartości.  
  
 `Shr.un` Wstawia zero bitu na najwyższej pozycji na każdej zmianie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `shr.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypycha rozmiar w bajtach, typ podanej wartości na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|Operator sizeof `valType`|Wypychanie rozmiar w bajtach, typ wartości jako `unsigned int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Rozmiar (w bajtach) typu podana wartość (`valType`) są wypychane na stosie.  
  
 `valType` musi być token metadanych ( `typeref` lub `typedef`), który określa typ wartości, typem referencyjnym lub parametr typu ogólnego.  
  
 Dla typu odwołania rozmiar zwrócony jest rozmiar wartości odniesienia odpowiadającego typu (4 bajty w systemach 32-bitowy), nie rozmiar danych przechowywanych w obiektach określone przez wartość odniesienia. Parametr typu ogólnego może służyć tylko w treści typu lub metody, który go definiuje. Podczas tworzenia wystąpienia tego typu lub metody, parametr typu ogólnego jest zastępowany przez typ wartości lub typem referencyjnym.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `sizeof` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość na szczycie stosu oceny w gnieździe argumentu z określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` >|starg `num`|POP najwyższą wartość ze stosu i zapisuje go w miejsce argumentu `num`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość obecnie na górze stosu jest zdjęte ze stosu i umieścić w gnieździe argument `num`.  
  
 `starg` Instrukcji pobiera wartość ze stosu i umieszcza je w gnieździe argument `num`. Typ wartości musi odpowiadać typowi argumentu, jak określono w podpisie metody bieżącej.  
  
 Procedury, które przyjmują o zmiennej liczbie argumentów `starg` instrukcji może służyć tylko w przypadku wstępnego stałej argumentów, wyklucza te w zmiennej część podpisu.  
  
 Wykonywanie w magazynie do argumentów, w których wartość całkowitą mniejszą niż 4 bajty obcina wartość, kiedy przesuwa się on ze stosu do argumentu. Wartości zmiennoprzecinkowe są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `starg` kod operacji:  
  
-   ILGenerator.Emit (OpCode, krótki)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość na szczycie stosu oceny w gnieździe argumentu z określonym indeksem, krótka.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|POP najwyższą wartość ze stosu i zapisuje go w miejsce argument `num`, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość obecnie na górze stosu jest zdjęte ze stosu i umieścić w gnieździe argument `num`.  
  
 `starg.s` Instrukcji pobiera wartość ze stosu i umieszcza je w gnieździe argument `num`. Typ wartości musi odpowiadać typowi argumentu, jak określono w podpisie metody bieżącej.  
  
 `starg.s` Instrukcji zapewnia efektywne kodowanie do użycia z argumentami pierwszych 256.  
  
 Procedury, które przyjmują o zmiennej liczbie argumentów `starg.s` instrukcji może służyć tylko w przypadku wstępnego stałej argumentów, wyklucza te w zmiennej część podpisu.  
  
 Wykonywanie w magazynie do argumentów, w których wartość całkowitą mniejszą niż 4 bajty obcina wartość, kiedy przesuwa się on ze stosu do argumentu. Wartości zmiennoprzecinkowe są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `starg.s` kod operacji:  
  
-   ILGenerator.Emit (OpCode, bajtów)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy pod danym indeksem wartość na stosie oceny, którego typ jest określony w instrukcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format programu Microsoft intermediate language (MSIL) zestawu, wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A4 &LT; `T` >|stelem `typeTok`|Zamienia element tablicy o indeksie podane wartości typu `typeTok` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, są wypychane na stosie.  
  
2.  Wartość indeksu `index`, do elementu w `array` są wypychane na stosie.  
  
3.  Wartość o typie określonym w instrukcji są wypychane na stosie.  
  
4.  Wartość, indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartość zostanie przełączone do elementu tablicy pod danym indeksem.  
  
 `stelem` Instrukcji zastępuje wartość elementu wskazywanego przez podany liczony od zera indeks w tablicy jednowymiarowej `array` z wartością. Wartość ma typ określony przez token `typeTok` w instrukcji.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stelem` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy pod danym indeksem z <see langword="native int" /> wartość na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9B|stelem.i|Zamienia element tablicy w podany indeks z `native int` wartość na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, są wypychane na stosie.  
  
2.  Nieprawidłowy indeks do elementu w `array` są wypychane na stosie.  
  
3.  Wartości są wypychane na stosie.  
  
4.  Wartość, indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartość zostanie przełączone do elementu tablicy pod danym indeksem.  
  
 `stelem.i` Instrukcji zastępuje wartość elementu `index` w tablicy jednowymiarowej `array` z `native int` wartość wypychane na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stelem.i` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy pod danym indeksem z <see langword="int8" /> wartość na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|Zamienia element tablicy w podany indeks z `int8` wartość na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, są wypychane na stosie.  
  
2.  Nieprawidłowy indeks do elementu w `array` są wypychane na stosie.  
  
3.  Wartości są wypychane na stosie.  
  
4.  Wartość, indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartość zostanie przełączone do elementu tablicy pod danym indeksem.  
  
 `stelem.i1` Instrukcji zastępuje wartość elementu `index` w tablicy jednowymiarowej `array` z `int8` wartość wypychane na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stelem.i1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy pod danym indeksem z <see langword="int16" /> wartość na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|Zamienia element tablicy w podany indeks z `int16` wartość na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, są wypychane na stosie.  
  
2.  Nieprawidłowy indeks do elementu w `array` są wypychane na stosie.  
  
3.  Wartości są wypychane na stosie.  
  
4.  Wartość, indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartość zostanie przełączone do elementu tablicy pod danym indeksem.  
  
 `stelem.i2` Instrukcji zastępuje wartość elementu `index` w tablicy jednowymiarowej `array` z `int16` wartość wypychane na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stelem.i2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy pod danym indeksem z <see langword="int32" /> wartość na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|Zamienia element tablicy w podany indeks z `int32` wartość na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, są wypychane na stosie.  
  
2.  Nieprawidłowy indeks do elementu w `array` są wypychane na stosie.  
  
3.  Wartości są wypychane na stosie.  
  
4.  Wartość, indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartość zostanie przełączone do elementu tablicy pod danym indeksem.  
  
 `stelem.i4` Instrukcji zastępuje wartość elementu `index` w tablicy jednowymiarowej `array` z `int32` wartość wypychane na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stelem.i4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy pod danym indeksem z <see langword="int64" /> wartość na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|Zamienia element tablicy w podany indeks z `int64` wartość na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, są wypychane na stosie.  
  
2.  Nieprawidłowy indeks do elementu w `array` są wypychane na stosie.  
  
3.  Wartości są wypychane na stosie.  
  
4.  Wartość, indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartość zostanie przełączone do elementu tablicy pod danym indeksem.  
  
 `stelem.i8` Instrukcji zastępuje wartość elementu `index` w tablicy jednowymiarowej `array` z `int64` wartość wypychane na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stelem.i8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy pod danym indeksem z <see langword="float32" /> wartość na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|Zamienia element tablicy w podany indeks z `float32` wartość na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, są wypychane na stosie.  
  
2.  Nieprawidłowy indeks do elementu w `array` są wypychane na stosie.  
  
3.  Wartości są wypychane na stosie.  
  
4.  Wartość, indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartość zostanie przełączone do elementu tablicy pod danym indeksem.  
  
 `stelem.r4` Instrukcji zastępuje wartość elementu `index` w tablicy jednowymiarowej `array` z `float32` wartość wypychane na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stelem.r4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy pod danym indeksem z <see langword="float64" /> wartość na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|Zamienia element tablicy w podany indeks z `float64` wartość na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, są wypychane na stosie.  
  
2.  Nieprawidłowy indeks do elementu w `array` są wypychane na stosie.  
  
3.  Wartości są wypychane na stosie.  
  
4.  Wartość, indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartość zostanie przełączone do elementu tablicy pod danym indeksem.  
  
 `stelem.r8` Instrukcji zastępuje wartość elementu `index` w tablicy jednowymiarowej `array` z `float64` wartość wypychane na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stelem.r8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element tablicy pod danym indeksem wartość odwołania do obiektu (typ <see langword="O" />) na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|Zamienia element tablicy w podany indeks z `ref` wartości (typu `O`) na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu do tablicy, `array`, są wypychane na stosie.  
  
2.  Nieprawidłowy indeks do elementu w `array` są wypychane na stosie.  
  
3.  Wartości są wypychane na stosie.  
  
4.  Wartość, indeksu i odwołanie do tablicy ze stosu; zdjęte ze stosu są wartość zostanie przełączone do elementu tablicy pod danym indeksem.  
  
 `stelem.ref` Instrukcji zastępuje wartość elementu wskazywanego przez podany indeks w tablicy jednowymiarowej `array` z `ref` (typ `O`) wartość wypychane na stosie.  
  
 Tablice obiektów i dlatego jest reprezentowany przez wartość typu `O`. Indeks jest typem `native int`.  
  
 Należy pamiętać, że `stelem.ref` niejawnie rzutuje podana wartość dla typu elementu `array` przed przypisaniem wartości do elementu tablicy. To rzutowanie może zakończyć się niepowodzeniem, nawet w przypadku kodu zweryfikowane. Ten sposób `stelem.ref` instrukcji może zgłosić <xref:System.InvalidCastException>. Dla tablic jednowymiarowych, które nie są liczony od zera, a dla tablic wielowymiarowych <xref:System.Array> klasa udostępnia <xref:System.Array.SetValue%2A> metody.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `array` jest odwołanie o wartości null.  
  
 <xref:System.IndexOutOfRangeException> jest generowany, jeśli `index` jest ujemny lub większy niż granica `array`.  
  
 <xref:System.ArrayTypeMismatchException> jest generowany, jeśli `array` nie przechowuje elementy typu wymagane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stelem.ref` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia wartość przechowywaną w polu odwołania do obiektu lub wskaźnika z nową wartością.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|Zastępuje wartości `field` obiektu z nową wartością.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu lub wskaźnika są wypychane na stosie.  
  
2.  Wartości są wypychane na stosie.  
  
3.  Wartość i odwołania/wskaźnika obiektu ze stosu; zdjęte ze stosu są wartość `field` w obiekcie jest zastępowany podana wartość.  
  
 `stfld` Instrukcji zastępuje wartość pola obiektu (typ `O`) lub za pomocą wskaźnika (typ `native int`, `&`, lub `*`) z danej wartości. `Field` jest token metadanych, który odwołuje się do odwołania do składowej pola. `stfld` Instrukcji może mieć prefiks z jednego lub obu <xref:System.Reflection.Emit.OpCodes.Unaligned> i <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli odwołanie do obiektu lub wskaźnika jest odwołanie o wartości null i pole nie jest statyczne.  
  
 <xref:System.MissingFieldException> jest generowany, jeśli `field` nie zostanie znaleziony w metadanych. Jest to zazwyczaj sprawdzana podczas konwersji do kodu macierzystego, nie w czasie wykonywania instrukcji Microsoft Intermediate Language (MSIL).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stfld` kod operacji:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="native int" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DF|stind.i|Magazyny `native int` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Wartości są wypychane na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.i` Magazynów instrukcji `native int` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.i` instrukcji można używać w sposób zgodny z typem wskaźnika. Działanie `stind.i` instrukcji może być zmienione przez bezpośrednio poprzedzający <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu też dorozumianych przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stind.i` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="int8" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|52|stind.I1|Magazyny `int8` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Wartości są wypychane na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.i1` Magazynów instrukcji `int8` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.i1` instrukcji można używać w sposób zgodny z typem wskaźnika. Działanie `stind.i1` instrukcji może być zmienione przez bezpośrednio poprzedzający <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu też dorozumianych przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stind.i1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="int16" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|53|stind.I2|Magazyny `int16` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Wartości są wypychane na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.i2` Magazynów instrukcji `int16` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.2i` instrukcji można używać w sposób zgodny z typem wskaźnika. Działanie `stind.i2` instrukcji może być zmienione przez bezpośrednio poprzedzający <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu też dorozumianych przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stind.i2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="int32" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|54|stind.i4|Magazyny `int32` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Wartości są wypychane na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.i4` Magazynów instrukcji `int32` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.i4` instrukcji można używać w sposób zgodny z typem wskaźnika. Działanie `stind.i4` instrukcji może być zmienione przez bezpośrednio poprzedzający <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu też dorozumianych przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stind.i4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="int64" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|55|stind.i8|Magazyny `int64` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Wartości są wypychane na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.i8` Magazynów instrukcji `int64` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.i8` instrukcji można używać w sposób zgodny z typem wskaźnika. Działanie `stind.i` instrukcji może być zmienione przez bezpośrednio poprzedzający <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu też dorozumianych przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stind.i8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="float32" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|56|stind.r4|Magazyny `float32` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Wartości są wypychane na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.r4` Magazynów instrukcji `float32` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.r4` instrukcji można używać w sposób zgodny z typem wskaźnika. Działanie `stind.r4` instrukcji może być zmienione przez bezpośrednio poprzedzający <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu też dorozumianych przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stind.r4` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="float64" /> na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|57|stind.r8|Magazyny `float64` wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Wartości są wypychane na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.r8` Magazynów instrukcji `float64` wartość na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.r8` instrukcji można używać w sposób zgodny z typem wskaźnika. Działanie `stind.r8` instrukcji może być zmienione przez bezpośrednio poprzedzający <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu też dorozumianych przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stind.r8` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość odwołania do obiektu na podany adres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|51|stind.ref|Przechowuje odwołania do obiektu (typ `O`) wartość pod danym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Wartości są wypychane na stosie.  
  
3.  Wartość i adres ze stosu; zdjęte ze stosu są wartość znajduje się pod adresem.  
  
 `stind.ref` Instrukcji przechowuje wartość odwołania do obiektu na podany adres (typ `native int`, `*`, lub `&`).  
  
 Typ bezpiecznego działania wymaga, aby `stind.ref` instrukcji można używać w sposób zgodny z typem wskaźnika. Działanie `stind.ref` instrukcji może być zmienione przez bezpośrednio poprzedzający <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `addr` naturalnie nie jest wyrównany dla typu argumentu też dorozumianych przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stind.ref` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącą wartość z góry stosu oceny i zapisuje go w liście zmiennej lokalnej z określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|stloc `index`|Pobiera wartość ze stosu i zapisuje go w zmiennej lokalnej `index`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość się zdjęte ze stosu zniżki w stosunku do stosu i umieszcza w zmiennej lokalnej `index`.  
  
 `stloc` Instrukcji POP najwyższą wartość ze stosu oceny i przenosi ją na liczbę zmiennych lokalnych `index`, gdzie zmienne lokalne są numerowane 0 lub nowszy. Typ wartości musi odpowiadać typowi zmiennej lokalnej, jak to określono w bieżącej metody podpisu lokalnego.  
  
 Przechowywanie w zmiennych lokalnych, w których wartość całkowitą mniejszą niż 4 bajty obcina wartość, kiedy przesuwa się on ze stosu do zmiennej lokalnej. Wartości zmiennoprzecinkowe są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Poprawne instrukcji Microsoft Intermediate Language (MSIL) wymagają, aby `index` mieć prawidłowy indeks lokalnego. Dla `stloc` instrukcji, `index` musi należeć do zakresu 0 i 65534 włącznie (w szczególności 65535 nie jest prawidłowy). Z wyjątkiem 65535 przyczyną jest pragmatyczne: implementacje prawdopodobnie będzie używać 2-bajtowych liczb całkowitych do śledzenia, zarówno lokalne indeksu, a także całkowita liczba zmiennych lokalnych dla danej metody. Indeks 65535 dokonano prawidłowe, wymagałoby na liczbę całkowitą szersze śledzić liczbę zmiennych lokalnych w takiej metody.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `stloc` kod operacji:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, krótki)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącą wartość z góry stosu oceny i zapisuje go w lokalnym listy zmiennych pod indeksem 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0A|stloc.0|Pobiera wartość ze stosu do zmiennej lokalnej 0.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość się zdjęte ze stosu zniżki w stosunku do stosu i umieszcza w zmiennej lokalnej indeksowane przez 0.  
  
 `stloc.0` Instrukcji POP najwyższą wartość ze stosu oceny i przenosi ją do zmiennej lokalnej indeksowane przez 0. Typ wartości musi odpowiadać typowi zmiennej lokalnej, jak to określono w bieżącej metody podpisu lokalnego.  
  
 `stloc.0` jest szczególnie wydajne kodowania do przechowywania wartości zmiennej lokalnej 0.  
  
 Przechowywanie w zmiennych lokalnych, w których wartość całkowitą mniejszą niż 4 bajty obcina wartość, kiedy przesuwa się on ze stosu do zmiennej lokalnej. Wartości zmiennoprzecinkowe są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stloc.0` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącą wartość z góry stosu oceny i zapisuje go w lokalnym listy zmiennych pod indeksem 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0B|stloc.1|Pobiera wartość ze stosu do zmiennej lokalnej 1.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość się zdjęte ze stosu zniżki w stosunku do stosu i umieszcza w zmiennej lokalnej indeksowane przez 1.  
  
 `stloc.1` Instrukcji POP najwyższą wartość ze stosu oceny i przenosi ją do zmiennej lokalnej indeksowane przez 1. Typ wartości musi odpowiadać typowi zmiennej lokalnej, jak to określono w bieżącej metody podpisu lokalnego.  
  
 `stloc.1` jest szczególnie wydajne kodowania do przechowywania wartości zmiennej lokalnej 1.  
  
 Przechowywanie w zmiennych lokalnych, w których wartość całkowitą mniejszą niż 4 bajty obcina wartość, kiedy przesuwa się on ze stosu do zmiennej lokalnej. Wartości zmiennoprzecinkowe są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stloc.1` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącą wartość z góry stosu oceny i zapisuje go w lokalnym listy zmiennych pod indeksem 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0C|stloc.2|Pobiera wartość ze stosu do zmiennej lokalnej 2|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość się zdjęte ze stosu zniżki w stosunku do stosu i umieszcza w zmiennej lokalnej indeksowane przez 2.  
  
 `stloc.2` Instrukcji POP najwyższą wartość ze stosu oceny i przenosi ją do zmiennej lokalnej indeksowane przez 2. Typ wartości musi odpowiadać typowi zmiennej lokalnej, jak to określono w bieżącej metody podpisu lokalnego.  
  
 `stloc.2` jest szczególnie wydajne kodowania do przechowywania wartości zmiennej lokalnej 2.  
  
 Przechowywanie w zmiennych lokalnych, w których wartość całkowitą mniejszą niż 4 bajty obcina wartość, kiedy przesuwa się on ze stosu do zmiennej lokalnej. Wartości zmiennoprzecinkowe są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stloc.2` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącą wartość z góry stosu oceny i zapisuje go w lokalnym listę zmiennych pod indeksem 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0D|stloc.3|Pobiera wartość ze stosu do zmiennej lokalnej 3|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość się zdjęte ze stosu zniżki w stosunku do stosu i umieszcza w zmiennej lokalnej indeksowane przez 3.  
  
 `stloc.3` Instrukcji POP najwyższą wartość ze stosu oceny i przenosi ją do zmiennej lokalnej indeksowane przez 3. Typ wartości musi odpowiadać typowi zmiennej lokalnej, jak to określono w bieżącej metody podpisu lokalnego.  
  
 `stloc.3` jest szczególnie wydajne kodowania do przechowywania wartości zmiennej lokalnej 3.  
  
 Przechowywanie w zmiennych lokalnych, w których wartość całkowitą mniejszą niż 4 bajty obcina wartość, kiedy przesuwa się on ze stosu do zmiennej lokalnej. Wartości zmiennoprzecinkowe są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stloc.3` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącą wartość z góry stosu oceny i zapisuje go w liście zmiennych lokalnych w <paramref name="index" /> (skrócona forma).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|Pobiera wartość ze stosu i zapisuje go w zmiennej lokalnej `index`, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartość się zdjęte ze stosu zniżki w stosunku do stosu i umieszcza w zmiennej lokalnej `index`.  
  
 `stloc.s` Instrukcji POP najwyższą wartość ze stosu oceny i przenosi ją na liczbę zmiennych lokalnych `index`, gdzie zmienne lokalne są numerowane 0 lub nowszy. Typ wartości musi odpowiadać typowi zmiennej lokalnej, jak to określono w bieżącej metody podpisu lokalnego.  
  
 `stloc.s` Instrukcji zapewnia efektywne kodowanie dla zmiennych lokalnych 0 do 255.  
  
 Przechowywanie w zmiennych lokalnych, w których wartość całkowitą mniejszą niż 4 bajty obcina wartość, kiedy przesuwa się on ze stosu do zmiennej lokalnej. Wartości zmiennoprzecinkowe są zaokrąglane z ich rozmiar natywnego (typ `F`) do rozmiaru skojarzonych z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `stloc.s` kod operacji:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, bajtów)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiuje wartość o określonym typie ze stosu oceny na adres podany pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Przechowuje wartość typu `class` ze stosu w pamięci.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
2.  Obiekt typu wartości typu `class` są wypychane na stosie.  
  
3.  Obiekt i adres ze stosu; zdjęte ze stosu są obiektu typu wartościowego znajduje się pod adresem.  
  
 `stobj` Instrukcji kopiuje obiektu typu wartościowego na adres określony adres (wskaźnik typu `native int`, `*`, lub `&`). Liczbą bajtów skopiowanych zależy od rozmiaru klasy reprezentowane przez `class`, token metadanych reprezentujący typ wartości.  
  
 Działanie `stobj` instrukcji może być zmienione przez bezpośrednio poprzedzający <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksu instrukcji.  
  
 <xref:System.TypeLoadException> jest generowany, jeśli nie można odnaleźć klasy. Jest to zazwyczaj wykrywany, po instrukcji Microsoft Intermediate Language (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stobj` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia wartości pola statyczne wartość ze stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|Zastępuje wartości w `field` o podanej wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości są wypychane na stosie.  
  
2.  Wartość jest zdjęte ze stosu ze stosu i przechowywane w `field`.  
  
 `stsfld` Instrukcji zastępuje wartość pola statyczne z wartością ze stosu. `field` jest token metadanych, który musi odwoływać się do elementu członkowskiego pole statyczne.  
  
 `stsfld` Instrukcji może być poprzedzony <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.MissingFieldException> jest generowany, jeśli pole nie zostanie znaleziony w metadanych. Jest to zazwyczaj sprawdzana po instrukcji Microsoft Intermediate Language (MSIL) są konwertowane do kodu macierzystego, nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `stsfld` kod operacji:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Odejmuje wartość jednego z innego i wypycha wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|59|Sub|Odejmuje jedną wartość z innej, zwracając wartość liczbową.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value2` jest odejmowany od `value1`.  
  
4.  Wyniki są wypychane na stosie.  
  
 Nie wykryto przepełnienia liczby całkowitej operacji (do obsługi właściwego przepełnienie zobacz <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Liczba całkowita odejmowania opakowuje, a nie zmienia nasycenie. Na przykład: przy założeniu 8-bitowych liczb całkowitych, gdzie `value1` jest równa 0 i `value2` jest ustawiona na 1, "zawinięty" wynik będzie 255.  
  
 Przepełnienie zmiennoprzecinkowej zwraca `+inf` (`PositiveInfinity`) lub `-inf` (`NegativeInfinity`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `sub` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Odejmuje jedną liczbę całkowitą z innego, przeprowadza sprawdzanie przepełnienia i umieszcza wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DA|sub.ovf|Odejmuje jedną liczbę całkowitą z innego ze sprawdzeniem przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value2` jest odejmowany od `value1` ze sprawdzaniem dla przepełnienia.  
  
4.  Wyniki są wypychane na stosie.  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Ta operacja jest wykonywana na liczby całkowite ze znakiem; w przypadku wartości zmiennoprzecinkowe, użyj <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `sub.ovf` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Odejmuje jedną wartość liczby całkowitej bez znaku z innego, przeprowadza sprawdzanie przepełnienia i umieszcza wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|Odejmuje jedną wartość liczby całkowitej bez znaku z innego ze sprawdzeniem przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu; `value2` jest odejmowany od `value1` ze sprawdzaniem dla przepełnienia.  
  
4.  Wyniki są wypychane na stosie.  
  
 <xref:System.OverflowException> jest generowany, jeśli wynik nie może być reprezentowana w typie wyniku.  
  
 Ta operacja jest wykonywana na liczby całkowite ze znakiem; w przypadku wartości zmiennoprzecinkowe, użyj <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `sub.ovf.un` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implementuje tabelę przeskoków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|Przełącz (`N`, `t1`, `t2`... `tN`)|Przechodzi do jednego z `N` wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Wartości są wypychane na stosie.  
  
2.  Wartość zostanie zdjęte ze stosu i wykonywania jest przekazywana do instrukcji w przesunięciu indeksowane według wartości, gdy wartość jest mniejsza niż `N`.  
  
 `switch` Instrukcji implementuje tabelę przeskoków. Format instrukcji jest `unsigned int32` reprezentujący liczbę wszystkich elementów docelowych `N`, a następnie `N` wartości int32, określając przejść elementów docelowych. Te obiekty docelowe są reprezentowane jako przesunięcia (dodatnia lub ujemna) od początku instrukcji zgodnie z dokumentem `switch` instrukcji.  
  
 `switch` Instrukcji pobiera wartość ze stosu i porównuje go jako liczba całkowita bez znaku do `N`. Jeśli wartość jest mniejsza niż `N`, wykonanie jest przekazywany do docelowego indeksowane według wartości, których obiekty docelowe są numerowane od 0 (na przykład, wartość 0 przyjmuje pierwszego obiektu docelowego, przyjmuje wartość 1, docelowych w drugiej i tak dalej). Jeśli wartość jest większa niż lub równa `N`, program kontynuuje wykonywanie następnej instrukcji (poniżej).  
  
 Jeśli instrukcja docelowy ma co najmniej jeden kod prefiksu, kontroli można przesłać tylko do pierwszej z tych prefiksów.  
  
 Kontrolowanie transferu do i z `try`, `catch`, `filter`, i `finally` bloki nie można wykonać przy tej instrukcji. (Przeniesienie takie są znacznie ograniczone i należy zamiast tego użyj instrukcji pozostaw).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `switch` opcode. `Label[]` Argument jest tablicą reprezentujący 32-bitowe przesunięcia etykiet.  
  
-   ILGenerator.Emit (OpCode, Label[])  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje użycie `Switch` opcode do generują tabelę przeskoków użycie tablicy <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wykonuje instrukcji wywołania metody mieć sufiks w taki sposób, że ramka stosu bieżącej metody zostanie usunięty przed wykonaniem instrukcji rzeczywistego wywołania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 14|tail.|Kolejne wywołanie kończy bieżącej metody|  
  
 Nie ma żadnych zachowania przejścia stack zdefiniowane w tej instrukcji.  
  
 `tail` Instrukcji prefiks musi bezpośrednio poprzedzać <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, lub <xref:System.Reflection.Emit.OpCodes.Callvirt> instrukcji. Wskazuje, że ramka stosu bieżącej metody powinny zostać usunięte przed wykonaniem instrukcji wywołania. Również zakłada, że wartość zwracana z wywołania następujących jest również wartość zwrócona przez obiekt bieżącej metody i wywołania w związku z tym można przekonwertować na szybkie cross-method.  
  
 Stos może być pusty, z wyjątkiem argumenty przesyłanych przez następujące wywołanie. Instrukcję po instrukcji wywołania musi być ret. Tak więc sekwencji tylko prawidłowy kod jest `tail. call` (lub `calli` lub `callvirt`). Poprawne instrukcji Microsoft Intermediate Language (MSIL) nie należy tworzyć gałęzi do `call` instrukcji, ale może tworzyć gałęzi do kolejnego <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 Nie można odrzucić bieżące ramce, gdy formant jest przekazywany z niezaufanego kodu do zaufanego kodu, ponieważ może to zagrozić zabezpieczeń tożsamości kodu. Zabezpieczenia .NET Framework sprawdza, czy w związku z tym może spowodować, że `tail` mają być ignorowane, pozostawiając standardowego <xref:System.Reflection.Emit.OpCodes.Call> instrukcji. Podobnie, w kolejności umożliwia wyjścia zsynchronizowane regionu po wywołaniu zwraca, `tail` prefiks jest ignorowana, gdy używać do kończenia działania metodę, która jest oznaczona zsynchronizowane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `tail` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Wystąpienie obiektu Opcode.</param>
        <summary>Zwraca wartość PRAWDA lub FAŁSZ, jeśli podany kod operacji przyjmuje argument jednobajtowych.</summary>
        <returns><see langword="true" /> lub <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia znajdowanie rozkazów MSIL, które są "krótkiej formy", do użytku w zoptymalizowanym kodzie.  
  
 `TakesSingleByteArgument` Zwraca `true` Jeśli <xref:System.Reflection.Emit.OpCode> wystąpienia przyjmuje argument jednobajtowych w następujących przypadkach:  
  
-   Opcode wykonuje instrukcję gałęzi do adresu o rozmiarze bajtów (na przykład <xref:System.Reflection.Emit.OpCodes.Br_S> i <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   Opcode wypycha wartość bajtową na stosie (na przykład <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   Opcode odwołuje się do zmiennej lub argumentu za pośrednictwem wielkości bajtów "krótkiej formy" (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloc_S> i <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 W przeciwnym razie zwraca `false`.  
  
 W poniższym przykładzie pokazano użycie `TakesSingleByteArgument` przez odzwierciedlenie na `OpCodes` klasy i testowanie w celu sprawdzenia czy każdy `OpCode` pola przyjmuje argument jednobajtowych.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obecnie zgłasza obiekt wyjątku na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7A|throw|Zgłasza wyjątek.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu (na wyjątek) są wypychane na stosie.  
  
2.  Odwołanie do obiektu zostanie zdjęte ze stosu i wyjątku.  
  
 `throw` Instrukcji wyrzuca obiekt wyjątku (typ `O`) obecnie na stosie.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli odwołanie do obiektu jest odwołanie o wartości null.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `throw` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje adres obecnie na jego podstawie stosu oceny nie może być wyrównane do naturalnym rozmiaru natychmiast po <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, lub <see langword="cpblk" /> instrukcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 12 < `unsigned int8` >|niewyrównanych. `alignment`|Wskazuje, że kolejne wskaźnik instrukcji może być niewyrównany.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
 `Unaligned` Określa, że adres (niezarządzany wskaźnik `native int`) na stosie może nie wyrównany do naturalnym rozmiaru natychmiast po `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, lub `cpblk` instrukcji. Oznacza to aby uzyskać <xref:System.Reflection.Emit.OpCodes.Ldind_I4> wyrównanie adresu nie może być do granicy 4-bajtowych instrukcji. Aby uzyskać `initblk` i `cpblk` wyrównanie domyślne to architektura zależne (4-bajtowych na 32-bitowe procesory, 8-bajtowych na 64-bitowych procesorach). Należy użyć generatorów kodu, które o rozmiarze 32-bitowe słowo nie ograniczają dane wyjściowe `unaligned` Jeśli wyrównanie nie jest znany w czasie kompilacji jako 8-bajtowych.  
  
 Wartość wyrównania musi być 1, 2 lub 4 i oznacza, że wygenerowany kod powinien zakładają, że adres jest bajcie znaków dwubajtowych, lub cztery bajtami, odpowiednio. Należy pamiętać, że przejściowy wskaźników (typ `*`) zawsze są wyrównane.  
  
 Podczas gdy wyrównanie `cpblk` instrukcji logicznie wymaga dwóch liczb (jeden dla źródła) i jeden dla miejsca docelowego, istnieje bez zauważalnego wpływu na wydajność, jeśli tylko niższy numer jest określony.  
  
 `unaligned` i `volatile` prefiksy można łączyć w obu kolejności. Musi bezpośrednio poprzedzać `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, lub `cpblk` instrukcji. Tylko <xref:System.Reflection.Emit.OpCodes.Volatile> prefiks jest dozwolone w przypadku <xref:System.Reflection.Emit.OpCodes.Ldsfld> i <xref:System.Reflection.Emit.OpCodes.Stsfld> instrukcje.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metody można użyć `unaligned` kod operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
-   ILGenerator.Emit (Opcode, bajtów)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje spakowany reprezentacja typu wartości do postaci rozpakowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|79 < `T` >|Rozpakowywanie `valType`|Wyodrębnia dane typu wartości z `obj`, jego opakowany reprezentacji.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu są wypychane na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte ze stosu ze stosu i rozpakowany na wskaźnik typu wartości.  
  
3.  Wartość wskaźnika typu są wypychane na stosie.  
  
 Typ wartości ma dwa oddzielne reprezentacje w ramach Common Language Infrastructure (CLI):  
  
-   Używany, gdy typ wartości jest osadzony w innym obiekcie formularz "raw".  
  
-   Formularz "spakowane", gdzie dane w typ wartości opakowany jest (opakowany) obiektu, dzięki czemu może istnieć jako niezależne jednostki.  
  
 `unbox` Konwertuje odwołanie do obiektu (typ `O`), opakowany reprezentacja typu wartości do wskaźnika typu wartości (wskaźnik zarządzanego typu `&`), jego rozpakowany formularza. Typ podanej wartości (`valType`) jest token metadanych, wskazujący typ typu wartości zawartych w obiektu w ramce.  
  
 W odróżnieniu od <xref:System.Reflection.Emit.OpCodes.Box>, co jest wymagane do utworzenia kopii typu wartości do użycia w obiekcie, `unbox` nie jest wymagane do skopiowania typ wartości z obiektu. Zwykle po prostu oblicza adres typu wartości, który jest już obecny wewnątrz obiektu w ramce.  
  
 <xref:System.InvalidCastException> jest generowany, jeśli obiekt nie jest spakowany jako `valType`.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli odwołanie do obiektu jest odwołanie o wartości null.  
  
 <xref:System.TypeLoadException> jest generowany, jeśli wartość typu `valType` nie można odnaleźć. Jest to zazwyczaj wykrywany, po instrukcji Microsoft Intermediate Language (MSIL) są konwertowane do kodu natywnego, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `unbox` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje spakowany reprezentujący typ określony w instrukcji do postaci rozpakowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format programu Microsoft intermediate language (MSIL) zestawu, wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A5 < `T` >|unbox.any `typeTok`|Wyodrębnij dane z `obj`, jego opakowany reprezentacji.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Odwołanie do obiektu `obj` są wypychane na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte ze stosu ze stosu i rozpakowany typ określony w instrukcji.  
  
3.  Wynikowy typ odwołanie lub wartość obiektu są wypychane na stosie.  
  
 Po zastosowaniu do formy opakowanej typu wartości `unbox.any` instrukcji wyodrębnia wartości zawartych w `obj` (typu `O`) i dlatego jest odpowiednikiem `unbox` następuje `ldobj`.  
  
 W przypadku zastosowania do typu odwołania `unbox.any` instrukcji ma taki sam skutek jak `castclass` `typeTok`.  
  
 Jeśli argument `typeTok` jest parametr typu ogólnego, a następnie zachowanie środowiska uruchomieniowego jest określana przez typ, który jest określony dla tego parametru typu ogólnego.  
  
 <xref:System.InvalidCastException> jest generowany, jeśli `obj` nie jest typ spakowany.  
  
 <xref:System.NullReferenceException> jest generowany, jeśli `obj` jest odwołanie o wartości null.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `unbox.any` kod operacji:  
  
-   ILGenerator.Emit (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że adres obecnie na jego podstawie stosu oceny może być nietrwałe i wyniki odczytu nie można buforować lokalizacji lub wielu sklepach do tej lokalizacji nie można pominąć.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 13|volatile.|Wskazuje, czy odwołanie kolejnych wskaźnika jest nietrwały.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  Adres są wypychane na stosie.  
  
 `volatile`. Określa, że adres jest adres volatile (czyli go mogą być przywoływane zewnętrznie w bieżącym wątku wykonywania) oraz wyniki odczytu nie można buforować lokalizacji lub wielu sklepach do tej lokalizacji nie można pominąć. Oznaczanie dostępu jako `volatile` tylko, które dostęp za pomocą; ma wpływ na inne uzyskuje dostęp do tej samej lokalizacji, które muszą być oznaczone oddzielnie. Dostęp do lokalizacji volatile nie trzeba przeprowadzać niepodzielne.  
  
 <xref:System.Reflection.Emit.OpCodes.Unaligned> i `volatile` prefiksy można łączyć w obu kolejności. Musi bezpośrednio poprzedzać `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, lub `cpblk` instrukcji. Tylko `volatile` prefiks jest dozwolone w przypadku <xref:System.Reflection.Emit.OpCodes.Ldsfld> i <xref:System.Reflection.Emit.OpCodes.Stsfld> instrukcje.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `volatile` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oblicza bitowe XOR najważniejsze dwie wartości na stosie oceny, wypychanie wynik na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono szesnastkowym i format zestawu Microsoft Intermediate Language (MSIL), wraz z podsumowaniem krótkie odniesienie instrukcji:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|61|xor|Bitowe XOR dwóch wartości całkowitych oblicza i zwraca liczbę całkowitą.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, jest:  
  
1.  `value1` są wypychane na stosie.  
  
2.  `value2` są wypychane na stosie.  
  
3.  `value2` i `value1` są zdjęte ze stosu ze stosu i ich bitowe XOR obliczane.  
  
4.  Bitowe XOR dla `value2` i `value1` są wypychane na stosie.  
  
 `xor` Instrukcja oblicza iloczynu bitowego XOR TOP dwie wartości na stosie i pozostawia wynik na stosie.  
  
 `Xor` jest operacją specyficzne dla liczby całkowitej.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> można użyć przeładowania metody `xor` kod operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

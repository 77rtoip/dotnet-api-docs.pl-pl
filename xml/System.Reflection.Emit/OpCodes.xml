<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aea33b9e902b909e4adf9f543fadb5190ce68f9b" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69109971" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera informacje o polu dotyczące emisji języka pośredniego (MSIL) firmy Microsoft w <see cref="T:System.Reflection.Emit.ILGenerator" /> celu przeładunku przez elementy <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />członkowskie klasy (takie jak).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowy opis kodów operacji dla elementów członkowskich, zobacz dokumentację Common Language Infrastructure (CLI), szczególnie "Partition III: Zestaw instrukcji CIL "i" partycja II: Definicja i semantyka metadanych ". Dokumentacja jest dostępna w trybie online; Zobacz [standardy C# ECMA i Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) w MSDN i [Standard ECMA-335-Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w międzynarodowej witrynie sieci Web ECMA.  
  
   
  
## Examples  
 Poniższy przykład demonstruje konstrukcję metody dynamicznej przy użyciu <xref:System.Reflection.Emit.ILGenerator> , aby emitować `OpCodes` <xref:System.Reflection.Emit.MethodBuilder>do.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dodaje dwie wartości i wypycha wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|58|add|Dodaje dwie wartości liczbowe, zwracając nową wartość liczbową.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; jest dodawany do `value2`. `value1`  
  
4.  Wynik jest wypychany na stosie.  
  
 Nie wykryto przepełnienia dla operacji całkowitych (Aby uzyskać prawidłową <xref:System.Reflection.Emit.OpCodes.Add_Ovf>obsługę przepełnienia, zobacz).  
  
 Dodawanie wartości całkowitych, a nie nasycenia. Na przykład przy założeniu 8-bitowych liczb całkowitych, gdzie `value1` jest ustawiona na 255 i `value2` ma ustawioną wartość 1, zawinięty wynik to 0, a nie 256.  
  
 Przepełnienie zmiennoprzecinkowe `+inf` zwraca`PositiveInfinity`() `-inf` lub`NegativeInfinity`().  
  
 W poniższej tabeli wymieniono akceptowalne Typy operandów i ich odpowiadający typ danych wynikowych. Jeśli nie ma wpisu dla konkretnej kombinacji typu (na przykład `int32` i; `float` `int32` i`int64`) jest nieprawidłowym językiem pośrednim firmy Microsoft (MSIL) i generuje błąd.  
  
|parametru|wartość1 — typ|Typ wartość2|Typ wyniku|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `add` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dodaje dwie liczby całkowite, wykonuje sprawdzanie przepełnienia i wypycha wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D6|add.ovf|Dodaje dwie wartości całkowite ze znakiem i sprawdzanie przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; `value1` dodano do`value2` programu przy użyciu sprawdzenia przepełnienia.  
  
4.  Wynik jest wypychany na stosie.  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie jest reprezentowany w typie wyniku.  
  
 Tę operację można wykonać w przypadku liczb całkowitych ze znakiem. Dla wartości zmiennoprzecinkowych Użyj <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 W poniższej tabeli wymieniono akceptowalne Typy operandów i ich odpowiadający typ danych wynikowych. Jeśli nie ma wpisu dla konkretnej kombinacji typu (na przykład `int32` i; `float` `int32` i`int64`) jest nieprawidłową instrukcją języka pośredniego firmy Microsoft (MSIL) i generuje błąd.  
  
|parametru|wartość1 — typ|Typ wartość2|Typ wyniku|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `add.ovf` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dodaje dwie wartości bez znaku, wykonuje sprawdzanie przepełnienia i wypycha wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|Dodaje dwie wartości unsigned Integer ze sprawdzaniem przeciążenia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; `value1` dodano do`value2` programu przy użyciu sprawdzenia przepełnienia.  
  
4.  Wynik jest wypychany na stosie.  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie jest reprezentowany w typie wyniku.  
  
 Tę operację można wykonać w przypadku liczb całkowitych ze znakiem. Dla wartości zmiennoprzecinkowych Użyj <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 W poniższej tabeli wymieniono akceptowalne Typy operandów i ich odpowiadający typ danych wynikowych. Jeśli nie ma wpisu dla konkretnej kombinacji typu (na przykład `int32` i; `float` `int32` i`int64`) jest nieprawidłową instrukcją języka pośredniego firmy Microsoft (MSIL) i generuje błąd.  
  
|parametru|wartość1 — typ|Typ wartość2|Typ wyniku|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `add.ovf.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oblicza wartość bitową i dwie wartości i wypycha wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Instrukcja|Opis|  
|------------|-----------------|-----------------|  
|5F|and|Określa wartości bitowe i dwie liczby całkowite.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value1`i `value2` są zdjęte ze stosu; jest obliczana wartość bitowa oraz dwie wartości.  
  
4.  Wynik jest wypychany na stosie.  
  
 `and` Instrukcja oblicza bitową i dwie pierwsze wartości na stosie i pozostawia wynik na stosie.  
  
 `And`jest operacją specyficzną dla liczby całkowitej.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `and` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca niezarządzany wskaźnik do listy argumentów bieżącej metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 00|arglist|Zwraca dojście listy argumentów dla bieżącej metody.|  
  
 Ta operacja nie wykonuje żadnych zachowań stosu szacowania.  
  
 Instrukcja zwraca nieprzezroczysty uchwyt (niezarządzany wskaźnik typu `native int`) reprezentujący listę argumentów bieżącej metody. `arglist` To dojście jest prawidłowe tylko w okresie istnienia bieżącej metody. Można jednak przekazać dojście do innych metod, o ile bieżąca metoda znajduje się w wątku kontroli. `arglist` Instrukcję można wykonać tylko w metodzie, która przyjmuje zmienną liczbę argumentów.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `arglist` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej, jeśli dwie wartości są równe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq`target`|Rozgałęzienie do instrukcji docelowej przy `target` przesunięciu, jeśli dwie wartości są równe.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest równe `value2`, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest równa `value2`. `beq` Efekt jest taki sam jak wykonywanie `ceq` instrukcji, po której następuje `brtrue` gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Akceptowane typy argumentów operacji są hermetyzowane poniżej:  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.  
  
 Sterowanie transferami do i z `try`bloków `catch`, `filter`,, `finally` i nie może być wykonywane przez tę <xref:System.Reflection.Emit.OpCodes.Leave> instrukcję (takie transfery są poważnie ograniczone i należy zamiast tego użyć instrukcji).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `beq` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej (krótka wersja), jeśli dwie wartości są równe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2E < `int8` >|BEQ. s`target`|Rozgałęzienie do instrukcji docelowej przy `target` przesunięciu, jeśli jest równa, krótka|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest równe `value2`, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest równa `value2`. `beq.s` Efekt jest taki sam jak wykonywanie `ceq` instrukcji, po której następuje `brtrue` gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.  
  
 Akceptowane typy argumentów operacji są hermetyzowane poniżej:  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.  
  
 Sterowanie transferami do i z `try`bloków `catch`, `filter`,, `finally` i nie może być wykonywane przez tę <xref:System.Reflection.Emit.OpCodes.Leave> instrukcję (takie transfery są poważnie ograniczone i należy zamiast tego użyć instrukcji).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `beq.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest większa lub równa drugiej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa lub równa drugiej wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`większa lub równa, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest `value2`większy lub równy. `bge` Efekt jest identyczny z wykonywaniem `clt.un` instrukcji, po której `brfalse` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bge` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest większa lub równa drugiej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2F `<int8>`|BGE. s`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa lub równa drugiej wartości, krótkiej postaci.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`większa lub równa, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest `value2`większy lub równy. `bge.s` Efekt jest identyczny z wykonywaniem `clt.un` instrukcji, po której `brfalse` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bge.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest większa niż druga wartość, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|41 `<int32>`|BGE. un`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa lub równa drugiej wartości (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`większa lub równa, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje kontrolę do określonej instrukcji docelowej `value2`, jeśli `value1` jest większa lub równa, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `bge.un` Efekt jest identyczny z wykonywaniem `clt` instrukcji, po której `brfalse` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bge.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest większa niż druga wartość, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|34 < `int8` >|BGE. un. s`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa lub równa drugiej wartości (niepodpisane wartości), krótka forma.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`większa lub równa, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje kontrolę do określonej instrukcji docelowej `value2`, jeśli `value1` jest większa lub równa, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `bge.un.s` Efekt jest identyczny z wykonywaniem `clt` instrukcji, po której `brfalse` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bge.un.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest większa niż druga wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3D < `int32` >|#c0`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa niż druga wartość.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest większy niż `value2`, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest większy niż `value2`. `bgt` Efekt jest identyczny z wykonywaniem `cgt` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bgt` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest większa niż druga wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|30 < `int8` >|budżetowy. s`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa niż druga wartość, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest większy niż `value2`, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest większy niż `value2`. `bgt.s` Efekt jest identyczny z wykonywaniem `cgt` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bgt.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest większa niż druga wartość, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|42 < `int32` >|budżetowy. un`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa niż druga wartość (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest większy niż `value2`, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest większy niż `value2`, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `bgt.un` Efekt jest identyczny z wykonywaniem `cgt.un` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bgt.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest większa niż druga wartość, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|35 < `int8` >|budżetowy. un. s`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa niż druga wartość (wartości niepodpisane), krótka forma.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest większy niż `value2`, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest większy niż `value2`, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `bgt.un.s` Efekt jest identyczny z wykonywaniem `cgt.un` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bgt.un.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3E `<int32>`|beli`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`mniejsze lub równe, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje sterowanie do określonej instrukcji docelowej, jeśli `value1` jest `value2`mniejsza lub równa. `ble` Efekt jest identyczny z wykonywaniem `cgt` instrukcji (`cgt.un` dla zmiennoprzecinkowych), `brfalse` po której następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ble` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|31 `<int8>`|beli. s`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości w formie krótkiej.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`mniejsze lub równe, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje sterowanie do określonej instrukcji docelowej, jeśli `value1` jest `value2`mniejsza lub równa. `ble.s` Efekt jest identyczny z wykonywaniem `cgt` instrukcji (`cgt.un` dla operacji zmiennoprzecinkowych`brfalse` ), po której następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ble.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|43 `<int32>`|beli. un`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`mniejsze lub równe, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje kontrolę do określonej instrukcji docelowej `value2`, jeśli `value1` jest ona mniejsza lub równa, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `ble.un` Efekt jest identyczny z wykonywaniem `cgt.un` instrukcji (`cgt` dla zmiennoprzecinkowych), `brfalse` po której następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ble.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości, podczas porównywania wartości liczb całkowitych i nieuporządkowanych wartości zmiennoprzecinkowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|36 `<int8>`|beli. un. s`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości (niepodpisane wartości), krótka forma.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`mniejsze lub równe, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje kontrolę do określonej instrukcji docelowej `value2`, jeśli `value1` jest ona mniejsza lub równa, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `ble.un.s` Efekt jest identyczny z wykonywaniem `cgt.un` instrukcji (`cgt` dla zmiennoprzecinkowych), `brfalse` po której następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ble.un.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest mniejsza od drugiej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3F < `int32` >|blt`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza od drugiej wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest mniejszy niż `value2`, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje sterowanie do określonej instrukcji docelowej, jeśli `value1` jest `value2`mniejsza lub równa. `blt` Efekt jest identyczny z wykonywaniem `clt` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `blt` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest mniejsza od drugiej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|32 < `int8` >|BLT. s`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza niż druga wartość, krótka.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest mniejszy niż `value2`, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest mniejszy niż `value2`. `blt.s` Efekt jest identyczny z wykonywaniem `clt` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `blt.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest mniejsza niż druga wartość, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|44 < `int32` >|BLT. un`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza niż druga wartość (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest mniejszy niż `value2`, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest mniejszy niż `value2`, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `blt.un` Efekt jest identyczny z wykonywaniem `clt.un` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `blt.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest mniejsza niż druga wartość, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|37 < `int8` >|BLT. un. s`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza niż druga wartość (wartości niepodpisane), krótka forma.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest mniejszy niż `value2`, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest mniejszy niż `value2`, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `blt.un` Efekt jest identyczny z wykonywaniem `clt.un` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `blt.un.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej, gdy dwie wartości bez znaku lub nieuporządkowane wartości zmiennoprzecinkowe nie są równe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|40 < `int32` >|BNE. un`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli dwie niepodpisane wartości całkowite nie są równe (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` nie jest równe `value2`, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje kontrolę do określonej instrukcji docelowej `value2`, jeśli `value1` nie jest równa, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `bne.un` Efekt jest identyczny z wykonywaniem `ceq` instrukcji, po której `brfalse` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bne.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej (krótka wersja), gdy dwie wartości całkowite bez znaku lub nieuporządkowane wartości zmiennoprzecinkowe nie są równe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|33 < `int8` >|BNE. un. s`target`|Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli dwie niepodpisane wartości całkowite nie są równe (wartości bez znaku), krótka forma.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; Jeśli `value1` nie jest równe `value2`, wykonywana jest operacja rozgałęzienia.  
  
 Instrukcja przekazuje kontrolę do określonej instrukcji docelowej `value2`, jeśli `value1` nie jest równa, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `bne.un` Efekt jest identyczny z wykonywaniem `ceq` instrukcji, po której `brfalse` następuje gałąź do konkretnej instrukcji docelowej. Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bne.un.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje typ wartości na odwołanie do obiektu (typ <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8C < `T` >|dialogowym`valTypeToken`|Przekonwertuj typ wartości (typu określonego w `valTypeToken`) na prawdziwe odwołanie do obiektu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Typ wartości jest wypychany do stosu.  
  
2.  Typ wartości to zdjęte ze stosu; `box` operacja jest wykonywana.  
  
3.  Odwołanie do obiektu typu wartości "opakowane" jest wypychane na stosie.  
  
 Typ wartości ma dwie oddzielne reprezentacje w Common Language Infrastructure (interfejs wiersza polecenia):  
  
-   Formularz "RAW" używany, gdy typ wartości jest osadzony w innym obiekcie lub na stosie.  
  
-   Formularz "opakowany", w którym dane w typie wartości są opakowane (opakowane) do obiektu, tak aby mógł istnieć jako niezależna jednostka.  
  
 Instrukcja konwertuje typ "RAW" (unopakowany) na odwołanie do obiektu (typ `O`). `box` Jest to realizowane przez utworzenie nowego obiektu i skopiowanie danych z typu wartości do nowo przydzielonego obiektu. `valTypeToken`to token metadanych wskazujący typ wartości typu na stosie.  
  
 <xref:System.OutOfMemoryException>jest zgłaszany w przypadku braku wystarczającej ilości pamięci do spełnienia żądania.  
  
 <xref:System.TypeLoadException>jest zgłaszany, jeśli nie można znaleźć klasy. Jest to zwykle wykrywane podczas konwertowania języka pośredniego (MSIL) firmy Microsoft na kod natywny, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `box` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezwarunkowo przenosi kontrolę do instrukcji docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|Gałęzie do instrukcji docelowej w określonym przesunięciu.|  
  
 Ta operacja nie wykonuje żadnych zachowań stosu szacowania.  
  
 `br` Instrukcja bezwarunkowego transferuje kontrolę do docelowej instrukcji. Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `br` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezwarunkowo przenosi kontrolę do instrukcji docelowej (krótka wersja).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br. s`target`|Gałęzie do instrukcji docelowej o określonej przesunięciu i skrócie.|  
  
 Ta operacja nie wykonuje żadnych zachowań stosu szacowania.  
  
 `br.s` Instrukcja bezwarunkowego transferuje kontrolę do docelowej instrukcji. Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `br.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sygnalizuje Common Language Infrastructure (CLI), aby poinformować debuger, że punkt przerwania został wystawiony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|01|break|informowanie debugera o osiągnięciu punktu przerwania.|  
  
 Ta operacja nie wykonuje żadnych zachowań stosu szacowania.  
  
 `break` Instrukcja dotyczy obsługi debugowania. Sygnalizuje interfejs wiersza polecenia, aby poinformować debuger o konieczności wyzwolenia punktu przerwania. Nie ma żadnego wpływu na stan interpretera.  
  
 `break` Instrukcja ma najmniejszy możliwy rozmiar instrukcji, co umożliwia stosowanie poprawek kodu z punktem przerwania i generowanie minimalnych zakłóceń w otaczającym kodzie.  
  
 `break` Instrukcja może być zalewkami do debugera, nic nie robić lub podnieść wyjątek zabezpieczeń. Dokładne zachowanie jest zdefiniowane przez implementację.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `break` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej, jeśli <paramref name="value" /> jest <see langword="false" />, odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic) lub zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse`target`<br /><br /> brnull`target`<br /><br /> brzero `target`|Odgałęzienia do instrukcji docelowej w określonym przesunięciu `false`, jeśli.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany do stosu przez poprzednią operację.  
  
2.  `value`zdjęte ze stosu; Jeśli `value` `target`jest `false`, należy rozgałęzić do.  
  
 `value` `brzero` `int32` `O` `int64`Instrukcje (i jego aliasy `brnull` i) przesyłają kontrolki do określonej instrukcji docelowej, jeśli (typu, odwołanie do obiektu, wskaźnik zarządzany `brfalse` , wskaźnik `*`przejściowy `native int`,) ma wartość`false`zero (). `&` Jeśli `value` wartość jest różna od zera`true`(), wykonywanie jest kontynuowane przy następnej instrukcji.  
  
 Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `brfalse` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej, jeśli <paramref name="value" /> jest <see langword="false" />, odwołanie o wartości null lub zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse. s`target`<br /><br /> brnull. s`target`<br /><br /> brzero. s`target`|Gałęzie do instrukcji docelowej w określonym przesunięciu if `false`, Short Form.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany do stosu przez poprzednią operację.  
  
2.  `value`zdjęte ze stosu; Jeśli `value` `target`jest `false`, należy rozgałęzić do.  
  
 `value` `brzero` `int32` `O` `int64`Instrukcje (i jego aliasy `brnull` i) przesyłają kontrolki do określonej instrukcji docelowej, jeśli (typu, odwołanie do obiektu, wskaźnik zarządzany `brfalse.s` , wskaźnik `*`przejściowy `native int`,) ma wartość`false`zero (). `&` Jeśli `value` wartość jest różna od zera`true`(), wykonywanie jest kontynuowane przy następnej instrukcji.  
  
 Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `brfalse.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej, jeśli <paramref name="value" /> ma <see langword="true" />wartość, nie ma wartości null lub jest różna od zera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue`target`<br /><br /> do kąpieli`target`|Rozgałęzienie do instrukcji docelowej pod określonym przesunięciem, jeśli nie jest`true`zerem ().|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany do stosu przez poprzednią operację.  
  
2.  `value`zdjęte ze stosu; Jeśli `value` `target`jest `true`, należy rozgałęzić do.  
  
 Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value` (typ `native int`) ma wartość różną od zera`true`(). `brtrue` Jeśli `value` wartość jest równa zero (`false`), wykonywanie jest kontynuowane przy następnej instrukcji.  
  
 Jeśli `value` jest odwołaniem do obiektu ( `O`typ) `brinst` , to (alias `brtrue`dla) przenosi formant, jeśli reprezentuje wystąpienie obiektu (na przykład, jeśli nie jest odwołaniem do obiektu null; zobacz <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `brtrue` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant do instrukcji docelowej (krótka wersja), <paramref name="value" /> Jeśli <see langword="true" />ma wartość, nie ma wartości null lub jest różna od zera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue. s`target`<br /><br /> do kąpieli. s`target`|Rozgałęzienie do instrukcji docelowej pod określonym przesunięciem, jeśli nie jest`true`zerem (), krótką formą.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany do stosu przez poprzednią operację.  
  
2.  `value`zdjęte ze stosu; Jeśli `value` `target`jest `true`, należy rozgałęzić do.  
  
 Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value` (typ `native int`) ma wartość różną od zera`true`(). `brtrue.s` Jeśli `value` wartość jest równa zero (`false`), wykonywanie jest kontynuowane przy następnej instrukcji.  
  
 Jeśli `value` jest odwołaniem do obiektu ( `O`typ) `brinst` , to (alias `brtrue`dla) przenosi formant, jeśli reprezentuje wystąpienie obiektu (na przykład, jeśli nie jest odwołaniem do obiektu null; zobacz <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów. Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `brtrue.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wywołuje metodę wskazywaną przez deskryptor metody przekazywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|28 < `T` >|połączeń`methodDesc`|Wywołaj metodę opisaną przez `methodDesc`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Argumenty `arg1` metody przez `argN` są wypychane na stosie.  
  
2.  Argumenty `arg1` metody przez `argN` są zdjęte ze stosu; wywołanie metody jest wykonywane z tymi argumentami, a sterowanie jest przekazywane do metody, do której odwołuje się deskryptor metody. Po zakończeniu wartość zwracana jest generowana przez metodę wywoływaną i wysyłana do obiektu wywołującego.  
  
3.  Wartość zwracana jest wypychana do stosu.  
  
 `call` Instrukcja wywołuje metodę wskazywaną przez deskryptor metody przekazywania instrukcji. Deskryptor metody jest tokenem metadanych, który wskazuje metodę wywołania oraz liczbę, typ i kolejność argumentów umieszczonych na stosie, które zostały przekazane do tej metody, a także konwencję wywoływania, która ma zostać użyta. Instrukcja może być bezpośrednio poprzedzona `tail` instrukcją prefiksu<xref:System.Reflection.Emit.OpCodes.Tailcall>(), aby określić, że bieżący stan metody powinien zostać wystawiony przed przekazaniem kontroli. `call` Jeśli wywołanie przenosi formant do metody o wyższym poziomie zaufania niż Metoda pierwotna, Ramka stosu nie zostanie wydzielona. Zamiast tego wykonywanie jest kontynuowane w trybie dyskretnym `tail` , tak jakby nie została dostarczona. Token metadanych zawiera wystarczające informacje, aby określić, czy wywołanie jest metodą statyczną, metodą wystąpienia, metodą wirtualną lub funkcją globalną. We wszystkich tych przypadkach adres docelowy jest ustalany całkowicie z deskryptora metody (Kontrast to z <xref:System.Reflection.Emit.OpCodes.Callvirt> instrukcją wywołania metod wirtualnych, gdzie adres docelowy jest również zależny od typu środowiska uruchomieniowego wystąpienia odwołanie zostało wypchnięte przed <xref:System.Reflection.Emit.OpCodes.Callvirt>().  
  
 Argumenty są umieszczane na stosie w kolejności od lewej do prawej. Oznacza to, że pierwszy argument jest obliczany i umieszczany na stosie, drugi argument, a następnie trzeci, do momentu, aż wszystkie wymagane argumenty będą korzystającego stos w kolejności malejącej. Istnieją trzy ważne przypadki specjalne:  
  
 1. Wywołania metody wystąpienia (lub wirtualnej) muszą wypchnąć to odwołanie do wystąpienia przed dowolnymi argumentami widocznymi dla użytkownika. Odwołanie do wystąpienia nie może być odwołaniem o wartości null. Sygnatura przeprowadzona w metadanych nie zawiera wpisu na liście parametrów dla `this` wskaźnika; zamiast tego używa bitu, aby wskazać, czy metoda wymaga `this` przekazania wskaźnika.  
  
 2. Jest to prawidłowe wywoływanie metody wirtualnej przy użyciu `call` ( `callvirt`a nie); oznacza to, że metoda jest rozpoznawana przy użyciu klasy określonej przez metodę, a nie określona dynamicznie z wywoływanego obiektu.  
  
 3. Należy pamiętać, że `Invoke` Metoda delegata może być wywoływana przy użyciu `call` instrukcji or. `callvirt`  
  
 <xref:System.Security.SecurityException>mogą być zgłaszane, jeśli zabezpieczenia systemu nie udzielą dostępu wywołującego do wywołanej metody. Sprawdzanie zabezpieczeń może wystąpić, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.  
  
> [!NOTE]
>  Podczas wywoływania metod klasy System. Object w typach wartości, rozważ użycie `constrained` prefiksu `callvirt` z instrukcją `call` zamiast emitowania instrukcji. Eliminuje to konieczność emitowania różnych IL w zależności od tego, czy typ wartości przesłania metodę, unikając potencjalnego problemu z wersją. Rozważ użycie `constrained` prefiksu podczas wywoływania metod interfejsu dla typów wartości, ponieważ metoda typu wartości implementująca metodę interfejsu można zmienić `MethodImpl`przy użyciu. Te problemy są opisane bardziej szczegółowo w <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `call` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
-   Elemencie ILGenerator. EmitCall (OpCode, MethodInfo, Type [])  
  
> [!NOTE]
>  Metoda jest dostępna dla `varargs` wywołań. <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Użyj metody dla normalnych wywołań.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wywołuje metodę wskazującą stos oceny (jako wskaźnik do punktu wejścia) z argumentami opisanymi przez konwencję wywoływania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|29 < `T` >|Calli`callSiteDescr`|Wywołuje metodę wskazywaną z argumentami opisanymi przez konwencję wywoływania.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Argumenty `arg1` metody przez `argN` są wypychane na stosie.  
  
2.  Wskaźnik wejścia metody jest wypychany do stosu.  
  
3.  Argumenty `arg1` metody przez `argN` i wskaźnik wejścia metody są zdjęte ze stosu; wywołanie metody jest wykonywane. Po zakończeniu wartość zwracana jest generowana przez metodę wywoływaną i wysyłana do obiektu wywołującego.  
  
4.  Wartość zwracana jest wypychana do stosu.  
  
 Instrukcja wywołuje wskaźnik wejścia metody z argumentami `arg1` przez `argN`. `calli` Typy tych argumentów są opisane przez określoną konwencję wywoływania (`callSiteDesc`). Instrukcja może być bezpośrednio poprzedzona `tail` prefiksem (<xref:System.Reflection.Emit.OpCodes.Tailcall>), aby określić, że bieżący stan metody powinien zostać wystawiony przed przekazaniem kontroli. `calli` Jeśli wywołanie przeniesie formant do metody o wyższym poziomie zaufania niż Metoda pochodzenia, Ramka stosu nie zostanie wydzielona; Zamiast tego wykonywanie będzie kontynuowane w trybie dyskretnym, `tail` tak jakby nie została dostarczona.  
  
 Przyjmuje się, że wskaźnik wejścia metody jest określonym wskaźnikiem do kodu natywnego (maszyny docelowej), który może być słusznie wywoływany z argumentami opisanymi w konwencji wywoływania (tokenem metadanych dla podpisu autonomicznego). Taki wskaźnik można utworzyć przy użyciu <xref:System.Reflection.Emit.OpCodes.Ldftn> instrukcji lub <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> lub przekazywać z kodu natywnego.  
  
 Konwencja wywoływania nie jest sprawdzana dynamicznie, dlatego kod, który używa `calli` instrukcji, nie działa prawidłowo, jeśli miejsce docelowe nie używa faktycznie określonej konwencji wywoływania.  
  
 Argumenty są umieszczane na stosie w kolejności od lewej do prawej. Oznacza to, że pierwszy argument jest obliczany i umieszczany na stosie, drugi argument, a następnie trzeci, do momentu, aż wszystkie wymagane argumenty będą korzystającego stos w kolejności malejącej. Sekwencja kodu tworzenia argumentów dla wystąpienia lub metody wirtualnej musi wypchnąć to odwołanie do wystąpienia (które nie może być odwołaniem null) przed żadnym z argumentów widocznych dla użytkownika.  
  
 <xref:System.Security.SecurityException>mogą być zgłaszane, jeśli zabezpieczenia systemu nie udzielą dostępu wywołującego do wywołanej metody. Sprawdzanie zabezpieczeń może wystąpić, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.  
  
 Poniższe <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> metody mogą służyć do `calli` wykonywania instrukcji na stosie. Należy pamiętać `calli` , że należy ją wywołać za pomocą poniższych metod zamiast <xref:System.Reflection.Emit.ILGenerator.Emit%2A> używać klasy do umieszczania instrukcji bezpośrednio na stosie.  
  
-   Elemencie ILGenerator. EmitCalli (opcode, CallingConventions, Type, Type [], Type []) dla wywołań przy użyciu zarządzanej konwencji wywoływania.  
  
-   Elemencie ILGenerator. EmitCalli (opcode, CallingConvention, Type, Type []) dla wywołań za pomocą niezarządzanej konwencji wywoływania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wywołuje metodę z późnym wiązaniem dla obiektu, wypchnięcie wartości zwracanej na stos szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6F < `T` >|elementu`method`|Wywołuje określoną metodę skojarzoną z `obj`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `obj` do obiektu jest wypychane na stosie.  
  
2.  Argumenty `arg1` metody przez `argN` są wypychane na stosie.  
  
3.  Argumenty `arg1` metody przez `argN` i odwołania `obj` do obiektu są zdjęte ze stosu; wywołanie metody jest wykonywane z tymi argumentami `obj` , a kontrola jest przekazywana do metody, która jest określana przez metodę Token metadanych. Po zakończeniu wartość zwracana jest generowana przez metodę wywoływaną i wysyłana do obiektu wywołującego.  
  
4.  Wartość zwracana jest wypychana do stosu.  
  
 `callvirt` Instrukcja wywołuje metodę z późnym wiązaniem dla obiektu. Oznacza to, że metoda jest wybierana na podstawie typu `obj` środowiska uruchomieniowego, a nie klasy czasu kompilacji widocznego w wskaźniku metody. `Callvirt`może służyć do wywoływania zarówno metody wirtualnej, jak i wystąpienia. Instrukcja może być bezpośrednio poprzedzona `tail` prefiksem (<xref:System.Reflection.Emit.OpCodes.Tailcall>), aby określić, że bieżąca Ramka stosu powinna zostać wydana przed przekazaniem kontroli. `callvirt` Jeśli wywołanie przeniesie formant do metody o wyższym poziomie zaufania niż oryginalna Metoda, Ramka stosu nie zostanie wydzielona.  
  
 Token metadanych metody zawiera nazwę, klasę i podpis metody do wywołania. Klasa skojarzona z `obj` jest klasą, której jest wystąpieniem. Jeśli klasa definiuje niestatyczną metodę, która pasuje do wskazanej nazwy metody i podpisu, ta metoda jest wywoływana. W przeciwnym razie wszystkie klasy w łańcuchu klas bazowych tej klasy są sprawdzane w kolejności. Jeśli nie zostanie znaleziona żadna metoda, występuje błąd.  
  
 `Callvirt`przed wywołaniem metody punkty obecności obiektu i skojarzonych z nim argumentów są wyłączane. Jeśli metoda ma wartość zwracaną, jest wypychana na stosie po zakończeniu metody. Po stronie `obj` wywoływanej parametr jest dostępny jako argument 0, `arg1` jako argument 1 i tak dalej.  
  
 Argumenty są umieszczane na stosie w kolejności od lewej do prawej. Oznacza to, że pierwszy argument jest obliczany i umieszczany na stosie, drugi argument, a następnie trzeci, do momentu, aż wszystkie wymagane argumenty będą korzystającego stos w kolejności malejącej. Odwołanie `obj` do wystąpienia (zawsze wymagane dla `callvirt`) musi zostać wypchnięte przed dowolnymi argumentami widocznymi dla użytkownika. Sygnatura (przeprowadzona w tokenie metadanych) nie musi zawierać wpisu na liście parametrów dla tego wskaźnika.  
  
 Należy zauważyć, że metoda wirtualna może być również wywoływana przy <xref:System.Reflection.Emit.OpCodes.Call> użyciu instrukcji.  
  
 <xref:System.MissingMethodException>jest zgłaszany, jeśli nie można znaleźć metody niestatycznej o wskazanej nazwie i podpisie w klasie skojarzonej `obj` z lub żadnej z jej klas podstawowych. Jest to zwykle wykrywane, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.  
  
 <xref:System.NullReferenceException>jest zgłaszany, Jeśli obj ma wartość null.  
  
 <xref:System.Security.SecurityException>jest zgłaszany, jeśli zabezpieczenia systemu nie udzielą dostępu wywołującego do wywołanej metody. Sprawdzanie zabezpieczeń może wystąpić, gdy CIL jest konwertowany na kod natywny, a nie w czasie wykonywania.  
  
> [!NOTE]
>  Podczas wywoływania metod klasy System. Object w typach wartości należy rozważyć użycie `constrained` prefiksu `callvirt` z instrukcją. Eliminuje to konieczność emitowania różnych IL w zależności od tego, czy typ wartości przesłania metodę, unikając potencjalnego problemu z wersją. Rozważ użycie `constrained` prefiksu podczas wywoływania metod interfejsu dla typów wartości, ponieważ metoda typu wartości implementująca metodę interfejsu można zmienić `MethodImpl`przy użyciu. Te problemy są opisane bardziej szczegółowo w <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `callvirt` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
-   Elemencie ILGenerator. EmitCall (OpCode, MethodInfo, Type [])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Próbuje rzutować obiekt przekazaną przez odwołanie do określonej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass`class`|Rzutuje obiekt na nowy obiekt typu `class`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu jest wypychane na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte ze stosu; przywoływany obiekt jest rzutowany jako `class`określony.  
  
3.  Jeśli to się powiedzie, nowe odwołanie do obiektu jest wypychane na stosie.  
  
 Instrukcja próbuje rzutować odwołania do obiektu (typu `O`) korzystającego stos na określoną klasę. `castclass` Nowa klasa jest określana przez token metadanych wskazujący żądaną klasę. Jeśli klasa obiektu w górnej części stosu nie implementuje nowej klasy (przy założeniu, że nowa klasa jest interfejsem) i nie jest klasą pochodną nowej klasy <xref:System.InvalidCastException> , zostanie zgłoszony. Jeśli odwołanie do obiektu jest odwołaniem null, `castclass` powiedzie się i zwróci nowy obiekt jako odwołanie o wartości null.  
  
 <xref:System.InvalidCastException>jest zgłaszany, jeśli nie można rzutować na klasę.  
  
 <xref:System.TypeLoadException>jest zgłaszany, jeśli nie można znaleźć klasy. Jest to zwykle wykrywane, gdy instrukcja języka pośredniego (MSIL) firmy Microsoft jest konwertowana na kod natywny, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `castclass` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje dwie wartości. Jeśli są równe, wartość całkowita 1 <see langword="(int32" />) jest wypychana do stosu oceny; w przeciwnym razie<see langword="int32" />0 () jest wypychany do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 01|ceq|Wypchnięcia 1 `value1` , `value2`jeśli jest równe; w przeciwnym razie wypycha 0.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; jest porównywany `value2`z. `value1`  
  
4.  Jeśli `value1` jest równe, `value2`1 jest wypychany do stosu; w przeciwnym razie 0 jest wypychana do stosu.  
  
 Instrukcja porównuje `value1` i `value2`. `ceq` Jeśli `value1` jest `int32`równe, 1 (z typu) jest wypychany na stosie. `value2` W przeciwnym razie 0 ( `int32`z typu) jest wypychany na stosie.  
  
 W przypadku liczby zmiennoprzecinkowej program `ceq` zwróci wartość 0, jeśli liczby są nieuporządkowane (albo oba są NaN). Wartości nieskończone są równe sobie same.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ceq` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje dwie wartości. Jeśli pierwsza wartość jest większa niż sekunda, wartość całkowita 1 <see langword="(int32" />) jest wypychana do stosu oceny; w przeciwnym razie<see langword="int32" />0 () jest wypychany do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 02|cgt|Wypchnięcia 1 `value1` , jeśli jest `value2`większa niż; w przeciwnym wypadku wypchnij 0.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; test jeśli `value1` jest większy niż `value2`. `cgt`  
  
4.  Jeśli `value1` jest większa niż `value2`, 1 jest wypychana do stosu; w przeciwnym razie 0 jest wypychana do stosu.  
  
 Instrukcja porównuje `value1` i `value2`. `cgt` Jeśli `value1` jest ściśle większa niż `value2`, `int32` wartość 1 jest wypychana na stosie. W przeciwnym razie wartość 0 jest wypychana na stosie. `int32`  
  
-   W przypadku liczb zmiennoprzecinkowych zwraca `cgt` wartość 0, jeśli liczby są nieuporządkowane (czyli jeśli jeden lub oba argumenty są NaN).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `cgt` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje dwie niepodpisane lub nieuporządkowane wartości. Jeśli pierwsza wartość jest większa niż sekunda, wartość całkowita 1 <see langword="(int32" />) jest wypychana do stosu oceny; w przeciwnym razie<see langword="int32" />0 () jest wypychany do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|Wypchnięcia 1 `value1` , jeśli jest `value2`większa niż; w przeciwnym razie wypycha 0 (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; test jeśli `value1` jest większy niż `value2`. `cgt.un`  
  
4.  Jeśli `value1` jest większa niż `value2`, 1 jest wypychana do stosu; w przeciwnym razie 0 jest wypychana do stosu.  
  
 Wartość 1 jest wypychana na stosie, jeśli którekolwiek z `true` następujących elementów: `int32`  
  
 W przypadku liczb `value1` zmiennoprzecinkowych nie jest uporządkowana w odniesieniu do `value2`.  
  
 W przypadku wartości całkowitych jest ściśle większa `value2` niż w przypadku, `value1` gdy jest traktowana jako liczba bez znaku.  
  
 W przeciwnym razie wartość 0 jest wypychana na stosie. `int32`  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `cgt.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zgłasza <see cref="T:System.ArithmeticException" /> , czy wartość nie jest wartością skończoną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|C3|ckfinite|Zgłoś <xref:System.ArithmeticException> , jeśli wartość nie jest liczbą skończoną.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie. 
  
2.  `value`jest zdjęte ze stosu i `ckfinite` jest wykonywana na nim instrukcja.  
  
3.  `value`jest wypychany na stosie, jeśli nie zostanie zgłoszony żaden wyjątek.  
  
 Zwraca `ckfinite instruction` `+-` wartość, Jeśli`value` (liczba zmiennoprzecinkowa) jest wartością typu "nie jest liczbą" (NaN) lub nieskończoną. <xref:System.ArithmeticException> `Ckfinite`pozostawia wartość na stosie, jeśli nie zostanie zgłoszony żaden wyjątek. Wykonanie nie jest określone, `value` Jeśli nie jest liczbą zmiennoprzecinkową.  
  
 <xref:System.ArithmeticException>jest zgłaszany `value` , jeśli nie jest numerem "normal".  
  
 Należy zauważyć, że specjalny wyjątek lub Klasa <xref:System.ArithmeticException> pochodna może być bardziej odpowiednia, przekazując niepoprawną wartość do procedury obsługi wyjątków.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ckfinite` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje dwie wartości. Jeśli pierwsza wartość jest mniejsza niż sekunda, wartość całkowita 1 <see langword="(int32" />) jest wypychana do stosu oceny; w przeciwnym razie<see langword="int32" />0 () jest wypychany do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 04|clt|Wypchnięcia 1 `value1` , jeśli jest `value2`mniejsza niż; w przeciwnym wypadku wypchnij 0.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to: 

1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; sprawdza, `value1` czy jest mniejsza `value2`niż. `clt`  
  
4.  Jeśli `value1` jest mniejsza niż `value2`, 1 jest wypychana do stosu; w przeciwnym razie 0 jest wypychana na stos.  
  
 Instrukcja porównuje `value1` i `value2`. `clt` Jeśli `value1` jest ściśle mniejsze niż `value2`, `int32` wartość 1 jest wypychana na stosie. W przeciwnym razie wartość 0 jest wypychana na stosie. `int32`  
  
-   W przypadku liczb zmiennoprzecinkowych zwraca `clt` wartość 0, jeśli liczby są nieuporządkowane (czyli jeśli jeden lub oba argumenty są NaN).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `clt` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Porównuje niepodpisane lub nieuporządkowane <paramref name="value1" /> wartości <paramref name="value2" />i. Jeśli <paramref name="value1" /> jest mniejsza niż <paramref name="value2" />, wartość całkowita 1 <see langword="(int32" />) jest wypychana do stosu oceny; w przeciwnym razie 0 (<see langword="int32" />) jest wypychana do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 05|CLT. un|Wypchnięcia 1 `value1` , jeśli jest `value2`mniejsza niż; w przeciwnym wypadku wypycha 0 (wartości bez znaku).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; sprawdza, `value1` czy jest mniejsza `value2`niż. `clt.un`  
  
4.  Jeśli `value1` jest mniejsza niż `value2`, 1 jest wypychana do stosu; w przeciwnym razie 0 jest wypychana na stos.  
  
 Instrukcja porównuje `value1` i `value2`. `clt.un` `int32` Wartość 1 jest wypychana na stosie, jeśli którykolwiek z następujących warunków jest spełniony:  
  
-   `value1`jest ściśle mniejsze niż `value2` (jak w `clt`przypadku).  
  
-   W przypadku liczb `value1` zmiennoprzecinkowych nie jest uporządkowana w odniesieniu do `value2`.  
  
-   W przypadku wartości całkowitych jest ściśle mniejsza `value2` niż w przypadku, `value1` gdy jest traktowana jako liczba bez znaku.  
  
 W przeciwnym razie wartość 0 jest wypychana na stosie. `int32`  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `clt.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ogranicza typ, na którym jest nawiązywane wywołanie metody wirtualnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 16 < `T` >|ograniczone. `thisType`|Wywołaj metodę wirtualną na typie ograniczonym do typu `T`.|  
  
 Prefiks jest dozwolony tylko `callvirt` w instrukcji. `constrained`  
  
 Stan stosu MSIL w tym punkcie musi być następujący:  
  
1.  Zarządzany wskaźnik `ptr`jest wypychany na stosie. Typ elementu `ptr` musi być wskaźnikiem zarządzanym (`&`) do `thisType`. Należy zauważyć, że różni się to od wielkości liter `callvirt` instrukcji bez prefiksu, która oczekuje `thisType`odwołania.  
  
2.  Argumenty `arg1` metody przez `argN` są wypychane na stosie, podobnie jak `callvirt` w przypadku instrukcji bez prefiksu.  
  
 Prefiks ma na celu umożliwienie `callvirt` wykonywania instrukcji w jednolity sposób niezależnie od tego, czy `thisType` jest typem wartości czy typem referencyjnym. `constrained`  
  
 Gdy instrukcja została poprzedzona `constrained` przez`thisType`, instrukcja jest wykonywana w następujący sposób: `method` `callvirt`  
  
-   Jeśli `thisType` jest typem referencyjnym (w przeciwieństwie do typu wartości `ptr` ), oznacza to, że `callvirt` zostanie on wywoływany i przeszedł jako wskaźnik "this `method`" do elementu.  
  
-   Jeśli `thisType` jest typem wartości i `thisType` implementuje `method` `method` , jest `call` przenoszona niezmodyfikowana jako wskaźnik "This" do instrukcji,dlaimplementacjiprzez`method` `ptr` `thisType`.  
  
-   Jeśli `thisType` jest typem wartości i `thisType` nie implementuje `method` `ptr` elementu, jest on wywołujący, opakowany i przeszedł jako wskaźnik "This" do `callvirt` `method` instrukcji.  
  
 Ten ostatni przypadek może wystąpić tylko wtedy `method` , gdy został <xref:System.Object>zdefiniowany <xref:System.ValueType>w, <xref:System.Enum> lub i nie został `thisType`zastąpiony przez. W takim przypadku opakowanie powoduje wykonanie kopii oryginalnego obiektu. Jednak ponieważ żadna z metod <xref:System.Object>, <xref:System.ValueType>i <xref:System.Enum> nie modyfikuje stanu obiektu, nie można wykryć tego faktu.  
  
 `constrained` Prefiks obsługuje generatory IL, które tworzą kod generyczny. `callvirt` Zwykle instrukcja nie jest prawidłowa w typach wartości. Zamiast tego jest wymagane, aby kompilatory Il efektywnie wykonywały przekształcenie "This" opisane powyżej w czasie kompilacji, w zależności od typu `ptr` i metody wywoływanej. Jeśli `ptr` jednak jest typem ogólnym, który jest nieznany w czasie kompilacji, nie jest możliwe przekształcenie w czasie kompilacji.  
  
 Kod operacji pozwala kompilatorom Il wykonywać wywołania funkcji wirtualnej w jednolity sposób niezależnie od tego, czy `ptr` jest typem wartości czy typem referencyjnym. `constrained` Chociaż jest ona przeznaczona dla przypadku `thisType` `constrained` , gdzie jest zmienną typu ogólnego, prefiks również działa dla typów nierodzajowych i może zmniejszyć złożoność generowania wywołań wirtualnych w językach, które ukrywają różnice między typami wartości i typy odwołań.  
  
 Przy użyciu `constrained` prefiksu można również uniknąć potencjalnych problemów z wersjami typów wartości. `constrained` Jeśli prefiks nie jest używany, różne Il muszą być emitowane w zależności od tego, czy typ wartości przesłania metodę System. Object. Na przykład, jeśli `V` typ wartości zastępuje metodę Object. ToString () `Object.ToString()` `call` `V.ToString()` , jest emitowana instrukcja. Jeśli `callvirt` tak nie jest, `box` instrukcja i instrukcja są emitowane. Problem z przechowywaniem wersji może wystąpić w poprzednim przypadku, jeśli zastąpienie zostanie później usunięte, a w drugim przypadku, jeśli przesłonięcie zostanie później dodane.  
  
 Prefiks może być również używany do wywołania metod interfejsu w typach wartości, ponieważ metoda typu wartości implementująca metodę interfejsu można zmienić `MethodImpl`przy użyciu. `constrained` `constrained` Jeśli prefiks nie jest używany, kompilator jest zmuszony do wybrania metod, które mają być powiązane z typem wartości w czasie kompilacji. `constrained` Używanie prefiksu pozwala na powiązanie MSIL z metodą implementującą metodę interfejsu w czasie wykonywania, a nie w czasie kompilacji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `constrained` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na górze stosu oceny na <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D3|conv.i|Konwertuj na `native int`, `native int` wypychanie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.i` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu. Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany). Wartości zmiennoprzecinkowe są konwertowane na `F` typ.  
  
 Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera. Podczas konwertowania od a `float64` `float32`do, precyzja może zostać utracona. Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana. Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.  
  
 Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.  
  
 W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.i` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na górze stosu oceny na <see langword="int8" />, a następnie rozszerza (konsole). <see langword="int32" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|67|CONV. I1|Konwertuj na `int8`, `int32` wypychanie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.i1` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu. Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany). Wartości zmiennoprzecinkowe są konwertowane na `F` typ.  
  
 Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera. Podczas konwertowania od a `float64` `float32`do, precyzja może zostać utracona. Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana. Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.  
  
 Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.  
  
 W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.i1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na górze stosu oceny na <see langword="int16" />, a następnie rozszerza (konsole). <see langword="int32" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|68|conv.i2|Konwertuj na `int16`, `int32` wypychanie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.i2` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu. Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany). Wartości zmiennoprzecinkowe są konwertowane na `F` typ.  
  
 Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera. Podczas konwertowania od a `float64` `float32`do, precyzja może zostać utracona. Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana. Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.  
  
 Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.  
  
 W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.i2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na górze stosu oceny na <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|69|CONV. i4|Konwertuj na `int32`, `int32` wypychanie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.i4` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu. Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany). Wartości zmiennoprzecinkowe są konwertowane na `F` typ.  
  
 Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera. Podczas konwertowania od a `float64` `float32`do, precyzja może zostać utracona. Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana. Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.  
  
 Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.  
  
 W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.i4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na górze stosu oceny na <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6A|CONV. i8|Konwertuj na `int64`, `int64` wypychanie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.i8` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu. Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany). Wartości zmiennoprzecinkowe są konwertowane na `F` typ.  
  
 Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera. Podczas konwertowania od a `float64` `float32`do, precyzja może zostać utracona. Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana. Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.  
  
 Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.  
  
 W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.i8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje podpisaną wartość na górze stosu oceny na podpisaną <see langword="native int" />, przerzucanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|Konwertuj na `native int` (na stosie jako `native int`) i Zgłoś wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.i` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na górze stosu oceny na podpisaną <see langword="native int" />, przerzucanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|Konwertuje wartość `native int` bez znaku na (na stosie jako `native int`) i zgłasza wyjątek w przypadku przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.i.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje podpisaną wartość na górze stosu oceny na podpisaną <see langword="int8" /> i rozszerza ją do <see langword="int32" />, <see cref="T:System.OverflowException" /> zwracając przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|Konwertuj na `int8` (na stosie jako `int32`) i Zgłoś wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.i1` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny, aby była <see langword="int8" /> podpisana i rozszerzana do <see cref="T:System.OverflowException" /> <see langword="int32" />, zwracając przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|Konwertuje wartość bez znaku na `int8` (na stosie jako `int32`) i zgłasza wyjątek w przypadku przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.i1.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i1.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje podpisaną wartość znajdującą się na górze stosu oceny na <see langword="int16" /> podpisaną i rozszerzającą <see langword="int32" />ją <see cref="T:System.OverflowException" /> na, co powoduje Przerzucanie w przypadku przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|Konwertuj na `int16` (na stosie jako `int32`) i Zgłoś wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.i2` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny, aby była <see langword="int16" /> podpisana i rozszerzana do <see cref="T:System.OverflowException" /> <see langword="int32" />, zwracając przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|Konwertuje wartość bez znaku na `int16` (na stosie jako `int32`) i zgłasza wyjątek w przypadku przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.i2.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i2.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje podpisaną wartość na górze stosu oceny na podpisaną <see langword="int32" />, przerzucanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|Konwertuj na `int32` (na stosie jako `int32`) i Zgłoś wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.i4` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na górze stosu oceny na podpisaną <see langword="int32" />, przerzucanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|Konwertuje wartość bez znaku na `int32` (na stosie jako `int32`) i zgłasza wyjątek w przypadku przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.i4.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i4.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje podpisaną wartość na górze stosu oceny na podpisaną <see langword="int64" />, przerzucanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|Konwertuj na `int64` (na stosie jako `int64`) i Zgłoś wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.i8` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na górze stosu oceny na podpisaną <see langword="int64" />, przerzucanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|Konwertuje wartość bez znaku na `int64` (na stosie jako `int64`) i zgłasza wyjątek w przypadku przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.i8.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i8.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje podpisaną wartość znajdującą się na górze stosu oceny <see langword="unsigned native int" />na <see cref="T:System.OverflowException" /> , zwracając przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|Konwertuj na `unsigned native int` (na stosie jako `native int`) i Zgłoś wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.u` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na górze stosu oceny do, która <see langword="unsigned native int" />zostanie przerzucana <see cref="T:System.OverflowException" /> w przypadku przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|Konwertuje wartość unsigned `unsigned native int` na (na stosie `native int`jako) i zgłasza wyjątek w przypadku przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.u.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.uvf.u.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje podpisaną wartość na górze stosu oceny na <see langword="unsigned int8" /> i rozszerza ją do <see langword="int32" />, co powoduje Przerzucanie <see cref="T:System.OverflowException" /> w przypadku przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|Konwertuj na `unsigned int8` (na stosie jako `int32`) i Zgłoś wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.u1` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny do <see langword="unsigned int8" /> i rozszerza ją do <see langword="int32" />, co powoduje <see cref="T:System.OverflowException" /> Przerzucanie w przypadku przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|Konwertuje wartość bez znaku na `unsigned int8` (na stosie jako `int32`) i zgłasza wyjątek w przypadku przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.u1.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u1.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje podpisaną wartość na górze stosu oceny na <see langword="unsigned int16" /> i rozszerza ją do <see langword="int32" />, co powoduje Przerzucanie <see cref="T:System.OverflowException" /> w przypadku przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|Konwertuj na `unsigned int16` (na stosie jako `int32`) i Zgłoś wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.u2` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na szczycie stosu oceny do <see langword="unsigned int16" /> i rozszerza ją do <see langword="int32" />, co powoduje <see cref="T:System.OverflowException" /> Przerzucanie w przypadku przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|Konwertuje wartość bez znaku na `unsigned int16` (na stosie jako `int32`) i zgłasza wyjątek w przypadku przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.u2.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u2.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje podpisaną wartość znajdującą się na górze stosu oceny <see langword="unsigned int32" />na <see cref="T:System.OverflowException" /> , zwracając przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|Konwertuj na `unsigned int32` (na stosie jako `int32`) i Zgłoś wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.u4` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na górze stosu oceny do, która <see langword="unsigned int32" />zostanie przerzucana <see cref="T:System.OverflowException" /> w przypadku przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|Konwertuje wartość bez znaku na `unsigned int32` (na stosie jako `int32`) i zgłasza wyjątek w przypadku przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.u4.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u4.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje podpisaną wartość znajdującą się na górze stosu oceny <see langword="unsigned int64" />na <see cref="T:System.OverflowException" /> , zwracając przy przepełnieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|Konwertuj na `unsigned int64` (na stosie jako `int64`) i Zgłoś wyjątek przy przepełnieniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.u8` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość bez znaku na górze stosu oceny do, która <see langword="unsigned int64" />zostanie przerzucana <see cref="T:System.OverflowException" /> w przypadku przepełnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|Konwertuje wartość bez znaku na `unsigned int64` (na stosie jako `int64`) i zgłasza wyjątek w przypadku przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji. W przypadku przepełnienia występuje wyjątek.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.ovf.u8.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu. Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.  
  
 Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera. Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u8.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość liczby całkowitej bez znaku na górze stosu oceny na <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|76|conv.r.un|Konwertuj liczbę całkowitą bez znaku na zmiennoprzecinkową, wypychania `F` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.r.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu. Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany). Wartości zmiennoprzecinkowe są konwertowane na `F` typ.  
  
 Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera. Podczas konwertowania od a `float64` `float32`do, precyzja może zostać utracona. Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana. Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.  
  
 Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą `result` , zwracana wartość jest nieokreślona. Operacja przyjmuje liczbę całkowitą ze stosu, interpretuje ją jako unsigned i zastępuje ją liczbą zmiennoprzecinkową, aby reprezentować liczbę całkowitą: `float32`albo, jeśli jest wystarczająco szeroka, aby reprezentować liczbę całkowitą bez utraty dokładności, lub inną `conv.r.un` a `float64`.  
  
 W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.r.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na górze stosu oceny na <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6B|CONV. R4|Konwertuj na `float32`, `F` wypychanie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.r4` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu. Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany). Wartości zmiennoprzecinkowe są konwertowane na `F` typ.  
  
 Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera. Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona. Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana. Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.  
  
 Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.  
  
 W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.r4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na górze stosu oceny na <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6C|conv.r8|Konwertuj na `float64`, `F` wypychanie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.r8` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu. Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany). Wartości zmiennoprzecinkowe są konwertowane na `F` typ.  
  
 Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera. Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona. Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana. Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.  
  
 Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.  
  
 W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.r8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na górze stosu oceny na <see langword="unsigned native int" />i rozszerza <see langword="native int" />ją na.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|E0|conv.u|Konwertuj na `unsigned native int`, `native int` wypychanie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.u` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu. Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany). Wartości zmiennoprzecinkowe są konwertowane na `F` typ.  
  
 Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera. Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona. Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana. Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.  
  
 Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.  
  
 W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.u` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na górze stosu oceny na <see langword="unsigned int8" />i rozszerza <see langword="int32" />ją na.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D2|CONV. U1|Konwertuj na `int8`, `int32` wypychanie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.u1` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu. Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany). Wartości zmiennoprzecinkowe są konwertowane na `F` typ.  
  
 Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera. Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona. Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana. Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.  
  
 Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.  
  
 W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.u1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na górze stosu oceny na <see langword="unsigned int16" />i rozszerza <see langword="int32" />ją na.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D1|conv.u2|Konwertuj na `int16`, `int32` wypychanie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.u2` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu. Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany). Wartości zmiennoprzecinkowe są konwertowane na `F` typ.  
  
 Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera. Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona. Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana. Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.  
  
 Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.  
  
 W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.u2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na górze stosu oceny na <see langword="unsigned int32" />i rozszerza <see langword="int32" />ją na.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6D|CONV. U4|Konwertuj na `unsigned int32`, `int32` wypychanie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.u4` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu. Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany). Wartości zmiennoprzecinkowe są konwertowane na `F` typ.  
  
 Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera. Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona. Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana. Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.  
  
 Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.  
  
 W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.u4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje wartość na górze stosu oceny na <see langword="unsigned int64" />i rozszerza <see langword="int64" />ją na.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|6E|conv.u8|Konwertuj na `int64`, `int64` wypychanie na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.  
  
3.  Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.  
  
 `conv.u8` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu. Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany). Wartości zmiennoprzecinkowe są konwertowane na `F` typ.  
  
 Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera. Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona. Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana. Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane. Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.  
  
 Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.  
  
 W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki. Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.u8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiuje określoną liczbę bajtów z adresu źródłowego na adres docelowy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Kopiuj dane z jednego bloku pamięci do innego.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres docelowy jest wypychany na stosie.  
  
2.  Adres źródłowy jest wypychany na stosie.  
  
3.  Liczba bajtów do skopiowania jest wypychana do stosu.  
  
4.  Liczba bajtów, adres źródłowy i adres docelowy są zdjęte ze stosu. określona liczba bajtów jest kopiowana z adresu źródłowego na adres docelowy.  
  
 `native int` `native int` `&` `*` `*` `&`Instrukcja kopiuje liczbę (typ `unsigned int32`) bajtów z adresu źródłowego (typu, lub) do adresu docelowego (typu, lub). `cpblk` Zachowanie `cpblk` nie jest określone, jeśli obszary źródłowe i docelowe nakładają się na siebie.  
  
 `cpblk`przyjęto założenie, że zarówno adres źródłowy, jak i docelowy są wyrównane do naturalnego rozmiaru maszyny. Instrukcja może być bezpośrednio poprzedzona `unaligned.<prefix>` instrukcją, aby wskazać, że źródło lub miejsce docelowe nie są wyrównane. `cpblk`  
  
 Operację `cpblk` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.  
  
 <xref:System.NullReferenceException>mogą być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `cpblk` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiuje typ <see langword="&amp;" />wartości znajdujący się w adresie obiektu (typu <see langword="*" /> lub <see langword="native int" />) do <see langword="*" /> adresu obiektu docelowego (typu <see langword="&amp;" />lub <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|Kopiuje typ wartości z obiektu źródłowego do obiektu docelowego.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu docelowego jest wypychane na stosie.  
  
2.  Odwołanie do obiektu źródłowego jest wypychane na stosie.  
  
3.  Te dwa odwołania do obiektów są zdjęte ze stosu; Typ wartości pod adresem obiektu źródłowego jest kopiowany na adres obiektu docelowego.  
  
 Zachowanie `cpobj` nie jest określone, jeśli odwołania do obiektów źródłowych i docelowych nie są wskaźnikami do wystąpień klasy reprezentowanej przez token `classTok` klasy (a `typeref` lub `typedef`) lub jeśli `classTok` nie reprezentują Typ wartości.  
  
 <xref:System.NullReferenceException>mogą być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `cpobj` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dzieli dwie wartości i wypycha wynik jako zmiennoprzecinkowe (Type <see langword="F" />) lub iloraz (Type <see langword="int32" />) na stosie oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5B|div|Dzieli dwie wartości w celu zwrócenia wyniku ilorazu lub zmiennoprzecinkowego.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; jest podzielona `value2`przez. `value1`  
  
4.  Wynik jest wypychany na stosie.  
  
 `result` = `value1`blok DIV wartość2 spełnia następujące warunki:  
  
 &#124;`result` &#124; = &#124; / &#124;, i: &#124; &#124; `value1` `value2`  
  
 Sign (`result`) = +, If SIGN (`value1`) = Sign (`value2`), or-, If SIGN (`value1`) ~ = Sign (`value2`)  
  
 `div` Instrukcja oblicza wynik i wypchnięcie go na stosie.  
  
 Dzielenie liczb całkowitych jest obcinane do zera.  
  
 Dzielenie liczby skończonej przez zero powoduje prawidłowe podpisaną wartość nieskończoną.  
  
 Dzielenie zera przez zero lub nieskończoność przez nieskończoność powoduje utworzenie wartości NaN (nie-Number). Każda liczba podzielona przez nieskończoność spowoduje wygenerowanie wartości zerowej.  
  
 Operacje całek generują <xref:System.ArithmeticException> , jeśli wynik nie może być reprezentowany w typie wyniku. Może się tak zdarzyć `value1` , jeśli jest to maksymalna wartość ujemna `value2` i wynosi-1.  
  
 <xref:System.DivideByZeroException> Jeśli`value2` wartość jest równa zero, operacje całkowite generują.  
  
 Należy pamiętać, że na platformach <xref:System.OverflowException> opartych na procesorze Intel jest zgłaszany podczas obliczania (Minint DIV-1). Operacje zmiennoprzecinkowe nigdy nie zgłaszają wyjątku (zamiast tego generują NaNs lub nieskończoności).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `div` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dzieli dwie wartości bez znaku i wypchnij wynik (<see langword="int32" />) na stos oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5C|div.un|Dzieli dwie wartości, bez znaku, zwracając iloraz.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; jest podzielona `value2`przez. `value1`  
  
4.  Wynik jest wypychany na stosie.  
  
 Instrukcja oblicza podzieloną przez `value2`, zarówno jako liczby całkowite `result` bez znaku, i wypchnięcia na stosie. `value1` `div.un`  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `div.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiuje bieżącą wartość na stosie ewaluacyjnym, a następnie wypchnij kopię na stos oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|25|DUP|Duplikuje wartość w górnej części stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`jest zdjęte na stosie dla duplikacji.  
  
3.  `value`jest wypychany na stosie.  
  
4.  Zduplikowana wartość jest wypychana do stosu.  
  
 `dup` Instrukcja duplikuje górny element stosu i pozostawia dwie identyczne wartości korzystającego.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `dup` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi kontrolę z <see langword="filter" /> klauzuli wyjątku z powrotem do procedury obsługi wyjątków Common Language Infrastructure (CLI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 11|Element Endfilter|Klauzula End Filter dla obsługi wyjątków SEH.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`zdjęte ze stosu; `endfilter` jest wykonywany i kontrola jest przenoszona do programu obsługi wyjątków.  
  
 `Value`(który musi być typu `int32` i jest jednym z określonych wartości) jest zwracana z klauzuli Filter. Powinien być jednym z:  
  
-   `exception_continue_search`(`value` = 0) aby kontynuować wyszukiwanie programu obsługi wyjątków  
  
-   `exception_execute_handler`(`value` = 1) w celu rozpoczęcia drugiej fazy obsługi wyjątków, w której bloki finally są uruchamiane do momentu, w którym znajduje się procedura obsługi skojarzona z tą klauzulą filtru. Po odnajdywaniu program obsługi jest wykonywany.  
  
 Inne wartości całkowite spowodują wygenerowanie nieokreślonych wyników.  
  
 Punkt wejścia filtru, jak pokazano w tabeli wyjątków metody, musi być pierwszą instrukcją w bloku kodu filtru. Instrukcja `endfilter` musi być ostatnią instrukcją w bloku kodu filtru (w związku z tym może być tylko jeden `endfilter` dla każdego pojedynczego bloku filtru). Po wykonaniu `endfilter` instrukcji kontrola logicznie przepływa z powrotem do mechanizmu obsługi wyjątków interfejsu wiersza polecenia.  
  
 Kontrolka nie może zostać przesłana do bloku filtru, z wyjątkiem mechanizmu wyjątku. Nie można przenieść formantu z bloku filtru, z wyjątkiem użycia `throw` instrukcji lub przez wykonanie ostatniej `endfilter` instrukcji. Nie można osadzić `try` bloku `filter` w bloku. Jeśli wyjątek jest zgłaszany wewnątrz `filter` bloku, jest przechwytywany i zwracana jest wartość 0 (`exception_continue_search`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `endfilter` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi formant z <see langword="fault" /> klauzuli or <see langword="finally" /> bloku wyjątków z powrotem do procedury obsługi wyjątków Common Language Infrastructure (CLI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DC|element Endfinally<br /><br /> endfault|Zamyka klauzulę `fault`orblokuwyjątków `finally` .|  
  
 Dla tej instrukcji nie ma zachowań przejścia stosu.  
  
 `Endfinally`i `endfault` sygnalizować koniec `finally` klauzuli or `fault` , aby można było kontynuować rozwinięcia stosu do momentu wywołania programu obsługi wyjątków. Instrukcja `endfinally` lub`endfault` przeniesie kontrolę z powrotem do mechanizmu wyjątków interfejsu wiersza polecenia. Mechanizm następnie wyszukuje następną `finally` klauzulę w łańcuchu, Jeśli chroniony blok został zakończony przy użyciu instrukcji opuszczania. Jeśli chroniony blok został zakończony przy użyciu wyjątku, interfejs wiersza polecenia wyszukuje następny `finally` lub `fault`lub wprowadza procedurę obsługi wyjątków wybraną podczas pierwszego przebiegu obsługi wyjątków.  
  
 Instrukcja może wystąpić tylko `finally` w obrębie bloku. `endfinally` W przeciwieństwie `endfilter` do instrukcji nie istnieje wymóg, że blok kończy `endfinally` się instrukcją i może zawierać `endfinally` tyle instrukcji w bloku, ile jest to wymagane. Te same ograniczenia dotyczą `endfault` instrukcji `fault` i bloku.  
  
 Kontrolka nie może zostać przeniesiona `finally` do `fault`bloku (lub) z wyjątkiem mechanizmu wyjątku. Kontrolka nie może być transferowana `finally` z bloku `fault`(lub), z wyjątkiem użycia `throw` instrukcji lub wykonywania `endfinally` instrukcji (lub `endfault`). W szczególności nie można "wyprowadzić" `finally` <xref:System.Reflection.Emit.OpCodes.Ret> bloku (lub `fault`) albo wykonać instrukcji lub <xref:System.Reflection.Emit.OpCodes.Leave> w `finally` bloku (lub `fault`).  
  
 Zwróć uwagę, `endfault` że `endfinally` instrukcje i są aliasami — odpowiadają temu kodowi kodu.  
  
 Poniższe <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `endfinally` użyć kodu operacji (`endfault`), a także `ILGenerator` metody <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inicjuje określony blok pamięci pod określonym adresem i początkową wartością.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 18|initblk|Ustaw każdą lokalizację w bloku pamięci na daną wartość.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres początkowy jest wypychany do stosu.  
  
2.  Wartość inicjalizacji jest wypychana do stosu.  
  
3.  Liczba bajtów do zainicjowania jest wypychana do stosu.  
  
4.  Liczba bajtów, wartość inicjalizacji i adres początkowy są zdjęte ze stosu, a Inicjalizacja jest wykonywana zgodnie z ich wartościami.  
  
 `&` `native int` `*` `unsigned int8`Instrukcja ustawia liczbę (`unsigned int32`) bajtów rozpoczynającą się od określonego adresu (typu, lub) do wartości inicjującej (typu). `initblk` `initblk`przyjęto, że adres początkowy jest wyrównany do naturalnego rozmiaru maszyny.  
  
 Działanie `initblk` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.  
  
 <xref:System.NullReferenceException>mogą być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `initblk` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inicjuje każde pole typu wartości o określonym adresie do odwołania o wartości null lub 0 z odpowiedniego typu pierwotnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 15 < `T` >|`initobj``typeTok`|Inicjuje typ wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres typu wartości do zainicjowania jest wypychany na stosie.  
  
2.  Adres jest zdjęte ze stosu; Typ wartości pod określonym adresem jest inicjowany jako typ `typeTok`.  
  
 Instrukcja inicjuje każde pole o typie wartości określonym przez wypychany adres (typu `native int`, `&`lub `*`) do odwołania o wartości null lub 0 z odpowiedniego typu pierwotnego. `initobj` Po wywołaniu tej metody wystąpienie jest gotowe do wywołania metody konstruktora. Jeśli `typeTok` jest typem referencyjnym, ta instrukcja ma ten sam `ldnull` skutek, po którym `stind.ref`następuje.  
  
 W <xref:System.Reflection.Emit.OpCodes.Newobj>przeciwieństwie `initobj` do, nie wywołuje metody konstruktora. `Initobj`jest przeznaczony do inicjowania typów wartości, podczas `newobj` gdy jest używany do przydzielania i inicjowania obiektów.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `initobj` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Testuje, czy odwołanie do obiektu <see langword="O" />(typ) jest wystąpieniem konkretnej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|75 < `T` >|Isinst`class`|Testuje `class`, czy odwołanie do obiektu jest wystąpieniem, zwracając odwołanie o wartości null lub wystąpienie tej klasy lub interfejsu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu jest wypychane na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte ze stosu i przetestowane, aby sprawdzić, czy jest to wystąpienie klasy, która została `class`przeniesiona.  
  
3.  Wynik (odwołanie do obiektu lub odwołanie o wartości null) jest wypychany na stosie.  
  
 `Class`jest tokenem metadanych wskazującym żądaną klasę. Jeśli klasa obiektu `class` na górze stosu implementuje (Jeśli `class` jest interfejsem) lub `class` jest klasą pochodną (Jeśli `class` jest klasą regularną), jest rzutowana na typ `class` , a wynik jest wypychany na stosie. dokładnie tak, <xref:System.Reflection.Emit.OpCodes.Castclass> jakby został wywołany. W przeciwnym razie odwołanie o wartości null jest wypychane na stosie. Jeśli odwołanie do obiektu jest odwołaniem null, `isinst` podobnie zwraca odwołanie o wartości null.  
  
 <xref:System.TypeLoadException>jest zgłaszany, jeśli nie można znaleźć klasy. Jest to zwykle wykrywane, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `isinst` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opuszcza bieżącą metodę i przechodzi do określonej metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|27 < `T` >|element JMP`method`|Wyjdź z bieżącej metody i Przeskocz do określonej metody.|  
  
 Dla tej instrukcji nie ma zachowań przejścia stosu.  
  
 Instrukcja (skoku) przenosi formant do metody określonej przez `method`, która jest tokenem metadanych dla odwołania do metody. `jmp` Bieżące argumenty są przekazywane do metody docelowej.  
  
 Stos oceny musi być pusty, gdy ta instrukcja zostanie wykonana. Konwencja wywoływania, liczba i typ argumentów w adresie docelowym muszą być zgodne z bieżącą metodą.  
  
 `filter` `try` `finally` `catch`Instrukcji nie można użyć do przetransferowania kontrolki z elementu,,, lub. `jmp`  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `jmp` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument (do którego odwołuje się określona wartość indeksu) na stosie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg `index`|Załaduj argument `index` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość `index` argumentu jest wypychana na stosie.  
  
 Instrukcja wypchnięcie argumentu indeksowanego w `index`, gdzie argumenty są indeksowane od 0 do wewnątrz na stosie szacowania. `ldarg` `ldarg` Instrukcja może służyć do załadowania typu wartości lub wartości pierwotnej na stos przez skopiowanie jej z argumentu przychodzącego. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez podpis bieżącej metody.  
  
 W przypadku procedur, które pobierają listę argumentów o zmiennej długości `ldarg` , instrukcja może być używana tylko dla początkowych argumentów stałych, a nie dla zmiennych części sygnatury (zobacz instrukcje, <xref:System.Reflection.Emit.OpCodes.Arglist> Aby uzyskać więcej informacji).  
  
 Argumenty, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty `int32` , są rozszerzane do typu podczas ładowania na stos. Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarg` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, krótkie)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument pod indeksem 0 na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|02|ldarg. 0|Załaduj argument 0 na stos|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość argumentu w indeksie 0 jest wypychana do stosu.  
  
 `ldarg.0` Instrukcja jest wydajnym kodowaniem do ładowania wartości argumentu przy indeksie 0.  
  
 `ldarg.0` Instrukcja wypchnięcie argumentu indeksowanego o 0 na stos oceny. `ldarg.0` Instrukcja może służyć do załadowania typu wartości lub wartości pierwotnej na stos przez skopiowanie jej z argumentu przychodzącego. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez podpis bieżącej metody.  
  
 Argumenty, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty `int32` , są rozszerzane do typu podczas ładowania na stos. Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarg.0` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument w indeksie 1 na stos szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|03|ldarg. 1|Załaduj argument 1 na stos.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość argumentu w indeksie 1 jest wypychana do stosu.  
  
 `ldarg.1` Instrukcja jest wydajnym kodowaniem do ładowania wartości argumentu przy indeksie 1.  
  
 `ldarg.1` Instrukcja wypchnięcie argumentu indeksowanego o 1 na stos oceny. `ldarg.1` Instrukcja może służyć do załadowania typu wartości lub wartości pierwotnej na stos przez skopiowanie jej z argumentu przychodzącego. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez podpis bieżącej metody.  
  
 Argumenty, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty `int32` , są rozszerzane do typu podczas ładowania na stos. Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarg.1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument w indeksie 2 na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|04|ldarg. 2|Załaduj argument 2 na stos.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość argumentu w indeksie 2 jest wypychana do stosu.  
  
 `ldarg.2` Instrukcja jest wydajnym kodowaniem do ładowania wartości argumentu przy indeksie 2.  
  
 `ldarg.2` Instrukcja wypchnięcie argumentu indeksowanego o 2 na stos oceny. `ldarg.2` Instrukcja może służyć do załadowania typu wartości lub wartości pierwotnej na stos przez skopiowanie jej z argumentu przychodzącego. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez podpis bieżącej metody.  
  
 Argumenty, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty `int32` , są rozszerzane do typu podczas ładowania na stos. Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarg.2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument w indeksie 3 na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|05|ldarg. 3|Załaduj argument 3 na stos.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość argumentu w indeksie 3 jest wypychana do stosu.  
  
 `ldarg.3` Instrukcja jest wydajnym kodowaniem do ładowania wartości argumentu przy indeksie 3.  
  
 `ldarg.3` Instrukcja wypchnięcie argumentu indeksowanego w 3 na stos szacowania. `ldarg.3` Instrukcja może służyć do załadowania typu wartości lub wartości pierwotnej na stos przez skopiowanie jej z argumentu przychodzącego. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez podpis bieżącej metody.  
  
 Argumenty, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty `int32` , są rozszerzane do typu podczas ładowania na stos. Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarg.3` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje argument (do którego odwołuje się określony indeks formularza skróconego) na stos oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg. s`index`|Załaduj argument `index` w na stosie, skróconej postaci.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość `index` argumentu jest wypychana na stosie.  
  
 `ldarg.s` Instrukcja to wydajne kodowanie dla załadowania argumentów indeksowanych z 4 do 255.  
  
 Instrukcja wypchnięcie argumentu indeksowanego w `index`, gdzie argumenty są indeksowane od 0 do wewnątrz na stosie szacowania. `ldarg.s` `ldarg.s` Instrukcja może służyć do załadowania typu wartości lub wartości pierwotnej na stos przez skopiowanie jej z argumentu przychodzącego. Typ wartości argumentu jest taki sam jak typ argumentu, określony przez podpis bieżącej metody.  
  
 W przypadku procedur, które pobierają listę argumentów o zmiennej długości `ldarg.s` , instrukcja może być używana tylko dla początkowych argumentów stałych, a nie dla zmiennych części sygnatury (zobacz instrukcje, <xref:System.Reflection.Emit.OpCodes.Arglist> Aby uzyskać więcej informacji).  
  
 Argumenty, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty `int32` , są rozszerzane do typu podczas ładowania na stos. Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarg.s` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Załaduj adres argumentu na stos szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0A <`unsigned int16` >|ldarga `index`|Pobierz adres argumentu indeksowanego przez `index`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres `addr` argumentu indeksowanego przez `index` jest wypychany na stosie.  
  
 Instrukcja Pobiera adres (typ `*`) argumentu indeksowanego przez `index`, gdzie argumenty są indeksowane od 0 lub do wewnątrz. `ldarga` Adres `addr` jest zawsze wyrównany do naturalnej granicy na komputerze docelowym.  
  
 W przypadku procedur, które pobierają listę argumentów o zmiennej długości `ldarga` , instrukcja może być używana tylko dla początkowych argumentów stałych, a nie dla zmiennych części sygnatury.  
  
 `ldarga`jest używany przez przekazywanie parametrów przez odwołanie. W innych przypadkach <xref:System.Reflection.Emit.OpCodes.Ldarg> i <xref:System.Reflection.Emit.OpCodes.Starg> powinny być używane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarga` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, krótkie)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Załaduj adres argumentu w postaci skróconej na stos oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga.s `index`|Pobierz adres argumentu, który jest indeksowany `index`przez, Short Form.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres `addr` argumentu indeksowanego przez `index` jest wypychany na stosie.  
  
 `ldarga.s`(krótka forma `ldarga`) powinna być używana dla numerów argumentów od 0 do 255 i jest bardziej wydajnym kodowaniem.  
  
 Instrukcja Pobiera adres (typ`*`) argumentu indeksowanego przez `index`, gdzie argumenty są indeksowane od 0 lub do wewnątrz. `ldarga.s` Adres `addr` jest zawsze wyrównany do naturalnej granicy na komputerze docelowym.  
  
 W przypadku procedur, które pobierają listę argumentów o zmiennej długości `ldarga.s` , instrukcja może być używana tylko dla początkowych argumentów stałych, a nie dla zmiennych części sygnatury.  
  
 `ldarga.s`jest używany przez przekazywanie parametrów przez odwołanie. W innych przypadkach <xref:System.Reflection.Emit.OpCodes.Ldarg_S> i <xref:System.Reflection.Emit.OpCodes.Starg_S> powinny być używane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarga.s` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcie dostarczonej wartości typu <see langword="int32" /> na stos oceny <see langword="int32" />jako.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|20 < `int32` >|LDC. i4`num`|Wypchnij wartość `num` na stos.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość `num` jest wypychana do stosu.  
  
 Należy zauważyć, że istnieją specjalne krótkie (i bardziej wydajne) kodowania dla liczb całkowitych — od 128 do 127, a szczególnie krótkie kodowania dla-1 do 8. Wszystkie krótkie kodowania wypychają 4 bajty całkowite na stosie. Dłuższe kodowania są używane w przypadku 8-bajtowych liczb całkowitych i 4 i 8-bajtowych liczb zmiennoprzecinkowych, a także wartości 4-bajtowych, które nie mieszczą się w krótkich formularzach. Istnieją trzy sposoby wypychania 8-bajtowej stałej całkowitej na stos  
  
 1. <xref:System.Reflection.Emit.OpCodes.Ldc_I8> Użyj instrukcji dla stałych, które muszą być wyrażone w więcej niż 32 bitów.  
  
 2. Użyj instrukcji i <xref:System.Reflection.Emit.OpCodes.Conv_I8> dla stałych, które wymagają od 9 do 32 bitów. <xref:System.Reflection.Emit.OpCodes.Ldc_I4>  
  
 3. Użyj krótkiej instrukcji formularza, a następnie <xref:System.Reflection.Emit.OpCodes.Conv_I8> dla stałych, które mogą być wyrażone w 8 lub mniejszej liczbie bitów.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnij wartość całkowitą 0 na stos oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|Wypchnij 0 na stos.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość 0 jest wypychana do stosu.  
  
 Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 0. Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.0` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnij wartość całkowitą z 1 na stos oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|Wypchnij 1 na stos.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość 1 jest wypychana do stosu.  
  
 Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 1. Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypychanie wartości całkowitej 2 na stos oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|Wypchnięcie 2 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość 2 jest wypychana do stosu.  
  
 Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 2. Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnij wartość całkowitą z 3 na stos oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|Wypychanie 3 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość 3 jest wypychana do stosu.  
  
 Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 3. Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.3` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypychanie wartości całkowitej 4 na stos oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|Wypchnięcie 4 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość 4 jest wypychana do stosu.  
  
 Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 4. Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcie wartości całkowitej 5 na stos oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|Wypchnij 5 na stos.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość 5 jest wypychana do stosu.  
  
 Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 5. Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.5` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypychanie wartości całkowitej 6 na stos oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|Wypchnięcie 6 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość 6 jest wypychana do stosu.  
  
 Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 6. Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.6` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnij liczbę całkowitą z 7 na stos oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|Wypchnięcie 7 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość 7 jest wypychana do stosu.  
  
 Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 7. Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.7` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypychanie wartości całkowitej 8 na stos oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|Wypchnięcie 8 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość 8 jest wypychana do stosu.  
  
 Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 8. Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcie wartości całkowitej-1 na stosie oceny jako <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|Wypchnięcia-1 na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość-1 jest wypychana do stosu.  
  
 Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej-1. Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.m1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnij podaną <see langword="int8" /> wartość na stos oceny <see langword="int32" />jako krótką formę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|1F < `int8` >|ldc.i4.s `num`|Wypchnij do stosu jako `int32`krótka forma. `num`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość `num` jest wypychana do stosu.  
  
 `ldc.i4.s`jest bardziej wydajnym kodowaniem do wypychania liczb całkowitych od-128 do 127 na stosie ewaluacyjnym.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.s` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcie dostarczonej wartości typu <see langword="int64" /> na stos oceny <see langword="int64" />jako.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|21 < `int64` >|LDC. i8`num`|`int64`Wypchnij `num` na stos jako.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość `num` jest wypychana do stosu.  
  
 To kodowanie wypychanie `int64` wartości na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i8` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, Long)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcie dostarczonej wartości typu <see langword="float32" /> na stos oceny jako typ <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|22 < `float32` >|LDC. R4`num`|`F`Wypchnij `num` na stos jako.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość `num` jest wypychana do stosu.  
  
 To kodowanie wypychanie `float32` wartości na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.r4` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, Single)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcie dostarczonej wartości typu <see langword="float64" /> na stos oceny jako typ <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.r8 `num`|`F`Wypchnij `num` na stos jako.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość `num` jest wypychana do stosu.  
  
 To kodowanie wypychanie `float64` wartości na stosie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.r8` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, Double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element w określonym indeksie tablicy na początku stosu oceny jako typ określony w instrukcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem`typeTok`|Ładuje element w `index` górnej części stosu jako typ `typeTok`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `array` do obiektu jest wypychane na stosie.  
  
2.  Wartość `index` indeksu jest wypychana do stosu.  
  
3.  `index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.  
  
4.  Wartość jest wypychana do stosu.  
  
 Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem` Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.  
  
 Typ wartości zwracanej jest określany przez token `typeTok` w instrukcji.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż górna `array`granica.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element z typem <see langword="native int" /> w określonym indeksie tablicy na początku stosu oceny <see langword="native int" />jako.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|97|ldelem.i|Ładuje element z typem `native int` w `index` górnej `native int`części stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `array` do obiektu jest wypychane na stosie.  
  
2.  Wartość `index` indeksu jest wypychana do stosu.  
  
3.  `index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.  
  
4.  Wartość jest wypychana do stosu.  
  
 Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.i` Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.  
  
 Wartość zwracana dla elementu `ldelem.i` is `native int`równa się.  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.i` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element z typem <see langword="int8" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int32" />jako.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|Ładuje element z typem `int8` w `index` górnej `int32`części stosu jako element.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `array` do obiektu jest wypychane na stosie.  
  
2.  Wartość `index` indeksu jest wypychana do stosu.  
  
3.  `index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.  
  
4.  Wartość jest wypychana do stosu.  
  
 Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.i1` Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.  
  
 Wartość zwracana dla elementu `ldelem.i1` is `int8`równa się.  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.i1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element z typem <see langword="int16" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int32" />jako.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|Ładuje element z typem `int16` w `index` górnej `int32`części stosu jako element.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `array` do obiektu jest wypychane na stosie.  
  
2.  Wartość `index` indeksu jest wypychana do stosu.  
  
3.  `index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.  
  
4.  Wartość jest wypychana do stosu.  
  
 Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.i2` Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.  
  
 Wartość zwracana dla elementu `ldelem.i2` is `int16`równa się.  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.i2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element z typem <see langword="int32" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int32" />jako.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|Ładuje element z typem `int32` w `index` górnej `int32`części stosu jako element.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `array` do obiektu jest wypychane na stosie.  
  
2.  Wartość `index` indeksu jest wypychana do stosu.  
  
3.  `index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.  
  
4.  Wartość jest wypychana do stosu.  
  
 Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.i4` Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.  
  
 Wartość zwracana dla elementu `ldelem.i4` is `int32`równa się.  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.i4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element z typem <see langword="int64" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int64" />jako.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|Ładuje element z typem `int64` w `index` górnej `int64`części stosu jako element.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `array` do obiektu jest wypychane na stosie.  
  
2.  Wartość `index` indeksu jest wypychana do stosu.  
  
3.  `index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.  
  
4.  Wartość jest wypychana do stosu.  
  
 Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.i8` Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.  
  
 Wartość zwracana dla elementu `ldelem.i8` is `int64`równa się.  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.i8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element z typem <see langword="float32" /> w określonym indeksie tablicy na początku stosu oceny jako typ <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|Ładuje element z typem `float32` na `index` górze stosu jako typ `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `array` do obiektu jest wypychane na stosie.  
  
2.  Wartość `index` indeksu jest wypychana do stosu.  
  
3.  `index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.  
  
4.  Wartość jest wypychana do stosu.  
  
 Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.r4` Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.  
  
 Wartość zwracana dla elementu `ldelem.r4` is `float32`równa się.  
  
 Wartości zmiennoprzecinkowe są konwertowane na typ `F` podczas ładowania na stos szacowania.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.r4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element z typem <see langword="float64" /> w określonym indeksie tablicy na początku stosu oceny jako typ <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|Ładuje element z typem `float64` na `index` górze stosu jako typ `F`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `array` do obiektu jest wypychane na stosie.  
  
2.  Wartość `index` indeksu jest wypychana do stosu.  
  
3.  `index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.  
  
4.  Wartość jest wypychana do stosu.  
  
 Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.r8` Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.  
  
 Wartość zwracana dla elementu `ldelem.r8` is `float64`równa się.  
  
 Wartości zmiennoprzecinkowe są konwertowane na typ `F` podczas ładowania na stos szacowania.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.r8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element zawierający odwołanie do obiektu w określonym indeksie tablicy na początku stosu oceny jako typ <see langword="O" /> (odwołanie do obiektu).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|Ładuje element z odwołaniem do obiektu w `index` górnej części stosu jako typ. `O`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `array` do obiektu jest wypychane na stosie.  
  
2.  Wartość `index` indeksu jest wypychana do stosu.  
  
3.  `index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.  
  
4.  Wartość jest wypychana do stosu.  
  
 Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.ref` Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.  
  
 Wartość zwracana dla elementu `ldelem.ref` is Type `O` (odwołanie do obiektu).  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.ref` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element z typem <see langword="unsigned int8" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int32" />jako.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|Ładuje element z typem `unsigned int8` w `index` górnej `int32`części stosu jako element.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `array` do obiektu jest wypychane na stosie.  
  
2.  Wartość `index` indeksu jest wypychana do stosu.  
  
3.  `index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.  
  
4.  Wartość jest wypychana do stosu.  
  
 Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.u1` Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.  
  
 Wartość zwracana dla elementu `ldelem.u1` is `int8`równa się.  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.u1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element z typem <see langword="unsigned int16" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int32" />jako.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|Ładuje element z typem `unsigned int16` przy indeksie na górze stosu `int32`jako.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `array` do obiektu jest wypychane na stosie.  
  
2.  Wartość `index` indeksu jest wypychana do stosu.  
  
3.  `index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.  
  
4.  Wartość jest wypychana do stosu.  
  
 Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.u2` Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.  
  
 Wartość zwracana dla elementu `ldelem.u2` is `int16`równa się.  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.u2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje element z typem <see langword="unsigned int32" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int32" />jako.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|Ładuje element z typem `unsigned int32` przy indeksie na górze stosu `int32`jako.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `array` do obiektu jest wypychane na stosie.  
  
2.  Wartość `index` indeksu jest wypychana do stosu.  
  
3.  `index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.  
  
4.  Wartość jest wypychana do stosu.  
  
 Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.u4` Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.  
  
 Wartość zwracana dla elementu `ldelem.u4` is `int32`równa się.  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany, jeśli tablica nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.u4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje adres elementu tablicy w określonym indeksie tablicy na początku stosu oceny jako typ <see langword="&amp;" /> (zarządzany wskaźnik).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema`class`|Ładuje adres elementu tablicy w `index` górnej części stosu oceny jako typ `&` (wskaźnik zarządzany).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `array` do obiektu jest wypychane na stosie.  
  
2.  Wartość `index` indeksu jest wypychana do stosu.  
  
3.  `index`i `array` są zdjęte ze stosu; adres zapisany na pozycji `index` w `array` jest wyszukiwany.  
  
4.  Adres jest wypychany na stosie.  
  
 Służy do pobierania adresu obiektu w określonym indeksie w tablicy obiektów (typu `class`). `ldelema` Instrukcja ładuje adres wartości w indeksie `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelema` Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`. Wartość musi być typu `class` przeniesiona z instrukcją.  
  
 Zwracana wartość dla `ldelema` jest wskaźnikiem zarządzanym (Type `&`).  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelema` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Znajduje wartość pola w obiekcie, którego odwołanie znajduje się obecnie na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld`field`|Wypchnij wartość pola w określonym obiekcie na stos.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu (lub wskaźnik) jest wypychane na stosie.  
  
2.  Odwołanie do obiektu (lub wskaźnik) jest zdjęte ze stosu; znaleziono wartość określonego pola w obiekcie.  
  
3.  Wartość przechowywana w polu jest wypychana do stosu.  
  
 `ldfld` Instrukcja wypycha wartość pola znajdującego się w obiekcie na stosie. Obiekt musi znajdować się na stosie jako odwołanie do obiektu ( `O`typ), zarządzany wskaźnik (typ `&`), niezarządzany wskaźnik ( `native int`typ), wskaźnik przejściowy ( `*`typ) lub wystąpienie typu wartości. Użycie niezarządzanego wskaźnika jest niedozwolone w kodzie możliwym do zweryfikowania. Pole obiektu jest określone przez token metadanych, który musi odwoływać się do elementu członkowskiego pola. Zwracany typ jest taki sam jak skojarzony z polem. Pole może być polem wystąpienia (w którym przypadku obiekt nie może być odwołaniem o wartości null) ani polem statycznym.  
  
 Instrukcja może być poprzedzona przez jedną lub obie <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksy i <xref:System.Reflection.Emit.OpCodes.Volatile>. `ldfld`  
  
 <xref:System.NullReferenceException>jest zgłaszany, jeśli obiekt ma wartość null, a pole nie jest statyczne.  
  
 <xref:System.MissingFieldException>jest zgłaszany, jeśli nie odnaleziono określonego pola w metadanych. Jest to zazwyczaj zaznaczone, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldfld` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Znajduje adres pola w obiekcie, którego odwołanie znajduje się obecnie na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|Wypchnięcie adresu `field` do określonego obiektu na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu (lub wskaźnik) jest wypychane na stosie.  
  
2.  Odwołanie do obiektu (lub wskaźnik) jest zdjęte ze stosu; znaleziono adres określonego pola w obiekcie.  
  
3.  Adres określonego pola jest wypychany na stosie.  
  
 `ldflda` Instrukcja wypycha adres pola znajdującego się w obiekcie na stosie. Obiekt musi znajdować się na stosie jako odwołanie do obiektu ( `O`typ), zarządzany wskaźnik (typ `&`), niezarządzany wskaźnik ( `native int`typ), wskaźnik przejściowy ( `*`typ) lub wystąpienie typu wartości. Użycie niezarządzanego wskaźnika jest niedozwolone w kodzie możliwym do zweryfikowania. Pole obiektu jest określone przez token metadanych, który musi odwoływać się do elementu członkowskiego pola.  
  
 Wartość zwracana przez `ldflda` jest wskaźnikiem zarządzanym (Type `&`), chyba że obiekt jest wypychany do stosu jako niezarządzany wskaźnik, w tym przypadku adres zwrotny jest również wskaźnikiem niezarządzanym (typ `native int`).  
  
 Instrukcja może być poprzedzona przez jedną lub obie <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksy i <xref:System.Reflection.Emit.OpCodes.Volatile>. `ldflda`  
  
 <xref:System.InvalidOperationException>jest zgłaszany, jeśli obiekt nie znajduje się w domenie aplikacji, z której jest uzyskiwany dostęp. Nie można załadować adresu pola, które nie znajduje się w domenie aplikacji do uzyskiwania dostępu.  
  
 <xref:System.NullReferenceException>jest zgłaszany, jeśli obiekt ma wartość null, a pole nie jest statyczne.  
  
 <xref:System.MissingFieldException>jest zgłaszany, jeśli nie odnaleziono określonego pola w metadanych. Jest to zazwyczaj zaznaczone, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldflda` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnij niezarządzany wskaźnik ( <see langword="native int" />typ) do kodu natywnego implementującego określoną metodę na stosie ewaluacyjnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|Ldftn`method`|Wypchnięcie wskaźnika do metody, `method` do której odwołuje się stos.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Niezarządzany wskaźnik do określonej metody jest wypychany do stosu.  
  
 Konkretna metoda (`method`) może być wywoływana przy użyciu <xref:System.Reflection.Emit.OpCodes.Calli> instrukcji, jeśli odwołuje się do metody zarządzanej (lub zastępczej, która przechodzi z kodu zarządzanego do niezarządzanego).  
  
 Wartość zwrócona wskazuje na kod natywny przy użyciu konwencji wywoływania CLR. Tego wskaźnika metody nie należy przekazywać do niezarządzanego kodu natywnego jako procedury wywołania zwrotnego.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldftn` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartość typu <see langword="native int" /> <see langword="native int" /> na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4D|ldind.i|Ładuje wartość na adres `addr` na stos jako `native int`. `native int`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.  
  
3.  Pobrana wartość jest wypychana do stosu.  
  
 `native int` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub *) na stosie jako. `native int` `ldind.i`  
  
 Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.  
  
 Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.  
  
 Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU. Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.i` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartość typu <see langword="int8" /> <see langword="int32" /> na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|46|ldind.i1|Ładuje wartość pod `addr` adresem`int32`nastosjako. `int8`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.  
  
3.  Pobrana wartość jest wypychana do stosu. 
  
 `int32` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub *) na stosie jako. `int8` `ldind.i1`  
  
 Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.  
  
 Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.  
  
 Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU. Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.i1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartość typu <see langword="int16" /> <see langword="int32" /> na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|48|ldind. I2|Ładuje wartość pod `addr` adresem`int32`nastosjako. `int16`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.  
  
3.  Pobrana wartość jest wypychana do stosu.  
  
 `int32` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub *) na stosie jako. `int16` `ldind.i2`  
  
 Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.  
  
 Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.  
  
 Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU. Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.i2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartość typu <see langword="int32" /> <see langword="int32" /> na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4A|ldind. i4|Ładuje wartość pod `addr` adresem`int32`nastosjako. `int32`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.  
  
3.  Pobrana wartość jest wypychana do stosu.  
  
 `int32` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub *) na stosie jako. `int32` `ldind.i4`  
  
 Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.  
  
 Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.  
  
 Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU. Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.i4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartość typu <see langword="int64" /> <see langword="int64" /> na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4C|ldind.i8|Ładuje wartość pod `addr` adresem`int64`nastosjako. `int64`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.  
  
3.  Pobrana wartość jest wypychana do stosu.  
  
 `int64` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub *) na stosie jako. `int64` `ldind.i8`  
  
 Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.  
  
 Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.  
  
 Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU. Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.i8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartość typu <see langword="float32" /> jako typ <see langword="F" /> (float) na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4E|ldind. R4|Ładuje wartość pod adresem `addr` na stos jako typ `F`. `float32`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.  
  
3.  Pobrana wartość jest wypychana do stosu.  
  
 `F` `&` `native int`Instrukcja pośrednio `float32` ładuje wartość z podanego adresu (typu, lub *) na stos jako typ. `ldind.r4`  
  
 Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.  
  
 Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.  
  
 Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU. Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.r4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartość typu <see langword="float64" /> jako typ <see langword="F" /> (float) na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4F|ldind. R8|Ładuje wartość pod adresem `addr` na stos jako typ `F`. `float64`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.  
  
3.  Pobrana wartość jest wypychana do stosu.  
  
 `float64` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub *) na stosie jako. `float64` `ldind.r8`  
  
 Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.  
  
 Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.  
  
 Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU. Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.r8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wczytuje odwołanie do obiektu jako typ <see langword="O" /> (odwołanie do obiektu) na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|50|ldind.ref|Ładuje odwołanie do obiektu na `addr` stosie jako typ`O`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Adres jest zdjęte ze stosu; pobrano odwołanie do obiektu znajdującego się pod adresem.  
  
3.  Pobrane odwołanie jest wypychane do stosu.  
  
 Instrukcja pośrednio wczytuje obiekt odwołuje się do określonego adresu (typu `native int`, `&`lub *) na stos jako typ `O`. `ldind.ref`  
  
 Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.  
  
 Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.  
  
 Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU. Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.ref` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartość typu <see langword="unsigned int8" /> <see langword="int32" /> na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|47|ldind. U1|Ładuje wartość pod `addr` adresem`int32`nastosjako. `unsigned int8`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.  
  
3.  Pobrana wartość jest wypychana do stosu.  
  
 `int32``native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub *) na stosie jako. `unsigned int8` `ldind.u1`  
  
 Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.  
  
 Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.  
  
 Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU. Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.u1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartość typu <see langword="unsigned int16" /> <see langword="int32" /> na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|49|ldind.u2|Ładuje wartość pod `addr` adresem`int32`nastosjako. `unsigned int16`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.  
  
3.  Pobrana wartość jest wypychana do stosu.  
  
 `int32` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub *) na stosie jako. `unsigned int16` `ldind.u2`  
  
 Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.  
  
 Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.  
  
 Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU. Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.u2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje wartość typu <see langword="unsigned int32" /> <see langword="int32" /> na stosie oceny pośrednio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|4B|ldind. U4|Ładuje wartość pod `addr` adresem`int32`nastosjako. `unsigned int32`|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.  
  
3.  Pobrana wartość jest wypychana do stosu.  
  
 `int32` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub *) na stosie jako. `unsigned int32` `ldind.u4`  
  
 Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`  
  
 Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny. Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.  
  
 Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.  
  
 Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych). Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane. W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU. Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.  
  
 <xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.u4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnij liczbę elementów tablicy jednowymiarowej o wartości zero na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8E|ldlen|Wypchnij Długość (typu `natural unsigned int`) tablicy na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu tablicy jest wypychane na stosie.  
  
2.  Odwołanie do tablicy jest zdjęte z stosu, a długość jest obliczana.  
  
3.  Długość jest wypychana na stosie.  
  
 Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`. Długość jest zwracana jako `natural unsigned int`.  
  
 <xref:System.NullReferenceException>jest zgłaszany, jeśli odwołanie do tablicy jest odwołaniem o wartości null.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldlen` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmienną lokalną pod określonym indeksem na stos oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc`index`|Ładuje zmienną lokalną przy indeksie `index` na stos.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość zmiennej lokalnej w określonym indeksie jest wypychana do stosu.  
  
 `ldloc` Instrukcja wypycha zawartość lokalnego numeru zmiennej przy użyciu przekazanego indeksu do stosu oceny, gdzie zmienne lokalne są numerowane od 0 do wewnątrz. Zmienne lokalne są inicjowane na wartość 0 przed wprowadzeniem metody tylko wtedy, gdy flaga inicjacji w metodzie ma wartość true. Dostępne są 65 535 (2 ^ 16-1) zmienne lokalne (0 – 65534). Indeks 65 535 jest nieprawidłowy, ponieważ prawdopodobnie implementacje będą używały 2-bajtowej liczby całkowitej do śledzenia zarówno indeksu lokalnego, jak i łącznej liczby elementów lokalnych danej metody. Jeśli indeks 65535 był prawidłowy, będzie wymagał szerszej liczby całkowitej do śledzenia liczby elementów lokalnych w takiej metodzie.  
  
 Instrukcje `ldloc.0`, `ldloc.1`, `ldloc.2`i zapewniająwydajnekodowaniedouzyskiwaniadostępudopierwszychczterechzmiennychlokalnych.`ldloc.3`  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej, która jest określona w nagłówku metody. Zobacz partycja I. lokalne zmienne, które są mniejsze niż 4 bajty, są `int32` rozszerzane do typu podczas ładowania na stos. Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `ldloc` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, LocalBuilder)  
  
-   Elemencie ILGenerator. emisji (OpCode, krótkie)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmienną lokalną pod indeksem 0 na stos szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|06|ldloc. 0|Ładuje zmienną lokalną pod indeksem 0 na stos szacowania.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość zmiennej lokalnej na indeksie 0 jest wypychana do stosu.  
  
 `ldloc.0`to szczególnie wydajne kodowanie dla <xref:System.Reflection.Emit.OpCodes.Ldloc>, umożliwiające dostęp do zmiennej lokalnej przy indeksie 0.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej, która jest określona w nagłówku metody. Zmienne lokalne o długości mniejszej niż 4 bajty są rozszerzane `int32` do typu podczas ładowania na stosie. Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldloc.0` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmienną lokalną pod indeksem 1 na stos szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|07|ldloc. 1|Ładuje zmienną lokalną pod indeksem 1 na stos szacowania.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość zmiennej lokalnej na indeksie 1 jest wypychana na stosie.  
  
 `ldloc.1`to szczególnie wydajne kodowanie dla <xref:System.Reflection.Emit.OpCodes.Ldloc>, umożliwiające dostęp do zmiennej lokalnej przy użyciu indeksu 1.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej, która jest określona w nagłówku metody. Zmienne lokalne o długości mniejszej niż 4 bajty są rozszerzane `int32` do typu podczas ładowania na stosie. Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldloc.1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmienną lokalną pod indeksem 2 na stos szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|08|ldloc. 2|Ładuje zmienną lokalną pod indeksem 2 na stos szacowania.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość zmiennej lokalnej na indeksie 2 jest wypychana na stosie.  
  
 `ldloc.2`to szczególnie wydajne kodowanie dla <xref:System.Reflection.Emit.OpCodes.Ldloc>, umożliwiające dostęp do zmiennej lokalnej przy użyciu indeksu 2.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej, która jest określona w nagłówku metody. Zmienne lokalne o długości mniejszej niż 4 bajty są rozszerzane `int32` do typu podczas ładowania na stosie. Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldloc.2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmienną lokalną pod indeksem 3 na stos szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|09|ldloc. 3|Ładuje zmienną lokalną pod indeksem 3 na stos szacowania.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość zmiennej lokalnej na indeksie 3 jest wypychana na stosie.  
  
 `ldloc.3`to szczególnie wydajne kodowanie dla <xref:System.Reflection.Emit.OpCodes.Ldloc>, umożliwiające dostęp do zmiennej lokalnej przy użyciu indeksu 3.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej, która jest określona w nagłówku metody. Zmienne lokalne o długości mniejszej niż 4 bajty są rozszerzane `int32` do typu podczas ładowania na stosie. Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldloc.3` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje zmienną lokalną pod określonym indeksem do stosu ewaluacyjnego, krótkiej formy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|Ładuje zmienną lokalną przy indeksie `index` do stosu, krótkiej formy.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość zmiennej lokalnej w określonym indeksie jest wypychana do stosu.  
  
 `ldloc.s` Instrukcja wypycha zawartość lokalnego numeru zmiennej przy użyciu przekazanego indeksu do stosu oceny, gdzie zmienne lokalne są numerowane od 0 do wewnątrz. Zmienne lokalne są inicjowane na wartość 0 przed wprowadzeniem metody, jeśli flaga inicjacji w metodzie ma wartość true. W krótkim formularzu istnieją 256 (2 ^ 8) zmiennych lokalnych (0-255), co jest bardziej wydajnym kodowaniem niż `ldloc`.  
  
 Typ wartości jest taki sam jak typ zmiennej lokalnej, która jest określona w nagłówku metody. Zobacz partycja I. lokalne zmienne, które są mniejsze niż 4 bajty, są `int32` rozszerzane do typu podczas ładowania na stos. Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `ldloc.s` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, LocalBuilder)  
  
-   Elemencie ILGenerator. emisji (OpCode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje adres zmiennej lokalnej w określonym indeksie na stos szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE OD <`unsigned int16` >|ldloca `index`|Ładuje adres zmiennej lokalnej na `index` stosie szacowania.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres przechowywany w zmiennej lokalnej o określonym indeksie jest wypychany na stosie.  
  
 `ldloca` Instrukcja wypchnięcie adresu zmiennej lokalnej w przekazanym indeksie na stos, gdzie zmienne lokalne są numerowane od 0 do wewnątrz. Wartość wypchnięcia na stosie jest już prawidłowo wyrównana do użycia z instrukcjami takimi <xref:System.Reflection.Emit.OpCodes.Stind_I>jak <xref:System.Reflection.Emit.OpCodes.Ldind_I> i. Wynik jest wskaźnikiem przejściowym (Type `*`).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldloca` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, krótkie)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ładuje adres zmiennej lokalnej w określonym indeksie na stos oceny, skróconej postaci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|Ładuje adres zmiennej lokalnej na `index` stosie oceny, skróconej postaci.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres przechowywany w zmiennej lokalnej o określonym indeksie jest wypychany na stosie.  
  
 `ldloca.s` Instrukcja wypchnięcie adresu zmiennej lokalnej w przekazanym indeksie na stos, gdzie zmienne lokalne są numerowane od 0 do wewnątrz. Wartość wypchnięcia na stosie jest już prawidłowo wyrównana do użycia z instrukcjami takimi <xref:System.Reflection.Emit.OpCodes.Stind_I>jak <xref:System.Reflection.Emit.OpCodes.Ldind_I> i. Wynik jest wskaźnikiem przejściowym (Type `*`).  
  
 `ldloca.s` Instrukcja zapewnia wydajne kodowanie do użycia z lokalnymi zmiennymi od 0 do 255.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldloca.s` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcie odwołania o wartości null <see langword="O" />(Type) do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|14|ldnull|Wypchnij odwołanie o wartości null na stosie|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu o wartości null jest wypychane na stosie.  
  
 `ldnull`wypchnięcie odwołania o wartości null `O`(typ) na stosie. Jest on używany do inicjowania lokalizacji przed ich wypełnieniem danymi lub kiedy stają się one przestarzałe.  
  
 `ldnull`zawiera odwołanie o wartości null, które jest niezależne od rozmiaru.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldnull` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiuje obiekt typu wartości wskazywany przez adres na początku stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Skopiuj wystąpienie typu `class` wartości do stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres obiektu typu wartości jest wypychany do stosu.  
  
2.  Adres jest zdjęte ze stosu, a wystąpienie pod tym konkretnym adresem jest wyszukiwane.  
  
3.  Wartość obiektu przechowywanego w tym adresie jest wypychana do stosu.  
  
 `ldobj` Instrukcja służy do przekazywania typu wartości jako parametru.  
  
 `&` `*` `native int`Instrukcja kopiuje wartość wskazywaną przez `addrOfValObj` (z typu, lub) na górze stosu. `ldobj` Liczba kopiowanych bajtów zależy od rozmiaru klasy (określony przez `class` parametr). `class` Parametr jest tokenem metadanych reprezentującym typ wartości.  
  
 Operację `ldobj` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.  
  
 <xref:System.TypeLoadException>jest zgłaszany, jeśli nie można znaleźć klasy. Jest to zwykle wykrywane, gdy instrukcja języka pośredniego (MSIL) firmy Microsoft jest konwertowana na kod natywny, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldobj` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnij wartość pola statycznego na stos oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7E < `T` >|elementu ldsfld`field`|Wypchnij wartość `field` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość określonego pola jest wypychana do stosu.  
  
 `ldsfld` Instrukcja wypycha wartość statycznego (współużytkowanego przez wszystkie wystąpienia klasy) na stosie. Zwracanym typem jest skojarzona z tokenem `field`przekazywania metadanych.  
  
 `ldsfld` Instrukcja może<xref:System.Reflection.Emit.OpCodes.Volatile> mieć prefiks.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldsfld` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcie adresu pola statycznego na stos oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|Wypchnij adres `field` na stosie|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres określonego pola jest wypychany na stosie.  
  
 `ldsflda` Instrukcja wypycha adres statyczny (współdzielony przez wszystkie wystąpienia klasy) na stosie. Adres może być reprezentowany jako przejściowy wskaźnik (typ `*`), jeśli token `field` metadanych odwołuje się do typu, którego pamięć jest zarządzana. W przeciwnym razie odnosi się do niezarządzanego wskaźnika `native int`(Type). Zwróć uwagę `field` , że może to być statyczna globalna z przypisanym względnym adresem wirtualnym (przesunięcie pola od adresu podstawowego, w którym zawierający plik PE jest ładowany do pamięci), gdzie pamięć jest niezarządzana.  
  
 `ldsflda` Instrukcja może<xref:System.Reflection.Emit.OpCodes.Volatile> mieć prefiks.  
  
 <xref:System.MissingFieldException>jest zgłaszany, jeśli nie znaleziono pola w metadanych. Jest to zazwyczaj zaznaczone, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldsflda` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnij nowe odwołanie do obiektu do literału ciągu przechowywanego w metadanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr`mdToken`|Wypchnięcie obiektu ciągu dla tokenu `mdToken`ciągu metadanych.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu do ciągu jest wypychane na stosie.  
  
 Instrukcja wypycha odwołanie do obiektu (typ `O`) do nowego obiektu ciągu reprezentującego określony literał ciągu przechowywany w metadanych. `ldstr` `ldstr` Instrukcja przypisuje wymaganą ilość pamięci i wykonuje konwersję formatu wymaganą do przekonwertowania literału ciągu z formularza używanego w pliku do formatu ciągu wymaganego w czasie wykonywania.  
  
 Common Language Infrastructure (CLI) gwarantuje, że wynik dwóch `ldstr` instrukcji odnoszący się do dwóch tokenów metadanych, które mają taką samą sekwencję znaków, zwracają dokładnie ten sam obiekt String (proces znany jako "ciąg".  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldstr` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, String)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje token metadanych na reprezentację środowiska uruchomieniowego, wypychając go do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken`token`|Konwertuje token metadanych na reprezentację środowiska uruchomieniowego.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Przeniesiony token jest konwertowany na a `RuntimeHandle` i wypychany do stosu.  
  
 Instrukcja wypchnięcie `RuntimeHandle` dla określonego tokenu metadanych. `ldtoken` `RuntimeHandle` Może być`fieldref/fielddef` ,a`methodref/methoddef`, lub .`typeref/typedef`  
  
 Wartość wypchnięcia na stosie może być używana w wywołaniach `Reflection` metod w bibliotece klas systemu.  
  
 Aby uzyskać informacje na temat dojść do środowiska uruchomieniowego, <xref:System.RuntimeFieldHandle>zobacz <xref:System.RuntimeTypeHandle>następujące klasy <xref:System.RuntimeMethodHandle>:,, i.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `ldtoken` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnij niezarządzany wskaźnik ( <see langword="native int" />typ) do kodu natywnego implementującego określoną metodę wirtualną skojarzoną z określonym obiektem na stos oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 07 <`T` >|ldvirtftn `method`|Wypchnięcie wskaźnika do metody `method` wirtualnej obiektu na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu jest wypychane na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte ze stosu i adres punktu wejścia do metody (określony przez token `method`metadanych) jest wyszukiwany.  
  
3.  Wskaźnik do `method` jest wypychany na stosie.  
  
 Uzyskany niezarządzany wskaźnik został wypchnięte do stosu przez `ldvirtftn` instrukcję, można wywołać przy użyciu <xref:System.Reflection.Emit.OpCodes.Calli> instrukcji, jeśli odwołuje się do metody zarządzanej (lub zastępczej przechodzenia z kodu zarządzanego do niezarządzanego).  
  
 Wskaźnik niezarządzany wskazuje na kod natywny przy użyciu konwencji wywoływania CLR. Tego wskaźnika metody nie należy przekazywać do niezarządzanego kodu natywnego jako procedury wywołania zwrotnego.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldvirtftn` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamyka chroniony region kodu, bezwarunkowo przenosząc kontrolę do określonej instrukcji docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DD < `int32` >|Pozostaw`target`|Zamyka chroniony region kodu.|  
  
 Dla tej instrukcji nie określono zachowania przejścia stosu.  
  
 `leave` Instrukcja bezwarunkowo przenosi kontrolę do konkretnej instrukcji docelowej, reprezentowanej przez 4-bajtowe przesunięcia od początku instrukcji po bieżącej instrukcji.  
  
 `br` `try` `filter`Instrukcja jest podobna do instrukcji, ale może służyć do zamykania, lub `catch` bloku, a normalne instrukcje gałęzi mogą być używane tylko w takim bloku, aby przetransferować kontrolę w obrębie `leave` go. Instrukcja opróżnia stos oceny i zapewnia, że są wykonywane odpowiednie bloki otaczające `finally`. `leave`  
  
 Nie można użyć `leave` instrukcji, aby `finally` wyjść z bloku. Aby ułatwić generowanie kodu dla programów obsługi wyjątków, jest on prawidłowy z wewnątrz bloku catch, aby użyć `leave` instrukcji do przetransferowania kontroli do dowolnej instrukcji w `try` ramach skojarzonego bloku.  
  
 Jeśli instrukcja zawiera jeden lub więcej kodów prefiksów, formant można przesłać tylko do pierwszego z tych prefiksów.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `leave` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamyka chroniony region kodu, bezwarunkowo przenosząc kontrolę do instrukcji docelowej (krótka wersja).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DE < `int8` >|Pozostaw. s`target`|Wyjdź z chronionego regionu kodu, krótkiej formy.|  
  
 Dla tej instrukcji nie określono zachowania przejścia stosu.  
  
 `leave.s` Instrukcja bezwarunkowo przenosi kontrolę do przekazaną instrukcję docelową, reprezentowane jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.  
  
 `br` `try` `filter`Instrukcja jest podobna do instrukcji, ale może służyć do zamykania, lub `catch` bloku, a normalne instrukcje gałęzi mogą być używane tylko w takim bloku, aby przetransferować kontrolę w obrębie `leave.s` go. Instrukcja opróżnia stos oceny i zapewnia, że są wykonywane odpowiednie bloki otaczające `finally`. `leave.s`  
  
 Nie można użyć `leave.s` instrukcji, aby `finally` wyjść z bloku. Aby ułatwić generowanie kodu dla programów obsługi wyjątków, jest on prawidłowy z wewnątrz bloku catch, aby użyć `leave.s` instrukcji do przetransferowania kontroli do dowolnej instrukcji w `try` ramach skojarzonego bloku.  
  
 Jeśli instrukcja zawiera jeden lub więcej kodów prefiksów, formant można przesłać tylko do pierwszego z tych prefiksów.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `leave.s` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przydziela określoną liczbę bajtów z lokalnej puli pamięci dynamicznej i wypycha adres (przejściowy wskaźnik, typ <see langword="*" />) pierwszego przydzielonego bajtu na stos oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|Przydziel miejsce ze sterty lokalnej.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Liczba bajtów do przydzielenia jest wypychana do stosu.  
  
2.  Liczba bajtów zdjęte ze stosu; ilość pamięci odpowiadająca rozmiarowi jest przypisywany ze sterty lokalnej.  
  
3.  Wskaźnik do pierwszego bajtu przydzieloną pamięci jest wypychany do stosu.  
  
 Instrukcja przypisuje `natural unsigned int`(typu) bajty z lokalnej puli pamięci dynamicznej i zwraca adres (wskaźnik przejściowy, typ `*`) pierwszego przydzielonego bajtu. `size` `localloc` Blok zwróconej pamięci jest inicjowany do wartości 0 tylko wtedy, gdy flaga inicjacji metody `true`to. Gdy bieżąca metoda jest wykonywana a <xref:System.Reflection.Emit.OpCodes.Ret>, lokalna Pula pamięci jest udostępniana do ponownego użycia.  
  
 Otrzymany adres jest wyrównany w taki sposób, że dowolny typ danych pierwotnych może być przechowywany `stind` przy użyciu instrukcji ( <xref:System.Reflection.Emit.OpCodes.Stind_I4>takich jak `ldind` ) i ładowany przy użyciu instrukcji ( <xref:System.Reflection.Emit.OpCodes.Ldind_I4>takich jak).  
  
 `catch` `finally` `fault` Instrukcja nie może wystąpić `filter`w bloku,, lub. `localloc`  
  
 <xref:System.StackOverflowException>jest zgłaszany w przypadku braku wystarczającej ilości pamięci do obsługi żądania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `localloc` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnij wpisane odwołanie do wystąpienia określonego typu na stos oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|C6 < `T` >|mkrefany`class`|Wypchnięcie wpisany odwołanie typu `class` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wskaźnik do fragmentu danych jest wypychany do stosu.  
  
2.  Wskaźnik jest zdjęte i konwertowany na wpisane odwołanie typu `class`.  
  
3.  Wpisane odwołanie jest wypychane na stosie.  
  
 `mkrefany` Instrukcja obsługuje przekazywanie dynamicznie wpisanych odwołań. Wskaźnik musi być typu `&`, `*`, lub `native int`i zawierać prawidłowy adres elementu danych. `Class`jest tokenem klasy opisującym typ danych, do których odwołuje się wskaźnik. `Mkrefany`Wypchnij odwołanie do wpisanej wartości na stosie, dostarczając nieprzezroczysty deskryptor wskaźnika i typu `class`.  
  
 Jedyną poprawną operacją dozwoloną w przypadku odwołania z określonym typem jest przekazanie go do metody, która wymaga określenia typu jako parametru. Wywoływany może następnie użyć <xref:System.Reflection.Emit.OpCodes.Refanytype> instrukcji i <xref:System.Reflection.Emit.OpCodes.Refanyval> w celu pobrania odpowiednio typu (klasy) i adresu.  
  
 <xref:System.TypeLoadException>jest zgłaszany `class` , jeśli nie można znaleźć. Jest to zwykle wykrywane, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `mkrefany` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Mnoży dwie wartości i wypycha wynik na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5A|mul|Mnoży dwie wartości na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; jest mnożony przez `value2`. `value1`  
  
4.  Wynik jest wypychany na stosie.  
  
 Instrukcja `mul` jest `value2` mnożona przez i wypycha wynik na stosie. `value1` Operacje całkowite w trybie dyskretnym obcinają górne bity przy przepełnieniu.  
  
 Zobacz <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> , aby uzyskać określoną liczbę całkowitą operacji mnożenia z obsługą przepełnienia.  
  
 W przypadku typów zmiennoprzecinkowych 0 * nieskończoność = NaN.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `mul` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Mnoży dwie wartości całkowite, wykonuje sprawdzanie przepełnienia i wypycha wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|Mnoży dwie wartości całkowite na stosie za pomocą sprawdzania przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; jest mnożony przez `value2`, ze sprawdzaniem przepełnienia. `value1`  
  
4.  Wynik jest wypychany na stosie.  
  
 Instrukcja mnoży liczbę całkowitą `value1` przez liczbę całkowitą `value2` i wypycha wynik na stosie. `mul.ovf` Wyjątek jest zgłaszany, jeśli wynik nie będzie pasować do typu wynikowego.  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `mul.ovf` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Mnoży dwie wartości bez znaku, wykonuje sprawdzanie przepełnienia i wypycha wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|Mnoży dwie niepodpisane wartości ze stosu za pomocą sprawdzania przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; jest mnożony przez `value2`, ze sprawdzaniem przepełnienia. `value1`  
  
4.  Wynik jest wypychany na stosie.  
  
 Instrukcja mnoży liczbę całkowitą `value1` bez znaku przez liczbę całkowitą `value2` bez znaku i wypycha wynik na stosie. `mul.ovf.un` Wyjątek jest zgłaszany, jeśli wynik nie będzie pasować do typu wynikowego.  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `mul.ovf.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wyklucza wartość i wypycha wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|65|neg|Negacja wartości obecnie znajdującej się na szczycie stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość jest wypychana do stosu.  
  
2.  Wartość jest zdjęte ze stosu i Negacja.  
  
3.  Wynik jest wypychany na stosie.  
  
 `neg` Instrukcja powoduje negację wartości i wypchnięcie wyniku na szczycie stosu. Zwracany typ jest taki sam jak typ argumentu operacji.  
  
 Negacja wartości całkowitych jest negacją standardową. W szczególności Negacja najbardziej ujemnej liczby (która nie ma pozytywnego odpowiednika) daje najbardziej ujemną liczbę. Aby wykryć ten przepełnienie <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> , Użyj zamiast tego instrukcji (czyli Odejmij od 0).  
  
 Negacja liczby zmiennoprzecinkowej nie może przekroczyć, a Negacja NaN zwraca NaN.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `neg` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcie odwołania do obiektu do nowej tablicy jednowymiarowej opartej na zero, której elementy są określonego typu na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr`etype`|Tworzy nową tablicę z elementami typu `etype`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Liczba elementów w tablicy jest wypychana do stosu.  
  
2.  Liczba elementów jest zdjęte z stosu i tworzona jest tablica.  
  
3.  Odwołanie do obiektu do nowej tablicy jest wypychane na stosie.  
  
 Instrukcja wypycha odwołanie do obiektu (typ `O`) do nowej tablicy jednowymiarowej, której elementy są typu `etype` (token metadanych opisujący typ). `newarr` Liczba elementów w nowej tablicy powinna być określona jako `native int`. Prawidłowy indeks tablicy zakresu od zera do maksymalnej liczby elementów minus jeden.  
  
 Elementy tablicy mogą być dowolnego typu, w tym typów wartości.  
  
 Jednowymiarowe tablice liczb są tworzone przy użyciu tokenu metadanych odwołującego się do odpowiedniego typu wartości (<xref:System.Int32>itd.). Elementy tablicy są inicjowane na 0 dla odpowiedniego typu.  
  
 Tablice jednowymiarowe oparte na niezerowym i wielowymiarowe tablice są tworzone <xref:System.Reflection.Emit.OpCodes.Newobj> przy użyciu `newarr`zamiast. Często są one tworzone przy użyciu metod <xref:System.Array> klasy w .NET Framework.  
  
 <xref:System.OutOfMemoryException>jest zgłaszany w przypadku braku wystarczającej ilości pamięci do spełnienia żądania.  
  
 <xref:System.OverflowException>jest zgłaszany `numElems` , jeśli jest mniejszy niż 0.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `newarr` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tworzy nowy obiekt lub nowe wystąpienie typu wartości, wypchnięcie odwołania do obiektu (typu <see langword="O" />) na stos oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Alokuje niezainicjowany typ obiektu lub wartości i wywołuje metodę `ctor`konstruktora.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Argumenty `arg1` przez`argn` są wypychane na stosie w sekwencji.  
  
2.  Argumenty `argn` `ctor` przez `arg1` są zdjęte ze stosu i przechodzą do tworzenia obiektów.  
  
3.  Odwołanie do nowego obiektu jest wypychane do stosu.  
  
 `newobj` Instrukcja tworzy nowy obiekt lub nowe wystąpienie typu wartości. `Ctor`jest tokenem metadanych ( `methodref` lub `methoddef` , który musi być oznaczony jako Konstruktor), który wskazuje nazwę, klasę i podpis konstruktora do wywołania.  
  
 Instrukcja przydziela nowe wystąpienie klasy skojarzonej z `ctor` i inicjuje wszystkie pola w nowym wystąpieniu do 0 (odpowiedniego typu) lub odwołania o wartości null zgodnie z potrzebami. `newobj` Następnie wywołuje konstruktora `ctor` z podanym argumentami wraz z nowo utworzonym wystąpieniem. Po wywołaniu konstruktora, aktualnie zainicjowany odwołanie do obiektu (Type `O`) jest wypychane na stosie.  
  
 Z punktu widzenia konstruktora Niezainicjowany obiekt jest argumentem 0, a pozostałe argumenty przekazane do newobj są zgodne z kolejnością.  
  
 Wszystkie tablice jednowymiarowe oparte na zero są tworzone przy użyciu <xref:System.Reflection.Emit.OpCodes.Newarr>, nie `newobj`. Z drugiej strony, wszystkie inne tablice (więcej niż jeden wymiar lub jednowymiarowe, ale nie zero) są tworzone przy użyciu `newobj`.  
  
 Typy wartości nie są zwykle tworzone przy `newobj`użyciu. Są one zazwyczaj przydzieleni jako argumenty lub zmienne lokalne, przy `newarr` użyciu (dla tablic jednowymiarowych lub z jednowymiarowe) lub jako pola obiektów. Po przydzieleniu są one inicjowane przy użyciu <xref:System.Reflection.Emit.OpCodes.Initobj>. `newobj` Jednakże instrukcji można użyć do utworzenia nowego wystąpienia typu wartości na stosie, który można następnie przesłać jako argument, przechowywany w lokalnej itd.  
  
 <xref:System.OutOfMemoryException>jest zgłaszany w przypadku braku wystarczającej ilości pamięci do spełnienia żądania.  
  
 <xref:System.MissingMethodException>jest zgłaszany, jeśli nie `ctor` można odnaleźć metody konstruktora o wskazanej nazwie, klasie i podpisie. Jest to zwykle wykrywane, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `newobj` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypełnia miejsce, jeśli są poprawione poprawki kodów. Nie wykonano żadnej znaczącej operacji, chociaż można użyć cyklu przetwarzania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|00|NOP|Wykonuje operację bez zachowania.|  
  
 Nie ma żadnego zachowania przejściowego stosu zdefiniowanego dla tej instrukcji.  
  
 `nop` Operacja nic nie robi. Jest ona przeznaczona do wypełniania miejsca, jeśli są poprawione.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `nop` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oblicza liczbę całkowitą komplementarności wartości całkowitej na szczycie stosu i wypycha wynik do stosu oceny jako ten sam typ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|66|not|Oblicza liczbę całkowitą komplementarności wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value`jest wypychany na stosie.  
  
2.  `value`jest zdjęte z stosu i obliczany jest jego komplementarny uzupełniający.  
  
3.  Wynik jest wypychany na stosie.  
  
 `not` Instrukcja oblicza całkowite uzupełnienie wartości całkowitej i wypycha wynik do stosu. Zwracany typ jest taki sam jak typ argumentu operacji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `not` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oblicz komplementarną wartość całkowitą dwóch wartości całkowitych na stosie i wypchnij wynik na stos oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|60|lub|Oblicza bitową lub dwie wartości całkowite, zwraca liczbę całkowitą.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu i ich bitowe lub obliczone.  
  
4.  Wynik jest wypychany na stosie.  
  
 `or` Instrukcja oblicza bitową lub dwie wartości korzystającego stosu, wypychając wynik do stosu.  
  
 `Or`jest operacją specyficzną dla liczby całkowitej.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `or` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usuwa wartość aktualnie znajdującą się na szczycie stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|26|skakując|Pop wartość najwyższej wartości ze stosu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Górna wartość jest zdjęte ze stosu.  
  
 `pop` Instrukcja usuwa górny element ze stosu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `pop` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to instrukcja zastrzeżona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to instrukcja zastrzeżona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to instrukcja zastrzeżona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to instrukcja zastrzeżona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to instrukcja zastrzeżona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to instrukcja zastrzeżona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to instrukcja zastrzeżona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest to instrukcja zastrzeżona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że kolejna operacja adresu tablicy nie sprawdza typu w czasie wykonywania i zwraca zarządzany wskaźnik, którego zmienność jest ograniczone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 1E|trybie.|Określ, że kolejna operacja adresu tablicy nie sprawdza typu w czasie wykonywania i zwraca zarządzany wskaźnik z ograniczoną zmienność.|  
  
 Ten prefiks może występować tylko bezpośrednio przed `ldelema` instrukcją i wywołuje metodę specjalną `Address` w tablicach. Jego wpływ na następną operację to dwa cele:  
  
1.  W czasie wykonywania nie jest wykonywana żadna operacja sprawdzania typu. Należy zauważyć, że zwykle jest to niejawne sprawdzenie `ldelema` typu `stelem` dla instrukcji i, jeśli są używane w tablicach typu referencyjnego. Nie ma potrzeby sprawdzania typu w czasie wykonywania dla klas wartości, więc `readonly` w takim przypadku jest to no-op.  
  
2.  Weryfikator traktuje wynik operacji address-of jako zarządzany wskaźnik z ograniczoną zmienność.  
  
 Wskaźnik jest uznawany za ograniczony zmienność, ponieważ typ definiujący określa, czy wartość może być mutacja. W przypadku klas wartości, które uwidaczniają brak pól publicznych lub metod, które aktualizują wartość w miejscu, wskaźnik jest tylko do odczytu (w związku z tym nazwą prefiksu). W szczególności klasy reprezentujące typy pierwotne (na przykład system. Int32) nie ujawniają mutacje i w ten sposób są tylko do odczytu.  
  
 Zarządzany wskaźnik ograniczony w ten sposób może być używany tylko w następujący sposób:  
  
-   `object` Jako parametr `ldfld`instrukcji, `ldflda`, ,`stfld`lub`constrained callvirt` . `call`  
  
-   Jako parametr do instrukcji lub jednej z `ldind`instrukcji. `ldobj` `pointer`  
  
-   `source` Jako parametr`cpobj` do instrukcji.  
  
 Wszystkie inne operacje `stobj`niedozwolone, w tym `initobj`operacje,, lub `mkrefany` , lub dowolnych `stind` instrukcji.  
  
 Celem `readonly` prefiksu jest uniknięcie sprawdzania typu podczas pobierania elementu z tablicy w kodzie ogólnym. Na przykład wyrażenie `arr[i].m()`, gdzie typ elementu tablicy `arr` jest typem ogólnym, który jest ograniczony do posiadania interfejsu z metodą `m`, może kompilować do poniższego MSIL.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Bez prefiksu `ldelema` , instrukcja wykona sprawdzanie typu w przypadku, gdzie! 0 było typem referencyjnym. `readonly` Ten typ nie tylko jest nieefektywny, ale jest semantycznie nieprawidłowy. Sprawdzanie typu dla `ldelema` jest dokładnym odpowiednikiem, który jest zbyt silny. Jeśli tablica posiada podklasy typu! 0, w powyższym kodzie nie można sprawdzić typu.  
  
 Adres elementu tablicy jest pobierany, a nie sam element, w celu uzyskania dojścia dla `arr[i]` tego samego typu wartości i typów referencyjnych, co może być przekazaniem `constrained callvirt` do instrukcji.  
  
 Ogólnie rzecz biorąc, byłoby niebezpieczne, aby pominąć sprawdzanie czasu wykonywania, jeśli tablica posiada elementy typu referencyjnego. Aby zapewnić bezpieczeństwo, należy upewnić się, że żadne modyfikacje w tablicy nie są wykonywane za pomocą tego wskaźnika. Upewnij się, że reguły weryfikatora. Zarządzany wskaźnik można przesłać jako obiekt wywołania metody wystąpienia, dlatego nie jest on ściśle mówiący tylko do odczytu dla typów wartościowych, ale nie ma problemu z bezpieczeństwem typu dla typów wartości.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `readonly` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera token typu osadzony w określonym odwołaniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|Wypchnięcie tokenu typu przechowywanego w określonym odwołaniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do typu wartości jest wypychane do stosu.  
  
2.  Wpisane odwołanie to zdjęte z stosu i pobrano odpowiadający mu token typu.  
  
3.  Token typu jest wypychany do stosu.  
  
 Wpisane odwołanie zawiera token typu i adres do wystąpienia obiektu.  
  
 `refanytype` Instrukcja pobiera token typu osadzony w określonym odwołaniu. Zapoznaj <xref:System.Reflection.Emit.OpCodes.Mkrefany> się z instrukcjami dotyczącymi tworzenia wpisanych odwołań.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `refanytype` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres (Type <see langword="&amp;" />) osadzony w określonym odwołaniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval`type`|Wypchnięcie adresu przechowywanego w określonym odwołaniu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do typu wartości jest wypychane do stosu.  
  
2.  Odwołanie z określonym typem jest zdjęte z stosu i pobierany jest odpowiedni adres.  
  
3.  Adres jest wypychany na stosie.  
  
 Wpisane odwołanie zawiera token typu i adres do wystąpienia obiektu.  
  
 `refanyval` Instrukcja Pobiera adres osadzony w odwołanym typie. Typ osadzony w odwołaniu określonym na stosie musi być zgodny z typem określonym przez `type` (token metadanych, a `typedef` lub a `typeref`). Zapoznaj <xref:System.Reflection.Emit.OpCodes.Mkrefany> się z instrukcjami dotyczącymi powiązanej zawartości.  
  
 <xref:System.InvalidCastException>jest zgłaszany `type` , jeśli nie jest identyczny z typem przechowywanym w odwołaniu typu (w `type` tym przypadku jest klasą dostarczaną do <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrukcji, która konstruuje wspomniane odwołanie.  
  
 <xref:System.TypeLoadException>jest zgłaszany `type` , jeśli nie można znaleźć.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `refanyval` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dzieli dwie wartości i wypchnięcia reszty na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5D|REM|Wypchnięcie reszty dzielenia `value1` przez `value2` stos.|  
  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1` Jest wypychany do stosu.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu i resztą wartości `value1` `div` `value2` obliczanej.  
  
4.  Wynik jest wypychany na stosie.  
  
 `result` = `value1``rem` spełnia`value2` następujące warunki:  
  
 `result` = `value1` - `value2``×` (`value1` )i:`div` `value2`  
  
 0 = &#124; `result` &#124; < &#124; (`result`) = `div` Sign (`value1`), gdzie jest instrukcją dzielenia, która jest obcinana do zera. `value2` &#124;  
  
 Jeśli `value2` ma wartość zero `value1` lub jest nieskończoność, wynikiem jest NaN. Jeśli `value2` jest nieskończoność, wynik jest `value1` (Negacja `-infinity`).  
  
 <xref:System.DivideByZeroException> Jeśli`value2` wartość jest równa zero, operacje całkowite generują.  
  
 Należy pamiętać, że na platformach <xref:System.OverflowException> opartych na procesorze Intel jest zgłaszany podczas obliczania (Minint `rem` -1).  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `rem` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dzieli dwie wartości bez znaku i wypchnięcie reszty na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|5E|rem.un|Wypychanie pozostałej części dzielenia bez `value1` znaku przez `value2` niepodpisane na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu i resztą wartości `value1` `div` `value2` obliczanej.  
  
4.  Wynik jest wypychany na stosie.  
  
 `result` = `value1``rem.un` spełnia`value2` następujące warunki:  
  
 `result` = `value1` - `value2`x (`value1` `div.un` )i`value2`:  
  
 0 = `result`  <  ,gdzie`div.un` jest instrukcją dzielenia bez znaku. `value2`  
  
 `rem.un` Instrukcja obliczyiwypycha`result` ją na stosie. `Rem.un`traktuje swoje argumenty jako liczby całkowite bez znaku <xref:System.Reflection.Emit.OpCodes.Rem> , a jednocześnie traktuje je jako liczby całkowite ze znakiem.  
  
 `Rem.un`nie jest określony dla liczb zmiennoprzecinkowych.  
  
 <xref:System.DivideByZeroException> Jeśli`value2` wartość jest równa zero, operacje całkowite generują.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `rem.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca z bieżącej metody, wypchnięcie wartości zwracanej (jeśli istnieje) z stosu oceny wywoływanych elementów do stosu oceny wywołującego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|2A|RET|Zwraca z metody, która może zwracać wartość.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość zwracana jest zdjęte z stosu oceny wywoływanej.  
  
2.  Wartość zwracana uzyskana w kroku 1 jest wypychana do stosu oceny elementu wywołującego.  
  
 Jeśli wartość zwracana nie występuje na stosie oceny wywoływanej, żadna wartość nie jest zwracana (brak zachowań stosu dla metody wywoływanej ani wywołującej).  
  
 Typ wartości zwracanej, jeśli istnieje, bieżącej metody Określa typ wartości, która ma zostać pobrana z góry stosu i kopiowany na stos metody, która wywołała bieżącą metodę. Stos oceny dla bieżącej metody musi być pusty, z wyjątkiem wartości, która ma zostać zwrócona.  
  
 `filter``try` `finally` `catch`Instrukcja nie może być użyta do przetransferowania kontroli z,, lub bloku. `ret` Z poziomu programu `try` lub `catch`, należy użyć <xref:System.Reflection.Emit.OpCodes.Leave> instrukcji z miejscem docelowym `ret` instrukcji, która znajduje się poza wszystkimi otaczającymi blokami wyjątków. Ze względu `finally` na `filter` to, że bloki i są logicznie częścią obsługi wyjątków, a nie metodą, w której kod jest osadzony, prawidłowo wygenerowane instrukcje języka pośredniego firmy Microsoft (MSIL) nie wykonują metody powrotu z wewnątrz `filter` lub .`finally`  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ret` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ponownie generuje bieżący wyjątek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 1A|Rethrow|Ponownie generuje bieżący wyjątek|  
  
 Nie zdefiniowano zachowania przejścia stosu dla tej instrukcji.  
  
 Instrukcja jest dozwolona tylko w treści `catch` procedury obsługi. `rethrow` Zgłasza ten sam wyjątek, który został przechwycony przez ten program obsługi.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `rethrow` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi wartość całkowitą z lewej (w zerach) o określoną liczbę bitów, wypychając wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|62|shl|Przesuwa liczbę całkowitą z lewej strony (przesunięcie w zerach).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość jest wypychana do stosu.  
  
2.  Liczba bitów do przesunięcia jest wypychana do stosu.  
  
3.  Liczba bitów, które mają zostać przesunięte, a wartość to zdjęte ze stosu; wartość jest przesunięta w lewo o określoną liczbę bitów.  
  
4.  Wynik jest wypychany na stosie.  
  
 Instrukcja przenosi wartość ( `int32` `int64` Type lub`native int`) w lewo o określoną liczbę bitów. `shl` Liczba bitów jest wartością typu `int32` lub. `native int` Wartość zwracana jest nieokreślona, jeśli liczba bitów do przesunięcia jest większa lub równa szerokości (w bitach) podanej wartości.  
  
 `Shl`Wstawia zerowy bit w najmniejszej pozycji na każdej przesunięcia.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `shl` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przenosi wartość całkowitą (w znak) o prawo o określoną liczbę bitów, wypychając wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|63|SHR|Przesuwa liczbę całkowitą do prawej strony (przesunięcie w znak).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość jest wypychana do stosu.  
  
2.  Liczba bitów do przesunięcia jest wypychana do stosu.  
  
3.  Liczba bitów, które mają zostać przesunięte, a wartość to zdjęte ze stosu; wartość jest przesunięta w prawo o określoną liczbę bitów.  
  
4.  Wynik jest wypychany na stosie.  
  
 Instrukcja przesuwa wartość ( `int32` `int64` Type lub`native int`) bezpośrednio przez określoną liczbę bitów. `shr.un` Liczba bitów jest wartością typu `int32` lub. `native int` Wartość zwracana jest nieokreślona, jeśli liczba bitów do przesunięcia jest większa lub równa szerokości (w bitach) podanej wartości.  
  
 `Shr`replikuje bit wysokiej kolejności przy każdej zmianie, zachowując znak oryginalnej wartości w `result`.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `shr` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przesuwa liczbę całkowitą bez znaku (w zerach) z prawej strony o określoną liczbę bitów, wypychając wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|64|SHR. un|Przesuwa liczbę całkowitą do prawej strony (przesunięcie w zerach).|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość jest wypychana do stosu.  
  
2.  Liczba bitów do przesunięcia jest wypychana do stosu.  
  
3.  Liczba bitów, które mają zostać przesunięte, a wartość to zdjęte ze stosu; wartość jest przesunięta w prawo o określoną liczbę bitów.  
  
4.  Wynik jest wypychany na stosie.  
  
 Instrukcja przesuwa wartość ( `int32` `int64` Type lub`native int`) bezpośrednio przez określoną liczbę bitów. `shr.un` Liczba bitów jest wartością typu `int32` `int64` lub `native int`. Wartość zwracana jest nieokreślona, jeśli liczba bitów do przesunięcia jest większa lub równa szerokości (w bitach) podanej wartości.  
  
 `Shr.un`Wstawia zerowy bit w najwyższej pozycji w każdej przesunięciu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `shr.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wypchnięcie rozmiaru, w bajtach, dla podanego typu wartości na stos szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|sizeof`valType`|Wypchnij rozmiar (w bajtach) typu wartości jako `unsigned int32`.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Rozmiar (w bajtach) podanego typu wartości (`valType`) jest wypychany na stosie.  
  
 `valType`musi być tokenem metadanych (a `typeref` lub `typedef`), który określa typ wartości, typ odwołania lub parametr typu ogólnego.  
  
 W przypadku typu odwołania zwracanym rozmiarem jest rozmiar wartości odniesienia odpowiedniego typu (4 bajty w systemach 32-bitowych), a nie rozmiar danych przechowywanych w obiektach, do których odwołuje się wartość referencyjna. Parametru typu ogólnego można używać tylko w treści typu lub metody, która go definiuje. Gdy ten typ lub metoda jest tworzona, parametr typu ogólnego jest zastępowany przez typ wartości lub typ referencyjny.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `sizeof` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość na górze stosu oceny w gnieździe argumentu w określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` >|starg`num`|Wystawia górną wartość ze stosu i zapisuje ją w gnieździe `num`argumentu.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość znajdująca się na szczycie stosu jest zdjęte i umieszczona w gnieździe `num`argumentu.  
  
 Instrukcja wystawia wartość ze stosu i umieści ją w gnieździe `num`argumentu. `starg` Typ wartości musi być zgodny z typem argumentu, jak określono w podpisie bieżącej metody.  
  
 W przypadku procedur, które pobierają listę argumentów zmiennych `starg` , instrukcja może być używana tylko dla początkowych argumentów stałych, a nie dla zmiennych części sygnatury.  
  
 Przeprowadzenie zapisu w argumentach, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcina wartość w miarę przenoszenia z stosu do argumentu. Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `starg` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, krótkie)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość na górze stosu oceny w gnieździe argumentu w określonym indeksie, skróconej postaci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg. s`num`|Wystawia najwyższą wartość ze stosu i zapisuje ją w gnieździe `num`argumentów, krótką formą.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość znajdująca się na szczycie stosu jest zdjęte i umieszczona w gnieździe `num`argumentu.  
  
 Instrukcja wystawia wartość ze stosu i umieści ją w gnieździe `num`argumentu. `starg.s` Typ wartości musi być zgodny z typem argumentu, jak określono w podpisie bieżącej metody.  
  
 `starg.s` Instrukcja zapewnia wydajne kodowanie do użycia z pierwszych 256 argumentów.  
  
 W przypadku procedur, które pobierają listę argumentów zmiennych `starg.s` , instrukcja może być używana tylko dla początkowych argumentów stałych, a nie dla zmiennych części sygnatury.  
  
 Przeprowadzenie zapisu w argumentach, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcina wartość w miarę przenoszenia z stosu do argumentu. Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `starg.s` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zastępuje element Array w danym indeksie wartością na stosie ewaluacyjnym, którego typ jest określony w instrukcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|< A4`T` >|stelem`typeTok`|Zamienia element array na podany indeks o wartości typu `typeTok` na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.  
  
2.  Wartość `index`indeksu, do elementu w `array` jest wypychana na stosie.  
  
3.  Wartość typu określonego w instrukcji jest wypychana do stosu.  
  
4.  Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.  
  
 Instrukcja zastępuje wartość elementu w dostarczonym indeksie liczonym od zera w tablicy `array` jednowymiarowej z wartością. `stelem` Wartość ma typ określony przez token `typeTok` w instrukcji.  
  
 Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zastępuje element Array w danym indeksie <see langword="native int" /> wartością na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9B|stelem.i|Zastępuje element tablicy w podanym indeksie `native int` wartością na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.  
  
2.  Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.  
  
3.  Wartość jest wypychana do stosu.  
  
4.  Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.  
  
 Instrukcja zastępuje wartość elementu `index` w `array` tablicy`native int` jednowymiarowej wartością wypychaną na stos. `stelem.i`  
  
 Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.i` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zastępuje element Array w danym indeksie <see langword="int8" /> wartością na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|Zastępuje element tablicy w podanym indeksie `int8` wartością na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.  
  
2.  Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.  
  
3.  Wartość jest wypychana do stosu.  
  
4.  Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.  
  
 Instrukcja zastępuje wartość elementu `index` w `array` tablicy`int8` jednowymiarowej wartością wypychaną na stos. `stelem.i1`  
  
 Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.i1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zastępuje element Array w danym indeksie <see langword="int16" /> wartością na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|Zastępuje element tablicy w podanym indeksie `int16` wartością na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.  
  
2.  Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.  
  
3.  Wartość jest wypychana do stosu.  
  
4.  Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.  
  
 Instrukcja zastępuje wartość elementu `index` w `array` tablicy`int16` jednowymiarowej wartością wypychaną na stos. `stelem.i2`  
  
 Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.i2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zastępuje element Array w danym indeksie <see langword="int32" /> wartością na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|Zastępuje element tablicy w podanym indeksie `int32` wartością na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.  
  
2.  Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.  
  
3.  Wartość jest wypychana do stosu.  
  
4.  Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.  
  
 Instrukcja zastępuje wartość elementu `index` w `array` tablicy`int32` jednowymiarowej wartością wypychaną na stos. `stelem.i4`  
  
 Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.i4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zastępuje element Array w danym indeksie <see langword="int64" /> wartością na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|Zastępuje element tablicy w podanym indeksie `int64` wartością na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.  
  
2.  Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.  
  
3.  Wartość jest wypychana do stosu.  
  
4.  Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.  
  
 Instrukcja zastępuje wartość elementu `index` w `array` tablicy`int64` jednowymiarowej wartością wypychaną na stos. `stelem.i8`  
  
 Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.i8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zastępuje element Array w danym indeksie <see langword="float32" /> wartością na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|Zastępuje element tablicy w podanym indeksie `float32` wartością na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.  
  
2.  Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.  
  
3.  Wartość jest wypychana do stosu.  
  
4.  Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.  
  
 Instrukcja zastępuje wartość elementu `index` w `array` tablicy`float32` jednowymiarowej wartością wypychaną na stos. `stelem.r4`  
  
 Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.r4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zastępuje element Array w danym indeksie <see langword="float64" /> wartością na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|Zastępuje element tablicy w podanym indeksie `float64` wartością na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.  
  
2.  Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.  
  
3.  Wartość jest wypychana do stosu.  
  
4.  Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.  
  
 Instrukcja zastępuje wartość elementu `index` w `array` tablicy`float64` jednowymiarowej wartością wypychaną na stos. `stelem.r8`  
  
 Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`. Indeks jest typem `native int`.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.r8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia element Array w danym indeksie na wartość Ref obiektu (Type <see langword="O" />) na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|Zastępuje element tablicy w podanym indeksie `ref` wartością (typ `O`) na stosie.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.  
  
2.  Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.  
  
3.  Wartość jest wypychana do stosu.  
  
4.  Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.  
  
 Instrukcja zastępuje wartość elementu w podanym indeksie w tablicy `array` jednowymiarowej o `ref` wartości (Type `O`) wypchnięcia na stosie. `stelem.ref`  
  
 Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`. Indeks jest typem `native int`.  
  
 Należy zauważyć `stelem.ref` , że niejawnie rzutuje podaną wartość na `array` typ elementu przed przypisaniem wartości do elementu Array. To rzutowanie może zakończyć się niepowodzeniem, nawet w przypadku zweryfikowanego kodu. W `stelem.ref` rezultacie instrukcja może zgłosić <xref:System.InvalidCastException>. W przypadku tablic jednowymiarowych, które nie są oparte na zerach i dla <xref:System.Array> tablic wielowymiarowych, <xref:System.Array.SetValue%2A> Klasa udostępnia metodę.  
  
 <xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.  
  
 <xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.  
  
 <xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.ref` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zamienia wartość przechowywaną w polu odwołania do obiektu lub wskaźnika z nową wartością.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld`field`|Zamienia wartość `field` obiektu na nową wartość.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu lub wskaźnik jest wypychany do stosu.  
  
2.  Wartość jest wypychana do stosu.  
  
3.  Wartość i odwołanie do obiektu/wskaźnik są zdjęte ze stosu; wartość `field` w obiekcie jest zastępowana podaną wartością.  
  
 `native int` `O` `*` `&`Instrukcja zastępuje wartość pola obiektu (typu) lub za pośrednictwem wskaźnika (typu, lub) z daną wartością. `stfld` `Field`jest tokenem metadanych, który odwołuje się do odwołania do elementu członkowskiego pola. Instrukcja może mieć prefiks jednego lub obu elementów <xref:System.Reflection.Emit.OpCodes.Unaligned> i <xref:System.Reflection.Emit.OpCodes.Volatile>. `stfld`  
  
 <xref:System.NullReferenceException>jest zgłaszany, jeśli odwołanie do obiektu lub wskaźnik jest odwołaniem null, a pole nie jest statyczne.  
  
 <xref:System.MissingFieldException>jest zgłaszany `field` , jeśli nie zostanie znaleziony w metadanych. Jest to zwykle sprawdzane, gdy instrukcja języka pośredniego (MSIL) firmy Microsoft jest konwertowana na kod natywny, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stfld` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="native int" /> pod podanym adresem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DF|stind.i|`native int` Przechowuje wartość pod podanym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Wartość jest wypychana do stosu.  
  
3.  Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.  
  
 `&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (Type, lub). `native int` `stind.i`  
  
 Operacja bezpiecznego typu wymaga, aby `stind.i` instrukcja była używana w sposób spójny z typem wskaźnika. Operację `stind.i` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.  
  
 <xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.i` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="int8" /> pod podanym adresem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|52|stind. I1|`int8` Przechowuje wartość pod podanym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Wartość jest wypychana do stosu.  
  
3.  Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.  
  
 `&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (typu, lub). `int8` `stind.i1`  
  
 Operacja bezpiecznego typu wymaga, aby `stind.i1` instrukcja była używana w sposób spójny z typem wskaźnika. Operację `stind.i1` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.  
  
 <xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.i1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="int16" /> pod podanym adresem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|53|stind. I2|`int16` Przechowuje wartość pod podanym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Wartość jest wypychana do stosu.  
  
3.  Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.  
  
 `&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (typu, lub). `int16` `stind.i2`  
  
 Operacja bezpiecznego typu wymaga, aby `stind.2i` instrukcja była używana w sposób spójny z typem wskaźnika. Operację `stind.i2` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.  
  
 <xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.i2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="int32" /> pod podanym adresem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|54|stind.i4|`int32` Przechowuje wartość pod podanym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Wartość jest wypychana do stosu.  
  
3.  Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.  
  
 `&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (typu, lub). `int32` `stind.i4`  
  
 Operacja bezpiecznego typu wymaga, aby `stind.i4` instrukcja była używana w sposób spójny z typem wskaźnika. Operację `stind.i4` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.  
  
 <xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.i4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="int64" /> pod podanym adresem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|55|stind.i8|`int64` Przechowuje wartość pod podanym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Wartość jest wypychana do stosu.  
  
3.  Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.  
  
 `&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (typu, lub). `int64` `stind.i8`  
  
 Operacja bezpiecznego typu wymaga, aby `stind.i8` instrukcja była używana w sposób spójny z typem wskaźnika. Operację `stind.i` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.  
  
 <xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.i8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="float32" /> pod podanym adresem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|56|stind.r4|`float32` Przechowuje wartość pod podanym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Wartość jest wypychana do stosu.  
  
3.  Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.  
  
 `&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (Type, lub). `float32` `stind.r4`  
  
 Operacja bezpiecznego typu wymaga, aby `stind.r4` instrukcja była używana w sposób spójny z typem wskaźnika. Operację `stind.r4` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.  
  
 <xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.r4` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość typu <see langword="float64" /> pod podanym adresem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|57|stind.r8|`float64` Przechowuje wartość pod podanym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Wartość jest wypychana do stosu.  
  
3.  Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.  
  
 `&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (Type, lub). `float64` `stind.r8`  
  
 Operacja bezpiecznego typu wymaga, aby `stind.r8` instrukcja była używana w sposób spójny z typem wskaźnika. Operację `stind.r8` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.  
  
 <xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.r8` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje wartość odwołania do obiektu pod podanym adresem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|51|stind.ref|Przechowuje wartość odwołania do obiektu ( `O`Type) pod podanym adresem.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Wartość jest wypychana do stosu.  
  
3.  Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.  
  
 Instrukcja przechowuje wartość odwołania do obiektu pod podanym adresem (typu `native int`, `*`lub `&`). `stind.ref`  
  
 Operacja bezpiecznego typu wymaga, aby `stind.ref` instrukcja była używana w sposób spójny z typem wskaźnika. Operację `stind.ref` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.  
  
 <xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.ref` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pop bieżącą wartość od góry stosu oceny i zapisuje ją na liście zmiennych lokalnych pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|stloc`index`|Pop wartość ze stosu i zapisuje ją w zmiennej `index`lokalnej.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość jest zdjęte na stosie i umieszczona w zmiennej `index`lokalnej.  
  
 Instrukcja wystawia górną wartość na stosie szacowania i przenosi ją do lokalnego numeru `index`zmiennej, gdzie zmienne lokalne są numerowane od 0 do wewnątrz. `stloc` Typ wartości musi być zgodny z typem zmiennej lokalnej, jak określono w lokalnym podpisie metody.  
  
 Przechowywanie w zmiennych lokalnych, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcinają wartość w miarę przenoszenia ze stosu do zmiennej lokalnej. Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.  
  
 Poprawne instrukcje języka pośredniego firmy Microsoft (MSIL `index` ) wymagają, aby był prawidłowym indeksem lokalnym. `stloc` Dla`index` instrukcji musi znajdować się w zakresie od 0 do 65534 włącznie (w odniesieniu do 65535 jest nieprawidłowy). Przyczyna wykluczenia 65535 jest pragmatyczna: prawdopodobnie implementacje będą używały 2-bajtowej liczby całkowitej do śledzenia zarówno lokalnego indeksu, jak i łącznej liczby elementów lokalnych danej metody. Jeśli indeks 65535 był prawidłowy, będzie wymagał szerszej liczby całkowitej do śledzenia liczby elementów lokalnych w takiej metodzie.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `stloc` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, LocalBuilder)  
  
-   Elemencie ILGenerator. emisji (OpCode, krótkie)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pop bieżąca wartość od góry stosu oceny i zapisuje ją na liście zmiennych lokalnych pod indeksem 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0A|stloc. 0|Pop wartość ze stosu do zmiennej lokalnej 0.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość jest zdjęte na stosie i umieszczona w zmiennej lokalnej indeksowane przez 0.  
  
 `stloc.0` Instrukcja wystawia górną wartość na stosie szacowania i przenosi ją do zmiennej lokalnej indeksowanej przez 0. Typ wartości musi być zgodny z typem zmiennej lokalnej, jak określono w lokalnym podpisie metody.  
  
 `stloc.0`jest szczególnie wydajnym kodowaniem do przechowywania wartości w zmiennej lokalnej 0.  
  
 Przechowywanie w zmiennych lokalnych, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcinają wartość w miarę przenoszenia ze stosu do zmiennej lokalnej. Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stloc.0` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pop bieżąca wartość od góry stosu oceny i zapisuje ją na liście zmiennych lokalnych pod indeksem 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0B|stloc. 1|Pop wartość ze stosu do zmiennej lokalnej 1.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość jest zdjęte na stosie i umieszczona w zmiennej lokalnej indeksowanej przez 1.  
  
 `stloc.1` Instrukcja wystawia górną wartość na stosie szacowania i przenosi ją do zmiennej lokalnej indeksowanej przez 1. Typ wartości musi być zgodny z typem zmiennej lokalnej, jak określono w lokalnym podpisie metody.  
  
 `stloc.1`jest szczególnie wydajnym kodowaniem do przechowywania wartości w zmiennej lokalnej 1.  
  
 Przechowywanie w zmiennych lokalnych, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcinają wartość w miarę przenoszenia ze stosu do zmiennej lokalnej. Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stloc.1` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pop bieżąca wartość od góry stosu oceny i zapisuje ją na liście zmiennych lokalnych pod indeksem 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0C|stloc. 2|Pop wartość ze stosu do zmiennej lokalnej 2|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość jest zdjęte na stosie i umieszczona w zmiennej lokalnej indeksowanej przez 2.  
  
 `stloc.2` Instrukcja wystawia górną wartość na stosie szacowania i przenosi ją do zmiennej lokalnej indeksowanej przez 2. Typ wartości musi być zgodny z typem zmiennej lokalnej, jak określono w lokalnym podpisie metody.  
  
 `stloc.2`jest szczególnie wydajnym kodowaniem do przechowywania wartości w zmiennej lokalnej 2.  
  
 Przechowywanie w zmiennych lokalnych, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcinają wartość w miarę przenoszenia ze stosu do zmiennej lokalnej. Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stloc.2` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pop bieżąca wartość od góry stosu oceny i zapisuje ją na liście zmiennych lokalnych pod indeksem 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|0D|stloc. 3|Pop wartość ze stosu do zmiennej lokalnej 3|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość jest zdjęte na stosie i umieszczona w zmiennej lokalnej indeksowanej przez 3.  
  
 `stloc.3` Instrukcja wystawia górną wartość na stosie szacowania i przenosi ją do zmiennej lokalnej indeksowanej przez 3. Typ wartości musi być zgodny z typem zmiennej lokalnej, jak określono w lokalnym podpisie metody.  
  
 `stloc.3`jest szczególnie wydajnym kodowaniem do przechowywania wartości w zmiennej lokalnej 3.  
  
 Przechowywanie w zmiennych lokalnych, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcinają wartość w miarę przenoszenia ze stosu do zmiennej lokalnej. Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stloc.3` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pop bieżącą wartość od góry stosu oceny i zapisuje ją na liście zmiennych lokalnych w <paramref name="index" /> (krótka wersja).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc. s`index`|Pop wartość ze stosu i zapisuje ją w zmiennej `index`lokalnej, skróconej postaci.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość jest zdjęte na stosie i umieszczona w zmiennej `index`lokalnej.  
  
 Instrukcja wystawia górną wartość na stosie szacowania i przenosi ją do lokalnego numeru `index`zmiennej, gdzie zmienne lokalne są numerowane od 0 do wewnątrz. `stloc.s` Typ wartości musi być zgodny z typem zmiennej lokalnej, jak określono w lokalnym podpisie metody.  
  
 `stloc.s` Instrukcja zapewnia wydajne kodowanie zmiennych lokalnych od 0 do 255.  
  
 Przechowywanie w zmiennych lokalnych, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcinają wartość w miarę przenoszenia ze stosu do zmiennej lokalnej. Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `stloc.s` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, LocalBuilder)  
  
-   Elemencie ILGenerator. emisji (OpCode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiuje wartość określonego typu ze stosu oceny do podanego adresu pamięci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Przechowuje wartość typu `class` ze stosu do pamięci.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
2.  Obiekt typu wartości typu `class` jest wypychany do stosu.  
  
3.  Obiekt i adres są zdjęte ze stosu; Obiekt typu wartości jest przechowywany w adresie.  
  
 Instrukcja kopiuje obiekt typu wartości do adresu określonego przez adres (wskaźnik typu `native int`, `*`lub `&`). `stobj` Liczba kopiowanych bajtów zależy od rozmiaru klasy reprezentowanej przez `class`, tokenu metadanych reprezentującego typ wartości.  
  
 Operację `stobj` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.  
  
 <xref:System.TypeLoadException>jest zgłaszany, jeśli nie można znaleźć klasy. Jest to zwykle wykrywane, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stobj` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zastępuje wartość pola statycznego wartością ze stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld`field`|Zamienia wartość `field` przy użyciu podanej wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość jest wypychana do stosu.  
  
2.  Wartość jest zdjęte ze stosu i przechowywana w `field`.  
  
 `stsfld` Instrukcja zastępuje wartość pola statycznego wartością ze stosu. `field`jest tokenem metadanych, który musi odwoływać się do statycznego elementu członkowskiego pola.  
  
 Instrukcja może być poprzedzona przez <xref:System.Reflection.Emit.OpCodes.Volatile>. `stsfld`  
  
 <xref:System.MissingFieldException>jest zgłaszany, jeśli nie znaleziono pola w metadanych. Jest to zazwyczaj zaznaczone, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stsfld` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Odejmuje jedną wartość od drugiej i wypycha wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|59|sub|Odejmuje jedną wartość od innej, zwracając nową wartość liczbową.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; jest odejmowany od `value1`. `value2`  
  
4.  Wynik jest wypychany na stosie.  
  
 Nie wykryto przepełnienia dla operacji całkowitych (Aby uzyskać prawidłową <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>obsługę przepełnienia, zobacz).  
  
 Zawijanie liczb całkowitych, a nie nasycenie. Na przykład: przy założeniu 8-bitowych liczb całkowitych, gdzie `value1` jest ustawiona na 0 i `value2` jest ustawiona na 1, wynik "opakowany" będzie 255.  
  
 Przepełnienie zmiennoprzecinkowe `+inf` zwraca`PositiveInfinity`() `-inf` lub`NegativeInfinity`().  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `sub` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Odejmuje jedną wartość całkowitą od innej, wykonuje sprawdzanie przepełnienia i wypycha wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DA|sub.ovf|Odejmuje jedną wartość całkowitą od innej ze sprawdzaniem przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; jest odejmowany od `value1` do sprawdzenia przepełnienia. `value2`  
  
4.  Wynik jest wypychany na stosie.  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Ta operacja jest wykonywana w przypadku liczb całkowitych ze znakiem; dla wartości zmiennoprzecinkowych Użyj <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `sub.ovf` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Odejmuje jedną liczbę całkowitą bez znaku z innego, wykonuje sprawdzanie przepełnienia i wypycha wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|Odejmuje jedną liczbę całkowitą bez znaku z innej ze sprawdzaniem przepełnienia.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte ze stosu; jest odejmowany od `value1` do sprawdzenia przepełnienia. `value2`  
  
4.  Wynik jest wypychany na stosie.  
  
 <xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.  
  
 Ta operacja jest wykonywana w przypadku liczb całkowitych ze znakiem; dla wartości zmiennoprzecinkowych Użyj <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `sub.ovf.un` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implementuje tabelę skoku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... <`int32` >|Przełącz (`N`, `t1`, `t2`... `tN`)|Skacze do jednej `N` z wartości.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Wartość jest wypychana do stosu.  
  
2.  Wartość jest zdjęte na stosie, a wykonywanie jest przenoszone do instrukcji w przesunięciu indeksowanym przez wartość, gdzie wartość jest mniejsza niż `N`.  
  
 `switch` Instrukcja implementuje tabelę skoku. Format instrukcji jest `unsigned int32` reprezentujący liczbę elementów docelowych `N`, po których następuje `N` wartość Int32 określająca cele skoku. Te elementy docelowe są reprezentowane jako przesunięcia (dodatnie lub ujemne) od początku instrukcji zgodnie z tą `switch` instrukcją.  
  
 Instrukcja umieszcza wartość na stosie i porównuje ją, jako liczbę całkowitą bez znaku, do `N`. `switch` Jeśli wartość jest mniejsza niż `N`, wykonanie jest transferowane do obiektu docelowego indeksowanego przez wartość, gdzie cele są numerowane od 0 (na przykład wartość 0 przyjmuje pierwszy element docelowy, a wartość 1 przyjmuje drugi element docelowy itd.). Jeśli wartość jest większa lub równa `N`, wykonanie kontynuuje się przy następnej instrukcji (przekroczenie).  
  
 Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.  
  
 Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i. (Takie transfery są poważnie ograniczone i należy zamiast tego użyć instrukcji Opuść).  
  
 Poniższe <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `switch` używać kodu operacji. `Label[]` Argument jest tablicą etykiet reprezentujących przesunięcie 32-bitowe.  
  
-   Elemencie ILGenerator. emisji (OpCode, etykieta [])  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje użycie `Switch` kodu w celu wygenerowania tabeli skoku przy użyciu <xref:System.Reflection.Emit.Label>tablicy.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wykonuje instrukcję wywoływanego wywołania metody w taki sposób, aby ramka stosu bieżącej metody została usunięta przed wykonaniem rzeczywistej instrukcji wywołania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 14|drugorzędn.|Kolejne wywołanie kończy bieżące metody|  
  
 Nie ma żadnego zachowania przejścia stosu zdefiniowanego dla tej instrukcji.  
  
 Instrukcja prefiksu musi występować bezpośrednio <xref:System.Reflection.Emit.OpCodes.Call>przed instrukcją, <xref:System.Reflection.Emit.OpCodes.Callvirt> <xref:System.Reflection.Emit.OpCodes.Calli>, lub. `tail` Wskazuje, że ramka stosu bieżącej metody powinna zostać usunięta przed wykonaniem instrukcji Call. Oznacza to również, że wartość zwracana z następującego wywołania jest również wartością zwracaną przez bieżącą metodę, a wywołanie może zostać przekonwertowane na uskok metody krzyżowej.  
  
 Stos musi być pusty, z wyjątkiem argumentów, które są transferowane przez następujące wywołanie. Instrukcja po instrukcji Call musi być RET. W związku z tym jedyną prawidłową sekwencją kodu `calli` jest `callvirt` `tail. call` (lub lub). Poprawne instrukcje języka pośredniego firmy Microsoft (MSIL) nie mogą `call` odgałęziać do instrukcji, ale może odgałęziać się do kolejnego <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 Nie można odrzucić bieżącej ramki, gdy kontrolka jest przekazywana z niezaufanego kodu do zaufanego kodu, ponieważ mogłoby to spowodować zagrożenie dla kodu zabezpieczenia tożsamości. W związku z tym sprawdzanie zabezpieczeń .NET Framework może `tail` spowodować zignorowanie i pozostawienie standardowej <xref:System.Reflection.Emit.OpCodes.Call> instrukcji. Podobnie, aby zezwolić na zakończenie synchronizowanego regionu po wywołaniu wywołania, `tail` prefiks jest ignorowany, gdy jest używany do zamykania metody oznaczonej jako zsynchronizowane.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `tail` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Wystąpienie obiektu opcode.</param>
        <summary>Zwraca wartość true lub false, jeśli podany element opcode przyjmuje jednobajtowy argument.</summary>
        <returns><see langword="true" />lub <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do znajdowania, które kody operacji MSIL są "krótkie", do użycia w zoptymalizowanym kodzie.  
  
 `TakesSingleByteArgument``true` zwraca<xref:System.Reflection.Emit.OpCode> czy wystąpienie przyjmuje jeden dwubajtowy argument w następujących przypadkach:  
  
-   Kod operacji wykonuje instrukcję Branch dla adresu o rozmiarze bajtowym (na przykład <xref:System.Reflection.Emit.OpCodes.Br_S> i <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   Kod operacji wypchnij wartość bajtową na stos (na przykład <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   Kod operacji odwołuje się do zmiennej lub argumentu za pośrednictwem skróconej formy o rozmiarze bajtowym ( <xref:System.Reflection.Emit.OpCodes.Ldloc_S> na <xref:System.Reflection.Emit.OpCodes.Stloc_S>przykład i).  
  
 W przeciwnym razie zwraca `false`.  
  
 W poniższym przykładzie pokazano `TakesSingleByteArgument` `OpCodes` sposób użycia przez odzwierciedlenie w klasie i testowaniu, aby sprawdzić, czy każde `OpCode` pole przyjmuje jednobajtowy argument.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zgłasza obiekt wyjątku aktualnie na stosie szacowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|7A|throw|Zgłasza wyjątek.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu (do wyjątku) jest wypychane na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte ze stosu i zgłoszono wyjątek.  
  
 Instrukcja zgłasza obiekt wyjątku (Type `O`) aktualnie na stosie. `throw`  
  
 <xref:System.NullReferenceException>jest zgłaszany, jeśli odwołanie do obiektu jest odwołaniem o wartości null.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `throw` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, że adres, który obecnie korzystającego stosu oceny, może nie być wyrównany do naturalnego <see langword="ldind" />rozmiaru bezpośrednio następującego, <see langword="stind" /> <see langword="ldfld" /> <see langword="initblk" />, <see langword="stfld" /> <see langword="ldobj" /> <see langword="stobj" />,,, lub <see langword="cpblk" /> instrukcja.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 12 < `unsigned int8` >|niewyrównany. `alignment`|Wskazuje, że dalsza instrukcja wskaźnika może być niewyrównana.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
 `Unaligned`Określa, że adres (niezarządzany wskaźnik `native int`,) na stosie, może nie być wyrównany do naturalnego rozmiaru bezpośrednio następujących `ldobj` `ldind` `stobj`, `stind` `ldfld` `stfld`,,,, `initblk` lub`cpblk` instrukcji. Oznacza to, że w <xref:System.Reflection.Emit.OpCodes.Ldind_I4> przypadku instrukcji wyrównanie adresu nie może być do 4-bajtowej granicy. Dla `initblk` i`cpblk` domyślne wyrównanie jest zależne od architektury (4 bajty na 32-bitowych procesorach CPU, 8-bajtowych na 64-bitowych procesorach). Generatory kodu, które nie ograniczają danych wyjściowych do 32-bitowego rozmiaru wyrazu, muszą być używane `unaligned` , jeśli wyrównanie nie jest znane w czasie kompilacji do 8-bajtowego.  
  
 Wartość wyrównania musi być równa 1, 2 lub 4 i oznacza, że wygenerowany kod powinien przyjąć, że adres jest odpowiednio bajtowy, dwubajtowy lub cztery bajty. Należy zauważyć, że wskaźniki przejściowe (Type `*`) są zawsze wyrównane.  
  
 Mimo że wyrównanie `cpblk` instrukcji logicznej wymaga dwóch liczb (jeden dla źródła i jeden dla miejsca docelowego), nie ma zauważalnego wpływu na wydajność, jeśli określono tylko niższą liczbę.  
  
 Prefiksy `volatile` i mogą być łączone w dowolnej kolejności. `unaligned` Muszą one bezpośrednio poprzedzać `ldind`instrukcje `stind`, `ldfld` `stfld` `stobj`,,, `ldobj`,, lub`cpblk` . `initblk` Tylko prefiks jest dozwolony <xref:System.Reflection.Emit.OpCodes.Ldsfld> dla instrukcji i <xref:System.Reflection.Emit.OpCodes.Stsfld>. <xref:System.Reflection.Emit.OpCodes.Volatile>  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `unaligned` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
-   Elemencie ILGenerator. emisji (opcode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje opakowaną reprezentację typu wartości na postać nieopakowaną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|79 < `T` >|Unbox`valType`|Wyodrębnia dane typu wartości z, `obj`w zapakowanym obszarze.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie do obiektu jest wypychane na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte z stosu i rozpakowane do wskaźnika typu wartości.  
  
3.  Wskaźnik typu wartości jest wypychany do stosu.  
  
 Typ wartości ma dwie oddzielne reprezentacje w Common Language Infrastructure (interfejs wiersza polecenia):  
  
-   Formularz "RAW" używany, gdy typ wartości jest osadzony w innym obiekcie.  
  
-   Formularz "opakowany", w którym dane w typie wartości są opakowane (opakowane) do obiektu, tak aby mógł istnieć jako niezależna jednostka.  
  
 Instrukcja konwertuje odwołanie do obiektu (typ `O`), opakowaną reprezentację typu wartości do wskaźnika typu wartości (zarządzany wskaźnik, typ `&`), jego nieopakowany formularz. `unbox` Podany typ wartości (`valType`) jest tokenem metadanych wskazującym typ wartości, która znajduje się w zapakowanym obiekcie.  
  
 W przeciwieństwie <xref:System.Reflection.Emit.OpCodes.Box>do, co jest wymagane, aby utworzyć kopię typu wartości do użycia w obiekcie, `unbox` nie jest wymagana do kopiowania typu wartości z obiektu. Zwykle po prostu oblicza adres typu wartości, który jest już obecny w obiekcie zapakowanym.  
  
 <xref:System.InvalidCastException>jest zgłaszany, jeśli obiekt nie jest opakowany jako `valType`.  
  
 <xref:System.NullReferenceException>jest zgłaszany, jeśli odwołanie do obiektu jest odwołaniem o wartości null.  
  
 <xref:System.TypeLoadException>jest zgłaszany, jeśli nie `valType` można znaleźć typu wartości. Jest to zwykle wykrywane, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `unbox` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konwertuje opakowaną reprezentację typu określonego w instrukcji na postać nieopakowaną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|A5 < `T` >|Unbox. any`typeTok`|Wyodrębnij dane z `obj`, zapakowanych reprezentacji.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Odwołanie `obj` do obiektu jest wypychane na stosie.  
  
2.  Odwołanie do obiektu jest zdjęte z stosu i rozpakowane do typu określonego w instrukcji.  
  
3.  Typ referencyjny lub odwołanie do obiektu jest wypychany do stosu.  
  
 W `unbox.any` przypadku zastosowania do formy opakowanej typu wartości instrukcja wyodrębnia wartość zawartej w `obj` (typu `O`) i dlatego jest równoznaczna z `unbox` operatorem `ldobj`.  
  
 W przypadku zastosowania do typu `unbox.any` odwołania instrukcja ma ten sam skutek co. `castclass` `typeTok`  
  
 Jeśli argument `typeTok` jest parametrem typu ogólnego, zachowanie środowiska uruchomieniowego jest określane przez typ określony dla tego parametru typu ogólnego.  
  
 <xref:System.InvalidCastException>jest zgłaszany `obj` , jeśli nie jest typu opakowanego.  
  
 <xref:System.NullReferenceException>jest zgłaszany `obj` , jeśli jest odwołaniem o wartości null.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `unbox.any` używać kodu operacji:  
  
-   Elemencie ILGenerator. emisji (OpCode, typ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że adres, który jest obecnie korzystającego stosu oceny, może być nietrwały, a wyniki odczytywania tej lokalizacji nie mogą być buforowane lub nie można pominąć wielu magazynów dla tej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|FE 13|volatile.|Wskazuje, że kolejne odwołanie do wskaźnika jest nietrwałe.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  Adres jest wypychany na stosie.  
  
 `volatile`. Określa, że adres jest adresem nietrwałym (oznacza to, że można odwoływać się zewnętrznie do bieżącego wątku wykonywania) i wyniki odczytywania tej lokalizacji nie mogą być buforowane lub nie można pominąć wielu magazynów dla tej lokalizacji. Oznaczanie dostępu jako `volatile` ma wpływ tylko na jeden dostęp; inne dostęp do tej samej lokalizacji muszą być oznaczone osobno. Dostęp do lokalizacji nietrwałych nie musi być wykonywany niepodzielnie.  
  
 Prefiksy `volatile` i mogą być łączone w dowolnej kolejności. <xref:System.Reflection.Emit.OpCodes.Unaligned> Muszą one bezpośrednio poprzedzać `ldind`instrukcje `stind`, `ldfld` `stfld` `stobj`,,, `ldobj`,, lub`cpblk` . `initblk` Tylko prefiks jest dozwolony <xref:System.Reflection.Emit.OpCodes.Ldsfld> dla instrukcji i <xref:System.Reflection.Emit.OpCodes.Stsfld>. `volatile`  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `volatile` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oblicza bitową wartość XOR dla pierwszych dwóch wartości na stosie oceny, wypychając wynik do stosu oceny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:  
  
|Format|Format zestawu|Opis|  
|------------|---------------------|-----------------|  
|61|xor|Oblicza bitową XOR z dwóch wartości całkowitych i zwraca liczbę całkowitą.|  
  
 Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:  
  
1.  `value1`jest wypychany na stosie.  
  
2.  `value2`jest wypychany na stosie.  
  
3.  `value2`i `value1` są zdjęte z stosu i obliczone przez niego bitowe XOR.  
  
4.  Bitowe XOR `value2` i `value1` jest wypychane na stosie.  
  
 `xor` Instrukcja oblicza bitową wartość XOR dla pierwszych dwóch wartości na stosie i pozostawia wynik na stosie.  
  
 `Xor`jest operacją specyficzną dla liczby całkowitej.  
  
 Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `xor` używać kodu operacji:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

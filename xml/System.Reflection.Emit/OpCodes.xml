<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aea33b9e902b909e4adf9f543fadb5190ce68f9b" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69109971" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a1c4a-101">Zawiera informacje o polu dotyczące emisji języka pośredniego (MSIL) firmy Microsoft w <see cref="T:System.Reflection.Emit.ILGenerator" /> celu przeładunku przez elementy <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />członkowskie klasy (takie jak).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-101">Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <see cref="T:System.Reflection.Emit.ILGenerator" /> class members (such as <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-102">Aby uzyskać szczegółowy opis kodów operacji dla elementów członkowskich, zobacz dokumentację Common Language Infrastructure (CLI), szczególnie "Partition III: Zestaw instrukcji CIL "i" partycja II: Definicja i semantyka metadanych ".</span><span class="sxs-lookup"><span data-stu-id="a1c4a-102">For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="a1c4a-103">Dokumentacja jest dostępna w trybie online; Zobacz [standardy C# ECMA i Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) w MSDN i [Standard ECMA-335-Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w międzynarodowej witrynie sieci Web ECMA.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-103">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1c4a-104">Poniższy przykład demonstruje konstrukcję metody dynamicznej przy użyciu <xref:System.Reflection.Emit.ILGenerator> , aby emitować `OpCodes` <xref:System.Reflection.Emit.MethodBuilder>do.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-104">The following example demonstrates the construction of a dynamic method using <xref:System.Reflection.Emit.ILGenerator> to emit `OpCodes` into a <xref:System.Reflection.Emit.MethodBuilder>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-105">Dodaje dwie wartości i wypycha wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-105">Adds two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-106">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-106">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-107">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-107">Format</span></span>|<span data-ttu-id="a1c4a-108">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-108">Assembly Format</span></span>|<span data-ttu-id="a1c4a-109">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-109">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-110">58</span><span class="sxs-lookup"><span data-stu-id="a1c4a-110">58</span></span>|<span data-ttu-id="a1c4a-111">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-111">add</span></span>|<span data-ttu-id="a1c4a-112">Dodaje dwie wartości liczbowe, zwracając nową wartość liczbową.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-112">Adds two numeric values, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="a1c4a-113">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-113">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-114">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-114">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-115">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-115">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-116">`value2`i `value1` są zdjęte ze stosu; jest dodawany do `value2`. `value1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-116">`value2` and `value1` are popped from the stack; `value1` is added to `value2`.</span></span>  
  
4.  <span data-ttu-id="a1c4a-117">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-117">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-118">Nie wykryto przepełnienia dla operacji całkowitych (Aby uzyskać prawidłową <xref:System.Reflection.Emit.OpCodes.Add_Ovf>obsługę przepełnienia, zobacz).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-118">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span></span>  
  
 <span data-ttu-id="a1c4a-119">Dodawanie wartości całkowitych, a nie nasycenia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-119">Integer addition wraps, rather than saturates.</span></span> <span data-ttu-id="a1c4a-120">Na przykład przy założeniu 8-bitowych liczb całkowitych, gdzie `value1` jest ustawiona na 255 i `value2` ma ustawioną wartość 1, zawinięty wynik to 0, a nie 256.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-120">For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.</span></span>  
  
 <span data-ttu-id="a1c4a-121">Przepełnienie zmiennoprzecinkowe `+inf` zwraca`PositiveInfinity`() `-inf` lub`NegativeInfinity`().</span><span class="sxs-lookup"><span data-stu-id="a1c4a-121">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="a1c4a-122">W poniższej tabeli wymieniono akceptowalne Typy operandów i ich odpowiadający typ danych wynikowych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-122">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="a1c4a-123">Jeśli nie ma wpisu dla konkretnej kombinacji typu (na przykład `int32` i; `float` `int32` i`int64`) jest nieprawidłowym językiem pośrednim firmy Microsoft (MSIL) i generuje błąd.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-123">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</span></span>  
  
|<span data-ttu-id="a1c4a-124">parametru</span><span class="sxs-lookup"><span data-stu-id="a1c4a-124">operand</span></span>|<span data-ttu-id="a1c4a-125">wartość1 — typ</span><span class="sxs-lookup"><span data-stu-id="a1c4a-125">value1 type</span></span>|<span data-ttu-id="a1c4a-126">Typ wartość2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-126">value2 type</span></span>|<span data-ttu-id="a1c4a-127">Typ wyniku</span><span class="sxs-lookup"><span data-stu-id="a1c4a-127">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="a1c4a-128">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-128">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="a1c4a-129">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-129">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="a1c4a-130">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-130">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="a1c4a-131">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-131">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="a1c4a-132">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-132">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="a1c4a-133">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-133">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="a1c4a-134">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-134">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="a1c4a-135">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-135">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="a1c4a-136">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-136">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="a1c4a-137">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-137">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="a1c4a-138">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-138">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="a1c4a-139">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-139">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="a1c4a-140">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-140">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="a1c4a-141">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-141">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="a1c4a-142">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `add` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-142">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-143">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-143">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-144">Dodaje dwie liczby całkowite, wykonuje sprawdzanie przepełnienia i wypycha wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-144">Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-145">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-145">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-146">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-146">Format</span></span>|<span data-ttu-id="a1c4a-147">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-147">Assembly Format</span></span>|<span data-ttu-id="a1c4a-148">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-148">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-149">D6</span><span class="sxs-lookup"><span data-stu-id="a1c4a-149">D6</span></span>|<span data-ttu-id="a1c4a-150">add.ovf</span><span class="sxs-lookup"><span data-stu-id="a1c4a-150">add.ovf</span></span>|<span data-ttu-id="a1c4a-151">Dodaje dwie wartości całkowite ze znakiem i sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-151">Adds two signed integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="a1c4a-152">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-152">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-153">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-153">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-154">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-154">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-155">`value2`i `value1` są zdjęte ze stosu; `value1` dodano do`value2` programu przy użyciu sprawdzenia przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-155">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="a1c4a-156">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-156">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-157"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie jest reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-157"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-158">Tę operację można wykonać w przypadku liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-158">You can perform this operation on signed integers.</span></span> <span data-ttu-id="a1c4a-159">Dla wartości zmiennoprzecinkowych Użyj <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-159">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="a1c4a-160">W poniższej tabeli wymieniono akceptowalne Typy operandów i ich odpowiadający typ danych wynikowych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-160">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="a1c4a-161">Jeśli nie ma wpisu dla konkretnej kombinacji typu (na przykład `int32` i; `float` `int32` i`int64`) jest nieprawidłową instrukcją języka pośredniego firmy Microsoft (MSIL) i generuje błąd.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-161">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="a1c4a-162">parametru</span><span class="sxs-lookup"><span data-stu-id="a1c4a-162">operand</span></span>|<span data-ttu-id="a1c4a-163">wartość1 — typ</span><span class="sxs-lookup"><span data-stu-id="a1c4a-163">value1 type</span></span>|<span data-ttu-id="a1c4a-164">Typ wartość2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-164">value2 type</span></span>|<span data-ttu-id="a1c4a-165">Typ wyniku</span><span class="sxs-lookup"><span data-stu-id="a1c4a-165">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="a1c4a-166">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-166">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="a1c4a-167">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-167">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="a1c4a-168">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-168">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="a1c4a-169">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-169">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="a1c4a-170">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-170">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="a1c4a-171">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-171">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="a1c4a-172">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-172">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="a1c4a-173">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-173">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="a1c4a-174">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-174">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="a1c4a-175">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-175">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="a1c4a-176">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-176">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="a1c4a-177">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-177">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="a1c4a-178">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-178">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="a1c4a-179">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-179">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="a1c4a-180">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `add.ovf` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-181">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-181">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-182">Dodaje dwie wartości bez znaku, wykonuje sprawdzanie przepełnienia i wypycha wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-182">Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-183">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-184">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-184">Format</span></span>|<span data-ttu-id="a1c4a-185">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-185">Assembly Format</span></span>|<span data-ttu-id="a1c4a-186">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-187">D7</span><span class="sxs-lookup"><span data-stu-id="a1c4a-187">D7</span></span>|<span data-ttu-id="a1c4a-188">add.ovf.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-188">add.ovf.un</span></span>|<span data-ttu-id="a1c4a-189">Dodaje dwie wartości unsigned Integer ze sprawdzaniem przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-189">Adds two unsigned integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="a1c4a-190">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-191">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-191">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-192">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-192">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-193">`value2`i `value1` są zdjęte ze stosu; `value1` dodano do`value2` programu przy użyciu sprawdzenia przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-193">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="a1c4a-194">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-194">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-195"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie jest reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-195"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-196">Tę operację można wykonać w przypadku liczb całkowitych ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-196">You can perform this operation on signed integers.</span></span> <span data-ttu-id="a1c4a-197">Dla wartości zmiennoprzecinkowych Użyj <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-197">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="a1c4a-198">W poniższej tabeli wymieniono akceptowalne Typy operandów i ich odpowiadający typ danych wynikowych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-198">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="a1c4a-199">Jeśli nie ma wpisu dla konkretnej kombinacji typu (na przykład `int32` i; `float` `int32` i`int64`) jest nieprawidłową instrukcją języka pośredniego firmy Microsoft (MSIL) i generuje błąd.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-199">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="a1c4a-200">parametru</span><span class="sxs-lookup"><span data-stu-id="a1c4a-200">operand</span></span>|<span data-ttu-id="a1c4a-201">wartość1 — typ</span><span class="sxs-lookup"><span data-stu-id="a1c4a-201">value1 type</span></span>|<span data-ttu-id="a1c4a-202">Typ wartość2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-202">value2 type</span></span>|<span data-ttu-id="a1c4a-203">Typ wyniku</span><span class="sxs-lookup"><span data-stu-id="a1c4a-203">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="a1c4a-204">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-204">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="a1c4a-205">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-205">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="a1c4a-206">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-206">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="a1c4a-207">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-207">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="a1c4a-208">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-208">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="a1c4a-209">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-209">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="a1c4a-210">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-210">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="a1c4a-211">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-211">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="a1c4a-212">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-212">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="a1c4a-213">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-213">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="a1c4a-214">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-214">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="a1c4a-215">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-215">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="a1c4a-216">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-216">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="a1c4a-217">add</span><span class="sxs-lookup"><span data-stu-id="a1c4a-217">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="a1c4a-218">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `add.ovf.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-218">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-219">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-219">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-220">Oblicza wartość bitową i dwie wartości i wypycha wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-220">Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-221">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-221">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-222">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-222">Format</span></span>|<span data-ttu-id="a1c4a-223">Instrukcja</span><span class="sxs-lookup"><span data-stu-id="a1c4a-223">Instruction</span></span>|<span data-ttu-id="a1c4a-224">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-224">Description</span></span>|  
|------------|-----------------|-----------------|  
|<span data-ttu-id="a1c4a-225">5F</span><span class="sxs-lookup"><span data-stu-id="a1c4a-225">5F</span></span>|<span data-ttu-id="a1c4a-226">and</span><span class="sxs-lookup"><span data-stu-id="a1c4a-226">and</span></span>|<span data-ttu-id="a1c4a-227">Określa wartości bitowe i dwie liczby całkowite.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-227">Determines the bitwise AND of two integer values.</span></span>|  
  
 <span data-ttu-id="a1c4a-228">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-228">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-229">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-229">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-230">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-230">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-231">`value1`i `value2` są zdjęte ze stosu; jest obliczana wartość bitowa oraz dwie wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-231">`value1` and `value2` are popped from the stack; the bitwise AND of the two values is computed.</span></span>  
  
4.  <span data-ttu-id="a1c4a-232">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-232">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-233">`and` Instrukcja oblicza bitową i dwie pierwsze wartości na stosie i pozostawia wynik na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-233">The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-234">`And`jest operacją specyficzną dla liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-234">`And` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="a1c4a-235">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `and` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-235">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-236">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-236">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-237">Zwraca niezarządzany wskaźnik do listy argumentów bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-237">Returns an unmanaged pointer to the argument list of the current method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-238">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-238">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-239">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-239">Format</span></span>|<span data-ttu-id="a1c4a-240">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-240">Assembly Format</span></span>|<span data-ttu-id="a1c4a-241">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-241">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-242">FE 00</span><span class="sxs-lookup"><span data-stu-id="a1c4a-242">FE 00</span></span>|<span data-ttu-id="a1c4a-243">arglist</span><span class="sxs-lookup"><span data-stu-id="a1c4a-243">arglist</span></span>|<span data-ttu-id="a1c4a-244">Zwraca dojście listy argumentów dla bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-244">Returns an argument list handle for the current method.</span></span>|  
  
 <span data-ttu-id="a1c4a-245">Ta operacja nie wykonuje żadnych zachowań stosu szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-245">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="a1c4a-246">Instrukcja zwraca nieprzezroczysty uchwyt (niezarządzany wskaźnik typu `native int`) reprezentujący listę argumentów bieżącej metody. `arglist`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-246">The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method.</span></span> <span data-ttu-id="a1c4a-247">To dojście jest prawidłowe tylko w okresie istnienia bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-247">This handle is valid only during the lifetime of the current method.</span></span> <span data-ttu-id="a1c4a-248">Można jednak przekazać dojście do innych metod, o ile bieżąca metoda znajduje się w wątku kontroli.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-248">You can, however, pass the handle to other methods as long as the current method is on the thread of control.</span></span> <span data-ttu-id="a1c4a-249">`arglist` Instrukcję można wykonać tylko w metodzie, która przyjmuje zmienną liczbę argumentów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-249">You can only execute the `arglist` instruction within a method that takes a variable number of arguments.</span></span>  
  
 <span data-ttu-id="a1c4a-250">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `arglist` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-252">Przenosi formant do instrukcji docelowej, jeśli dwie wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-252">Transfers control to a target instruction if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-253">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-254">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-254">Format</span></span>|<span data-ttu-id="a1c4a-255">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-255">Assembly Format</span></span>|<span data-ttu-id="a1c4a-256">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-257">3B < `int32` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-257">3B < `int32` ></span></span>|<span data-ttu-id="a1c4a-258">beq`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-258">beq `target`</span></span>|<span data-ttu-id="a1c4a-259">Rozgałęzienie do instrukcji docelowej przy `target` przesunięciu, jeśli dwie wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-259">Branch to the target instruction at offset `target` if the two values are equal.</span></span>|  
  
 <span data-ttu-id="a1c4a-260">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-261">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-261">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-262">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-262">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-263">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest równe `value2`, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-263">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-264">Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest równa `value2`. `beq`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-264">The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="a1c4a-265">Efekt jest taki sam jak wykonywanie `ceq` instrukcji, po której następuje `brtrue` gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-265">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-266">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-266">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-267">Akceptowane typy argumentów operacji są hermetyzowane poniżej:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-267">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="a1c4a-268">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-268">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="a1c4a-269">Sterowanie transferami do i z `try`bloków `catch`, `filter`,, `finally` i nie może być wykonywane przez tę <xref:System.Reflection.Emit.OpCodes.Leave> instrukcję (takie transfery są poważnie ograniczone i należy zamiast tego użyć instrukcji).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-269">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="a1c4a-270">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `beq` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-271">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-271">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-272">Przenosi formant do instrukcji docelowej (krótka wersja), jeśli dwie wartości są równe.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-272">Transfers control to a target instruction (short form) if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-273">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-274">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-274">Format</span></span>|<span data-ttu-id="a1c4a-275">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-275">Assembly Format</span></span>|<span data-ttu-id="a1c4a-276">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-277">2E < `int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-277">2E < `int8` ></span></span>|<span data-ttu-id="a1c4a-278">BEQ. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-278">beq.s `target`</span></span>|<span data-ttu-id="a1c4a-279">Rozgałęzienie do instrukcji docelowej przy `target` przesunięciu, jeśli jest równa, krótka</span><span class="sxs-lookup"><span data-stu-id="a1c4a-279">Branch to the target instruction at offset `target` if equal, short form</span></span>|  
  
 <span data-ttu-id="a1c4a-280">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-281">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-281">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-282">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-282">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-283">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest równe `value2`, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-283">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-284">Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest równa `value2`. `beq.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-284">The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="a1c4a-285">Efekt jest taki sam jak wykonywanie `ceq` instrukcji, po której następuje `brtrue` gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-285">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-286">Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-286">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-287">Akceptowane typy argumentów operacji są hermetyzowane poniżej:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-287">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="a1c4a-288">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-288">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="a1c4a-289">Sterowanie transferami do i z `try`bloków `catch`, `filter`,, `finally` i nie może być wykonywane przez tę <xref:System.Reflection.Emit.OpCodes.Leave> instrukcję (takie transfery są poważnie ograniczone i należy zamiast tego użyć instrukcji).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-289">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="a1c4a-290">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `beq.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-290">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-291">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-291">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-292">Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest większa lub równa drugiej wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-292">Transfers control to a target instruction if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-293">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-293">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-294">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-294">Format</span></span>|<span data-ttu-id="a1c4a-295">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-295">Assembly Format</span></span>|<span data-ttu-id="a1c4a-296">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-296">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-297">3C `<int32>`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-297">3C `<int32>`</span></span>|<span data-ttu-id="a1c4a-298">bge`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-298">bge `target`</span></span>|<span data-ttu-id="a1c4a-299">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa lub równa drugiej wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-299">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="a1c4a-300">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-300">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-301">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-301">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-302">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-302">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-303">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`większa lub równa, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-303">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-304">Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest `value2`większy lub równy. `bge`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-304">The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="a1c4a-305">Efekt jest identyczny z wykonywaniem `clt.un` instrukcji, po której `brfalse` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-305">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-306">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-306">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-307">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-307">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-308">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-308">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-309">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bge` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-309">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-310">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-310">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-311">Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest większa lub równa drugiej wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-311">Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-312">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-312">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-313">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-313">Format</span></span>|<span data-ttu-id="a1c4a-314">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-314">Assembly Format</span></span>|<span data-ttu-id="a1c4a-315">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-315">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-316">2F `<int8>`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-316">2F `<int8>`</span></span>|<span data-ttu-id="a1c4a-317">BGE. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-317">bge.s `target`</span></span>|<span data-ttu-id="a1c4a-318">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa lub równa drugiej wartości, krótkiej postaci.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-318">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-319">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-319">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-320">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-320">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-321">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-321">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-322">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`większa lub równa, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-322">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-323">Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest `value2`większy lub równy. `bge.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-323">The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="a1c4a-324">Efekt jest identyczny z wykonywaniem `clt.un` instrukcji, po której `brfalse` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-324">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-325">Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-325">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-326">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-326">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-327">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-327">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-328">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bge.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-328">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-329">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-329">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-330">Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest większa niż druga wartość, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-330">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-331">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-331">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-332">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-332">Format</span></span>|<span data-ttu-id="a1c4a-333">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-333">Assembly Format</span></span>|<span data-ttu-id="a1c4a-334">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-334">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-335">41 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-335">41 `<int32>`</span></span>|<span data-ttu-id="a1c4a-336">BGE. un`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-336">bge.un `target`</span></span>|<span data-ttu-id="a1c4a-337">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa lub równa drugiej wartości (wartości bez znaku).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-337">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="a1c4a-338">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-338">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-339">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-339">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-340">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-340">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-341">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`większa lub równa, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-341">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-342">Instrukcja przekazuje kontrolę do określonej instrukcji docelowej `value2`, jeśli `value1` jest większa lub równa, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `bge.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-342">The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="a1c4a-343">Efekt jest identyczny z wykonywaniem `clt` instrukcji, po której `brfalse` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-343">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-344">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-344">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-345">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-345">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-346">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-346">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-347">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bge.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-348">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-348">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-349">Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest większa niż druga wartość, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-349">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-350">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-351">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-351">Format</span></span>|<span data-ttu-id="a1c4a-352">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-352">Assembly Format</span></span>|<span data-ttu-id="a1c4a-353">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-354">34 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-354">34 < `int8` ></span></span>|<span data-ttu-id="a1c4a-355">BGE. un. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-355">bge.un.s `target`</span></span>|<span data-ttu-id="a1c4a-356">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa lub równa drugiej wartości (niepodpisane wartości), krótka forma.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-356">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-357">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-358">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-358">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-359">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-359">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-360">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`większa lub równa, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-360">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-361">Instrukcja przekazuje kontrolę do określonej instrukcji docelowej `value2`, jeśli `value1` jest większa lub równa, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `bge.un.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-361">The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="a1c4a-362">Efekt jest identyczny z wykonywaniem `clt` instrukcji, po której `brfalse` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-362">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-363">Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-363">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-364">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-364">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-365">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-365">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-366">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bge.un.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-366">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-367">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-367">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-368">Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest większa niż druga wartość.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-368">Transfers control to a target instruction if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-369">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-370">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-370">Format</span></span>|<span data-ttu-id="a1c4a-371">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-371">Assembly Format</span></span>|<span data-ttu-id="a1c4a-372">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-373">3D < `int32` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-373">3D < `int32` ></span></span>|<span data-ttu-id="a1c4a-374">#c0`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-374">bgt `target`</span></span>|<span data-ttu-id="a1c4a-375">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa niż druga wartość.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-375">Branch to the target instruction at the specified offset if the first value is greater than the second value.</span></span>|  
  
 <span data-ttu-id="a1c4a-376">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-376">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-377">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-377">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-378">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-378">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-379">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest większy niż `value2`, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-379">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-380">Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest większy niż `value2`. `bgt`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-380">The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="a1c4a-381">Efekt jest identyczny z wykonywaniem `cgt` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-381">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-382">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-382">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-383">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-383">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-384">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-384">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-385">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bgt` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-386">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-386">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-387">Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest większa niż druga wartość.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-387">Transfers control to a target instruction (short form) if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-388">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-388">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-389">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-389">Format</span></span>|<span data-ttu-id="a1c4a-390">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-390">Assembly Format</span></span>|<span data-ttu-id="a1c4a-391">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-391">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-392">30 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-392">30 < `int8` ></span></span>|<span data-ttu-id="a1c4a-393">budżetowy. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-393">bgt.s `target`</span></span>|<span data-ttu-id="a1c4a-394">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa niż druga wartość, krótka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-394">Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-395">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-395">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-396">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-396">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-397">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-397">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-398">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest większy niż `value2`, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-398">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-399">Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest większy niż `value2`. `bgt.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-399">The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="a1c4a-400">Efekt jest identyczny z wykonywaniem `cgt` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-400">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-401">Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-401">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-402">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-402">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-403">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-403">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-404">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bgt.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-404">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-405">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-405">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-406">Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest większa niż druga wartość, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-406">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-407">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-407">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-408">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-408">Format</span></span>|<span data-ttu-id="a1c4a-409">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-409">Assembly Format</span></span>|<span data-ttu-id="a1c4a-410">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-410">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-411">42 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-411">42 < `int32` ></span></span>|<span data-ttu-id="a1c4a-412">budżetowy. un`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-412">bgt.un `target`</span></span>|<span data-ttu-id="a1c4a-413">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa niż druga wartość (wartości bez znaku).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-413">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="a1c4a-414">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-414">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-415">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-415">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-416">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-416">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-417">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest większy niż `value2`, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-417">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-418">Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest większy niż `value2`, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `bgt.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-418">The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="a1c4a-419">Efekt jest identyczny z wykonywaniem `cgt.un` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-419">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-420">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-420">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-421">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-421">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-422">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-422">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-423">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bgt.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-423">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-424">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-424">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-425">Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest większa niż druga wartość, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-425">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-426">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-426">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-427">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-427">Format</span></span>|<span data-ttu-id="a1c4a-428">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-428">Assembly Format</span></span>|<span data-ttu-id="a1c4a-429">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-429">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-430">35 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-430">35 < `int8` ></span></span>|<span data-ttu-id="a1c4a-431">budżetowy. un. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-431">bgt.un.s `target`</span></span>|<span data-ttu-id="a1c4a-432">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest większa niż druga wartość (wartości niepodpisane), krótka forma.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-432">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-433">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-433">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-434">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-434">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-435">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-435">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-436">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest większy niż `value2`, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-436">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-437">Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest większy niż `value2`, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `bgt.un.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-437">The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="a1c4a-438">Efekt jest identyczny z wykonywaniem `cgt.un` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-438">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-439">Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-439">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-440">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-440">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-441">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-441">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-442">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bgt.un.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-442">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-443">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-443">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-444">Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-444">Transfers control to a target instruction if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-445">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-445">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-446">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-446">Format</span></span>|<span data-ttu-id="a1c4a-447">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-447">Assembly Format</span></span>|<span data-ttu-id="a1c4a-448">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-448">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-449">3E `<int32>`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-449">3E `<int32>`</span></span>|<span data-ttu-id="a1c4a-450">beli`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-450">ble `target`</span></span>|<span data-ttu-id="a1c4a-451">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-451">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="a1c4a-452">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-452">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-453">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-453">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-454">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-454">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-455">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`mniejsze lub równe, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-455">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-456">Instrukcja przekazuje sterowanie do określonej instrukcji docelowej, jeśli `value1` jest `value2`mniejsza lub równa. `ble`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-456">The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="a1c4a-457">Efekt jest identyczny z wykonywaniem `cgt` instrukcji (`cgt.un` dla zmiennoprzecinkowych), `brfalse` po której następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-457">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-458">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-458">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-459">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-459">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-460">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-460">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-461">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ble` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-461">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-462">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-462">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-463">Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-463">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-464">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-464">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-465">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-465">Format</span></span>|<span data-ttu-id="a1c4a-466">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-466">Assembly Format</span></span>|<span data-ttu-id="a1c4a-467">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-467">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-468">31 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-468">31 `<int8>`</span></span>|<span data-ttu-id="a1c4a-469">beli. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-469">ble.s `target`</span></span>|<span data-ttu-id="a1c4a-470">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości w formie krótkiej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-470">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-471">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-471">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-472">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-472">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-473">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-473">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-474">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`mniejsze lub równe, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-474">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-475">Instrukcja przekazuje sterowanie do określonej instrukcji docelowej, jeśli `value1` jest `value2`mniejsza lub równa. `ble.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-475">The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="a1c4a-476">Efekt jest identyczny z wykonywaniem `cgt` instrukcji (`cgt.un` dla operacji zmiennoprzecinkowych`brfalse` ), po której następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-476">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-477">Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-477">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-478">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-478">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-479">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-479">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-480">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ble.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-481">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-481">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-482">Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-482">Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-483">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-484">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-484">Format</span></span>|<span data-ttu-id="a1c4a-485">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-485">Assembly Format</span></span>|<span data-ttu-id="a1c4a-486">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-487">43 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-487">43 `<int32>`</span></span>|<span data-ttu-id="a1c4a-488">beli. un`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-488">ble.un `target`</span></span>|<span data-ttu-id="a1c4a-489">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości (wartości bez znaku).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-489">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="a1c4a-490">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-491">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-491">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-492">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-492">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-493">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`mniejsze lub równe, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-493">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-494">Instrukcja przekazuje kontrolę do określonej instrukcji docelowej `value2`, jeśli `value1` jest ona mniejsza lub równa, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `ble.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-494">The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="a1c4a-495">Efekt jest identyczny z wykonywaniem `cgt.un` instrukcji (`cgt` dla zmiennoprzecinkowych), `brfalse` po której następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-495">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-496">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-496">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-497">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-497">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-498">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-498">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-499">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ble.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-500">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-500">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-501">Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości, podczas porównywania wartości liczb całkowitych i nieuporządkowanych wartości zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-501">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-502">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-503">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-503">Format</span></span>|<span data-ttu-id="a1c4a-504">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-504">Assembly Format</span></span>|<span data-ttu-id="a1c4a-505">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-506">36 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-506">36 `<int8>`</span></span>|<span data-ttu-id="a1c4a-507">beli. un. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-507">ble.un.s `target`</span></span>|<span data-ttu-id="a1c4a-508">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza lub równa drugiej wartości (niepodpisane wartości), krótka forma.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-508">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-509">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-510">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-510">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-511">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-511">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-512">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest `value2`mniejsze lub równe, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-512">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-513">Instrukcja przekazuje kontrolę do określonej instrukcji docelowej `value2`, jeśli `value1` jest ona mniejsza lub równa, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `ble.un.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-513">The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="a1c4a-514">Efekt jest identyczny z wykonywaniem `cgt.un` instrukcji (`cgt` dla zmiennoprzecinkowych), `brfalse` po której następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-514">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-515">Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-515">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-516">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-516">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-517">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-517">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-518">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ble.un.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-518">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-519">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-519">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-520">Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest mniejsza od drugiej wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-520">Transfers control to a target instruction if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-521">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-521">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-522">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-522">Format</span></span>|<span data-ttu-id="a1c4a-523">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-523">Assembly Format</span></span>|<span data-ttu-id="a1c4a-524">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-524">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-525">3F < `int32` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-525">3F < `int32` ></span></span>|<span data-ttu-id="a1c4a-526">blt`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-526">blt `target`</span></span>|<span data-ttu-id="a1c4a-527">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza od drugiej wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-527">Branch to the target instruction at the specified offset if the first value is less than the second value.</span></span>|  
  
 <span data-ttu-id="a1c4a-528">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-528">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-529">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-529">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-530">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-530">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-531">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest mniejszy niż `value2`, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-531">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-532">Instrukcja przekazuje sterowanie do określonej instrukcji docelowej, jeśli `value1` jest `value2`mniejsza lub równa. `blt`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-532">The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="a1c4a-533">Efekt jest identyczny z wykonywaniem `clt` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-533">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-534">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-534">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-535">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-535">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-536">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-536">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-537">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `blt` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-537">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-538">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-538">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-539">Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest mniejsza od drugiej wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-539">Transfers control to a target instruction (short form) if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-540">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-540">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-541">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-541">Format</span></span>|<span data-ttu-id="a1c4a-542">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-542">Assembly Format</span></span>|<span data-ttu-id="a1c4a-543">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-543">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-544">32 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-544">32 < `int8` ></span></span>|<span data-ttu-id="a1c4a-545">BLT. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-545">blt.s `target`</span></span>|<span data-ttu-id="a1c4a-546">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza niż druga wartość, krótka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-546">Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-547">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-547">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-548">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-548">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-549">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-549">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-550">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest mniejszy niż `value2`, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-550">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-551">Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest mniejszy niż `value2`. `blt.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-551">The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`.</span></span> <span data-ttu-id="a1c4a-552">Efekt jest identyczny z wykonywaniem `clt` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-552">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-553">Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-553">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-554">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-554">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-555">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-555">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-556">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `blt.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-556">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-557">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-557">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-558">Przenosi formant do instrukcji docelowej, jeśli pierwsza wartość jest mniejsza niż druga wartość, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-558">Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-559">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-559">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-560">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-560">Format</span></span>|<span data-ttu-id="a1c4a-561">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-561">Assembly Format</span></span>|<span data-ttu-id="a1c4a-562">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-562">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-563">44 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-563">44 < `int32` ></span></span>|<span data-ttu-id="a1c4a-564">BLT. un`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-564">blt.un `target`</span></span>|<span data-ttu-id="a1c4a-565">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza niż druga wartość (wartości bez znaku).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-565">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="a1c4a-566">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-566">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-567">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-567">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-568">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-568">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-569">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest mniejszy niż `value2`, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-569">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-570">Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest mniejszy niż `value2`, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `blt.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-570">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="a1c4a-571">Efekt jest identyczny z wykonywaniem `clt.un` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-571">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-572">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-572">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-573">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-573">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-574">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-574">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-575">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `blt.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-575">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-576">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-576">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-577">Przenosi formant do instrukcji docelowej (krótka wersja), jeśli pierwsza wartość jest mniejsza niż druga wartość, podczas porównywania wartości całkowitych bez znaku lub nieuporządkowanych wartości zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-577">Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-578">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-578">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-579">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-579">Format</span></span>|<span data-ttu-id="a1c4a-580">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-580">Assembly Format</span></span>|<span data-ttu-id="a1c4a-581">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-581">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-582">37 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-582">37 < `int8` ></span></span>|<span data-ttu-id="a1c4a-583">BLT. un. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-583">blt.un.s `target`</span></span>|<span data-ttu-id="a1c4a-584">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli pierwsza wartość jest mniejsza niż druga wartość (wartości niepodpisane), krótka forma.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-584">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-585">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-585">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-586">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-586">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-587">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-587">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-588">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` jest mniejszy niż `value2`, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-588">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-589">Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value1` jest mniejszy niż `value2`, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `blt.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-589">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="a1c4a-590">Efekt jest identyczny z wykonywaniem `clt.un` instrukcji, po której `brtrue` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-590">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-591">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-591">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-592">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-592">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-593">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-593">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-594">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `blt.un.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-594">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-595">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-595">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-596">Przenosi formant do instrukcji docelowej, gdy dwie wartości bez znaku lub nieuporządkowane wartości zmiennoprzecinkowe nie są równe.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-596">Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-597">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-597">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-598">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-598">Format</span></span>|<span data-ttu-id="a1c4a-599">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-599">Assembly Format</span></span>|<span data-ttu-id="a1c4a-600">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-600">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-601">40 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-601">40 < `int32` ></span></span>|<span data-ttu-id="a1c4a-602">BNE. un`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-602">bne.un `target`</span></span>|<span data-ttu-id="a1c4a-603">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli dwie niepodpisane wartości całkowite nie są równe (wartości bez znaku).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-603">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</span></span>|  
  
 <span data-ttu-id="a1c4a-604">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-604">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-605">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-605">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-606">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-606">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-607">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` nie jest równe `value2`, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-607">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-608">Instrukcja przekazuje kontrolę do określonej instrukcji docelowej `value2`, jeśli `value1` nie jest równa, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `bne.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-608">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="a1c4a-609">Efekt jest identyczny z wykonywaniem `ceq` instrukcji, po której `brfalse` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-609">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-610">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-610">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-611">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-611">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-612">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-612">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-613">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bne.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-613">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-614">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-614">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-615">Przenosi formant do instrukcji docelowej (krótka wersja), gdy dwie wartości całkowite bez znaku lub nieuporządkowane wartości zmiennoprzecinkowe nie są równe.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-615">Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-616">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-616">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-617">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-617">Format</span></span>|<span data-ttu-id="a1c4a-618">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-618">Assembly Format</span></span>|<span data-ttu-id="a1c4a-619">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-619">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-620">33 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-620">33 < `int8` ></span></span>|<span data-ttu-id="a1c4a-621">BNE. un. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-621">bne.un.s `target`</span></span>|<span data-ttu-id="a1c4a-622">Rozgałęzienie do instrukcji docelowej w określonym przesunięciu, jeśli dwie niepodpisane wartości całkowite nie są równe (wartości bez znaku), krótka forma.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-622">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-623">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-623">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-624">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-624">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-625">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-625">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-626">`value2`i `value1` są zdjęte ze stosu; Jeśli `value1` nie jest równe `value2`, wykonywana jest operacja rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-626">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="a1c4a-627">Instrukcja przekazuje kontrolę do określonej instrukcji docelowej `value2`, jeśli `value1` nie jest równa, w porównaniu z użyciem liczby całkowitej bez znaku lub nieuporządkowanej wartości zmiennoprzecinkowej. `bne.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-627">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="a1c4a-628">Efekt jest identyczny z wykonywaniem `ceq` instrukcji, po której `brfalse` następuje gałąź do konkretnej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-628">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="a1c4a-629">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-629">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-630">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-630">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-631">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-631">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-632">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `bne.un.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-632">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-633">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-633">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-634">Konwertuje typ wartości na odwołanie do obiektu (typ <see langword="O" />).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-634">Converts a value type to an object reference (type <see langword="O" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-635">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-635">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-636">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-636">Format</span></span>|<span data-ttu-id="a1c4a-637">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-637">Assembly Format</span></span>|<span data-ttu-id="a1c4a-638">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-638">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-639">8C < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-639">8C < `T` ></span></span>|<span data-ttu-id="a1c4a-640">dialogowym`valTypeToken`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-640">box `valTypeToken`</span></span>|<span data-ttu-id="a1c4a-641">Przekonwertuj typ wartości (typu określonego w `valTypeToken`) na prawdziwe odwołanie do obiektu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-641">Convert a value type (of the type specified in `valTypeToken`) to a true object reference.</span></span>|  
  
 <span data-ttu-id="a1c4a-642">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-642">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-643">Typ wartości jest wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-643">A value type is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-644">Typ wartości to zdjęte ze stosu; `box` operacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-644">The value type is popped from the stack; the `box` operation is performed.</span></span>  
  
3.  <span data-ttu-id="a1c4a-645">Odwołanie do obiektu typu wartości "opakowane" jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-645">An object reference to the resulting "boxed" value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-646">Typ wartości ma dwie oddzielne reprezentacje w Common Language Infrastructure (interfejs wiersza polecenia):</span><span class="sxs-lookup"><span data-stu-id="a1c4a-646">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="a1c4a-647">Formularz "RAW" używany, gdy typ wartości jest osadzony w innym obiekcie lub na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-647">A 'raw' form used when a value type is embedded within another object or on the stack.</span></span>  
  
-   <span data-ttu-id="a1c4a-648">Formularz "opakowany", w którym dane w typie wartości są opakowane (opakowane) do obiektu, tak aby mógł istnieć jako niezależna jednostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-648">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="a1c4a-649">Instrukcja konwertuje typ "RAW" (unopakowany) na odwołanie do obiektu (typ `O`). `box`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-649">The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`).</span></span> <span data-ttu-id="a1c4a-650">Jest to realizowane przez utworzenie nowego obiektu i skopiowanie danych z typu wartości do nowo przydzielonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-650">This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</span></span> <span data-ttu-id="a1c4a-651">`valTypeToken`to token metadanych wskazujący typ wartości typu na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-651">`valTypeToken` is a metadata token indicating the type of the value type on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-652"><xref:System.OutOfMemoryException>jest zgłaszany w przypadku braku wystarczającej ilości pamięci do spełnienia żądania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-652"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="a1c4a-653"><xref:System.TypeLoadException>jest zgłaszany, jeśli nie można znaleźć klasy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-653"><xref:System.TypeLoadException> is thrown if the class cannot be found.</span></span> <span data-ttu-id="a1c4a-654">Jest to zwykle wykrywane podczas konwertowania języka pośredniego (MSIL) firmy Microsoft na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-654">This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="a1c4a-655">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `box` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-655">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-656">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-656">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-657">Bezwarunkowo przenosi kontrolę do instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-657">Unconditionally transfers control to a target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-658">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-658">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-659">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-659">Format</span></span>|<span data-ttu-id="a1c4a-660">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-660">Assembly Format</span></span>|<span data-ttu-id="a1c4a-661">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-661">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-662">38 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-662">38 < `int32` ></span></span>|<span data-ttu-id="a1c4a-663">br `target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-663">br `target`</span></span>|<span data-ttu-id="a1c4a-664">Gałęzie do instrukcji docelowej w określonym przesunięciu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-664">Branches to a target instruction at the specified offset.</span></span>|  
  
 <span data-ttu-id="a1c4a-665">Ta operacja nie wykonuje żadnych zachowań stosu szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-665">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="a1c4a-666">`br` Instrukcja bezwarunkowego transferuje kontrolę do docelowej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-666">The `br` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="a1c4a-667">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-667">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-668">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-668">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-669">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-669">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-670">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `br` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-670">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-671">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-671">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-672">Bezwarunkowo przenosi kontrolę do instrukcji docelowej (krótka wersja).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-672">Unconditionally transfers control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-673">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-673">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-674">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-674">Format</span></span>|<span data-ttu-id="a1c4a-675">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-675">Assembly Format</span></span>|<span data-ttu-id="a1c4a-676">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-676">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-677">2B < `int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-677">2B < `int8` ></span></span>|<span data-ttu-id="a1c4a-678">br. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-678">br.s `target`</span></span>|<span data-ttu-id="a1c4a-679">Gałęzie do instrukcji docelowej o określonej przesunięciu i skrócie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-679">Branches to a target instruction at the specified offset, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-680">Ta operacja nie wykonuje żadnych zachowań stosu szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-680">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="a1c4a-681">`br.s` Instrukcja bezwarunkowego transferuje kontrolę do docelowej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-681">The `br.s` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="a1c4a-682">Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-682">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-683">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-683">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-684">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-684">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-685">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `br.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-685">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-686">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-686">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-687">Sygnalizuje Common Language Infrastructure (CLI), aby poinformować debuger, że punkt przerwania został wystawiony.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-687">Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-688">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-688">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-689">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-689">Format</span></span>|<span data-ttu-id="a1c4a-690">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-690">Assembly Format</span></span>|<span data-ttu-id="a1c4a-691">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-691">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-692">01</span><span class="sxs-lookup"><span data-stu-id="a1c4a-692">01</span></span>|<span data-ttu-id="a1c4a-693">break</span><span class="sxs-lookup"><span data-stu-id="a1c4a-693">break</span></span>|<span data-ttu-id="a1c4a-694">informowanie debugera o osiągnięciu punktu przerwania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-694">inform a debugger that a breakpoint has been reached.</span></span>|  
  
 <span data-ttu-id="a1c4a-695">Ta operacja nie wykonuje żadnych zachowań stosu szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-695">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="a1c4a-696">`break` Instrukcja dotyczy obsługi debugowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-696">The `break` instruction is for debugging support.</span></span> <span data-ttu-id="a1c4a-697">Sygnalizuje interfejs wiersza polecenia, aby poinformować debuger o konieczności wyzwolenia punktu przerwania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-697">It signals the CLI to inform the debugger that a break point has been tripped.</span></span> <span data-ttu-id="a1c4a-698">Nie ma żadnego wpływu na stan interpretera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-698">It has no other effect on the interpreter state.</span></span>  
  
 <span data-ttu-id="a1c4a-699">`break` Instrukcja ma najmniejszy możliwy rozmiar instrukcji, co umożliwia stosowanie poprawek kodu z punktem przerwania i generowanie minimalnych zakłóceń w otaczającym kodzie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-699">The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</span></span>  
  
 <span data-ttu-id="a1c4a-700">`break` Instrukcja może być zalewkami do debugera, nic nie robić lub podnieść wyjątek zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-700">The `break` instruction can trap to a debugger, do nothing, or raise a security exception.</span></span> <span data-ttu-id="a1c4a-701">Dokładne zachowanie jest zdefiniowane przez implementację.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-701">The exact behavior is implementation-defined.</span></span>  
  
 <span data-ttu-id="a1c4a-702">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `break` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-702">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-703">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-703">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-704">Przenosi formant do instrukcji docelowej, jeśli <paramref name="value" /> jest <see langword="false" />, odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic) lub zero.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-704">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference (<see langword="Nothing" /> in Visual Basic), or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-705">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-705">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-706">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-706">Format</span></span>|<span data-ttu-id="a1c4a-707">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-707">Assembly Format</span></span>|<span data-ttu-id="a1c4a-708">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-708">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-709">39 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-709">39 < `int32` ></span></span>|<span data-ttu-id="a1c4a-710">brfalse`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-710">brfalse `target`</span></span><br /><br /> <span data-ttu-id="a1c4a-711">brnull`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-711">brnull `target`</span></span><br /><br /> <span data-ttu-id="a1c4a-712">brzero `target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-712">brzero `target`</span></span>|<span data-ttu-id="a1c4a-713">Odgałęzienia do instrukcji docelowej w określonym przesunięciu `false`, jeśli.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-713">Branches to a target instruction at the specified offset if `false`.</span></span>|  
  
 <span data-ttu-id="a1c4a-714">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-714">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-715">`value`jest wypychany do stosu przez poprzednią operację.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-715">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="a1c4a-716">`value`zdjęte ze stosu; Jeśli `value` `target`jest `false`, należy rozgałęzić do.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-716">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="a1c4a-717">`value` `brzero` `int32` `O` `int64`Instrukcje (i jego aliasy `brnull` i) przesyłają kontrolki do określonej instrukcji docelowej, jeśli (typu, odwołanie do obiektu, wskaźnik zarządzany `brfalse` , wskaźnik `*`przejściowy `native int`,) ma wartość`false`zero (). `&`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-717">The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="a1c4a-718">Jeśli `value` wartość jest różna od zera`true`(), wykonywanie jest kontynuowane przy następnej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-718">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-719">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-719">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-720">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-720">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-721">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-721">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-722">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `brfalse` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-723">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-723">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-724">Przenosi formant do instrukcji docelowej, jeśli <paramref name="value" /> jest <see langword="false" />, odwołanie o wartości null lub zero.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-724">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference, or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-725">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-726">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-726">Format</span></span>|<span data-ttu-id="a1c4a-727">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-727">Assembly Format</span></span>|<span data-ttu-id="a1c4a-728">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-729">2C <`int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-729">2C <`int8` ></span></span>|<span data-ttu-id="a1c4a-730">brfalse. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-730">brfalse.s `target`</span></span><br /><br /> <span data-ttu-id="a1c4a-731">brnull. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-731">brnull.s `target`</span></span><br /><br /> <span data-ttu-id="a1c4a-732">brzero. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-732">brzero.s `target`</span></span>|<span data-ttu-id="a1c4a-733">Gałęzie do instrukcji docelowej w określonym przesunięciu if `false`, Short Form.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-733">Branches to a target instruction at the specified offset if `false`, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-734">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-734">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-735">`value`jest wypychany do stosu przez poprzednią operację.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-735">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="a1c4a-736">`value`zdjęte ze stosu; Jeśli `value` `target`jest `false`, należy rozgałęzić do.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-736">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="a1c4a-737">`value` `brzero` `int32` `O` `int64`Instrukcje (i jego aliasy `brnull` i) przesyłają kontrolki do określonej instrukcji docelowej, jeśli (typu, odwołanie do obiektu, wskaźnik zarządzany `brfalse.s` , wskaźnik `*`przejściowy `native int`,) ma wartość`false`zero (). `&`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-737">The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="a1c4a-738">Jeśli `value` wartość jest różna od zera`true`(), wykonywanie jest kontynuowane przy następnej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-738">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-739">Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-739">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-740">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-740">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-741">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-741">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-742">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `brfalse.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-742">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-743">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-743">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-744">Przenosi formant do instrukcji docelowej, jeśli <paramref name="value" /> ma <see langword="true" />wartość, nie ma wartości null lub jest różna od zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-744">Transfers control to a target instruction if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-745">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-745">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-746">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-746">Format</span></span>|<span data-ttu-id="a1c4a-747">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-747">Assembly Format</span></span>|<span data-ttu-id="a1c4a-748">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-748">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-749">3A < `int32` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-749">3A < `int32` ></span></span>|<span data-ttu-id="a1c4a-750">brtrue`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-750">brtrue `target`</span></span><br /><br /> <span data-ttu-id="a1c4a-751">do kąpieli`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-751">brinst `target`</span></span>|<span data-ttu-id="a1c4a-752">Rozgałęzienie do instrukcji docelowej pod określonym przesunięciem, jeśli nie jest`true`zerem ().</span><span class="sxs-lookup"><span data-stu-id="a1c4a-752">Branch to a target instruction at the specified offset if non-zero (`true`).</span></span>|  
  
 <span data-ttu-id="a1c4a-753">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-753">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-754">`value`jest wypychany do stosu przez poprzednią operację.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-754">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="a1c4a-755">`value`zdjęte ze stosu; Jeśli `value` `target`jest `true`, należy rozgałęzić do.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-755">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="a1c4a-756">Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value` (typ `native int`) ma wartość różną od zera`true`(). `brtrue`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-756">The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="a1c4a-757">Jeśli `value` wartość jest równa zero (`false`), wykonywanie jest kontynuowane przy następnej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-757">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-758">Jeśli `value` jest odwołaniem do obiektu ( `O`typ) `brinst` , to (alias `brtrue`dla) przenosi formant, jeśli reprezentuje wystąpienie obiektu (na przykład, jeśli nie jest odwołaniem do obiektu null; zobacz <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-758">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="a1c4a-759">Instrukcja docelowa jest reprezentowana jako przesunięte 4-bajtowe przesunięcie od początku instrukcji zgodnie z bieżącą instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-759">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-760">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-760">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-761">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-761">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-762">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `brtrue` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-762">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-763">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-763">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-764">Przenosi formant do instrukcji docelowej (krótka wersja), <paramref name="value" /> Jeśli <see langword="true" />ma wartość, nie ma wartości null lub jest różna od zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-764">Transfers control to a target instruction (short form) if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-765">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-765">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-766">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-766">Format</span></span>|<span data-ttu-id="a1c4a-767">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-767">Assembly Format</span></span>|<span data-ttu-id="a1c4a-768">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-768">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-769">2D < `int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-769">2D < `int8` ></span></span>|<span data-ttu-id="a1c4a-770">brtrue. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-770">brtrue.s `target`</span></span><br /><br /> <span data-ttu-id="a1c4a-771">do kąpieli. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-771">brinst.s `target`</span></span>|<span data-ttu-id="a1c4a-772">Rozgałęzienie do instrukcji docelowej pod określonym przesunięciem, jeśli nie jest`true`zerem (), krótką formą.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-772">Branch to a target instruction at the specified offset if non-zero (`true`), short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-773">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-773">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-774">`value`jest wypychany do stosu przez poprzednią operację.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-774">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="a1c4a-775">`value`zdjęte ze stosu; Jeśli `value` `target`jest `true`, należy rozgałęzić do.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-775">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="a1c4a-776">Instrukcja przekazuje formant do określonej instrukcji docelowej, jeśli `value` (typ `native int`) ma wartość różną od zera`true`(). `brtrue.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-776">The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="a1c4a-777">Jeśli `value` wartość jest równa zero (`false`), wykonywanie jest kontynuowane przy następnej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-777">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-778">Jeśli `value` jest odwołaniem do obiektu ( `O`typ) `brinst` , to (alias `brtrue`dla) przenosi formant, jeśli reprezentuje wystąpienie obiektu (na przykład, jeśli nie jest odwołaniem do obiektu null; zobacz <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-778">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="a1c4a-779">Instrukcja docelowa jest reprezentowana jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-779">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-780">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-780">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="a1c4a-781">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-781">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-782">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `brtrue.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-782">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-783">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-783">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-784">Wywołuje metodę wskazywaną przez deskryptor metody przekazywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-784">Calls the method indicated by the passed method descriptor.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-785">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-785">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-786">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-786">Format</span></span>|<span data-ttu-id="a1c4a-787">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-787">Assembly Format</span></span>|<span data-ttu-id="a1c4a-788">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-788">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-789">28 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-789">28 < `T` ></span></span>|<span data-ttu-id="a1c4a-790">połączeń`methodDesc`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-790">call `methodDesc`</span></span>|<span data-ttu-id="a1c4a-791">Wywołaj metodę opisaną przez `methodDesc`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-791">Call the method described by `methodDesc`.</span></span>|  
  
 <span data-ttu-id="a1c4a-792">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-792">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-793">Argumenty `arg1` metody przez `argN` są wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-793">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-794">Argumenty `arg1` metody przez `argN` są zdjęte ze stosu; wywołanie metody jest wykonywane z tymi argumentami, a sterowanie jest przekazywane do metody, do której odwołuje się deskryptor metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-794">Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</span></span> <span data-ttu-id="a1c4a-795">Po zakończeniu wartość zwracana jest generowana przez metodę wywoływaną i wysyłana do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-795">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
3.  <span data-ttu-id="a1c4a-796">Wartość zwracana jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-796">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-797">`call` Instrukcja wywołuje metodę wskazywaną przez deskryptor metody przekazywania instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-797">The `call` instruction calls the method indicated by the method descriptor passed with the instruction.</span></span> <span data-ttu-id="a1c4a-798">Deskryptor metody jest tokenem metadanych, który wskazuje metodę wywołania oraz liczbę, typ i kolejność argumentów umieszczonych na stosie, które zostały przekazane do tej metody, a także konwencję wywoływania, która ma zostać użyta.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-798">The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</span></span> <span data-ttu-id="a1c4a-799">Instrukcja może być bezpośrednio poprzedzona `tail` instrukcją prefiksu<xref:System.Reflection.Emit.OpCodes.Tailcall>(), aby określić, że bieżący stan metody powinien zostać wystawiony przed przekazaniem kontroli. `call`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-799">The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="a1c4a-800">Jeśli wywołanie przenosi formant do metody o wyższym poziomie zaufania niż Metoda pierwotna, Ramka stosu nie zostanie wydzielona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-800">If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</span></span> <span data-ttu-id="a1c4a-801">Zamiast tego wykonywanie jest kontynuowane w trybie dyskretnym `tail` , tak jakby nie została dostarczona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-801">Instead, the execution continues silently as if the `tail` had not been supplied.</span></span> <span data-ttu-id="a1c4a-802">Token metadanych zawiera wystarczające informacje, aby określić, czy wywołanie jest metodą statyczną, metodą wystąpienia, metodą wirtualną lub funkcją globalną.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-802">The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</span></span> <span data-ttu-id="a1c4a-803">We wszystkich tych przypadkach adres docelowy jest ustalany całkowicie z deskryptora metody (Kontrast to z <xref:System.Reflection.Emit.OpCodes.Callvirt> instrukcją wywołania metod wirtualnych, gdzie adres docelowy jest również zależny od typu środowiska uruchomieniowego wystąpienia odwołanie zostało wypchnięte przed <xref:System.Reflection.Emit.OpCodes.Callvirt>().</span><span class="sxs-lookup"><span data-stu-id="a1c4a-803">In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span></span>  
  
 <span data-ttu-id="a1c4a-804">Argumenty są umieszczane na stosie w kolejności od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-804">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="a1c4a-805">Oznacza to, że pierwszy argument jest obliczany i umieszczany na stosie, drugi argument, a następnie trzeci, do momentu, aż wszystkie wymagane argumenty będą korzystającego stos w kolejności malejącej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-805">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="a1c4a-806">Istnieją trzy ważne przypadki specjalne:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-806">There are three important special cases:</span></span>  
  
 1. <span data-ttu-id="a1c4a-807">Wywołania metody wystąpienia (lub wirtualnej) muszą wypchnąć to odwołanie do wystąpienia przed dowolnymi argumentami widocznymi dla użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-807">Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</span></span> <span data-ttu-id="a1c4a-808">Odwołanie do wystąpienia nie może być odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-808">The instance reference must not be a null reference.</span></span> <span data-ttu-id="a1c4a-809">Sygnatura przeprowadzona w metadanych nie zawiera wpisu na liście parametrów dla `this` wskaźnika; zamiast tego używa bitu, aby wskazać, czy metoda wymaga `this` przekazania wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-809">The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.</span></span>  
  
 2. <span data-ttu-id="a1c4a-810">Jest to prawidłowe wywoływanie metody wirtualnej przy użyciu `call` ( `callvirt`a nie); oznacza to, że metoda jest rozpoznawana przy użyciu klasy określonej przez metodę, a nie określona dynamicznie z wywoływanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-810">It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</span></span>  
  
 3. <span data-ttu-id="a1c4a-811">Należy pamiętać, że `Invoke` Metoda delegata może być wywoływana przy użyciu `call` instrukcji or. `callvirt`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-811">Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-812"><xref:System.Security.SecurityException>mogą być zgłaszane, jeśli zabezpieczenia systemu nie udzielą dostępu wywołującego do wywołanej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-812"><xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="a1c4a-813">Sprawdzanie zabezpieczeń może wystąpić, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-813">The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a1c4a-814">Podczas wywoływania metod klasy System. Object w typach wartości, rozważ użycie `constrained` prefiksu `callvirt` z instrukcją `call` zamiast emitowania instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-814">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction.</span></span> <span data-ttu-id="a1c4a-815">Eliminuje to konieczność emitowania różnych IL w zależności od tego, czy typ wartości przesłania metodę, unikając potencjalnego problemu z wersją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-815">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="a1c4a-816">Rozważ użycie `constrained` prefiksu podczas wywoływania metod interfejsu dla typów wartości, ponieważ metoda typu wartości implementująca metodę interfejsu można zmienić `MethodImpl`przy użyciu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-816">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="a1c4a-817">Te problemy są opisane bardziej szczegółowo w <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-817">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="a1c4a-818">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `call` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-819">ILGenerator.Emit(OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-819">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="a1c4a-820">Elemencie ILGenerator. EmitCall (OpCode, MethodInfo, Type [])</span><span class="sxs-lookup"><span data-stu-id="a1c4a-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a1c4a-821">Metoda jest dostępna dla `varargs` wywołań. <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A></span><span class="sxs-lookup"><span data-stu-id="a1c4a-821">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls.</span></span> <span data-ttu-id="a1c4a-822"><xref:System.Reflection.Emit.ILGenerator.Emit%2A> Użyj metody dla normalnych wywołań.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-822">Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-823">Wywołuje metodę wskazującą stos oceny (jako wskaźnik do punktu wejścia) z argumentami opisanymi przez konwencję wywoływania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-823">Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-824">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-824">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-825">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-825">Format</span></span>|<span data-ttu-id="a1c4a-826">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-826">Assembly Format</span></span>|<span data-ttu-id="a1c4a-827">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-827">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-828">29 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-828">29 < `T` ></span></span>|<span data-ttu-id="a1c4a-829">Calli`callSiteDescr`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-829">calli `callSiteDescr`</span></span>|<span data-ttu-id="a1c4a-830">Wywołuje metodę wskazywaną z argumentami opisanymi przez konwencję wywoływania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-830">Calls the method pointed to with arguments described by the calling convention.</span></span>|  
  
 <span data-ttu-id="a1c4a-831">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-831">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-832">Argumenty `arg1` metody przez `argN` są wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-832">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-833">Wskaźnik wejścia metody jest wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-833">The method entry pointer is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-834">Argumenty `arg1` metody przez `argN` i wskaźnik wejścia metody są zdjęte ze stosu; wywołanie metody jest wykonywane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-834">Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed.</span></span> <span data-ttu-id="a1c4a-835">Po zakończeniu wartość zwracana jest generowana przez metodę wywoływaną i wysyłana do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-835">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="a1c4a-836">Wartość zwracana jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-836">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-837">Instrukcja wywołuje wskaźnik wejścia metody z argumentami `arg1` przez `argN`. `calli`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-837">The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`.</span></span> <span data-ttu-id="a1c4a-838">Typy tych argumentów są opisane przez określoną konwencję wywoływania (`callSiteDesc`).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-838">The types of these arguments are described by the specific calling convention (`callSiteDesc`).</span></span> <span data-ttu-id="a1c4a-839">Instrukcja może być bezpośrednio poprzedzona `tail` prefiksem (<xref:System.Reflection.Emit.OpCodes.Tailcall>), aby określić, że bieżący stan metody powinien zostać wystawiony przed przekazaniem kontroli. `calli`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-839">The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="a1c4a-840">Jeśli wywołanie przeniesie formant do metody o wyższym poziomie zaufania niż Metoda pochodzenia, Ramka stosu nie zostanie wydzielona; Zamiast tego wykonywanie będzie kontynuowane w trybie dyskretnym, `tail` tak jakby nie została dostarczona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-840">If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.</span></span>  
  
 <span data-ttu-id="a1c4a-841">Przyjmuje się, że wskaźnik wejścia metody jest określonym wskaźnikiem do kodu natywnego (maszyny docelowej), który może być słusznie wywoływany z argumentami opisanymi w konwencji wywoływania (tokenem metadanych dla podpisu autonomicznego).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-841">The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</span></span> <span data-ttu-id="a1c4a-842">Taki wskaźnik można utworzyć przy użyciu <xref:System.Reflection.Emit.OpCodes.Ldftn> instrukcji lub <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> lub przekazywać z kodu natywnego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-842">Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.</span></span>  
  
 <span data-ttu-id="a1c4a-843">Konwencja wywoływania nie jest sprawdzana dynamicznie, dlatego kod, który używa `calli` instrukcji, nie działa prawidłowo, jeśli miejsce docelowe nie używa faktycznie określonej konwencji wywoływania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-843">The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention.</span></span>  
  
 <span data-ttu-id="a1c4a-844">Argumenty są umieszczane na stosie w kolejności od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-844">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="a1c4a-845">Oznacza to, że pierwszy argument jest obliczany i umieszczany na stosie, drugi argument, a następnie trzeci, do momentu, aż wszystkie wymagane argumenty będą korzystającego stos w kolejności malejącej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-845">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="a1c4a-846">Sekwencja kodu tworzenia argumentów dla wystąpienia lub metody wirtualnej musi wypchnąć to odwołanie do wystąpienia (które nie może być odwołaniem null) przed żadnym z argumentów widocznych dla użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-846">The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</span></span>  
  
 <span data-ttu-id="a1c4a-847"><xref:System.Security.SecurityException>mogą być zgłaszane, jeśli zabezpieczenia systemu nie udzielą dostępu wywołującego do wywołanej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-847"><xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="a1c4a-848">Sprawdzanie zabezpieczeń może wystąpić, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-848">The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="a1c4a-849">Poniższe <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> metody mogą służyć do `calli` wykonywania instrukcji na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-849">The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack.</span></span> <span data-ttu-id="a1c4a-850">Należy pamiętać `calli` , że należy ją wywołać za pomocą poniższych metod zamiast <xref:System.Reflection.Emit.ILGenerator.Emit%2A> używać klasy do umieszczania instrukcji bezpośrednio na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-850">Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.</span></span>  
  
-   <span data-ttu-id="a1c4a-851">Elemencie ILGenerator. EmitCalli (opcode, CallingConventions, Type, Type [], Type []) dla wywołań przy użyciu zarządzanej konwencji wywoływania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-851">ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</span></span>  
  
-   <span data-ttu-id="a1c4a-852">Elemencie ILGenerator. EmitCalli (opcode, CallingConvention, Type, Type []) dla wywołań za pomocą niezarządzanej konwencji wywoływania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-852">ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-853">Wywołuje metodę z późnym wiązaniem dla obiektu, wypchnięcie wartości zwracanej na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-853">Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-854">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-855">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-855">Format</span></span>|<span data-ttu-id="a1c4a-856">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-856">Assembly Format</span></span>|<span data-ttu-id="a1c4a-857">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-858">6F < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-858">6F < `T` ></span></span>|<span data-ttu-id="a1c4a-859">elementu`method`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-859">callvirt `method`</span></span>|<span data-ttu-id="a1c4a-860">Wywołuje określoną metodę skojarzoną z `obj`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-860">Calls a specific method associated with `obj`.</span></span>|  
  
 <span data-ttu-id="a1c4a-861">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-862">Odwołanie `obj` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-862">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-863">Argumenty `arg1` metody przez `argN` są wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-863">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-864">Argumenty `arg1` metody przez `argN` i odwołania `obj` do obiektu są zdjęte ze stosu; wywołanie metody jest wykonywane z tymi argumentami `obj` , a kontrola jest przekazywana do metody, która jest określana przez metodę Token metadanych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-864">Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token.</span></span> <span data-ttu-id="a1c4a-865">Po zakończeniu wartość zwracana jest generowana przez metodę wywoływaną i wysyłana do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-865">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="a1c4a-866">Wartość zwracana jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-866">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-867">`callvirt` Instrukcja wywołuje metodę z późnym wiązaniem dla obiektu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-867">The `callvirt` instruction calls a late-bound method on an object.</span></span> <span data-ttu-id="a1c4a-868">Oznacza to, że metoda jest wybierana na podstawie typu `obj` środowiska uruchomieniowego, a nie klasy czasu kompilacji widocznego w wskaźniku metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-868">That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer.</span></span> <span data-ttu-id="a1c4a-869">`Callvirt`może służyć do wywoływania zarówno metody wirtualnej, jak i wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-869">`Callvirt` can be used to call both virtual and instance methods.</span></span> <span data-ttu-id="a1c4a-870">Instrukcja może być bezpośrednio poprzedzona `tail` prefiksem (<xref:System.Reflection.Emit.OpCodes.Tailcall>), aby określić, że bieżąca Ramka stosu powinna zostać wydana przed przekazaniem kontroli. `callvirt`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-870">The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control.</span></span> <span data-ttu-id="a1c4a-871">Jeśli wywołanie przeniesie formant do metody o wyższym poziomie zaufania niż oryginalna Metoda, Ramka stosu nie zostanie wydzielona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-871">If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</span></span>  
  
 <span data-ttu-id="a1c4a-872">Token metadanych metody zawiera nazwę, klasę i podpis metody do wywołania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-872">The method metadata token provides the name, class and signature of the method to call.</span></span> <span data-ttu-id="a1c4a-873">Klasa skojarzona z `obj` jest klasą, której jest wystąpieniem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-873">The class associated with `obj` is the class of which it is an instance.</span></span> <span data-ttu-id="a1c4a-874">Jeśli klasa definiuje niestatyczną metodę, która pasuje do wskazanej nazwy metody i podpisu, ta metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-874">If the class defines a non-static method that matches the indicated method name and signature, this method is called.</span></span> <span data-ttu-id="a1c4a-875">W przeciwnym razie wszystkie klasy w łańcuchu klas bazowych tej klasy są sprawdzane w kolejności.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-875">Otherwise all classes in the base class chain of this class are checked in order.</span></span> <span data-ttu-id="a1c4a-876">Jeśli nie zostanie znaleziona żadna metoda, występuje błąd.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-876">It is an error if no method is found.</span></span>  
  
 <span data-ttu-id="a1c4a-877">`Callvirt`przed wywołaniem metody punkty obecności obiektu i skojarzonych z nim argumentów są wyłączane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-877">`Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method.</span></span> <span data-ttu-id="a1c4a-878">Jeśli metoda ma wartość zwracaną, jest wypychana na stosie po zakończeniu metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-878">If the method has a return value, it is pushed on the stack upon method completion.</span></span> <span data-ttu-id="a1c4a-879">Po stronie `obj` wywoływanej parametr jest dostępny jako argument 0, `arg1` jako argument 1 i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-879">On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.</span></span>  
  
 <span data-ttu-id="a1c4a-880">Argumenty są umieszczane na stosie w kolejności od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-880">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="a1c4a-881">Oznacza to, że pierwszy argument jest obliczany i umieszczany na stosie, drugi argument, a następnie trzeci, do momentu, aż wszystkie wymagane argumenty będą korzystającego stos w kolejności malejącej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-881">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="a1c4a-882">Odwołanie `obj` do wystąpienia (zawsze wymagane dla `callvirt`) musi zostać wypchnięte przed dowolnymi argumentami widocznymi dla użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-882">The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments.</span></span> <span data-ttu-id="a1c4a-883">Sygnatura (przeprowadzona w tokenie metadanych) nie musi zawierać wpisu na liście parametrów dla tego wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-883">The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</span></span>  
  
 <span data-ttu-id="a1c4a-884">Należy zauważyć, że metoda wirtualna może być również wywoływana przy <xref:System.Reflection.Emit.OpCodes.Call> użyciu instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-884">Note that a virtual method can also be called using the <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-885"><xref:System.MissingMethodException>jest zgłaszany, jeśli nie można znaleźć metody niestatycznej o wskazanej nazwie i podpisie w klasie skojarzonej `obj` z lub żadnej z jej klas podstawowych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-885"><xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes.</span></span> <span data-ttu-id="a1c4a-886">Jest to zwykle wykrywane, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-886">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="a1c4a-887"><xref:System.NullReferenceException>jest zgłaszany, Jeśli obj ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-887"><xref:System.NullReferenceException> is thrown if obj is null.</span></span>  
  
 <span data-ttu-id="a1c4a-888"><xref:System.Security.SecurityException>jest zgłaszany, jeśli zabezpieczenia systemu nie udzielą dostępu wywołującego do wywołanej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-888"><xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="a1c4a-889">Sprawdzanie zabezpieczeń może wystąpić, gdy CIL jest konwertowany na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-889">The security check may occur when the CIL is converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a1c4a-890">Podczas wywoływania metod klasy System. Object w typach wartości należy rozważyć użycie `constrained` prefiksu `callvirt` z instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-890">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction.</span></span> <span data-ttu-id="a1c4a-891">Eliminuje to konieczność emitowania różnych IL w zależności od tego, czy typ wartości przesłania metodę, unikając potencjalnego problemu z wersją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-891">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="a1c4a-892">Rozważ użycie `constrained` prefiksu podczas wywoływania metod interfejsu dla typów wartości, ponieważ metoda typu wartości implementująca metodę interfejsu można zmienić `MethodImpl`przy użyciu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-892">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="a1c4a-893">Te problemy są opisane bardziej szczegółowo w <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-893">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="a1c4a-894">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `callvirt` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-895">ILGenerator.Emit(OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-895">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="a1c4a-896">Elemencie ILGenerator. EmitCall (OpCode, MethodInfo, Type [])</span><span class="sxs-lookup"><span data-stu-id="a1c4a-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-897">Próbuje rzutować obiekt przekazaną przez odwołanie do określonej klasy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-897">Attempts to cast an object passed by reference to the specified class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-898">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-899">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-899">Format</span></span>|<span data-ttu-id="a1c4a-900">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-900">Assembly Format</span></span>|<span data-ttu-id="a1c4a-901">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-902">74 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-902">74 < `T` ></span></span>|<span data-ttu-id="a1c4a-903">castclass`class`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-903">castclass `class`</span></span>|<span data-ttu-id="a1c4a-904">Rzutuje obiekt na nowy obiekt typu `class`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-904">Casts an object to a new object of type `class`.</span></span>|  
  
 <span data-ttu-id="a1c4a-905">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-906">Odwołanie do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-906">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-907">Odwołanie do obiektu jest zdjęte ze stosu; przywoływany obiekt jest rzutowany jako `class`określony.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-907">The object reference is popped from the stack; the referenced object is cast as the specified `class`.</span></span>  
  
3.  <span data-ttu-id="a1c4a-908">Jeśli to się powiedzie, nowe odwołanie do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-908">If successful, a new object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-909">Instrukcja próbuje rzutować odwołania do obiektu (typu `O`) korzystającego stos na określoną klasę. `castclass`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-909">The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class.</span></span> <span data-ttu-id="a1c4a-910">Nowa klasa jest określana przez token metadanych wskazujący żądaną klasę.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-910">The new class is specified by a metadata token indicating the desired class.</span></span> <span data-ttu-id="a1c4a-911">Jeśli klasa obiektu w górnej części stosu nie implementuje nowej klasy (przy założeniu, że nowa klasa jest interfejsem) i nie jest klasą pochodną nowej klasy <xref:System.InvalidCastException> , zostanie zgłoszony.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-911">If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown.</span></span> <span data-ttu-id="a1c4a-912">Jeśli odwołanie do obiektu jest odwołaniem null, `castclass` powiedzie się i zwróci nowy obiekt jako odwołanie o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-912">If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-913"><xref:System.InvalidCastException>jest zgłaszany, jeśli nie można rzutować na klasę.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-913"><xref:System.InvalidCastException> is thrown if obj cannot be cast to class.</span></span>  
  
 <span data-ttu-id="a1c4a-914"><xref:System.TypeLoadException>jest zgłaszany, jeśli nie można znaleźć klasy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-914"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="a1c4a-915">Jest to zwykle wykrywane, gdy instrukcja języka pośredniego (MSIL) firmy Microsoft jest konwertowana na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-915">This is typically detected when a Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="a1c4a-916">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `castclass` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-916">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-917">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-917">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-918">Porównuje dwie wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-918">Compares two values.</span></span> <span data-ttu-id="a1c4a-919">Jeśli są równe, wartość całkowita 1 <see langword="(int32" />) jest wypychana do stosu oceny; w przeciwnym razie<see langword="int32" />0 () jest wypychany do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-919">If they are equal, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-920">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-920">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-921">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-921">Format</span></span>|<span data-ttu-id="a1c4a-922">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-922">Assembly Format</span></span>|<span data-ttu-id="a1c4a-923">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-923">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-924">FE 01</span><span class="sxs-lookup"><span data-stu-id="a1c4a-924">FE 01</span></span>|<span data-ttu-id="a1c4a-925">ceq</span><span class="sxs-lookup"><span data-stu-id="a1c4a-925">ceq</span></span>|<span data-ttu-id="a1c4a-926">Wypchnięcia 1 `value1` , `value2`jeśli jest równe; w przeciwnym razie wypycha 0.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-926">Pushes 1 if `value1` equals `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="a1c4a-927">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-927">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-928">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-928">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-929">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-929">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-930">`value2`i `value1` są zdjęte ze stosu; jest porównywany `value2`z. `value1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-930">`value2` and `value1` are popped from the stack; `value1` is compared to `value2`.</span></span>  
  
4.  <span data-ttu-id="a1c4a-931">Jeśli `value1` jest równe, `value2`1 jest wypychany do stosu; w przeciwnym razie 0 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-931">If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-932">Instrukcja porównuje `value1` i `value2`. `ceq`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-932">The `ceq` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="a1c4a-933">Jeśli `value1` jest `int32`równe, 1 (z typu) jest wypychany na stosie. `value2`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-933">If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack.</span></span> <span data-ttu-id="a1c4a-934">W przeciwnym razie 0 ( `int32`z typu) jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-934">Otherwise 0 (of type `int32`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-935">W przypadku liczby zmiennoprzecinkowej program `ceq` zwróci wartość 0, jeśli liczby są nieuporządkowane (albo oba są NaN).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-935">For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN).</span></span> <span data-ttu-id="a1c4a-936">Wartości nieskończone są równe sobie same.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-936">The infinite values are equal to themselves.</span></span>  
  
 <span data-ttu-id="a1c4a-937">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ceq` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-939">Porównuje dwie wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-939">Compares two values.</span></span> <span data-ttu-id="a1c4a-940">Jeśli pierwsza wartość jest większa niż sekunda, wartość całkowita 1 <see langword="(int32" />) jest wypychana do stosu oceny; w przeciwnym razie<see langword="int32" />0 () jest wypychany do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-940">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-941">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-942">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-942">Format</span></span>|<span data-ttu-id="a1c4a-943">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-943">Assembly Format</span></span>|<span data-ttu-id="a1c4a-944">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-945">FE 02</span><span class="sxs-lookup"><span data-stu-id="a1c4a-945">FE 02</span></span>|<span data-ttu-id="a1c4a-946">cgt</span><span class="sxs-lookup"><span data-stu-id="a1c4a-946">cgt</span></span>|<span data-ttu-id="a1c4a-947">Wypchnięcia 1 `value1` , jeśli jest `value2`większa niż; w przeciwnym wypadku wypchnij 0.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-947">Pushes 1 if `value1` is greater than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="a1c4a-948">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-949">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-949">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-950">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-950">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-951">`value2`i `value1` są zdjęte ze stosu; test jeśli `value1` jest większy niż `value2`. `cgt`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-951">`value2` and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="a1c4a-952">Jeśli `value1` jest większa niż `value2`, 1 jest wypychana do stosu; w przeciwnym razie 0 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-952">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-953">Instrukcja porównuje `value1` i `value2`. `cgt`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-953">The `cgt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="a1c4a-954">Jeśli `value1` jest ściśle większa niż `value2`, `int32` wartość 1 jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-954">If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="a1c4a-955">W przeciwnym razie wartość 0 jest wypychana na stosie. `int32`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-955">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="a1c4a-956">W przypadku liczb zmiennoprzecinkowych zwraca `cgt` wartość 0, jeśli liczby są nieuporządkowane (czyli jeśli jeden lub oba argumenty są NaN).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-956">For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="a1c4a-957">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `cgt` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-957">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-958">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-958">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-959">Porównuje dwie niepodpisane lub nieuporządkowane wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-959">Compares two unsigned or unordered values.</span></span> <span data-ttu-id="a1c4a-960">Jeśli pierwsza wartość jest większa niż sekunda, wartość całkowita 1 <see langword="(int32" />) jest wypychana do stosu oceny; w przeciwnym razie<see langword="int32" />0 () jest wypychany do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-960">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-961">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-961">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-962">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-962">Format</span></span>|<span data-ttu-id="a1c4a-963">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-963">Assembly Format</span></span>|<span data-ttu-id="a1c4a-964">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-964">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-965">FE 03</span><span class="sxs-lookup"><span data-stu-id="a1c4a-965">FE 03</span></span>|<span data-ttu-id="a1c4a-966">cgt.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-966">cgt.un</span></span>|<span data-ttu-id="a1c4a-967">Wypchnięcia 1 `value1` , jeśli jest `value2`większa niż; w przeciwnym razie wypycha 0 (wartości bez znaku).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-967">Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="a1c4a-968">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-968">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-969">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-969">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-970">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-970">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-971">`value2`i `value1` są zdjęte ze stosu; test jeśli `value1` jest większy niż `value2`. `cgt.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-971">`value2` and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="a1c4a-972">Jeśli `value1` jest większa niż `value2`, 1 jest wypychana do stosu; w przeciwnym razie 0 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-972">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-973">Wartość 1 jest wypychana na stosie, jeśli którekolwiek z `true` następujących elementów: `int32`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-973">An `int32` value of 1 is pushed on the stack if any of the following is `true` :</span></span>  
  
 <span data-ttu-id="a1c4a-974">W przypadku liczb `value1` zmiennoprzecinkowych nie jest uporządkowana w odniesieniu do `value2`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-974">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
 <span data-ttu-id="a1c4a-975">W przypadku wartości całkowitych jest ściśle większa `value2` niż w przypadku, `value1` gdy jest traktowana jako liczba bez znaku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-975">For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="a1c4a-976">W przeciwnym razie wartość 0 jest wypychana na stosie. `int32`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-976">Otherwise an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-977">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `cgt.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-977">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-978">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-978">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-979">Zgłasza <see cref="T:System.ArithmeticException" /> , czy wartość nie jest wartością skończoną.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-979">Throws <see cref="T:System.ArithmeticException" /> if value is not a finite number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-980">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-980">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-981">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-981">Format</span></span>|<span data-ttu-id="a1c4a-982">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-982">Assembly Format</span></span>|<span data-ttu-id="a1c4a-983">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-983">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-984">C3</span><span class="sxs-lookup"><span data-stu-id="a1c4a-984">C3</span></span>|<span data-ttu-id="a1c4a-985">ckfinite</span><span class="sxs-lookup"><span data-stu-id="a1c4a-985">ckfinite</span></span>|<span data-ttu-id="a1c4a-986">Zgłoś <xref:System.ArithmeticException> , jeśli wartość nie jest liczbą skończoną.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-986">throw <xref:System.ArithmeticException> if value is not a finite number.</span></span>|  
  
 <span data-ttu-id="a1c4a-987">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-987">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-988">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-988">`value` is pushed onto the stack.</span></span> 
  
2.  <span data-ttu-id="a1c4a-989">`value`jest zdjęte ze stosu i `ckfinite` jest wykonywana na nim instrukcja.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-989">`value` is popped from the stack and the `ckfinite` instruction is performed on it.</span></span>  
  
3.  <span data-ttu-id="a1c4a-990">`value`jest wypychany na stosie, jeśli nie zostanie zgłoszony żaden wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-990">`value` is pushed back onto the stack if no exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-991">Zwraca `ckfinite instruction` `+-` wartość, Jeśli`value` (liczba zmiennoprzecinkowa) jest wartością typu "nie jest liczbą" (NaN) lub nieskończoną. <xref:System.ArithmeticException></span><span class="sxs-lookup"><span data-stu-id="a1c4a-991">The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a "not a number" value (NaN) or a `+-` infinity value.</span></span> <span data-ttu-id="a1c4a-992">`Ckfinite`pozostawia wartość na stosie, jeśli nie zostanie zgłoszony żaden wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-992">`Ckfinite` leaves the value on the stack if no exception is thrown.</span></span> <span data-ttu-id="a1c4a-993">Wykonanie nie jest określone, `value` Jeśli nie jest liczbą zmiennoprzecinkową.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-993">Execution is unspecified if `value` is not a floating-point number.</span></span>  
  
 <span data-ttu-id="a1c4a-994"><xref:System.ArithmeticException>jest zgłaszany `value` , jeśli nie jest numerem "normal".</span><span class="sxs-lookup"><span data-stu-id="a1c4a-994"><xref:System.ArithmeticException> is thrown if `value` is not a 'normal' number.</span></span>  
  
 <span data-ttu-id="a1c4a-995">Należy zauważyć, że specjalny wyjątek lub Klasa <xref:System.ArithmeticException> pochodna może być bardziej odpowiednia, przekazując niepoprawną wartość do procedury obsługi wyjątków.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-995">Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.</span></span>  
  
 <span data-ttu-id="a1c4a-996">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ckfinite` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-996">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-997">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-997">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-998">Porównuje dwie wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-998">Compares two values.</span></span> <span data-ttu-id="a1c4a-999">Jeśli pierwsza wartość jest mniejsza niż sekunda, wartość całkowita 1 <see langword="(int32" />) jest wypychana do stosu oceny; w przeciwnym razie<see langword="int32" />0 () jest wypychany do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-999">If the first value is less than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1000">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1000">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1001">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1001">Format</span></span>|<span data-ttu-id="a1c4a-1002">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1002">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1003">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1003">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1004">FE 04</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1004">FE 04</span></span>|<span data-ttu-id="a1c4a-1005">clt</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1005">clt</span></span>|<span data-ttu-id="a1c4a-1006">Wypchnięcia 1 `value1` , jeśli jest `value2`mniejsza niż; w przeciwnym wypadku wypchnij 0.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1006">Pushes 1 if `value1` is less than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="a1c4a-1007">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1007">The stack transitional behavior, in sequential order, is:</span></span> 

1.  <span data-ttu-id="a1c4a-1008">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1008">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1009">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1009">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1010">`value2`i `value1` są zdjęte ze stosu; sprawdza, `value1` czy jest mniejsza `value2`niż. `clt`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1010">`value2` and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="a1c4a-1011">Jeśli `value1` jest mniejsza niż `value2`, 1 jest wypychana do stosu; w przeciwnym razie 0 jest wypychana na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1011">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1012">Instrukcja porównuje `value1` i `value2`. `clt`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1012">The `clt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="a1c4a-1013">Jeśli `value1` jest ściśle mniejsze niż `value2`, `int32` wartość 1 jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1013">If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="a1c4a-1014">W przeciwnym razie wartość 0 jest wypychana na stosie. `int32`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1014">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="a1c4a-1015">W przypadku liczb zmiennoprzecinkowych zwraca `clt` wartość 0, jeśli liczby są nieuporządkowane (czyli jeśli jeden lub oba argumenty są NaN).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1015">For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="a1c4a-1016">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `clt` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1016">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1017">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1017">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1018">Porównuje niepodpisane lub nieuporządkowane <paramref name="value1" /> wartości <paramref name="value2" />i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1018">Compares the unsigned or unordered values <paramref name="value1" /> and <paramref name="value2" />.</span></span> <span data-ttu-id="a1c4a-1019">Jeśli <paramref name="value1" /> jest mniejsza niż <paramref name="value2" />, wartość całkowita 1 <see langword="(int32" />) jest wypychana do stosu oceny; w przeciwnym razie 0 (<see langword="int32" />) jest wypychana do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1019">If <paramref name="value1" /> is less than <paramref name="value2" />, then the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1020">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1020">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1021">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1021">Format</span></span>|<span data-ttu-id="a1c4a-1022">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1022">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1023">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1023">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1024">FE 05</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1024">FE 05</span></span>|<span data-ttu-id="a1c4a-1025">CLT. un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1025">clt.un</span></span>|<span data-ttu-id="a1c4a-1026">Wypchnięcia 1 `value1` , jeśli jest `value2`mniejsza niż; w przeciwnym wypadku wypycha 0 (wartości bez znaku).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1026">Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="a1c4a-1027">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1027">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1028">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1028">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1029">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1029">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1030">`value2`i `value1` są zdjęte ze stosu; sprawdza, `value1` czy jest mniejsza `value2`niż. `clt.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1030">`value2` and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="a1c4a-1031">Jeśli `value1` jest mniejsza niż `value2`, 1 jest wypychana do stosu; w przeciwnym razie 0 jest wypychana na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1031">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1032">Instrukcja porównuje `value1` i `value2`. `clt.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1032">The `clt.un` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="a1c4a-1033">`int32` Wartość 1 jest wypychana na stosie, jeśli którykolwiek z następujących warunków jest spełniony:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1033">An `int32` value of 1 is pushed on the stack if any of the following is true:</span></span>  
  
-   <span data-ttu-id="a1c4a-1034">`value1`jest ściśle mniejsze niż `value2` (jak w `clt`przypadku).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1034">`value1` is strictly less than `value2` (as for `clt`).</span></span>  
  
-   <span data-ttu-id="a1c4a-1035">W przypadku liczb `value1` zmiennoprzecinkowych nie jest uporządkowana w odniesieniu do `value2`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1035">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
-   <span data-ttu-id="a1c4a-1036">W przypadku wartości całkowitych jest ściśle mniejsza `value2` niż w przypadku, `value1` gdy jest traktowana jako liczba bez znaku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1036">For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="a1c4a-1037">W przeciwnym razie wartość 0 jest wypychana na stosie. `int32`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1037">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1038">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `clt.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1038">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1039">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1039">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1040">Ogranicza typ, na którym jest nawiązywane wywołanie metody wirtualnej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1040">Constrains the type on which a virtual method call is made.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1041">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1041">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1042">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1042">Format</span></span>|<span data-ttu-id="a1c4a-1043">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1043">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1044">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1044">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1045">FE 16 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-1045">FE 16 < `T` ></span></span>|<span data-ttu-id="a1c4a-1046">ograniczone.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1046">constrained.</span></span> `thisType`|<span data-ttu-id="a1c4a-1047">Wywołaj metodę wirtualną na typie ograniczonym do typu `T`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1047">Call a virtual method on a type constrained to be type `T`.</span></span>|  
  
 <span data-ttu-id="a1c4a-1048">Prefiks jest dozwolony tylko `callvirt` w instrukcji. `constrained`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1048">The `constrained` prefix is permitted only on a `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-1049">Stan stosu MSIL w tym punkcie musi być następujący:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1049">The state of the MSIL stack at this point must be as follows:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1050">Zarządzany wskaźnik `ptr`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1050">A managed pointer, `ptr`, is pushed onto the stack.</span></span> <span data-ttu-id="a1c4a-1051">Typ elementu `ptr` musi być wskaźnikiem zarządzanym (`&`) do `thisType`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1051">The type of `ptr` must be a managed pointer (`&`) to `thisType`.</span></span> <span data-ttu-id="a1c4a-1052">Należy zauważyć, że różni się to od wielkości liter `callvirt` instrukcji bez prefiksu, która oczekuje `thisType`odwołania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1052">Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1053">Argumenty `arg1` metody przez `argN` są wypychane na stosie, podobnie jak `callvirt` w przypadku instrukcji bez prefiksu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1053">Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-1054">Prefiks ma na celu umożliwienie `callvirt` wykonywania instrukcji w jednolity sposób niezależnie od tego, czy `thisType` jest typem wartości czy typem referencyjnym. `constrained`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1054">The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type.</span></span>  
  
 <span data-ttu-id="a1c4a-1055">Gdy instrukcja została poprzedzona `constrained` przez`thisType`, instrukcja jest wykonywana w następujący sposób: `method` `callvirt`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1055">When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:</span></span>  
  
-   <span data-ttu-id="a1c4a-1056">Jeśli `thisType` jest typem referencyjnym (w przeciwieństwie do typu wartości `ptr` ), oznacza to, że `callvirt` zostanie on wywoływany i przeszedł jako wskaźnik "this `method`" do elementu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1056">If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`.</span></span>  
  
-   <span data-ttu-id="a1c4a-1057">Jeśli `thisType` jest typem wartości i `thisType` implementuje `method` `method` , jest `call` przenoszona niezmodyfikowana jako wskaźnik "This" do instrukcji,dlaimplementacjiprzez`method` `ptr` `thisType`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1057">If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`.</span></span>  
  
-   <span data-ttu-id="a1c4a-1058">Jeśli `thisType` jest typem wartości i `thisType` nie implementuje `method` `ptr` elementu, jest on wywołujący, opakowany i przeszedł jako wskaźnik "This" do `callvirt` `method` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1058">If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-1059">Ten ostatni przypadek może wystąpić tylko wtedy `method` , gdy został <xref:System.Object>zdefiniowany <xref:System.ValueType>w, <xref:System.Enum> lub i nie został `thisType`zastąpiony przez.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1059">This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or <xref:System.Enum> and not overridden by `thisType`.</span></span> <span data-ttu-id="a1c4a-1060">W takim przypadku opakowanie powoduje wykonanie kopii oryginalnego obiektu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1060">In this case, the boxing causes a copy of the original object to be made.</span></span> <span data-ttu-id="a1c4a-1061">Jednak ponieważ żadna z metod <xref:System.Object>, <xref:System.ValueType>i <xref:System.Enum> nie modyfikuje stanu obiektu, nie można wykryć tego faktu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1061">However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.</span></span>  
  
 <span data-ttu-id="a1c4a-1062">`constrained` Prefiks obsługuje generatory IL, które tworzą kod generyczny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1062">The `constrained` prefix supports IL generators that create generic code.</span></span> <span data-ttu-id="a1c4a-1063">`callvirt` Zwykle instrukcja nie jest prawidłowa w typach wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1063">Normally the `callvirt` instruction is not valid on value types.</span></span> <span data-ttu-id="a1c4a-1064">Zamiast tego jest wymagane, aby kompilatory Il efektywnie wykonywały przekształcenie "This" opisane powyżej w czasie kompilacji, w zależności od typu `ptr` i metody wywoływanej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1064">Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called.</span></span> <span data-ttu-id="a1c4a-1065">Jeśli `ptr` jednak jest typem ogólnym, który jest nieznany w czasie kompilacji, nie jest możliwe przekształcenie w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1065">However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</span></span>  
  
 <span data-ttu-id="a1c4a-1066">Kod operacji pozwala kompilatorom Il wykonywać wywołania funkcji wirtualnej w jednolity sposób niezależnie od tego, czy `ptr` jest typem wartości czy typem referencyjnym. `constrained`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1066">The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type.</span></span> <span data-ttu-id="a1c4a-1067">Chociaż jest ona przeznaczona dla przypadku `thisType` `constrained` , gdzie jest zmienną typu ogólnego, prefiks również działa dla typów nierodzajowych i może zmniejszyć złożoność generowania wywołań wirtualnych w językach, które ukrywają różnice między typami wartości i typy odwołań.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1067">Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</span></span>  
  
 <span data-ttu-id="a1c4a-1068">Przy użyciu `constrained` prefiksu można również uniknąć potencjalnych problemów z wersjami typów wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1068">Using the `constrained` prefix also avoids potential versioning problems with value types.</span></span> <span data-ttu-id="a1c4a-1069">`constrained` Jeśli prefiks nie jest używany, różne Il muszą być emitowane w zależności od tego, czy typ wartości przesłania metodę System. Object.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1069">If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</span></span> <span data-ttu-id="a1c4a-1070">Na przykład, jeśli `V` typ wartości zastępuje metodę Object. ToString () `Object.ToString()` `call` `V.ToString()` , jest emitowana instrukcja. Jeśli `callvirt` tak nie jest, `box` instrukcja i instrukcja są emitowane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1070">For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted.</span></span> <span data-ttu-id="a1c4a-1071">Problem z przechowywaniem wersji może wystąpić w poprzednim przypadku, jeśli zastąpienie zostanie później usunięte, a w drugim przypadku, jeśli przesłonięcie zostanie później dodane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1071">A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</span></span>  
  
 <span data-ttu-id="a1c4a-1072">Prefiks może być również używany do wywołania metod interfejsu w typach wartości, ponieważ metoda typu wartości implementująca metodę interfejsu można zmienić `MethodImpl`przy użyciu. `constrained`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1072">The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="a1c4a-1073">`constrained` Jeśli prefiks nie jest używany, kompilator jest zmuszony do wybrania metod, które mają być powiązane z typem wartości w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1073">If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</span></span> <span data-ttu-id="a1c4a-1074">`constrained` Używanie prefiksu pozwala na powiązanie MSIL z metodą implementującą metodę interfejsu w czasie wykonywania, a nie w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1074">Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</span></span>  
  
 <span data-ttu-id="a1c4a-1075">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `constrained` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1075">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1076">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1076">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1077">Konwertuje wartość na górze stosu oceny na <see langword="native int" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1077">Converts the value on top of the evaluation stack to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1078">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1078">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1079">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1079">Format</span></span>|<span data-ttu-id="a1c4a-1080">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1080">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1081">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1081">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1082">D3</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1082">D3</span></span>|<span data-ttu-id="a1c4a-1083">conv.i</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1083">conv.i</span></span>|<span data-ttu-id="a1c4a-1084">Konwertuj na `native int`, `native int` wypychanie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1084">Convert to `native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1085">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1085">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1086">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1086">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1087">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1087">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1088">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1088">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1089">`conv.i` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1089">The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1090">Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1090">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="a1c4a-1091">Wartości zmiennoprzecinkowe są konwertowane na `F` typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1091">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="a1c4a-1092">Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1092">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="a1c4a-1093">Podczas konwertowania od a `float64` `float32`do, precyzja może zostać utracona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1093">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="a1c4a-1094">Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1094">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="a1c4a-1095">Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1095">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="a1c4a-1096">Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1096">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="a1c4a-1097">Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1097">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="a1c4a-1098">W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1098">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="a1c4a-1099">Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1099">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="a1c4a-1100">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.i` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1100">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1101">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1101">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1102">Konwertuje wartość na górze stosu oceny na <see langword="int8" />, a następnie rozszerza (konsole). <see langword="int32" /></span><span class="sxs-lookup"><span data-stu-id="a1c4a-1102">Converts the value on top of the evaluation stack to <see langword="int8" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1103">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1103">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1104">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1104">Format</span></span>|<span data-ttu-id="a1c4a-1105">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1105">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1106">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1106">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1107">67</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1107">67</span></span>|<span data-ttu-id="a1c4a-1108">CONV. I1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1108">conv.i1</span></span>|<span data-ttu-id="a1c4a-1109">Konwertuj na `int8`, `int32` wypychanie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1109">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1110">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1110">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1111">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1111">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1112">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1112">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1113">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1113">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1114">`conv.i1` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1114">The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1115">Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1115">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="a1c4a-1116">Wartości zmiennoprzecinkowe są konwertowane na `F` typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1116">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="a1c4a-1117">Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1117">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="a1c4a-1118">Podczas konwertowania od a `float64` `float32`do, precyzja może zostać utracona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1118">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="a1c4a-1119">Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1119">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="a1c4a-1120">Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1120">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="a1c4a-1121">Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1121">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="a1c4a-1122">Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1122">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="a1c4a-1123">W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1123">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="a1c4a-1124">Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1124">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="a1c4a-1125">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.i1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1125">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1126">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1126">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1127">Konwertuje wartość na górze stosu oceny na <see langword="int16" />, a następnie rozszerza (konsole). <see langword="int32" /></span><span class="sxs-lookup"><span data-stu-id="a1c4a-1127">Converts the value on top of the evaluation stack to <see langword="int16" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1128">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1128">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1129">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1129">Format</span></span>|<span data-ttu-id="a1c4a-1130">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1130">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1131">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1131">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1132">68</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1132">68</span></span>|<span data-ttu-id="a1c4a-1133">conv.i2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1133">conv.i2</span></span>|<span data-ttu-id="a1c4a-1134">Konwertuj na `int16`, `int32` wypychanie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1134">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1135">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1135">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1136">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1136">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1137">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1137">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1138">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1138">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1139">`conv.i2` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1139">The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1140">Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1140">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="a1c4a-1141">Wartości zmiennoprzecinkowe są konwertowane na `F` typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1141">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="a1c4a-1142">Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1142">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="a1c4a-1143">Podczas konwertowania od a `float64` `float32`do, precyzja może zostać utracona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1143">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="a1c4a-1144">Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1144">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="a1c4a-1145">Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1145">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="a1c4a-1146">Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1146">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="a1c4a-1147">Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1147">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="a1c4a-1148">W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1148">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="a1c4a-1149">Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1149">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="a1c4a-1150">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.i2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1150">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1151">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1151">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1152">Konwertuje wartość na górze stosu oceny na <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1152">Converts the value on top of the evaluation stack to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1153">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1153">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1154">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1154">Format</span></span>|<span data-ttu-id="a1c4a-1155">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1155">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1156">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1156">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1157">69</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1157">69</span></span>|<span data-ttu-id="a1c4a-1158">CONV. i4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1158">conv.i4</span></span>|<span data-ttu-id="a1c4a-1159">Konwertuj na `int32`, `int32` wypychanie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1159">Convert to `int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1160">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1160">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1161">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1161">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1162">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1162">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1163">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1163">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1164">`conv.i4` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1164">The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1165">Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1165">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="a1c4a-1166">Wartości zmiennoprzecinkowe są konwertowane na `F` typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1166">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="a1c4a-1167">Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1167">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="a1c4a-1168">Podczas konwertowania od a `float64` `float32`do, precyzja może zostać utracona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1168">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="a1c4a-1169">Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1169">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="a1c4a-1170">Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1170">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="a1c4a-1171">Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1171">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="a1c4a-1172">Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1172">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="a1c4a-1173">W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1173">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="a1c4a-1174">Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1174">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="a1c4a-1175">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.i4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1175">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1176">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1176">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1177">Konwertuje wartość na górze stosu oceny na <see langword="int64" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1177">Converts the value on top of the evaluation stack to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1178">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1178">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1179">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1179">Format</span></span>|<span data-ttu-id="a1c4a-1180">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1180">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1181">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1181">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1182">6A</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1182">6A</span></span>|<span data-ttu-id="a1c4a-1183">CONV. i8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1183">conv.i8</span></span>|<span data-ttu-id="a1c4a-1184">Konwertuj na `int64`, `int64` wypychanie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1184">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1185">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1185">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1186">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1186">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1187">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1187">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1188">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1188">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1189">`conv.i8` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1189">The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1190">Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1190">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="a1c4a-1191">Wartości zmiennoprzecinkowe są konwertowane na `F` typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1191">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="a1c4a-1192">Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1192">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="a1c4a-1193">Podczas konwertowania od a `float64` `float32`do, precyzja może zostać utracona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1193">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="a1c4a-1194">Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1194">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="a1c4a-1195">Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1195">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="a1c4a-1196">Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1196">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="a1c4a-1197">Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1197">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="a1c4a-1198">W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1198">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="a1c4a-1199">Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1199">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="a1c4a-1200">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.i8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1200">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1201">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1201">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1202">Konwertuje podpisaną wartość na górze stosu oceny na podpisaną <see langword="native int" />, przerzucanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1202">Converts the signed value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1203">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1203">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1204">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1204">Format</span></span>|<span data-ttu-id="a1c4a-1205">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1205">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1206">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1206">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1207">D4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1207">D4</span></span>|<span data-ttu-id="a1c4a-1208">conv.ovf.i</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1208">conv.ovf.i</span></span>|<span data-ttu-id="a1c4a-1209">Konwertuj na `native int` (na stosie jako `native int`) i Zgłoś wyjątek przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1209">Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1210">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1210">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1211">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1211">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1212">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1212">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1213">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1213">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1214">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1214">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1215">`conv.ovf.i` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1215">The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1216">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1216">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1217">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1217">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1218">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1218">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1219"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1219"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1220">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1220">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1221">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1221">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1222">Konwertuje wartość bez znaku na górze stosu oceny na podpisaną <see langword="native int" />, przerzucanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1222">Converts the unsigned value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1223">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1223">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1224">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1224">Format</span></span>|<span data-ttu-id="a1c4a-1225">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1225">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1226">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1226">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1227">8A</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1227">8A</span></span>|<span data-ttu-id="a1c4a-1228">conv.ovf.i.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1228">conv.ovf.i.un</span></span>|<span data-ttu-id="a1c4a-1229">Konwertuje wartość `native int` bez znaku na (na stosie jako `native int`) i zgłasza wyjątek w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1229">Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1230">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1230">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1231">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1231">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1232">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1232">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1233">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1233">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1234">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1234">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1235">`conv.ovf.i.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1235">The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1236">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1236">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1237">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1237">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1238">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1238">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1239"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1239"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1240">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1240">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1241">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1241">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1242">Konwertuje podpisaną wartość na górze stosu oceny na podpisaną <see langword="int8" /> i rozszerza ją do <see langword="int32" />, <see cref="T:System.OverflowException" /> zwracając przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1242">Converts the signed value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1243">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1243">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1244">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1244">Format</span></span>|<span data-ttu-id="a1c4a-1245">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1245">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1246">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1246">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1247">B3</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1247">B3</span></span>|<span data-ttu-id="a1c4a-1248">conv.ovf.i1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1248">conv.ovf.i1</span></span>|<span data-ttu-id="a1c4a-1249">Konwertuj na `int8` (na stosie jako `int32`) i Zgłoś wyjątek przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1249">Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1250">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1250">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1251">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1251">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1252">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1252">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1253">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1253">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1254">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1254">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1255">`conv.ovf.i1` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1255">The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1256">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1256">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1257">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1257">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1258">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1258">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1259"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1259"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1260">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1260">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1261">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1261">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1262">Konwertuje wartość bez znaku na szczycie stosu oceny, aby była <see langword="int8" /> podpisana i rozszerzana do <see cref="T:System.OverflowException" /> <see langword="int32" />, zwracając przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1262">Converts the unsigned value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1263">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1263">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1264">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1264">Format</span></span>|<span data-ttu-id="a1c4a-1265">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1265">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1266">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1266">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1267">82</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1267">82</span></span>|<span data-ttu-id="a1c4a-1268">conv.ovf.i1.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1268">conv.ovf.i1.un</span></span>|<span data-ttu-id="a1c4a-1269">Konwertuje wartość bez znaku na `int8` (na stosie jako `int32`) i zgłasza wyjątek w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1269">Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1270">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1270">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1271">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1271">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1272">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1272">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1273">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1273">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1274">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1274">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1275">`conv.ovf.i1.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1275">The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1276">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1276">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1277">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1277">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1278">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1278">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1279"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1279"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1280">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i1.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1280">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1281">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1281">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1282">Konwertuje podpisaną wartość znajdującą się na górze stosu oceny na <see langword="int16" /> podpisaną i rozszerzającą <see langword="int32" />ją <see cref="T:System.OverflowException" /> na, co powoduje Przerzucanie w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1282">Converts the signed value on top of the evaluation stack to signed <see langword="int16" /> and extending it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1283">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1283">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1284">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1284">Format</span></span>|<span data-ttu-id="a1c4a-1285">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1285">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1286">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1286">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1287">B5</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1287">B5</span></span>|<span data-ttu-id="a1c4a-1288">conv.ovf.i2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1288">conv.ovf.i2</span></span>|<span data-ttu-id="a1c4a-1289">Konwertuj na `int16` (na stosie jako `int32`) i Zgłoś wyjątek przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1289">Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1290">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1290">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1291">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1291">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1292">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1292">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1293">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1293">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1294">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1294">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1295">`conv.ovf.i2` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1295">The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1296">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1296">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1297">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1297">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1298">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1298">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1299"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1299"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1300">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1300">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1301">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1301">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1302">Konwertuje wartość bez znaku na szczycie stosu oceny, aby była <see langword="int16" /> podpisana i rozszerzana do <see cref="T:System.OverflowException" /> <see langword="int32" />, zwracając przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1302">Converts the unsigned value on top of the evaluation stack to signed <see langword="int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1303">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1303">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1304">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1304">Format</span></span>|<span data-ttu-id="a1c4a-1305">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1305">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1306">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1306">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1307">83</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1307">83</span></span>|<span data-ttu-id="a1c4a-1308">conv.ovf.i2.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1308">conv.ovf.i2.un</span></span>|<span data-ttu-id="a1c4a-1309">Konwertuje wartość bez znaku na `int16` (na stosie jako `int32`) i zgłasza wyjątek w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1309">Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1310">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1310">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1311">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1311">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1312">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1312">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1313">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1313">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1314">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1314">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1315">`conv.ovf.i2.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1315">The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1316">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1316">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1317">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1317">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1318">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1318">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1319"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1319"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1320">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i2.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1320">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1321">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1321">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1322">Konwertuje podpisaną wartość na górze stosu oceny na podpisaną <see langword="int32" />, przerzucanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1322">Converts the signed value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1323">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1323">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1324">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1324">Format</span></span>|<span data-ttu-id="a1c4a-1325">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1325">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1326">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1326">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1327">B7</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1327">B7</span></span>|<span data-ttu-id="a1c4a-1328">conv.ovf.i4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1328">conv.ovf.i4</span></span>|<span data-ttu-id="a1c4a-1329">Konwertuj na `int32` (na stosie jako `int32`) i Zgłoś wyjątek przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1329">Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1330">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1330">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1331">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1331">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1332">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1332">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1333">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1333">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1334">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1334">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1335">`conv.ovf.i4` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1335">The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1336">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1336">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1337">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1337">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1338">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1338">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1339"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1339"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1340">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1340">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1341">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1341">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1342">Konwertuje wartość bez znaku na górze stosu oceny na podpisaną <see langword="int32" />, przerzucanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1342">Converts the unsigned value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1343">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1343">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1344">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1344">Format</span></span>|<span data-ttu-id="a1c4a-1345">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1345">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1346">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1346">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1347">84</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1347">84</span></span>|<span data-ttu-id="a1c4a-1348">conv.ovf.i4.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1348">conv.ovf.i4.un</span></span>|<span data-ttu-id="a1c4a-1349">Konwertuje wartość bez znaku na `int32` (na stosie jako `int32`) i zgłasza wyjątek w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1349">Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1350">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1350">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1351">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1351">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1352">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1352">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1353">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1353">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1354">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1354">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1355">`conv.ovf.i4.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1355">The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1356">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1356">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1357">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1357">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1358">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1358">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1359"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1359"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1360">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i4.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1360">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1361">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1361">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1362">Konwertuje podpisaną wartość na górze stosu oceny na podpisaną <see langword="int64" />, przerzucanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1362">Converts the signed value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1363">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1363">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1364">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1364">Format</span></span>|<span data-ttu-id="a1c4a-1365">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1365">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1366">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1366">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1367">B9</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1367">B9</span></span>|<span data-ttu-id="a1c4a-1368">conv.ovf.i8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1368">conv.ovf.i8</span></span>|<span data-ttu-id="a1c4a-1369">Konwertuj na `int64` (na stosie jako `int64`) i Zgłoś wyjątek przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1369">Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1370">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1370">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1371">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1371">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1372">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1372">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1373">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1373">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1374">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1374">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1375">`conv.ovf.i8` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1375">The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1376">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1376">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1377">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1377">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1378">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1378">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1379"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1379"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1380">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1380">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1381">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1381">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1382">Konwertuje wartość bez znaku na górze stosu oceny na podpisaną <see langword="int64" />, przerzucanie <see cref="T:System.OverflowException" /> przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1382">Converts the unsigned value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1383">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1383">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1384">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1384">Format</span></span>|<span data-ttu-id="a1c4a-1385">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1385">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1386">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1386">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1387">85</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1387">85</span></span>|<span data-ttu-id="a1c4a-1388">conv.ovf.i8.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1388">conv.ovf.i8.un</span></span>|<span data-ttu-id="a1c4a-1389">Konwertuje wartość bez znaku na `int64` (na stosie jako `int64`) i zgłasza wyjątek w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1389">Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1390">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1390">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1391">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1391">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1392">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1392">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1393">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1393">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1394">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1394">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1395">`conv.ovf.i8.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1395">The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1396">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1396">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1397">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1397">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1398">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1398">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1399"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1399"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1400">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.i8.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1400">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1401">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1401">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1402">Konwertuje podpisaną wartość znajdującą się na górze stosu oceny <see langword="unsigned native int" />na <see cref="T:System.OverflowException" /> , zwracając przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1402">Converts the signed value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1403">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1403">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1404">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1404">Format</span></span>|<span data-ttu-id="a1c4a-1405">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1405">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1406">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1406">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1407">D5</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1407">D5</span></span>|<span data-ttu-id="a1c4a-1408">conv.ovf.u</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1408">conv.ovf.u</span></span>|<span data-ttu-id="a1c4a-1409">Konwertuj na `unsigned native int` (na stosie jako `native int`) i Zgłoś wyjątek przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1409">Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1410">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1410">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1411">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1411">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1412">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1412">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1413">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1413">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1414">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1414">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1415">`conv.ovf.u` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1415">The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1416">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1416">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1417">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1417">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1418">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1418">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1419"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1419"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1420">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1420">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1421">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1421">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1422">Konwertuje wartość bez znaku na górze stosu oceny do, która <see langword="unsigned native int" />zostanie przerzucana <see cref="T:System.OverflowException" /> w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1422">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1423">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1423">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1424">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1424">Format</span></span>|<span data-ttu-id="a1c4a-1425">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1425">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1426">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1426">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1427">8B</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1427">8B</span></span>|<span data-ttu-id="a1c4a-1428">conv.ovf.u.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1428">conv.ovf.u.un</span></span>|<span data-ttu-id="a1c4a-1429">Konwertuje wartość unsigned `unsigned native int` na (na stosie `native int`jako) i zgłasza wyjątek w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1429">Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1430">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1430">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1431">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1431">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1432">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1432">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1433">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1433">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1434">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1434">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1435">`conv.ovf.u.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1435">The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1436">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1436">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1437">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1437">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1438">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1438">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1439"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1439"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1440">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.uvf.u.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1440">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1441">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1441">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1442">Konwertuje podpisaną wartość na górze stosu oceny na <see langword="unsigned int8" /> i rozszerza ją do <see langword="int32" />, co powoduje Przerzucanie <see cref="T:System.OverflowException" /> w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1442">Converts the signed value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1443">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1443">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1444">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1444">Format</span></span>|<span data-ttu-id="a1c4a-1445">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1445">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1446">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1446">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1447">B4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1447">B4</span></span>|<span data-ttu-id="a1c4a-1448">conv.ovf.u1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1448">conv.ovf.u1</span></span>|<span data-ttu-id="a1c4a-1449">Konwertuj na `unsigned int8` (na stosie jako `int32`) i Zgłoś wyjątek przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1449">Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1450">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1450">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1451">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1451">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1452">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1452">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1453">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1453">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1454">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1454">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1455">`conv.ovf.u1` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1455">The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1456">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1456">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1457">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1457">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1458">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1458">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1459"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1459"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1460">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1460">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1461">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1461">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1462">Konwertuje wartość bez znaku na szczycie stosu oceny do <see langword="unsigned int8" /> i rozszerza ją do <see langword="int32" />, co powoduje <see cref="T:System.OverflowException" /> Przerzucanie w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1462">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1463">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1463">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1464">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1464">Format</span></span>|<span data-ttu-id="a1c4a-1465">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1465">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1466">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1466">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1467">86</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1467">86</span></span>|<span data-ttu-id="a1c4a-1468">conv.ovf.u1.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1468">conv.ovf.u1.un</span></span>|<span data-ttu-id="a1c4a-1469">Konwertuje wartość bez znaku na `unsigned int8` (na stosie jako `int32`) i zgłasza wyjątek w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1469">Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1470">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1470">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1471">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1471">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1472">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1472">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1473">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1473">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1474">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1474">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1475">`conv.ovf.u1.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1475">The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1476">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1476">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1477">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1477">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1478">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1478">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1479"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1479"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1480">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u1.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1481">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1482">Konwertuje podpisaną wartość na górze stosu oceny na <see langword="unsigned int16" /> i rozszerza ją do <see langword="int32" />, co powoduje Przerzucanie <see cref="T:System.OverflowException" /> w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1482">Converts the signed value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1483">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1484">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1484">Format</span></span>|<span data-ttu-id="a1c4a-1485">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1485">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1486">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1487">B6</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1487">B6</span></span>|<span data-ttu-id="a1c4a-1488">conv.ovf.u2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1488">conv.ovf.u2</span></span>|<span data-ttu-id="a1c4a-1489">Konwertuj na `unsigned int16` (na stosie jako `int32`) i Zgłoś wyjątek przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1489">Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1490">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1491">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1491">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1492">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1492">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1493">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1493">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1494">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1494">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1495">`conv.ovf.u2` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1495">The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1496">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1496">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1497">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1497">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1498">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1498">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1499"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1499"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1500">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1500">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1501">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1501">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1502">Konwertuje wartość bez znaku na szczycie stosu oceny do <see langword="unsigned int16" /> i rozszerza ją do <see langword="int32" />, co powoduje <see cref="T:System.OverflowException" /> Przerzucanie w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1502">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1503">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1503">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1504">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1504">Format</span></span>|<span data-ttu-id="a1c4a-1505">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1505">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1506">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1506">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1507">87</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1507">87</span></span>|<span data-ttu-id="a1c4a-1508">conv.ovf.u2.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1508">conv.ovf.u2.un</span></span>|<span data-ttu-id="a1c4a-1509">Konwertuje wartość bez znaku na `unsigned int16` (na stosie jako `int32`) i zgłasza wyjątek w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1509">Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1510">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1510">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1511">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1511">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1512">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1512">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1513">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1513">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1514">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1514">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1515">`conv.ovf.u2.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1515">The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1516">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1516">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1517">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1517">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1518">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1518">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1519"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1519"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1520">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u2.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1520">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1521">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1521">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1522">Konwertuje podpisaną wartość znajdującą się na górze stosu oceny <see langword="unsigned int32" />na <see cref="T:System.OverflowException" /> , zwracając przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1522">Converts the signed value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1523">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1523">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1524">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1524">Format</span></span>|<span data-ttu-id="a1c4a-1525">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1525">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1526">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1526">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1527">B8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1527">B8</span></span>|<span data-ttu-id="a1c4a-1528">conv.ovf.u4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1528">conv.ovf.u4</span></span>|<span data-ttu-id="a1c4a-1529">Konwertuj na `unsigned int32` (na stosie jako `int32`) i Zgłoś wyjątek przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1529">Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1530">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1530">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1531">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1531">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1532">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1532">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1533">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1533">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1534">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1534">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1535">`conv.ovf.u4` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1535">The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1536">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1536">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1537">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1537">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1538">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1538">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1539"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1539"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1540">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1540">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1541">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1541">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1542">Konwertuje wartość bez znaku na górze stosu oceny do, która <see langword="unsigned int32" />zostanie przerzucana <see cref="T:System.OverflowException" /> w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1542">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1543">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1543">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1544">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1544">Format</span></span>|<span data-ttu-id="a1c4a-1545">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1545">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1546">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1546">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1547">88</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1547">88</span></span>|<span data-ttu-id="a1c4a-1548">conv.ovf.u4.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1548">conv.ovf.u4.un</span></span>|<span data-ttu-id="a1c4a-1549">Konwertuje wartość bez znaku na `unsigned int32` (na stosie jako `int32`) i zgłasza wyjątek w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1549">Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1550">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1550">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1551">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1551">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1552">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1552">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1553">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1553">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1554">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1554">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1555">`conv.ovf.u4.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1555">The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1556">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1556">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1557">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1557">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1558">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1558">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1559"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1559"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1560">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u4.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1560">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1561">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1561">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1562">Konwertuje podpisaną wartość znajdującą się na górze stosu oceny <see langword="unsigned int64" />na <see cref="T:System.OverflowException" /> , zwracając przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1562">Converts the signed value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1563">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1563">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1564">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1564">Format</span></span>|<span data-ttu-id="a1c4a-1565">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1565">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1566">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1566">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1567">BA</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1567">BA</span></span>|<span data-ttu-id="a1c4a-1568">conv.ovf.u8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1568">conv.ovf.u8</span></span>|<span data-ttu-id="a1c4a-1569">Konwertuj na `unsigned int64` (na stosie jako `int64`) i Zgłoś wyjątek przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1569">Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1570">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1570">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1571">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1571">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1572">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1572">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1573">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1573">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1574">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1574">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1575">`conv.ovf.u8` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1575">The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1576">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1576">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1577">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1577">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1578">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1578">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1579"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1579"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1580">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1580">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1581">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1581">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1582">Konwertuje wartość bez znaku na górze stosu oceny do, która <see langword="unsigned int64" />zostanie przerzucana <see cref="T:System.OverflowException" /> w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1582">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1583">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1583">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1584">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1584">Format</span></span>|<span data-ttu-id="a1c4a-1585">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1585">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1586">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1586">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1587">89</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1587">89</span></span>|<span data-ttu-id="a1c4a-1588">conv.ovf.u8.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1588">conv.ovf.u8.un</span></span>|<span data-ttu-id="a1c4a-1589">Konwertuje wartość bez znaku na `unsigned int64` (na stosie jako `int64`) i zgłasza wyjątek w przypadku przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1589">Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="a1c4a-1590">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1590">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1591">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1591">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1592">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1592">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="a1c4a-1593">W przypadku przepełnienia występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1593">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1594">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1594">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1595">`conv.ovf.u8.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i umieszcza tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1595">The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1596">Jeśli wartość jest zbyt duża lub za mała, aby mogła być reprezentowana przez typ docelowy, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1596">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-1597">Konwersje z liczb zmiennoprzecinkowych na wartości całkowite obcinają liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1597">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="a1c4a-1598">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` przedłużone do momentu ich załadowania do `conv.ovf.i` stosu `conv.ovf.u` oceny (chyba że lub są używane, w tym `native int`przypadku wynik jest również).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1598">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-1599"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1599"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-1600">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.ovf.u8.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1600">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1601">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1601">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1602">Konwertuje wartość liczby całkowitej bez znaku na górze stosu oceny na <see langword="float32" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1602">Converts the unsigned integer value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1603">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1603">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1604">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1604">Format</span></span>|<span data-ttu-id="a1c4a-1605">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1605">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1606">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1606">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1607">76</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1607">76</span></span>|<span data-ttu-id="a1c4a-1608">conv.r.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1608">conv.r.un</span></span>|<span data-ttu-id="a1c4a-1609">Konwertuj liczbę całkowitą bez znaku na zmiennoprzecinkową, wypychania `F` na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1609">Convert unsigned integer to floating-point, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1610">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1610">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1611">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1611">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1612">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1612">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1613">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1613">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1614">`conv.r.un` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1614">The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1615">Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1615">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="a1c4a-1616">Wartości zmiennoprzecinkowe są konwertowane na `F` typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1616">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="a1c4a-1617">Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1617">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="a1c4a-1618">Podczas konwertowania od a `float64` `float32`do, precyzja może zostać utracona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1618">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="a1c4a-1619">Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1619">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="a1c4a-1620">Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1620">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="a1c4a-1621">Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1621">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="a1c4a-1622">Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą `result` , zwracana wartość jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1622">If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified.</span></span> <span data-ttu-id="a1c4a-1623">Operacja przyjmuje liczbę całkowitą ze stosu, interpretuje ją jako unsigned i zastępuje ją liczbą zmiennoprzecinkową, aby reprezentować liczbę całkowitą: `float32`albo, jeśli jest wystarczająco szeroka, aby reprezentować liczbę całkowitą bez utraty dokładności, lub inną `conv.r.un` a `float64`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1623">The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.</span></span>  
  
 <span data-ttu-id="a1c4a-1624">W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1624">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="a1c4a-1625">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.r.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1625">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1626">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1626">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1627">Konwertuje wartość na górze stosu oceny na <see langword="float32" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1627">Converts the value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1628">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1628">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1629">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1629">Format</span></span>|<span data-ttu-id="a1c4a-1630">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1630">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1631">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1631">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1632">6B</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1632">6B</span></span>|<span data-ttu-id="a1c4a-1633">CONV. R4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1633">conv.r4</span></span>|<span data-ttu-id="a1c4a-1634">Konwertuj na `float32`, `F` wypychanie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1634">Convert to `float32`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1635">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1635">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1636">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1636">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1637">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1637">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1638">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1638">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1639">`conv.r4` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1639">The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1640">Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1640">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="a1c4a-1641">Wartości zmiennoprzecinkowe są konwertowane na `F` typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1641">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="a1c4a-1642">Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1642">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="a1c4a-1643">Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1643">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="a1c4a-1644">Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1644">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="a1c4a-1645">Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1645">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="a1c4a-1646">Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1646">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="a1c4a-1647">Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1647">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="a1c4a-1648">W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1648">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="a1c4a-1649">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.r4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1649">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1650">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1650">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1651">Konwertuje wartość na górze stosu oceny na <see langword="float64" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1651">Converts the value on top of the evaluation stack to <see langword="float64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1652">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1652">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1653">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1653">Format</span></span>|<span data-ttu-id="a1c4a-1654">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1654">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1655">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1655">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1656">6C</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1656">6C</span></span>|<span data-ttu-id="a1c4a-1657">conv.r8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1657">conv.r8</span></span>|<span data-ttu-id="a1c4a-1658">Konwertuj na `float64`, `F` wypychanie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1658">Convert to `float64`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1659">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1659">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1660">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1660">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1661">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1661">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1662">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1662">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1663">`conv.r8` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1663">The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1664">Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1664">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="a1c4a-1665">Wartości zmiennoprzecinkowe są konwertowane na `F` typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1665">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="a1c4a-1666">Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1666">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="a1c4a-1667">Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1667">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="a1c4a-1668">Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1668">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="a1c4a-1669">Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1669">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="a1c4a-1670">Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1670">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="a1c4a-1671">Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1671">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="a1c4a-1672">W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1672">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="a1c4a-1673">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.r8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1673">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1674">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1674">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1675">Konwertuje wartość na górze stosu oceny na <see langword="unsigned native int" />i rozszerza <see langword="native int" />ją na.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1675">Converts the value on top of the evaluation stack to <see langword="unsigned native int" />, and extends it to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1676">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1676">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1677">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1677">Format</span></span>|<span data-ttu-id="a1c4a-1678">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1678">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1679">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1679">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1680">E0</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1680">E0</span></span>|<span data-ttu-id="a1c4a-1681">conv.u</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1681">conv.u</span></span>|<span data-ttu-id="a1c4a-1682">Konwertuj na `unsigned native int`, `native int` wypychanie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1682">Convert to `unsigned native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1683">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1683">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1684">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1684">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1685">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1685">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1686">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1686">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1687">`conv.u` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1687">The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1688">Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1688">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="a1c4a-1689">Wartości zmiennoprzecinkowe są konwertowane na `F` typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1689">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="a1c4a-1690">Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1690">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="a1c4a-1691">Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1691">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="a1c4a-1692">Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1692">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="a1c4a-1693">Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1693">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="a1c4a-1694">Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1694">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="a1c4a-1695">Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1695">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="a1c4a-1696">W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1696">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="a1c4a-1697">Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1697">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="a1c4a-1698">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.u` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1698">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1699">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1699">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1700">Konwertuje wartość na górze stosu oceny na <see langword="unsigned int8" />i rozszerza <see langword="int32" />ją na.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1700">Converts the value on top of the evaluation stack to <see langword="unsigned int8" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1701">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1701">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1702">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1702">Format</span></span>|<span data-ttu-id="a1c4a-1703">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1703">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1704">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1704">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1705">D2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1705">D2</span></span>|<span data-ttu-id="a1c4a-1706">CONV. U1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1706">conv.u1</span></span>|<span data-ttu-id="a1c4a-1707">Konwertuj na `int8`, `int32` wypychanie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1707">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1708">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1708">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1709">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1709">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1710">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1710">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1711">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1711">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1712">`conv.u1` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1712">The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1713">Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1713">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="a1c4a-1714">Wartości zmiennoprzecinkowe są konwertowane na `F` typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1714">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="a1c4a-1715">Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1715">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="a1c4a-1716">Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1716">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="a1c4a-1717">Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1717">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="a1c4a-1718">Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1718">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="a1c4a-1719">Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1719">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="a1c4a-1720">Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1720">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="a1c4a-1721">W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1721">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="a1c4a-1722">Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1722">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="a1c4a-1723">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.u1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1723">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1724">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1724">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1725">Konwertuje wartość na górze stosu oceny na <see langword="unsigned int16" />i rozszerza <see langword="int32" />ją na.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1725">Converts the value on top of the evaluation stack to <see langword="unsigned int16" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1726">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1726">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1727">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1727">Format</span></span>|<span data-ttu-id="a1c4a-1728">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1728">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1729">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1729">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1730">D1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1730">D1</span></span>|<span data-ttu-id="a1c4a-1731">conv.u2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1731">conv.u2</span></span>|<span data-ttu-id="a1c4a-1732">Konwertuj na `int16`, `int32` wypychanie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1732">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1733">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1733">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1734">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1734">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1735">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1735">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1736">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1736">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1737">`conv.u2` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1737">The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1738">Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1738">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="a1c4a-1739">Wartości zmiennoprzecinkowe są konwertowane na `F` typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1739">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="a1c4a-1740">Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1740">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="a1c4a-1741">Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1741">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="a1c4a-1742">Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1742">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="a1c4a-1743">Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1743">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="a1c4a-1744">Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1744">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="a1c4a-1745">Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1745">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="a1c4a-1746">W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1746">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="a1c4a-1747">Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1747">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="a1c4a-1748">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.u2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1748">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1749">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1749">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1750">Konwertuje wartość na górze stosu oceny na <see langword="unsigned int32" />i rozszerza <see langword="int32" />ją na.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1750">Converts the value on top of the evaluation stack to <see langword="unsigned int32" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1751">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1751">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1752">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1752">Format</span></span>|<span data-ttu-id="a1c4a-1753">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1753">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1754">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1754">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1755">6D</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1755">6D</span></span>|<span data-ttu-id="a1c4a-1756">CONV. U4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1756">conv.u4</span></span>|<span data-ttu-id="a1c4a-1757">Konwertuj na `unsigned int32`, `int32` wypychanie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1757">Convert to `unsigned int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1758">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1758">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1759">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1759">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1760">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1760">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1761">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1761">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1762">`conv.u4` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1762">The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1763">Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1763">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="a1c4a-1764">Wartości zmiennoprzecinkowe są konwertowane na `F` typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1764">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="a1c4a-1765">Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1765">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="a1c4a-1766">Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1766">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="a1c4a-1767">Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1767">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="a1c4a-1768">Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1768">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="a1c4a-1769">Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1769">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="a1c4a-1770">Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1770">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="a1c4a-1771">W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1771">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="a1c4a-1772">Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1772">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="a1c4a-1773">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.u4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1773">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1774">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1774">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1775">Konwertuje wartość na górze stosu oceny na <see langword="unsigned int64" />i rozszerza <see langword="int64" />ją na.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1775">Converts the value on top of the evaluation stack to <see langword="unsigned int64" />, and extends it to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1776">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1776">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1777">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1777">Format</span></span>|<span data-ttu-id="a1c4a-1778">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1778">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1779">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1779">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1780">6E</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1780">6E</span></span>|<span data-ttu-id="a1c4a-1781">conv.u8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1781">conv.u8</span></span>|<span data-ttu-id="a1c4a-1782">Konwertuj na `int64`, `int64` wypychanie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1782">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1783">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1783">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1784">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1784">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1785">`value`zdjęte z stosu i podjęto próbę wykonania operacji konwersji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1785">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1786">Jeśli konwersja zakończy się pomyślnie, wartość wyniki jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1786">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1787">`conv.u8` Kod operacji `value` konwertuje na górze stosu do typu określonego w opcode i pozostawia tę przekonwertowaną wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1787">The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="a1c4a-1788">Wartości całkowite mniejsze niż 4 bajty są rozszerzane `int32` do momentu załadowania do stosu oceny (chyba `conv.i` że `conv.u` jest to wynik `native int`lub jest używany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1788">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="a1c4a-1789">Wartości zmiennoprzecinkowe są konwertowane na `F` typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1789">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="a1c4a-1790">Konwersja z liczb zmiennoprzecinkowych na wartości całkowite Obcina liczbę w kierunku zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1790">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="a1c4a-1791">Podczas konwertowania z `float64` `float32`do, precyzja może zostać utracona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1791">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="a1c4a-1792">Jeśli `value` jest za duża `float32 (F)`, aby zmieścić się w, nieskończoności dodatniej (Jeśli `value` jest dodatni) lub ujemną `value` nieskończoność (jeśli jest ujemna) jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1792">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="a1c4a-1793">Jeśli przepełnienie powoduje przekonwertowanie jednego typu liczb całkowitych na inny, bity o wysokim stopniu są obcinane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1793">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="a1c4a-1794">Jeśli wynik jest mniejszy niż `int32`, wartość jest podwyższana, aby wypełnić miejsce.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1794">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="a1c4a-1795">Jeśli przepełnienie powoduje przekonwertowanie typu zmiennoprzecinkowego na liczbę całkowitą, zwrócona wartość jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1795">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="a1c4a-1796">W przypadku korzystania z tego pola nie są kiedykolwiek zgłaszane żadne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1796">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="a1c4a-1797">Zobacz <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> i<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> , aby uzyskać równoważne instrukcje, które spowodują zgłoszenie wyjątku, gdy typ wyniku nie może prawidłowo przedstawić wartości wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1797">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="a1c4a-1798">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `conv.u8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1798">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1799">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1799">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1800">Kopiuje określoną liczbę bajtów z adresu źródłowego na adres docelowy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1800">Copies a specified number bytes from a source address to a destination address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1801">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1801">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1802">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1802">Format</span></span>|<span data-ttu-id="a1c4a-1803">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1803">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1804">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1804">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1805">FE 17</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1805">FE 17</span></span>|<span data-ttu-id="a1c4a-1806">cpblk</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1806">cpblk</span></span>|<span data-ttu-id="a1c4a-1807">Kopiuj dane z jednego bloku pamięci do innego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1807">Copy data from one memory block to another.</span></span>|  
  
 <span data-ttu-id="a1c4a-1808">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1808">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1809">Adres docelowy jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1809">The destination address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1810">Adres źródłowy jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1810">The source address is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1811">Liczba bajtów do skopiowania jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1811">The number of bytes to copy is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="a1c4a-1812">Liczba bajtów, adres źródłowy i adres docelowy są zdjęte ze stosu. określona liczba bajtów jest kopiowana z adresu źródłowego na adres docelowy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1812">The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</span></span>  
  
 <span data-ttu-id="a1c4a-1813">`native int` `native int` `&` `*` `*` `&`Instrukcja kopiuje liczbę (typ `unsigned int32`) bajtów z adresu źródłowego (typu, lub) do adresu docelowego (typu, lub). `cpblk`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1813">The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`).</span></span> <span data-ttu-id="a1c4a-1814">Zachowanie `cpblk` nie jest określone, jeśli obszary źródłowe i docelowe nakładają się na siebie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1814">The behavior of `cpblk` is unspecified if the source and destination areas overlap.</span></span>  
  
 <span data-ttu-id="a1c4a-1815">`cpblk`przyjęto założenie, że zarówno adres źródłowy, jak i docelowy są wyrównane do naturalnego rozmiaru maszyny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1815">`cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine.</span></span> <span data-ttu-id="a1c4a-1816">Instrukcja może być bezpośrednio poprzedzona `unaligned.<prefix>` instrukcją, aby wskazać, że źródło lub miejsce docelowe nie są wyrównane. `cpblk`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1816">The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.</span></span>  
  
 <span data-ttu-id="a1c4a-1817">Operację `cpblk` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1817">The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-1818"><xref:System.NullReferenceException>mogą być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1818"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-1819">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `cpblk` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1819">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1820">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1820">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1821">Kopiuje typ <see langword="&amp;" />wartości znajdujący się w adresie obiektu (typu <see langword="*" /> lub <see langword="native int" />) do <see langword="*" /> adresu obiektu docelowego (typu <see langword="&amp;" />lub <see langword="native int" />).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1821">Copies the value type located at the address of an object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />) to the address of the destination object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1822">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1822">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1823">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1823">Format</span></span>|<span data-ttu-id="a1c4a-1824">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1824">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1825">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1825">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1826">70 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-1826">70 < `T` ></span></span>|<span data-ttu-id="a1c4a-1827">cpobj `classTok`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1827">cpobj `classTok`</span></span>|<span data-ttu-id="a1c4a-1828">Kopiuje typ wartości z obiektu źródłowego do obiektu docelowego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1828">Copies a value type from a source object to a destination object.</span></span>|  
  
 <span data-ttu-id="a1c4a-1829">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1829">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1830">Odwołanie do obiektu docelowego jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1830">The destination object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1831">Odwołanie do obiektu źródłowego jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1831">The source object reference is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1832">Te dwa odwołania do obiektów są zdjęte ze stosu; Typ wartości pod adresem obiektu źródłowego jest kopiowany na adres obiektu docelowego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1832">The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</span></span>  
  
 <span data-ttu-id="a1c4a-1833">Zachowanie `cpobj` nie jest określone, jeśli odwołania do obiektów źródłowych i docelowych nie są wskaźnikami do wystąpień klasy reprezentowanej przez token `classTok` klasy (a `typeref` lub `typedef`) lub jeśli `classTok` nie reprezentują Typ wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1833">The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type.</span></span>  
  
 <span data-ttu-id="a1c4a-1834"><xref:System.NullReferenceException>mogą być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1834"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-1835">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `cpobj` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1835">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1836">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1836">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1837">Dzieli dwie wartości i wypycha wynik jako zmiennoprzecinkowe (Type <see langword="F" />) lub iloraz (Type <see langword="int32" />) na stosie oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1837">Divides two values and pushes the result as a floating-point (type <see langword="F" />) or quotient (type <see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1838">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1838">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1839">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1839">Format</span></span>|<span data-ttu-id="a1c4a-1840">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1840">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1841">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1841">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1842">5B</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1842">5B</span></span>|<span data-ttu-id="a1c4a-1843">div</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1843">div</span></span>|<span data-ttu-id="a1c4a-1844">Dzieli dwie wartości w celu zwrócenia wyniku ilorazu lub zmiennoprzecinkowego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1844">Divides two values to return a quotient or floating-point result.</span></span>|  
  
 <span data-ttu-id="a1c4a-1845">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1845">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1846">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1846">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1847">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1847">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1848">`value2`i `value1` są zdjęte ze stosu; jest podzielona `value2`przez. `value1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1848">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="a1c4a-1849">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1849">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1850">`result` = `value1`blok DIV wartość2 spełnia następujące warunki:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1850">`result` = `value1` div value2 satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="a1c4a-1851">&#124;`result` &#124; = &#124; / &#124;, i: &#124; &#124; `value1` `value2`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1851">&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:</span></span>  
  
 <span data-ttu-id="a1c4a-1852">Sign (`result`) = +, If SIGN (`value1`) = Sign (`value2`), or-, If SIGN (`value1`) ~ = Sign (`value2`)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1852">sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)</span></span>  
  
 <span data-ttu-id="a1c4a-1853">`div` Instrukcja oblicza wynik i wypchnięcie go na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1853">The `div` instruction computes the result and pushes it on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1854">Dzielenie liczb całkowitych jest obcinane do zera.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1854">Integer division truncates towards zero.</span></span>  
  
 <span data-ttu-id="a1c4a-1855">Dzielenie liczby skończonej przez zero powoduje prawidłowe podpisaną wartość nieskończoną.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1855">Division of a finite number by zero produces the correctly signed infinite value.</span></span>  
  
 <span data-ttu-id="a1c4a-1856">Dzielenie zera przez zero lub nieskończoność przez nieskończoność powoduje utworzenie wartości NaN (nie-Number).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1856">Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</span></span> <span data-ttu-id="a1c4a-1857">Każda liczba podzielona przez nieskończoność spowoduje wygenerowanie wartości zerowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1857">Any number divided by infinity will produce a zero value.</span></span>  
  
 <span data-ttu-id="a1c4a-1858">Operacje całek generują <xref:System.ArithmeticException> , jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1858">Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type.</span></span> <span data-ttu-id="a1c4a-1859">Może się tak zdarzyć `value1` , jeśli jest to maksymalna wartość ujemna `value2` i wynosi-1.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1859">This can happen if `value1` is the maximum negative value, and `value2` is -1.</span></span>  
  
 <span data-ttu-id="a1c4a-1860"><xref:System.DivideByZeroException> Jeśli`value2` wartość jest równa zero, operacje całkowite generują.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1860">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="a1c4a-1861">Należy pamiętać, że na platformach <xref:System.OverflowException> opartych na procesorze Intel jest zgłaszany podczas obliczania (Minint DIV-1).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1861">Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1).</span></span> <span data-ttu-id="a1c4a-1862">Operacje zmiennoprzecinkowe nigdy nie zgłaszają wyjątku (zamiast tego generują NaNs lub nieskończoności).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1862">Floating-point operations never throw an exception (they produce NaNs or infinities instead).</span></span>  
  
 <span data-ttu-id="a1c4a-1863">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `div` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1863">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1864">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1864">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1865">Dzieli dwie wartości bez znaku i wypchnij wynik (<see langword="int32" />) na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1865">Divides two unsigned integer values and pushes the result (<see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1866">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1866">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1867">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1867">Format</span></span>|<span data-ttu-id="a1c4a-1868">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1868">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1869">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1869">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1870">5C</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1870">5C</span></span>|<span data-ttu-id="a1c4a-1871">div.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1871">div.un</span></span>|<span data-ttu-id="a1c4a-1872">Dzieli dwie wartości, bez znaku, zwracając iloraz.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1872">Divides two values, unsigned, returning a quotient.</span></span>|  
  
 <span data-ttu-id="a1c4a-1873">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1873">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1874">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1874">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1875">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1875">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1876">`value2`i `value1` są zdjęte ze stosu; jest podzielona `value2`przez. `value1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1876">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="a1c4a-1877">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1877">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1878">Instrukcja oblicza podzieloną przez `value2`, zarówno jako liczby całkowite `result` bez znaku, i wypchnięcia na stosie. `value1` `div.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1878">The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1879">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `div.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1879">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1880">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1880">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1881">Kopiuje bieżącą wartość na stosie ewaluacyjnym, a następnie wypchnij kopię na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1881">Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1882">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1882">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1883">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1883">Format</span></span>|<span data-ttu-id="a1c4a-1884">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1884">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1885">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1885">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1886">25</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1886">25</span></span>|<span data-ttu-id="a1c4a-1887">DUP</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1887">dup</span></span>|<span data-ttu-id="a1c4a-1888">Duplikuje wartość w górnej części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1888">Duplicates the value on the top of the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-1889">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1889">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1890">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1890">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1891">`value`jest zdjęte na stosie dla duplikacji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1891">`value` is popped off of the stack for duplication.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1892">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1892">`value` is pushed back onto the stack.</span></span>  
  
4.  <span data-ttu-id="a1c4a-1893">Zduplikowana wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1893">A duplicate value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1894">`dup` Instrukcja duplikuje górny element stosu i pozostawia dwie identyczne wartości korzystającego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1894">The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it.</span></span>  
  
 <span data-ttu-id="a1c4a-1895">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `dup` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1895">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1896">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1896">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1897">Przenosi kontrolę z <see langword="filter" /> klauzuli wyjątku z powrotem do procedury obsługi wyjątków Common Language Infrastructure (CLI).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1897">Transfers control from the <see langword="filter" /> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1898">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1899">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1899">Format</span></span>|<span data-ttu-id="a1c4a-1900">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1900">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1901">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1902">FE 11</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1902">FE 11</span></span>|<span data-ttu-id="a1c4a-1903">Element Endfilter</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1903">endfilter</span></span>|<span data-ttu-id="a1c4a-1904">Klauzula End Filter dla obsługi wyjątków SEH.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1904">End filter clause of SEH exception handling.</span></span>|  
  
 <span data-ttu-id="a1c4a-1905">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1906">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1906">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1907">`value`zdjęte ze stosu; `endfilter` jest wykonywany i kontrola jest przenoszona do programu obsługi wyjątków.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1907">`value` is popped from the stack; `endfilter` is executed and control is transferred to the exception handler.</span></span>  
  
 <span data-ttu-id="a1c4a-1908">`Value`(który musi być typu `int32` i jest jednym z określonych wartości) jest zwracana z klauzuli Filter.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1908">`Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause.</span></span> <span data-ttu-id="a1c4a-1909">Powinien być jednym z:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1909">It should be one of:</span></span>  
  
-   <span data-ttu-id="a1c4a-1910">`exception_continue_search`(`value` = 0) aby kontynuować wyszukiwanie programu obsługi wyjątków</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1910">`exception_continue_search` (`value` = 0) to continue searching for an exception handler</span></span>  
  
-   <span data-ttu-id="a1c4a-1911">`exception_execute_handler`(`value` = 1) w celu rozpoczęcia drugiej fazy obsługi wyjątków, w której bloki finally są uruchamiane do momentu, w którym znajduje się procedura obsługi skojarzona z tą klauzulą filtru.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1911">`exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</span></span> <span data-ttu-id="a1c4a-1912">Po odnajdywaniu program obsługi jest wykonywany.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1912">Upon discovery, the handler is executed.</span></span>  
  
 <span data-ttu-id="a1c4a-1913">Inne wartości całkowite spowodują wygenerowanie nieokreślonych wyników.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1913">Other integer values will produce unspecified results.</span></span>  
  
 <span data-ttu-id="a1c4a-1914">Punkt wejścia filtru, jak pokazano w tabeli wyjątków metody, musi być pierwszą instrukcją w bloku kodu filtru.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1914">The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</span></span> <span data-ttu-id="a1c4a-1915">Instrukcja `endfilter` musi być ostatnią instrukcją w bloku kodu filtru (w związku z tym może być tylko jeden `endfilter` dla każdego pojedynczego bloku filtru).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1915">The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block).</span></span> <span data-ttu-id="a1c4a-1916">Po wykonaniu `endfilter` instrukcji kontrola logicznie przepływa z powrotem do mechanizmu obsługi wyjątków interfejsu wiersza polecenia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1916">After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.</span></span>  
  
 <span data-ttu-id="a1c4a-1917">Kontrolka nie może zostać przesłana do bloku filtru, z wyjątkiem mechanizmu wyjątku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1917">Control cannot be transferred into a filter block except through the exception mechanism.</span></span> <span data-ttu-id="a1c4a-1918">Nie można przenieść formantu z bloku filtru, z wyjątkiem użycia `throw` instrukcji lub przez wykonanie ostatniej `endfilter` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1918">Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction.</span></span> <span data-ttu-id="a1c4a-1919">Nie można osadzić `try` bloku `filter` w bloku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1919">You cannot embed a `try` block within a `filter` block.</span></span> <span data-ttu-id="a1c4a-1920">Jeśli wyjątek jest zgłaszany wewnątrz `filter` bloku, jest przechwytywany i zwracana jest wartość 0 (`exception_continue_search`).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1920">If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.</span></span>  
  
 <span data-ttu-id="a1c4a-1921">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `endfilter` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1921">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1922">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1922">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1923">Przenosi formant z <see langword="fault" /> klauzuli or <see langword="finally" /> bloku wyjątków z powrotem do procedury obsługi wyjątków Common Language Infrastructure (CLI).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1923">Transfers control from the <see langword="fault" /> or <see langword="finally" /> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1924">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1924">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1925">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1925">Format</span></span>|<span data-ttu-id="a1c4a-1926">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1926">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1927">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1927">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1928">DC</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1928">DC</span></span>|<span data-ttu-id="a1c4a-1929">element Endfinally</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1929">endfinally</span></span><br /><br /> <span data-ttu-id="a1c4a-1930">endfault</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1930">endfault</span></span>|<span data-ttu-id="a1c4a-1931">Zamyka klauzulę `fault`orblokuwyjątków `finally` .</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1931">Ends the `finally` or `fault` clause of an exception block.</span></span>|  
  
 <span data-ttu-id="a1c4a-1932">Dla tej instrukcji nie ma zachowań przejścia stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1932">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-1933">`Endfinally`i `endfault` sygnalizować koniec `finally` klauzuli or `fault` , aby można było kontynuować rozwinięcia stosu do momentu wywołania programu obsługi wyjątków.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1933">`Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked.</span></span> <span data-ttu-id="a1c4a-1934">Instrukcja `endfinally` lub`endfault` przeniesie kontrolę z powrotem do mechanizmu wyjątków interfejsu wiersza polecenia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1934">The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism.</span></span> <span data-ttu-id="a1c4a-1935">Mechanizm następnie wyszukuje następną `finally` klauzulę w łańcuchu, Jeśli chroniony blok został zakończony przy użyciu instrukcji opuszczania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1935">The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction.</span></span> <span data-ttu-id="a1c4a-1936">Jeśli chroniony blok został zakończony przy użyciu wyjątku, interfejs wiersza polecenia wyszukuje następny `finally` lub `fault`lub wprowadza procedurę obsługi wyjątków wybraną podczas pierwszego przebiegu obsługi wyjątków.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1936">If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.</span></span>  
  
 <span data-ttu-id="a1c4a-1937">Instrukcja może wystąpić tylko `finally` w obrębie bloku. `endfinally`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1937">An `endfinally` instruction might only appear lexically within a `finally` block.</span></span> <span data-ttu-id="a1c4a-1938">W przeciwieństwie `endfilter` do instrukcji nie istnieje wymóg, że blok kończy `endfinally` się instrukcją i może zawierać `endfinally` tyle instrukcji w bloku, ile jest to wymagane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1938">Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required.</span></span> <span data-ttu-id="a1c4a-1939">Te same ograniczenia dotyczą `endfault` instrukcji `fault` i bloku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1939">These same restrictions apply to the `endfault` instruction and the `fault` block.</span></span>  
  
 <span data-ttu-id="a1c4a-1940">Kontrolka nie może zostać przeniesiona `finally` do `fault`bloku (lub) z wyjątkiem mechanizmu wyjątku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1940">Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism.</span></span> <span data-ttu-id="a1c4a-1941">Kontrolka nie może być transferowana `finally` z bloku `fault`(lub), z wyjątkiem użycia `throw` instrukcji lub wykonywania `endfinally` instrukcji (lub `endfault`).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1941">Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction.</span></span> <span data-ttu-id="a1c4a-1942">W szczególności nie można "wyprowadzić" `finally` <xref:System.Reflection.Emit.OpCodes.Ret> bloku (lub `fault`) albo wykonać instrukcji lub <xref:System.Reflection.Emit.OpCodes.Leave> w `finally` bloku (lub `fault`).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1942">In particular, you cannot "fall out" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.</span></span>  
  
 <span data-ttu-id="a1c4a-1943">Zwróć uwagę, `endfault` że `endfinally` instrukcje i są aliasami — odpowiadają temu kodowi kodu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1943">Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode.</span></span>  
  
 <span data-ttu-id="a1c4a-1944">Poniższe <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `endfinally` użyć kodu operacji (`endfault`), a także `ILGenerator` metody <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1944">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span></span>  
  
-   <span data-ttu-id="a1c4a-1945">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1945">ILGenerator.Emit(OpCode)</span></span>  
  
-   <span data-ttu-id="a1c4a-1946">ILGenerator.EndExceptionBlock()</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1946">ILGenerator.EndExceptionBlock()</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1947">Inicjuje określony blok pamięci pod określonym adresem i początkową wartością.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1947">Initializes a specified block of memory at a specific address to a given size and initial value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1948">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1948">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1949">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1949">Format</span></span>|<span data-ttu-id="a1c4a-1950">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1950">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1951">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1951">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1952">FE 18</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1952">FE 18</span></span>|<span data-ttu-id="a1c4a-1953">initblk</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1953">initblk</span></span>|<span data-ttu-id="a1c4a-1954">Ustaw każdą lokalizację w bloku pamięci na daną wartość.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1954">Set each location in a block of memory to a given value.</span></span>|  
  
 <span data-ttu-id="a1c4a-1955">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1955">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1956">Adres początkowy jest wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1956">A starting address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1957">Wartość inicjalizacji jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1957">An initialization value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1958">Liczba bajtów do zainicjowania jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1958">The number of bytes to initialize is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="a1c4a-1959">Liczba bajtów, wartość inicjalizacji i adres początkowy są zdjęte ze stosu, a Inicjalizacja jest wykonywana zgodnie z ich wartościami.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1959">The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</span></span>  
  
 <span data-ttu-id="a1c4a-1960">`&` `native int` `*` `unsigned int8`Instrukcja ustawia liczbę (`unsigned int32`) bajtów rozpoczynającą się od określonego adresu (typu, lub) do wartości inicjującej (typu). `initblk`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1960">The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`).</span></span> <span data-ttu-id="a1c4a-1961">`initblk`przyjęto, że adres początkowy jest wyrównany do naturalnego rozmiaru maszyny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1961">`initblk` assumes that the starting address is aligned to the natural size of the machine.</span></span>  
  
 <span data-ttu-id="a1c4a-1962">Działanie `initblk` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1962">The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-1963"><xref:System.NullReferenceException>mogą być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1963"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-1964">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `initblk` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1964">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1965">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1965">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1966">Inicjuje każde pole typu wartości o określonym adresie do odwołania o wartości null lub 0 z odpowiedniego typu pierwotnego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1966">Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1967">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1967">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1968">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1968">Format</span></span>|<span data-ttu-id="a1c4a-1969">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1969">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1970">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1970">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1971">FE 15 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-1971">FE 15 < `T` ></span></span>|<span data-ttu-id="a1c4a-1972">`initobj``typeTok`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1972">`initobj` `typeTok`</span></span>|<span data-ttu-id="a1c4a-1973">Inicjuje typ wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1973">Initializes a value type.</span></span>|  
  
 <span data-ttu-id="a1c4a-1974">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1974">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1975">Adres typu wartości do zainicjowania jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1975">The address of the value type to initialize is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1976">Adres jest zdjęte ze stosu; Typ wartości pod określonym adresem jest inicjowany jako typ `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1976">The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`.</span></span>  
  
 <span data-ttu-id="a1c4a-1977">Instrukcja inicjuje każde pole o typie wartości określonym przez wypychany adres (typu `native int`, `&`lub `*`) do odwołania o wartości null lub 0 z odpowiedniego typu pierwotnego. `initobj`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1977">The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type.</span></span> <span data-ttu-id="a1c4a-1978">Po wywołaniu tej metody wystąpienie jest gotowe do wywołania metody konstruktora.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1978">After this method is called, the instance is ready for a constructor method to be called.</span></span> <span data-ttu-id="a1c4a-1979">Jeśli `typeTok` jest typem referencyjnym, ta instrukcja ma ten sam `ldnull` skutek, po którym `stind.ref`następuje.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1979">If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.</span></span>  
  
 <span data-ttu-id="a1c4a-1980">W <xref:System.Reflection.Emit.OpCodes.Newobj>przeciwieństwie `initobj` do, nie wywołuje metody konstruktora.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1980">Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method.</span></span> <span data-ttu-id="a1c4a-1981">`Initobj`jest przeznaczony do inicjowania typów wartości, podczas `newobj` gdy jest używany do przydzielania i inicjowania obiektów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1981">`Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects.</span></span>  
  
 <span data-ttu-id="a1c4a-1982">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `initobj` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1982">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-1983">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1983">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-1984">Testuje, czy odwołanie do obiektu <see langword="O" />(typ) jest wystąpieniem konkretnej klasy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1984">Tests whether an object reference (type <see langword="O" />) is an instance of a particular class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-1985">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1985">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-1986">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1986">Format</span></span>|<span data-ttu-id="a1c4a-1987">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1987">Assembly Format</span></span>|<span data-ttu-id="a1c4a-1988">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1988">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-1989">75 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-1989">75 < `T` ></span></span>|<span data-ttu-id="a1c4a-1990">Isinst`class`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1990">isinst `class`</span></span>|<span data-ttu-id="a1c4a-1991">Testuje `class`, czy odwołanie do obiektu jest wystąpieniem, zwracając odwołanie o wartości null lub wystąpienie tej klasy lub interfejsu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1991">Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface.</span></span>|  
  
 <span data-ttu-id="a1c4a-1992">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1992">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-1993">Odwołanie do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1993">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-1994">Odwołanie do obiektu jest zdjęte ze stosu i przetestowane, aby sprawdzić, czy jest to wystąpienie klasy, która została `class`przeniesiona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1994">The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`.</span></span>  
  
3.  <span data-ttu-id="a1c4a-1995">Wynik (odwołanie do obiektu lub odwołanie o wartości null) jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1995">The result (either an object reference or a null reference) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-1996">`Class`jest tokenem metadanych wskazującym żądaną klasę.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1996">`Class` is a metadata token indicating the desired class.</span></span> <span data-ttu-id="a1c4a-1997">Jeśli klasa obiektu `class` na górze stosu implementuje (Jeśli `class` jest interfejsem) lub `class` jest klasą pochodną (Jeśli `class` jest klasą regularną), jest rzutowana na typ `class` , a wynik jest wypychany na stosie. dokładnie tak, <xref:System.Reflection.Emit.OpCodes.Castclass> jakby został wywołany.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1997">If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called.</span></span> <span data-ttu-id="a1c4a-1998">W przeciwnym razie odwołanie o wartości null jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1998">Otherwise, a null reference is pushed on the stack.</span></span> <span data-ttu-id="a1c4a-1999">Jeśli odwołanie do obiektu jest odwołaniem null, `isinst` podobnie zwraca odwołanie o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-1999">If the object reference itself is a null reference, then `isinst` likewise returns a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2000"><xref:System.TypeLoadException>jest zgłaszany, jeśli nie można znaleźć klasy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2000"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="a1c4a-2001">Jest to zwykle wykrywane, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2001">This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="a1c4a-2002">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `isinst` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2003">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2003">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2004">Opuszcza bieżącą metodę i przechodzi do określonej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2004">Exits current method and jumps to specified method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2005">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2006">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2006">Format</span></span>|<span data-ttu-id="a1c4a-2007">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2007">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2008">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2009">27 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2009">27 < `T` ></span></span>|<span data-ttu-id="a1c4a-2010">element JMP`method`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2010">jmp `method`</span></span>|<span data-ttu-id="a1c4a-2011">Wyjdź z bieżącej metody i Przeskocz do określonej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2011">Exit current method and jump to specified method.</span></span>|  
  
 <span data-ttu-id="a1c4a-2012">Dla tej instrukcji nie ma zachowań przejścia stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2012">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-2013">Instrukcja (skoku) przenosi formant do metody określonej przez `method`, która jest tokenem metadanych dla odwołania do metody. `jmp`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2013">The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference.</span></span> <span data-ttu-id="a1c4a-2014">Bieżące argumenty są przekazywane do metody docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2014">The current arguments are transferred to the destination method.</span></span>  
  
 <span data-ttu-id="a1c4a-2015">Stos oceny musi być pusty, gdy ta instrukcja zostanie wykonana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2015">The evaluation stack must be empty when this instruction is executed.</span></span> <span data-ttu-id="a1c4a-2016">Konwencja wywoływania, liczba i typ argumentów w adresie docelowym muszą być zgodne z bieżącą metodą.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2016">The calling convention, number and type of arguments at the destination address must match that of the current method.</span></span>  
  
 <span data-ttu-id="a1c4a-2017">`filter` `try` `finally` `catch`Instrukcji nie można użyć do przetransferowania kontrolki z elementu,,, lub. `jmp`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2017">The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block.</span></span>  
  
 <span data-ttu-id="a1c4a-2018">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `jmp` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2018">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2019">ILGenerator.Emit(OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2019">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2020">Ładuje argument (do którego odwołuje się określona wartość indeksu) na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2020">Loads an argument (referenced by a specified index value) onto the stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2021">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2021">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2022">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2022">Format</span></span>|<span data-ttu-id="a1c4a-2023">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2023">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2024">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2024">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2025">FE 09 < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2025">FE 09 < `unsigned int16` ></span></span>|<span data-ttu-id="a1c4a-2026">ldarg `index`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2026">ldarg `index`</span></span>|<span data-ttu-id="a1c4a-2027">Załaduj argument `index` na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2027">Load argument at `index` onto stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2028">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2028">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2029">Wartość `index` argumentu jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2029">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2030">Instrukcja wypchnięcie argumentu indeksowanego w `index`, gdzie argumenty są indeksowane od 0 do wewnątrz na stosie szacowania. `ldarg`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2030">The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2031">`ldarg` Instrukcja może służyć do załadowania typu wartości lub wartości pierwotnej na stos przez skopiowanie jej z argumentu przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2031">The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="a1c4a-2032">Typ wartości argumentu jest taki sam jak typ argumentu, określony przez podpis bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2032">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="a1c4a-2033">W przypadku procedur, które pobierają listę argumentów o zmiennej długości `ldarg` , instrukcja może być używana tylko dla początkowych argumentów stałych, a nie dla zmiennych części sygnatury (zobacz instrukcje, <xref:System.Reflection.Emit.OpCodes.Arglist> Aby uzyskać więcej informacji).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2033">For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="a1c4a-2034">Argumenty, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty `int32` , są rozszerzane do typu podczas ładowania na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2034">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="a1c4a-2035">Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2035">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="a1c4a-2036">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarg` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2036">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2037">Elemencie ILGenerator. emisji (OpCode, krótkie)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2037">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2038">Ładuje argument pod indeksem 0 na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2038">Loads the argument at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2039">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2039">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2040">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2040">Format</span></span>|<span data-ttu-id="a1c4a-2041">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2041">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2042">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2042">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2043">02</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2043">02</span></span>|<span data-ttu-id="a1c4a-2044">ldarg. 0</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2044">ldarg.0</span></span>|<span data-ttu-id="a1c4a-2045">Załaduj argument 0 na stos</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2045">Load argument 0 onto stack</span></span>|  
  
 <span data-ttu-id="a1c4a-2046">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2046">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2047">Wartość argumentu w indeksie 0 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2047">The argument value at index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2048">`ldarg.0` Instrukcja jest wydajnym kodowaniem do ładowania wartości argumentu przy indeksie 0.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2048">The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0.</span></span>  
  
 <span data-ttu-id="a1c4a-2049">`ldarg.0` Instrukcja wypchnięcie argumentu indeksowanego o 0 na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2049">The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2050">`ldarg.0` Instrukcja może służyć do załadowania typu wartości lub wartości pierwotnej na stos przez skopiowanie jej z argumentu przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2050">The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="a1c4a-2051">Typ wartości argumentu jest taki sam jak typ argumentu, określony przez podpis bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2051">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="a1c4a-2052">Argumenty, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty `int32` , są rozszerzane do typu podczas ładowania na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2052">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="a1c4a-2053">Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2053">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="a1c4a-2054">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarg.0` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2054">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2055">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2055">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2056">Ładuje argument w indeksie 1 na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2056">Loads the argument at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2057">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2057">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2058">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2058">Format</span></span>|<span data-ttu-id="a1c4a-2059">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2059">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2060">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2060">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2061">03</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2061">03</span></span>|<span data-ttu-id="a1c4a-2062">ldarg. 1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2062">ldarg.1</span></span>|<span data-ttu-id="a1c4a-2063">Załaduj argument 1 na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2063">Load argument 1 onto stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2064">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2064">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2065">Wartość argumentu w indeksie 1 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2065">The argument value at index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2066">`ldarg.1` Instrukcja jest wydajnym kodowaniem do ładowania wartości argumentu przy indeksie 1.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2066">The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1.</span></span>  
  
 <span data-ttu-id="a1c4a-2067">`ldarg.1` Instrukcja wypchnięcie argumentu indeksowanego o 1 na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2067">The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2068">`ldarg.1` Instrukcja może służyć do załadowania typu wartości lub wartości pierwotnej na stos przez skopiowanie jej z argumentu przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2068">The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="a1c4a-2069">Typ wartości argumentu jest taki sam jak typ argumentu, określony przez podpis bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2069">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="a1c4a-2070">Argumenty, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty `int32` , są rozszerzane do typu podczas ładowania na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2070">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="a1c4a-2071">Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="a1c4a-2072">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarg.1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2074">Ładuje argument w indeksie 2 na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2074">Loads the argument at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2075">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2076">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2076">Format</span></span>|<span data-ttu-id="a1c4a-2077">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2077">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2078">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2079">04</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2079">04</span></span>|<span data-ttu-id="a1c4a-2080">ldarg. 2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2080">ldarg.2</span></span>|<span data-ttu-id="a1c4a-2081">Załaduj argument 2 na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2081">Load argument 2 onto stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2082">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2083">Wartość argumentu w indeksie 2 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2083">The argument value at index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2084">`ldarg.2` Instrukcja jest wydajnym kodowaniem do ładowania wartości argumentu przy indeksie 2.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2084">The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2.</span></span>  
  
 <span data-ttu-id="a1c4a-2085">`ldarg.2` Instrukcja wypchnięcie argumentu indeksowanego o 2 na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2085">The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2086">`ldarg.2` Instrukcja może służyć do załadowania typu wartości lub wartości pierwotnej na stos przez skopiowanie jej z argumentu przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2086">The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="a1c4a-2087">Typ wartości argumentu jest taki sam jak typ argumentu, określony przez podpis bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2087">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="a1c4a-2088">Argumenty, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty `int32` , są rozszerzane do typu podczas ładowania na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2088">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="a1c4a-2089">Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2089">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="a1c4a-2090">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarg.2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2090">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2091">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2091">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2092">Ładuje argument w indeksie 3 na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2092">Loads the argument at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2093">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2093">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2094">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2094">Format</span></span>|<span data-ttu-id="a1c4a-2095">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2095">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2096">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2096">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2097">05</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2097">05</span></span>|<span data-ttu-id="a1c4a-2098">ldarg. 3</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2098">ldarg.3</span></span>|<span data-ttu-id="a1c4a-2099">Załaduj argument 3 na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2099">Load argument 3 onto stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2100">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2100">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2101">Wartość argumentu w indeksie 3 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2101">The argument value at index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2102">`ldarg.3` Instrukcja jest wydajnym kodowaniem do ładowania wartości argumentu przy indeksie 3.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2102">The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3.</span></span>  
  
 <span data-ttu-id="a1c4a-2103">`ldarg.3` Instrukcja wypchnięcie argumentu indeksowanego w 3 na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2103">The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2104">`ldarg.3` Instrukcja może służyć do załadowania typu wartości lub wartości pierwotnej na stos przez skopiowanie jej z argumentu przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2104">The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="a1c4a-2105">Typ wartości argumentu jest taki sam jak typ argumentu, określony przez podpis bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2105">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="a1c4a-2106">Argumenty, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty `int32` , są rozszerzane do typu podczas ładowania na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2106">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="a1c4a-2107">Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2107">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="a1c4a-2108">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarg.3` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2108">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2109">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2109">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2110">Ładuje argument (do którego odwołuje się określony indeks formularza skróconego) na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2110">Loads the argument (referenced by a specified short form index) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2111">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2112">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2112">Format</span></span>|<span data-ttu-id="a1c4a-2113">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2113">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2114">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2115">0E < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2115">0E < `unsigned int8` ></span></span>|<span data-ttu-id="a1c4a-2116">ldarg. s`index`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2116">ldarg.s `index`</span></span>|<span data-ttu-id="a1c4a-2117">Załaduj argument `index` w na stosie, skróconej postaci.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2117">Load argument at `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-2118">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2119">Wartość `index` argumentu jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2119">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2120">`ldarg.s` Instrukcja to wydajne kodowanie dla załadowania argumentów indeksowanych z 4 do 255.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2120">The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255.</span></span>  
  
 <span data-ttu-id="a1c4a-2121">Instrukcja wypchnięcie argumentu indeksowanego w `index`, gdzie argumenty są indeksowane od 0 do wewnątrz na stosie szacowania. `ldarg.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2121">The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2122">`ldarg.s` Instrukcja może służyć do załadowania typu wartości lub wartości pierwotnej na stos przez skopiowanie jej z argumentu przychodzącego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2122">The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="a1c4a-2123">Typ wartości argumentu jest taki sam jak typ argumentu, określony przez podpis bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2123">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="a1c4a-2124">W przypadku procedur, które pobierają listę argumentów o zmiennej długości `ldarg.s` , instrukcja może być używana tylko dla początkowych argumentów stałych, a nie dla zmiennych części sygnatury (zobacz instrukcje, <xref:System.Reflection.Emit.OpCodes.Arglist> Aby uzyskać więcej informacji).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2124">For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="a1c4a-2125">Argumenty, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty `int32` , są rozszerzane do typu podczas ładowania na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2125">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="a1c4a-2126">Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2126">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="a1c4a-2127">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarg.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2127">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2128">Elemencie ILGenerator. emisji (OpCode, Byte)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2128">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2129">Załaduj adres argumentu na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2129">Load an argument address onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2130">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2130">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2131">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2131">Format</span></span>|<span data-ttu-id="a1c4a-2132">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2132">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2133">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2133">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2134">FE 0A <`unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2134">FE 0A < `unsigned int16` ></span></span>|<span data-ttu-id="a1c4a-2135">ldarga `index`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2135">ldarga `index`</span></span>|<span data-ttu-id="a1c4a-2136">Pobierz adres argumentu indeksowanego przez `index`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2136">Fetch the address of argument indexed by `index`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2137">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2137">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2138">Adres `addr` argumentu indeksowanego przez `index` jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2138">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2139">Instrukcja Pobiera adres (typ `*`) argumentu indeksowanego przez `index`, gdzie argumenty są indeksowane od 0 lub do wewnątrz. `ldarga`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2139">The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="a1c4a-2140">Adres `addr` jest zawsze wyrównany do naturalnej granicy na komputerze docelowym.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2140">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="a1c4a-2141">W przypadku procedur, które pobierają listę argumentów o zmiennej długości `ldarga` , instrukcja może być używana tylko dla początkowych argumentów stałych, a nie dla zmiennych części sygnatury.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2141">For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="a1c4a-2142">`ldarga`jest używany przez przekazywanie parametrów przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2142">`ldarga` is used for by-ref parameter passing.</span></span> <span data-ttu-id="a1c4a-2143">W innych przypadkach <xref:System.Reflection.Emit.OpCodes.Ldarg> i <xref:System.Reflection.Emit.OpCodes.Starg> powinny być używane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2143">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.</span></span>  
  
 <span data-ttu-id="a1c4a-2144">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarga` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2144">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2145">Elemencie ILGenerator. emisji (OpCode, krótkie)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2145">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2146">Załaduj adres argumentu w postaci skróconej na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2146">Load an argument address, in short form, onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2147">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2147">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2148">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2148">Format</span></span>|<span data-ttu-id="a1c4a-2149">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2149">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2150">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2150">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2151">0F < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2151">0F < `unsigned int8` ></span></span>|<span data-ttu-id="a1c4a-2152">ldarga.s `index`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2152">ldarga.s `index`</span></span>|<span data-ttu-id="a1c4a-2153">Pobierz adres argumentu, który jest indeksowany `index`przez, Short Form.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2153">Fetch the address of argument indexed by `index`, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-2154">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2154">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2155">Adres `addr` argumentu indeksowanego przez `index` jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2155">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2156">`ldarga.s`(krótka forma `ldarga`) powinna być używana dla numerów argumentów od 0 do 255 i jest bardziej wydajnym kodowaniem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2156">`ldarga.s` (the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding.</span></span>  
  
 <span data-ttu-id="a1c4a-2157">Instrukcja Pobiera adres (typ`*`) argumentu indeksowanego przez `index`, gdzie argumenty są indeksowane od 0 lub do wewnątrz. `ldarga.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2157">The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="a1c4a-2158">Adres `addr` jest zawsze wyrównany do naturalnej granicy na komputerze docelowym.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2158">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="a1c4a-2159">W przypadku procedur, które pobierają listę argumentów o zmiennej długości `ldarga.s` , instrukcja może być używana tylko dla początkowych argumentów stałych, a nie dla zmiennych części sygnatury.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2159">For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="a1c4a-2160">`ldarga.s`jest używany przez przekazywanie parametrów przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2160">`ldarga.s` is used for by-ref parameter passing.</span></span> <span data-ttu-id="a1c4a-2161">W innych przypadkach <xref:System.Reflection.Emit.OpCodes.Ldarg_S> i <xref:System.Reflection.Emit.OpCodes.Starg_S> powinny być używane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2161">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.</span></span>  
  
 <span data-ttu-id="a1c4a-2162">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldarga.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2162">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2163">Elemencie ILGenerator. emisji (OpCode, Byte)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2163">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2164">Wypchnięcie dostarczonej wartości typu <see langword="int32" /> na stos oceny <see langword="int32" />jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2164">Pushes a supplied value of type <see langword="int32" /> onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2165">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2165">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2166">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2166">Format</span></span>|<span data-ttu-id="a1c4a-2167">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2167">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2168">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2168">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2169">20 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2169">20 < `int32` ></span></span>|<span data-ttu-id="a1c4a-2170">LDC. i4`num`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2170">ldc.i4 `num`</span></span>|<span data-ttu-id="a1c4a-2171">Wypchnij wartość `num` na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2171">Pushes the value `num` onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2172">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2172">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2173">Wartość `num` jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2173">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2174">Należy zauważyć, że istnieją specjalne krótkie (i bardziej wydajne) kodowania dla liczb całkowitych — od 128 do 127, a szczególnie krótkie kodowania dla-1 do 8.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2174">Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</span></span> <span data-ttu-id="a1c4a-2175">Wszystkie krótkie kodowania wypychają 4 bajty całkowite na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2175">All short encodings push 4 byte integers on the stack.</span></span> <span data-ttu-id="a1c4a-2176">Dłuższe kodowania są używane w przypadku 8-bajtowych liczb całkowitych i 4 i 8-bajtowych liczb zmiennoprzecinkowych, a także wartości 4-bajtowych, które nie mieszczą się w krótkich formularzach.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2176">Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</span></span> <span data-ttu-id="a1c4a-2177">Istnieją trzy sposoby wypychania 8-bajtowej stałej całkowitej na stos</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2177">There are three ways to push an 8 byte integer constant onto the stack</span></span>  
  
 1. <span data-ttu-id="a1c4a-2178"><xref:System.Reflection.Emit.OpCodes.Ldc_I8> Użyj instrukcji dla stałych, które muszą być wyrażone w więcej niż 32 bitów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2178">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.</span></span>  
  
 2. <span data-ttu-id="a1c4a-2179">Użyj instrukcji i <xref:System.Reflection.Emit.OpCodes.Conv_I8> dla stałych, które wymagają od 9 do 32 bitów. <xref:System.Reflection.Emit.OpCodes.Ldc_I4></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2179">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.</span></span>  
  
 3. <span data-ttu-id="a1c4a-2180">Użyj krótkiej instrukcji formularza, a następnie <xref:System.Reflection.Emit.OpCodes.Conv_I8> dla stałych, które mogą być wyrażone w 8 lub mniejszej liczbie bitów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2180">Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.</span></span>  
  
 <span data-ttu-id="a1c4a-2181">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2181">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2182">Elemencie ILGenerator. emisji (OpCode, int)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2182">ILGenerator.Emit(OpCode, int)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2183">Wypchnij wartość całkowitą 0 na stos oceny jako <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2183">Pushes the integer value of 0 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2184">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2184">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2185">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2185">Format</span></span>|<span data-ttu-id="a1c4a-2186">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2186">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2187">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2187">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2188">16</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2188">16</span></span>|<span data-ttu-id="a1c4a-2189">ldc.i4.0</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2189">ldc.i4.0</span></span>|<span data-ttu-id="a1c4a-2190">Wypchnij 0 na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2190">Pushes 0 onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2191">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2191">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2192">Wartość 0 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2192">The value 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2193">Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 0.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2193">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="a1c4a-2194">Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2194">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2195">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.0` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2195">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2196">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2196">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2197">Wypchnij wartość całkowitą z 1 na stos oceny jako <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2197">Pushes the integer value of 1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2198">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2198">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2199">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2199">Format</span></span>|<span data-ttu-id="a1c4a-2200">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2200">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2201">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2201">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2202">17</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2202">17</span></span>|<span data-ttu-id="a1c4a-2203">ldc.i4.1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2203">ldc.i4.1</span></span>|<span data-ttu-id="a1c4a-2204">Wypchnij 1 na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2204">Pushes 1 onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2205">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2205">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2206">Wartość 1 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2206">The value 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2207">Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 1.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2207">This is a special short encoding for the push of the integer value 1.</span></span> <span data-ttu-id="a1c4a-2208">Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2208">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2209">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2209">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2210">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2210">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2211">Wypychanie wartości całkowitej 2 na stos oceny jako <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2211">Pushes the integer value of 2 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2212">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2212">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2213">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2213">Format</span></span>|<span data-ttu-id="a1c4a-2214">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2214">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2215">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2215">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2216">18</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2216">18</span></span>|<span data-ttu-id="a1c4a-2217">ldc.i4.2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2217">ldc.i4.2</span></span>|<span data-ttu-id="a1c4a-2218">Wypchnięcie 2 na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2218">Pushes 2 onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2219">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2219">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2220">Wartość 2 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2220">The value 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2221">Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 2.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2221">This is a special short encoding for the push of the integer value 2.</span></span> <span data-ttu-id="a1c4a-2222">Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2222">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2223">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2224">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2224">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2225">Wypchnij wartość całkowitą z 3 na stos oceny jako <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2225">Pushes the integer value of 3 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2226">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2227">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2227">Format</span></span>|<span data-ttu-id="a1c4a-2228">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2228">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2229">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2230">19</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2230">19</span></span>|<span data-ttu-id="a1c4a-2231">ldc.i4.3</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2231">ldc.i4.3</span></span>|<span data-ttu-id="a1c4a-2232">Wypychanie 3 na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2232">Pushes 3 onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2233">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2234">Wartość 3 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2234">The value 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2235">Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 3.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2235">This is a special short encoding for the push of the integer value 3.</span></span> <span data-ttu-id="a1c4a-2236">Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2236">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2237">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.3` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2237">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2238">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2238">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2239">Wypychanie wartości całkowitej 4 na stos oceny jako <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2239">Pushes the integer value of 4 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2240">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2240">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2241">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2241">Format</span></span>|<span data-ttu-id="a1c4a-2242">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2242">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2243">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2243">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2244">1A</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2244">1A</span></span>|<span data-ttu-id="a1c4a-2245">ldc.i4.4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2245">ldc.i4.4</span></span>|<span data-ttu-id="a1c4a-2246">Wypchnięcie 4 na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2246">Pushes 4 onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2247">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2247">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2248">Wartość 4 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2248">The value 4 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2249">Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 4.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2249">This is a special short encoding for the push of the integer value 4.</span></span> <span data-ttu-id="a1c4a-2250">Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2250">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2251">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2251">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2252">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2252">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2253">Wypchnięcie wartości całkowitej 5 na stos oceny jako <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2253">Pushes the integer value of 5 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2254">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2254">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2255">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2255">Format</span></span>|<span data-ttu-id="a1c4a-2256">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2256">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2257">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2257">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2258">1B</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2258">1B</span></span>|<span data-ttu-id="a1c4a-2259">ldc.i4.5</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2259">ldc.i4.5</span></span>|<span data-ttu-id="a1c4a-2260">Wypchnij 5 na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2260">Pushes 5 onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2261">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2261">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2262">Wartość 5 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2262">The value 5 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2263">Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 5.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2263">This is a special short encoding for the push of the integer value 5.</span></span> <span data-ttu-id="a1c4a-2264">Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2264">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2265">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.5` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2265">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2266">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2266">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2267">Wypychanie wartości całkowitej 6 na stos oceny jako <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2267">Pushes the integer value of 6 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2268">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2268">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2269">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2269">Format</span></span>|<span data-ttu-id="a1c4a-2270">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2270">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2271">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2271">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2272">1C</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2272">1C</span></span>|<span data-ttu-id="a1c4a-2273">ldc.i4.6</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2273">ldc.i4.6</span></span>|<span data-ttu-id="a1c4a-2274">Wypchnięcie 6 na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2274">Pushes 6 onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2275">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2275">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2276">Wartość 6 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2276">The value 6 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2277">Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 6.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2277">This is a special short encoding for the push of the integer value 6.</span></span> <span data-ttu-id="a1c4a-2278">Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2278">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2279">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.6` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2279">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2280">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2280">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2281">Wypchnij liczbę całkowitą z 7 na stos oceny jako <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2281">Pushes the integer value of 7 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2282">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2282">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2283">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2283">Format</span></span>|<span data-ttu-id="a1c4a-2284">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2284">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2285">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2285">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2286">1D</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2286">1D</span></span>|<span data-ttu-id="a1c4a-2287">ldc.i4.7</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2287">ldc.i4.7</span></span>|<span data-ttu-id="a1c4a-2288">Wypchnięcie 7 na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2288">Pushes 7 onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2289">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2289">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2290">Wartość 7 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2290">The value 7 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2291">Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 7.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2291">This is a special short encoding for the push of the integer value 7.</span></span> <span data-ttu-id="a1c4a-2292">Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2292">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2293">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.7` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2293">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2294">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2294">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2295">Wypychanie wartości całkowitej 8 na stos oceny jako <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2295">Pushes the integer value of 8 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2296">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2296">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2297">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2297">Format</span></span>|<span data-ttu-id="a1c4a-2298">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2298">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2299">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2299">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2300">1E</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2300">1E</span></span>|<span data-ttu-id="a1c4a-2301">ldc.i4.8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2301">ldc.i4.8</span></span>|<span data-ttu-id="a1c4a-2302">Wypchnięcie 8 na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2302">Pushes 8 onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2303">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2303">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2304">Wartość 8 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2304">The value 8 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2305">Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej 8.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2305">This is a special short encoding for the push of the integer value 8.</span></span> <span data-ttu-id="a1c4a-2306">Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2306">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2307">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2307">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2308">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2308">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2309">Wypchnięcie wartości całkowitej-1 na stosie oceny jako <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2309">Pushes the integer value of -1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2310">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2310">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2311">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2311">Format</span></span>|<span data-ttu-id="a1c4a-2312">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2312">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2313">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2313">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2314">15</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2314">15</span></span>|<span data-ttu-id="a1c4a-2315">ldc.i4.m1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2315">ldc.i4.m1</span></span>|<span data-ttu-id="a1c4a-2316">Wypchnięcia-1 na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2316">Pushes -1 onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2317">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2317">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2318">Wartość-1 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2318">The value -1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2319">Jest to specjalne krótkie kodowanie dla wypchnięcia wartości całkowitej-1.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2319">This is a special short encoding for the push of the integer value -1.</span></span> <span data-ttu-id="a1c4a-2320">Wszystkie specjalne krótkie kodowania wypychania 4-bajtowe liczby całkowite na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2320">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2321">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.m1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2321">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2322">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2322">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2323">Wypchnij podaną <see langword="int8" /> wartość na stos oceny <see langword="int32" />jako krótką formę.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2323">Pushes the supplied <see langword="int8" /> value onto the evaluation stack as an <see langword="int32" />, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2324">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2324">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2325">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2325">Format</span></span>|<span data-ttu-id="a1c4a-2326">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2326">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2327">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2327">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2328">1F < `int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2328">1F < `int8` ></span></span>|<span data-ttu-id="a1c4a-2329">ldc.i4.s `num`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2329">ldc.i4.s `num`</span></span>|<span data-ttu-id="a1c4a-2330">Wypchnij do stosu jako `int32`krótka forma. `num`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2330">Pushes `num` onto the stack as `int32`, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-2331">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2331">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2332">Wartość `num` jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2332">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2333">`ldc.i4.s`jest bardziej wydajnym kodowaniem do wypychania liczb całkowitych od-128 do 127 na stosie ewaluacyjnym.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2333">`ldc.i4.s` is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2334">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i4.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2335">Elemencie ILGenerator. emisji (OpCode, Byte)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2335">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2336">Wypchnięcie dostarczonej wartości typu <see langword="int64" /> na stos oceny <see langword="int64" />jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2336">Pushes a supplied value of type <see langword="int64" /> onto the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2337">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2337">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2338">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2338">Format</span></span>|<span data-ttu-id="a1c4a-2339">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2339">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2340">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2340">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2341">21 < `int64` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2341">21 < `int64` ></span></span>|<span data-ttu-id="a1c4a-2342">LDC. i8`num`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2342">ldc.i8 `num`</span></span>|<span data-ttu-id="a1c4a-2343">`int64`Wypchnij `num` na stos jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2343">Pushes `num` onto the stack as `int64`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2344">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2344">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2345">Wartość `num` jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2345">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2346">To kodowanie wypychanie `int64` wartości na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2346">This encoding pushes an `int64` value onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2347">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.i8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2348">Elemencie ILGenerator. emisji (OpCode, Long)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2348">ILGenerator.Emit(OpCode, long)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2349">Wypchnięcie dostarczonej wartości typu <see langword="float32" /> na stos oceny jako typ <see langword="F" /> (float).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2349">Pushes a supplied value of type <see langword="float32" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2350">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2351">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2351">Format</span></span>|<span data-ttu-id="a1c4a-2352">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2352">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2353">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2354">22 < `float32` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2354">22 < `float32` ></span></span>|<span data-ttu-id="a1c4a-2355">LDC. R4`num`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2355">ldc.r4 `num`</span></span>|<span data-ttu-id="a1c4a-2356">`F`Wypchnij `num` na stos jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2356">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2357">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2358">Wartość `num` jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2358">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2359">To kodowanie wypychanie `float32` wartości na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2359">This encoding pushes a `float32` value onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2360">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.r4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2360">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2361">Elemencie ILGenerator. emisji (OpCode, Single)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2361">ILGenerator.Emit(OpCode, single)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2362">Wypchnięcie dostarczonej wartości typu <see langword="float64" /> na stos oceny jako typ <see langword="F" /> (float).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2362">Pushes a supplied value of type <see langword="float64" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2363">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2363">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2364">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2364">Format</span></span>|<span data-ttu-id="a1c4a-2365">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2365">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2366">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2366">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2367">23 < `float64` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2367">23 < `float64` ></span></span>|<span data-ttu-id="a1c4a-2368">ldc.r8 `num`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2368">ldc.r8 `num`</span></span>|<span data-ttu-id="a1c4a-2369">`F`Wypchnij `num` na stos jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2369">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2370">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2370">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2371">Wartość `num` jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2371">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2372">To kodowanie wypychanie `float64` wartości na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2372">This encoding pushes a `float64` value onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2373">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldc.r8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2373">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2374">Elemencie ILGenerator. emisji (OpCode, Double)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2374">ILGenerator.Emit(OpCode, double)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2375">Ładuje element w określonym indeksie tablicy na początku stosu oceny jako typ określony w instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2375">Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2376">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2376">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2377">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2377">Format</span></span>|<span data-ttu-id="a1c4a-2378">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2378">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2379">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2379">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2380">A3 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2380">A3 < `T` ></span></span>|<span data-ttu-id="a1c4a-2381">ldelem`typeTok`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2381">ldelem `typeTok`</span></span>|<span data-ttu-id="a1c4a-2382">Ładuje element w `index` górnej części stosu jako typ `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2382">Loads the element at `index` onto the top of the stack as type `typeTok`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2383">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2383">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2384">Odwołanie `array` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2384">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2385">Wartość `index` indeksu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2385">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2386">`index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2386">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="a1c4a-2387">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2387">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2388">Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2388">The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="a1c4a-2389">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2389">Arrays are objects, and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="a1c4a-2390">Typ wartości zwracanej jest określany przez token `typeTok` w instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2390">The type of the return value is specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-2391"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2391"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2392"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż górna `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2392"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the upper bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-2393">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2393">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2394">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2394">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2395">Ładuje element z typem <see langword="native int" /> w określonym indeksie tablicy na początku stosu oceny <see langword="native int" />jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2395">Loads the element with type <see langword="native int" /> at a specified array index onto the top of the evaluation stack as a <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2396">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2396">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2397">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2397">Format</span></span>|<span data-ttu-id="a1c4a-2398">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2398">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2399">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2399">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2400">97</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2400">97</span></span>|<span data-ttu-id="a1c4a-2401">ldelem.i</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2401">ldelem.i</span></span>|<span data-ttu-id="a1c4a-2402">Ładuje element z typem `native int` w `index` górnej `native int`części stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2402">Loads the element with type `native int` at `index` onto the top of the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2403">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2403">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2404">Odwołanie `array` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2404">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2405">Wartość `index` indeksu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2405">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2406">`index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2406">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="a1c4a-2407">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2407">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2408">Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.i`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2408">The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="a1c4a-2409">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2409">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="a1c4a-2410">Wartość zwracana dla elementu `ldelem.i` is `native int`równa się.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2410">The return value for `ldelem.i` is `native int`.</span></span>  
  
 <span data-ttu-id="a1c4a-2411">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2411">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2412"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2412"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2413"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2413"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-2414"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2414"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-2415">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.i` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2415">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2416">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2416">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2417">Ładuje element z typem <see langword="int8" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int32" />jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2417">Loads the element with type <see langword="int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2418">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2418">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2419">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2419">Format</span></span>|<span data-ttu-id="a1c4a-2420">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2420">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2421">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2421">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2422">90</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2422">90</span></span>|<span data-ttu-id="a1c4a-2423">ldelem.i1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2423">ldelem.i1</span></span>|<span data-ttu-id="a1c4a-2424">Ładuje element z typem `int8` w `index` górnej `int32`części stosu jako element.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2424">Loads the element with type `int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2425">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2425">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2426">Odwołanie `array` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2426">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2427">Wartość `index` indeksu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2427">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2428">`index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2428">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="a1c4a-2429">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2429">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2430">Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.i1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2430">The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="a1c4a-2431">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2431">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="a1c4a-2432">Wartość zwracana dla elementu `ldelem.i1` is `int8`równa się.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2432">The return value for `ldelem.i1` is `int8`.</span></span>  
  
 <span data-ttu-id="a1c4a-2433">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2433">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2434"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2434"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2435"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2435"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-2436"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2436"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-2437">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.i1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2437">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2438">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2438">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2439">Ładuje element z typem <see langword="int16" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int32" />jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2439">Loads the element with type <see langword="int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2440">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2440">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2441">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2441">Format</span></span>|<span data-ttu-id="a1c4a-2442">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2442">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2443">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2443">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2444">92</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2444">92</span></span>|<span data-ttu-id="a1c4a-2445">ldelem.i2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2445">ldelem.i2</span></span>|<span data-ttu-id="a1c4a-2446">Ładuje element z typem `int16` w `index` górnej `int32`części stosu jako element.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2446">Loads the element with type `int16` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2447">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2447">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2448">Odwołanie `array` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2448">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2449">Wartość `index` indeksu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2449">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2450">`index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2450">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="a1c4a-2451">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2451">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2452">Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.i2`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2452">The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="a1c4a-2453">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2453">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="a1c4a-2454">Wartość zwracana dla elementu `ldelem.i2` is `int16`równa się.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2454">The return value for `ldelem.i2` is `int16`.</span></span>  
  
 <span data-ttu-id="a1c4a-2455">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2455">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2456"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2456"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2457"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2457"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-2458"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2458"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-2459">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.i2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2459">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2460">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2460">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2461">Ładuje element z typem <see langword="int32" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int32" />jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2461">Loads the element with type <see langword="int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2462">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2462">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2463">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2463">Format</span></span>|<span data-ttu-id="a1c4a-2464">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2464">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2465">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2465">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2466">94</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2466">94</span></span>|<span data-ttu-id="a1c4a-2467">ldelem.i4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2467">ldelem.i4</span></span>|<span data-ttu-id="a1c4a-2468">Ładuje element z typem `int32` w `index` górnej `int32`części stosu jako element.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2468">Loads the element with type `int32` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2469">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2469">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2470">Odwołanie `array` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2470">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2471">Wartość `index` indeksu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2471">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2472">`index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2472">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="a1c4a-2473">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2473">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2474">Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.i4`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2474">The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="a1c4a-2475">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2475">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="a1c4a-2476">Wartość zwracana dla elementu `ldelem.i4` is `int32`równa się.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2476">The return value for `ldelem.i4` is `int32`.</span></span>  
  
 <span data-ttu-id="a1c4a-2477">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2477">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2478"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2478"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2479"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2479"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-2480"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2480"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-2481">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.i4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2481">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2482">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2482">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2483">Ładuje element z typem <see langword="int64" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int64" />jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2483">Loads the element with type <see langword="int64" /> at a specified array index onto the top of the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2484">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2484">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2485">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2485">Format</span></span>|<span data-ttu-id="a1c4a-2486">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2486">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2487">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2487">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2488">96</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2488">96</span></span>|<span data-ttu-id="a1c4a-2489">ldelem.i8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2489">ldelem.i8</span></span>|<span data-ttu-id="a1c4a-2490">Ładuje element z typem `int64` w `index` górnej `int64`części stosu jako element.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2490">Loads the element with type `int64` at `index` onto the top of the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2491">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2491">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2492">Odwołanie `array` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2492">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2493">Wartość `index` indeksu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2493">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2494">`index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2494">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="a1c4a-2495">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2495">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2496">Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.i8`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2496">The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="a1c4a-2497">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2497">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="a1c4a-2498">Wartość zwracana dla elementu `ldelem.i8` is `int64`równa się.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2498">The return value for `ldelem.i8` is `int64`.</span></span>  
  
 <span data-ttu-id="a1c4a-2499">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2499">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2500"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2500"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2501"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2501"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-2502"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2502"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-2503">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.i8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2503">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2504">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2504">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2505">Ładuje element z typem <see langword="float32" /> w określonym indeksie tablicy na początku stosu oceny jako typ <see langword="F" /> (float).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2505">Loads the element with type <see langword="float32" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2506">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2506">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2507">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2507">Format</span></span>|<span data-ttu-id="a1c4a-2508">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2508">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2509">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2509">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2510">98</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2510">98</span></span>|<span data-ttu-id="a1c4a-2511">ldelem.r4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2511">ldelem.r4</span></span>|<span data-ttu-id="a1c4a-2512">Ładuje element z typem `float32` na `index` górze stosu jako typ `F`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2512">Loads the element with type `float32` at `index` onto the top of the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2513">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2513">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2514">Odwołanie `array` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2514">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2515">Wartość `index` indeksu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2515">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2516">`index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2516">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="a1c4a-2517">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2517">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2518">Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.r4`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2518">The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="a1c4a-2519">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2519">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="a1c4a-2520">Wartość zwracana dla elementu `ldelem.r4` is `float32`równa się.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2520">The return value for `ldelem.r4` is `float32`.</span></span>  
  
 <span data-ttu-id="a1c4a-2521">Wartości zmiennoprzecinkowe są konwertowane na typ `F` podczas ładowania na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2521">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2522"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2522"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2523"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2523"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-2524"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2524"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-2525">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.r4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2525">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2526">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2526">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2527">Ładuje element z typem <see langword="float64" /> w określonym indeksie tablicy na początku stosu oceny jako typ <see langword="F" /> (float).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2527">Loads the element with type <see langword="float64" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2528">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2528">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2529">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2529">Format</span></span>|<span data-ttu-id="a1c4a-2530">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2530">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2531">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2531">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2532">99</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2532">99</span></span>|<span data-ttu-id="a1c4a-2533">ldelem.r8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2533">ldelem.r8</span></span>|<span data-ttu-id="a1c4a-2534">Ładuje element z typem `float64` na `index` górze stosu jako typ `F`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2534">Loads the element with type `float64` at `index` onto the top of the stack as type `F`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2535">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2535">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2536">Odwołanie `array` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2536">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2537">Wartość `index` indeksu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2537">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2538">`index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2538">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="a1c4a-2539">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2539">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2540">Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.r8`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2540">The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="a1c4a-2541">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2541">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="a1c4a-2542">Wartość zwracana dla elementu `ldelem.r8` is `float64`równa się.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2542">The return value for `ldelem.r8` is `float64`.</span></span>  
  
 <span data-ttu-id="a1c4a-2543">Wartości zmiennoprzecinkowe są konwertowane na typ `F` podczas ładowania na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2543">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2544"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2544"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2545"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2545"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-2546"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2546"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-2547">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.r8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2547">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2548">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2548">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2549">Ładuje element zawierający odwołanie do obiektu w określonym indeksie tablicy na początku stosu oceny jako typ <see langword="O" /> (odwołanie do obiektu).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2549">Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <see langword="O" /> (object reference).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2550">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2550">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2551">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2551">Format</span></span>|<span data-ttu-id="a1c4a-2552">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2552">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2553">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2553">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2554">9A</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2554">9A</span></span>|<span data-ttu-id="a1c4a-2555">ldelem.ref</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2555">ldelem.ref</span></span>|<span data-ttu-id="a1c4a-2556">Ładuje element z odwołaniem do obiektu w `index` górnej części stosu jako typ. `O`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2556">Loads the element with an object reference at `index` onto the top of the stack as type `O`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2557">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2557">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2558">Odwołanie `array` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2558">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2559">Wartość `index` indeksu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2559">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2560">`index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2560">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="a1c4a-2561">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2561">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2562">Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.ref`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2562">The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="a1c4a-2563">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2563">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="a1c4a-2564">Wartość zwracana dla elementu `ldelem.ref` is Type `O` (odwołanie do obiektu).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2564">The return value for `ldelem.ref` is type `O` (object reference).</span></span>  
  
 <span data-ttu-id="a1c4a-2565"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2565"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2566"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2566"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-2567"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2567"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-2568">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.ref` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2568">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2569">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2569">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2570">Ładuje element z typem <see langword="unsigned int8" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int32" />jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2570">Loads the element with type <see langword="unsigned int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2571">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2571">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2572">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2572">Format</span></span>|<span data-ttu-id="a1c4a-2573">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2573">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2574">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2574">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2575">91</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2575">91</span></span>|<span data-ttu-id="a1c4a-2576">ldelem.u1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2576">ldelem.u1</span></span>|<span data-ttu-id="a1c4a-2577">Ładuje element z typem `unsigned int8` w `index` górnej `int32`części stosu jako element.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2577">Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2578">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2578">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2579">Odwołanie `array` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2579">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2580">Wartość `index` indeksu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2580">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2581">`index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2581">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="a1c4a-2582">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2582">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2583">Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.u1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2583">The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="a1c4a-2584">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2584">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="a1c4a-2585">Wartość zwracana dla elementu `ldelem.u1` is `int8`równa się.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2585">The return value for `ldelem.u1` is `int8`.</span></span>  
  
 <span data-ttu-id="a1c4a-2586">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2586">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2587"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2587"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2588"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2588"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-2589"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2589"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-2590">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.u1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2590">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2591">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2591">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2592">Ładuje element z typem <see langword="unsigned int16" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int32" />jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2592">Loads the element with type <see langword="unsigned int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2593">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2593">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2594">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2594">Format</span></span>|<span data-ttu-id="a1c4a-2595">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2595">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2596">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2596">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2597">93</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2597">93</span></span>|<span data-ttu-id="a1c4a-2598">ldelem.u2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2598">ldelem.u2</span></span>|<span data-ttu-id="a1c4a-2599">Ładuje element z typem `unsigned int16` przy indeksie na górze stosu `int32`jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2599">Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2600">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2600">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2601">Odwołanie `array` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2601">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2602">Wartość `index` indeksu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2602">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2603">`index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2603">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="a1c4a-2604">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2604">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2605">Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.u2`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2605">The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="a1c4a-2606">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2606">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="a1c4a-2607">Wartość zwracana dla elementu `ldelem.u2` is `int16`równa się.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2607">The return value for `ldelem.u2` is `int16`.</span></span>  
  
 <span data-ttu-id="a1c4a-2608">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2608">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2609"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2609"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2610"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2610"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-2611"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2611"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-2612">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.u2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2612">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2613">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2613">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2614">Ładuje element z typem <see langword="unsigned int32" /> w określonym indeksie tablicy na początku stosu oceny <see langword="int32" />jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2614">Loads the element with type <see langword="unsigned int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2615">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2615">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2616">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2616">Format</span></span>|<span data-ttu-id="a1c4a-2617">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2617">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2618">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2618">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2619">95</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2619">95</span></span>|<span data-ttu-id="a1c4a-2620">ldelem.u4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2620">ldelem.u4</span></span>|<span data-ttu-id="a1c4a-2621">Ładuje element z typem `unsigned int32` przy indeksie na górze stosu `int32`jako.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2621">Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2622">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2622">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2623">Odwołanie `array` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2623">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2624">Wartość `index` indeksu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2624">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2625">`index`i `array` są zdjęte ze stosu; wyszukiwana jest wartość przechowywana `index` na `array` pozycji w miejscu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2625">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="a1c4a-2626">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2626">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2627">Instrukcja ładuje wartość elementu z indeksem `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelem.u4`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2627">The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="a1c4a-2628">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2628">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="a1c4a-2629">Wartość zwracana dla elementu `ldelem.u4` is `int32`równa się.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2629">The return value for `ldelem.u4` is `int32`.</span></span>  
  
 <span data-ttu-id="a1c4a-2630">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2630">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2631"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2631"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2632"><xref:System.ArrayTypeMismatchException>jest zgłaszany, jeśli tablica nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2632"><xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-2633"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2633"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-2634">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelem.u4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2634">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2635">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2635">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2636">Ładuje adres elementu tablicy w określonym indeksie tablicy na początku stosu oceny jako typ <see langword="&amp;" /> (zarządzany wskaźnik).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2636">Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <see langword="&amp;" /> (managed pointer).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2637">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2637">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2638">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2638">Format</span></span>|<span data-ttu-id="a1c4a-2639">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2639">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2640">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2640">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2641">8F < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2641">8F < `T` ></span></span>|<span data-ttu-id="a1c4a-2642">ldelema`class`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2642">ldelema `class`</span></span>|<span data-ttu-id="a1c4a-2643">Ładuje adres elementu tablicy w `index` górnej części stosu oceny jako typ `&` (wskaźnik zarządzany).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2643">Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer).</span></span>|  
  
 <span data-ttu-id="a1c4a-2644">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2644">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2645">Odwołanie `array` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2645">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2646">Wartość `index` indeksu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2646">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2647">`index`i `array` są zdjęte ze stosu; adres zapisany na pozycji `index` w `array` jest wyszukiwany.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2647">`index` and `array` are popped from the stack; the address stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="a1c4a-2648">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2648">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2649">Służy do pobierania adresu obiektu w określonym indeksie w tablicy obiektów (typu `class`). `ldelema`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2649">The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`).</span></span> <span data-ttu-id="a1c4a-2650">Instrukcja ładuje adres wartości w indeksie `index` (Type `native int`) w tablicy `array` jednowymiarowej opartej na zero i umieszcza ją w górnej części stosu. `ldelema`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2650">The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="a1c4a-2651">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2651">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="a1c4a-2652">Wartość musi być typu `class` przeniesiona z instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2652">The value must be of type `class` passed with the instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-2653">Zwracana wartość dla `ldelema` jest wskaźnikiem zarządzanym (Type `&`).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2653">The return value for `ldelema` is a managed pointer (type `&`).</span></span>  
  
 <span data-ttu-id="a1c4a-2654">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2654">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2655"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2655"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-2656"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2656"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-2657"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2657"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-2658">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldelema` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2658">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2659">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2659">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2660">Znajduje wartość pola w obiekcie, którego odwołanie znajduje się obecnie na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2660">Finds the value of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2661">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2661">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2662">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2662">Format</span></span>|<span data-ttu-id="a1c4a-2663">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2663">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2664">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2664">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2665">7B < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2665">7B < `T` ></span></span>|<span data-ttu-id="a1c4a-2666">ldfld`field`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2666">ldfld `field`</span></span>|<span data-ttu-id="a1c4a-2667">Wypchnij wartość pola w określonym obiekcie na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2667">Pushes the value of a field in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2668">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2668">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2669">Odwołanie do obiektu (lub wskaźnik) jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2669">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2670">Odwołanie do obiektu (lub wskaźnik) jest zdjęte ze stosu; znaleziono wartość określonego pola w obiekcie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2670">The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2671">Wartość przechowywana w polu jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2671">The value stored in the field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2672">`ldfld` Instrukcja wypycha wartość pola znajdującego się w obiekcie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2672">The `ldfld` instruction pushes the value of a field located in an object onto the stack.</span></span> <span data-ttu-id="a1c4a-2673">Obiekt musi znajdować się na stosie jako odwołanie do obiektu ( `O`typ), zarządzany wskaźnik (typ `&`), niezarządzany wskaźnik ( `native int`typ), wskaźnik przejściowy ( `*`typ) lub wystąpienie typu wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2673">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="a1c4a-2674">Użycie niezarządzanego wskaźnika jest niedozwolone w kodzie możliwym do zweryfikowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2674">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="a1c4a-2675">Pole obiektu jest określone przez token metadanych, który musi odwoływać się do elementu członkowskiego pola.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2675">The object's field is specified by a metadata token that must refer to a field member.</span></span> <span data-ttu-id="a1c4a-2676">Zwracany typ jest taki sam jak skojarzony z polem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2676">The return type is the same as the one associated with the field.</span></span> <span data-ttu-id="a1c4a-2677">Pole może być polem wystąpienia (w którym przypadku obiekt nie może być odwołaniem o wartości null) ani polem statycznym.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2677">The field may be either an instance field (in which case the object must not be a null reference) or a static field.</span></span>  
  
 <span data-ttu-id="a1c4a-2678">Instrukcja może być poprzedzona przez jedną lub obie <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksy i <xref:System.Reflection.Emit.OpCodes.Volatile>. `ldfld`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2678">The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="a1c4a-2679"><xref:System.NullReferenceException>jest zgłaszany, jeśli obiekt ma wartość null, a pole nie jest statyczne.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2679"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="a1c4a-2680"><xref:System.MissingFieldException>jest zgłaszany, jeśli nie odnaleziono określonego pola w metadanych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2680"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="a1c4a-2681">Jest to zazwyczaj zaznaczone, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2681">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="a1c4a-2682">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldfld` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2682">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2683">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2683">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2684">Znajduje adres pola w obiekcie, którego odwołanie znajduje się obecnie na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2684">Finds the address of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2685">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2685">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2686">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2686">Format</span></span>|<span data-ttu-id="a1c4a-2687">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2687">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2688">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2688">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2689">7C < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2689">7C < `T` ></span></span>|<span data-ttu-id="a1c4a-2690">ldflda `field`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2690">ldflda `field`</span></span>|<span data-ttu-id="a1c4a-2691">Wypchnięcie adresu `field` do określonego obiektu na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2691">Pushes the address of `field` in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2692">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2692">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2693">Odwołanie do obiektu (lub wskaźnik) jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2693">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2694">Odwołanie do obiektu (lub wskaźnik) jest zdjęte ze stosu; znaleziono adres określonego pola w obiekcie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2694">The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2695">Adres określonego pola jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2695">The address of the specified field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2696">`ldflda` Instrukcja wypycha adres pola znajdującego się w obiekcie na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2696">The `ldflda` instruction pushes the address of a field located in an object onto the stack.</span></span> <span data-ttu-id="a1c4a-2697">Obiekt musi znajdować się na stosie jako odwołanie do obiektu ( `O`typ), zarządzany wskaźnik (typ `&`), niezarządzany wskaźnik ( `native int`typ), wskaźnik przejściowy ( `*`typ) lub wystąpienie typu wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2697">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="a1c4a-2698">Użycie niezarządzanego wskaźnika jest niedozwolone w kodzie możliwym do zweryfikowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2698">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="a1c4a-2699">Pole obiektu jest określone przez token metadanych, który musi odwoływać się do elementu członkowskiego pola.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2699">The object's field is specified by a metadata token that must refer to a field member.</span></span>  
  
 <span data-ttu-id="a1c4a-2700">Wartość zwracana przez `ldflda` jest wskaźnikiem zarządzanym (Type `&`), chyba że obiekt jest wypychany do stosu jako niezarządzany wskaźnik, w tym przypadku adres zwrotny jest również wskaźnikiem niezarządzanym (typ `native int`).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2700">The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`).</span></span>  
  
 <span data-ttu-id="a1c4a-2701">Instrukcja może być poprzedzona przez jedną lub obie <xref:System.Reflection.Emit.OpCodes.Unaligned> prefiksy i <xref:System.Reflection.Emit.OpCodes.Volatile>. `ldflda`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2701">The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="a1c4a-2702"><xref:System.InvalidOperationException>jest zgłaszany, jeśli obiekt nie znajduje się w domenie aplikacji, z której jest uzyskiwany dostęp.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2702"><xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed.</span></span> <span data-ttu-id="a1c4a-2703">Nie można załadować adresu pola, które nie znajduje się w domenie aplikacji do uzyskiwania dostępu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2703">The address of a field that is not inside the accessing application domain cannot be loaded.</span></span>  
  
 <span data-ttu-id="a1c4a-2704"><xref:System.NullReferenceException>jest zgłaszany, jeśli obiekt ma wartość null, a pole nie jest statyczne.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2704"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="a1c4a-2705"><xref:System.MissingFieldException>jest zgłaszany, jeśli nie odnaleziono określonego pola w metadanych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2705"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="a1c4a-2706">Jest to zazwyczaj zaznaczone, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2706">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="a1c4a-2707">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldflda` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2707">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2708">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2708">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2709">Wypchnij niezarządzany wskaźnik ( <see langword="native int" />typ) do kodu natywnego implementującego określoną metodę na stosie ewaluacyjnym.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2709">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a specific method onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2710">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2710">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2711">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2711">Format</span></span>|<span data-ttu-id="a1c4a-2712">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2712">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2713">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2713">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2714">FE 06 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-2714">FE 06 < `T` ></span></span>|<span data-ttu-id="a1c4a-2715">Ldftn`method`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2715">ldftn `method`</span></span>|<span data-ttu-id="a1c4a-2716">Wypchnięcie wskaźnika do metody, `method` do której odwołuje się stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2716">Pushes a pointer to a method referenced by `method` on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2717">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2717">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2718">Niezarządzany wskaźnik do określonej metody jest wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2718">The unmanaged pointer to a specific method is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2719">Konkretna metoda (`method`) może być wywoływana przy użyciu <xref:System.Reflection.Emit.OpCodes.Calli> instrukcji, jeśli odwołuje się do metody zarządzanej (lub zastępczej, która przechodzi z kodu zarządzanego do niezarządzanego).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2719">The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="a1c4a-2720">Wartość zwrócona wskazuje na kod natywny przy użyciu konwencji wywoływania CLR.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2720">The value returned points to native code using the CLR calling convention.</span></span> <span data-ttu-id="a1c4a-2721">Tego wskaźnika metody nie należy przekazywać do niezarządzanego kodu natywnego jako procedury wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2721">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="a1c4a-2722">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldftn` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2723">ILGenerator.Emit(OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2723">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2724">Ładuje wartość typu <see langword="native int" /> <see langword="native int" /> na stosie oceny pośrednio.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2724">Loads a value of type <see langword="native int" /> as a <see langword="native int" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2725">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2726">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2726">Format</span></span>|<span data-ttu-id="a1c4a-2727">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2727">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2728">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2729">4D</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2729">4D</span></span>|<span data-ttu-id="a1c4a-2730">ldind.i</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2730">ldind.i</span></span>|<span data-ttu-id="a1c4a-2731">Ładuje wartość na adres `addr` na stos jako `native int`. `native int`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2731">Loads the `native int` value at address `addr` onto the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2732">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2732">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2733">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2733">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2734">Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2734">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2735">Pobrana wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2735">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2736">`native int` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub \*) na stosie jako. `native int` `ldind.i`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2736">The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `native int`.</span></span>  
  
 <span data-ttu-id="a1c4a-2737">Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2737">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="a1c4a-2738">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2738">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2739">Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2739">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2740">Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2740">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="a1c4a-2741">Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2741">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="a1c4a-2742">Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2742">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="a1c4a-2743">W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2743">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="a1c4a-2744">Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2744">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="a1c4a-2745"><xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2745"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-2746">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.i` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2746">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2747">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2747">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2748">Ładuje wartość typu <see langword="int8" /> <see langword="int32" /> na stosie oceny pośrednio.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2748">Loads a value of type <see langword="int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2749">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2749">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2750">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2750">Format</span></span>|<span data-ttu-id="a1c4a-2751">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2751">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2752">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2752">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2753">46</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2753">46</span></span>|<span data-ttu-id="a1c4a-2754">ldind.i1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2754">ldind.i1</span></span>|<span data-ttu-id="a1c4a-2755">Ładuje wartość pod `addr` adresem`int32`nastosjako. `int8`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2755">Loads the `int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2756">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2756">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2757">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2757">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2758">Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2758">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2759">Pobrana wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2759">The fetched value is pushed onto the stack.</span></span> 
  
 <span data-ttu-id="a1c4a-2760">`int32` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub \*) na stosie jako. `int8` `ldind.i1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2760">The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="a1c4a-2761">Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2761">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="a1c4a-2762">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2762">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2763">Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2763">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2764">Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2764">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="a1c4a-2765">Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2765">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="a1c4a-2766">Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2766">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="a1c4a-2767">W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2767">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="a1c4a-2768">Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2768">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="a1c4a-2769"><xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2769"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-2770">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.i1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2770">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2771">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2771">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2772">Ładuje wartość typu <see langword="int16" /> <see langword="int32" /> na stosie oceny pośrednio.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2772">Loads a value of type <see langword="int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2773">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2773">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2774">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2774">Format</span></span>|<span data-ttu-id="a1c4a-2775">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2775">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2776">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2776">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2777">48</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2777">48</span></span>|<span data-ttu-id="a1c4a-2778">ldind. I2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2778">ldind.i2</span></span>|<span data-ttu-id="a1c4a-2779">Ładuje wartość pod `addr` adresem`int32`nastosjako. `int16`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2779">Loads the `int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2780">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2780">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2781">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2781">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2782">Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2782">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2783">Pobrana wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2783">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2784">`int32` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub \*) na stosie jako. `int16` `ldind.i2`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2784">The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="a1c4a-2785">Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2785">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="a1c4a-2786">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2786">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2787">Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2787">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2788">Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2788">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="a1c4a-2789">Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2789">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="a1c4a-2790">Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2790">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="a1c4a-2791">W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2791">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="a1c4a-2792">Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2792">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="a1c4a-2793"><xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2793"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-2794">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.i2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2794">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2795">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2795">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2796">Ładuje wartość typu <see langword="int32" /> <see langword="int32" /> na stosie oceny pośrednio.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2796">Loads a value of type <see langword="int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2797">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2797">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2798">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2798">Format</span></span>|<span data-ttu-id="a1c4a-2799">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2799">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2800">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2800">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2801">4A</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2801">4A</span></span>|<span data-ttu-id="a1c4a-2802">ldind. i4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2802">ldind.i4</span></span>|<span data-ttu-id="a1c4a-2803">Ładuje wartość pod `addr` adresem`int32`nastosjako. `int32`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2803">Loads the `int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2804">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2804">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2805">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2805">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2806">Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2806">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2807">Pobrana wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2807">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2808">`int32` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub \*) na stosie jako. `int32` `ldind.i4`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2808">The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="a1c4a-2809">Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2809">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="a1c4a-2810">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2810">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2811">Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2811">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2812">Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2812">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="a1c4a-2813">Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2813">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="a1c4a-2814">Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2814">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="a1c4a-2815">W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2815">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="a1c4a-2816">Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2816">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="a1c4a-2817"><xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2817"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-2818">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.i4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2819">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2819">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2820">Ładuje wartość typu <see langword="int64" /> <see langword="int64" /> na stosie oceny pośrednio.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2820">Loads a value of type <see langword="int64" /> as an <see langword="int64" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2821">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2821">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2822">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2822">Format</span></span>|<span data-ttu-id="a1c4a-2823">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2823">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2824">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2824">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2825">4C</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2825">4C</span></span>|<span data-ttu-id="a1c4a-2826">ldind.i8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2826">ldind.i8</span></span>|<span data-ttu-id="a1c4a-2827">Ładuje wartość pod `addr` adresem`int64`nastosjako. `int64`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2827">Loads the `int64` value at address `addr` onto the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2828">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2828">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2829">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2829">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2830">Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2830">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2831">Pobrana wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2831">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2832">`int64` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub \*) na stosie jako. `int64` `ldind.i8`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2832">The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int64`.</span></span>  
  
 <span data-ttu-id="a1c4a-2833">Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2833">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="a1c4a-2834">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2834">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2835">Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2835">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2836">Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2836">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="a1c4a-2837">Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2837">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="a1c4a-2838">Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2838">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="a1c4a-2839">W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2839">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="a1c4a-2840">Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2840">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="a1c4a-2841"><xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2841"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-2842">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.i8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2842">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2843">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2843">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2844">Ładuje wartość typu <see langword="float32" /> jako typ <see langword="F" /> (float) na stosie oceny pośrednio.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2844">Loads a value of type <see langword="float32" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2845">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2845">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2846">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2846">Format</span></span>|<span data-ttu-id="a1c4a-2847">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2847">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2848">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2848">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2849">4E</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2849">4E</span></span>|<span data-ttu-id="a1c4a-2850">ldind. R4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2850">ldind.r4</span></span>|<span data-ttu-id="a1c4a-2851">Ładuje wartość pod adresem `addr` na stos jako typ `F`. `float32`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2851">Loads the `float32` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2852">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2852">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2853">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2853">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2854">Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2854">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2855">Pobrana wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2855">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2856">`F` `&` `native int`Instrukcja pośrednio `float32` ładuje wartość z podanego adresu (typu, lub \*) na stos jako typ. `ldind.r4`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2856">The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a type `F`.</span></span>  
  
 <span data-ttu-id="a1c4a-2857">Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2857">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="a1c4a-2858">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2858">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2859">Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2859">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2860">Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2860">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="a1c4a-2861">Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2861">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="a1c4a-2862">Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2862">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="a1c4a-2863">W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2863">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="a1c4a-2864">Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2864">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="a1c4a-2865"><xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2865"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-2866">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.r4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2866">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2867">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2867">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2868">Ładuje wartość typu <see langword="float64" /> jako typ <see langword="F" /> (float) na stosie oceny pośrednio.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2868">Loads a value of type <see langword="float64" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2869">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2869">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2870">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2870">Format</span></span>|<span data-ttu-id="a1c4a-2871">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2871">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2872">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2872">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2873">4F</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2873">4F</span></span>|<span data-ttu-id="a1c4a-2874">ldind. R8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2874">ldind.r8</span></span>|<span data-ttu-id="a1c4a-2875">Ładuje wartość pod adresem `addr` na stos jako typ `F`. `float64`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2875">Loads the `float64` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2876">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2876">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2877">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2877">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2878">Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2878">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2879">Pobrana wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2879">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2880">`float64` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub \*) na stosie jako. `float64` `ldind.r8`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2880">The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `float64`.</span></span>  
  
 <span data-ttu-id="a1c4a-2881">Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2881">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="a1c4a-2882">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2882">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2883">Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2883">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2884">Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2884">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="a1c4a-2885">Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2885">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="a1c4a-2886">Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2886">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="a1c4a-2887">W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2887">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="a1c4a-2888">Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2888">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="a1c4a-2889"><xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2889"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-2890">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.r8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2890">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2891">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2891">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2892">Wczytuje odwołanie do obiektu jako typ <see langword="O" /> (odwołanie do obiektu) na stosie oceny pośrednio.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2892">Loads an object reference as a type <see langword="O" /> (object reference) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2893">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2893">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2894">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2894">Format</span></span>|<span data-ttu-id="a1c4a-2895">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2895">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2896">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2896">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2897">50</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2897">50</span></span>|<span data-ttu-id="a1c4a-2898">ldind.ref</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2898">ldind.ref</span></span>|<span data-ttu-id="a1c4a-2899">Ładuje odwołanie do obiektu na `addr` stosie jako typ`O`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2899">Loads the object reference at address `addr` onto the stack as a type `O`</span></span>|  
  
 <span data-ttu-id="a1c4a-2900">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2900">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2901">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2901">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2902">Adres jest zdjęte ze stosu; pobrano odwołanie do obiektu znajdującego się pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2902">The address is popped from the stack; the object reference located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2903">Pobrane odwołanie jest wypychane do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2903">The fetched reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2904">Instrukcja pośrednio wczytuje obiekt odwołuje się do określonego adresu (typu `native int`, `&`lub \*) na stos jako typ `O`. `ldind.ref`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2904">The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or \*) onto the stack as type `O`.</span></span>  
  
 <span data-ttu-id="a1c4a-2905">Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2905">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="a1c4a-2906">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2906">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2907">Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2907">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2908">Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2908">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="a1c4a-2909">Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2909">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="a1c4a-2910">Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2910">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="a1c4a-2911">W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2911">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="a1c4a-2912">Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2912">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="a1c4a-2913"><xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2913"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-2914">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.ref` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2914">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2915">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2915">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2916">Ładuje wartość typu <see langword="unsigned int8" /> <see langword="int32" /> na stosie oceny pośrednio.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2916">Loads a value of type <see langword="unsigned int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2917">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2917">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2918">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2918">Format</span></span>|<span data-ttu-id="a1c4a-2919">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2919">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2920">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2920">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2921">47</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2921">47</span></span>|<span data-ttu-id="a1c4a-2922">ldind. U1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2922">ldind.u1</span></span>|<span data-ttu-id="a1c4a-2923">Ładuje wartość pod `addr` adresem`int32`nastosjako. `unsigned int8`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2923">Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2924">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2924">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2925">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2925">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2926">Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2926">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2927">Pobrana wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2927">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2928">`int32``native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub \*) na stosie jako. `unsigned int8` `ldind.u1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2928">The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="a1c4a-2929">Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2929">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="a1c4a-2930">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2930">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2931">Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2931">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2932">Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2932">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="a1c4a-2933">Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2933">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="a1c4a-2934">Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2934">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="a1c4a-2935">W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2935">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="a1c4a-2936">Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2936">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="a1c4a-2937"><xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2937"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-2938">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.u1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2938">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2939">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2939">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2940">Ładuje wartość typu <see langword="unsigned int16" /> <see langword="int32" /> na stosie oceny pośrednio.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2940">Loads a value of type <see langword="unsigned int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2941">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2942">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2942">Format</span></span>|<span data-ttu-id="a1c4a-2943">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2943">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2944">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2945">49</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2945">49</span></span>|<span data-ttu-id="a1c4a-2946">ldind.u2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2946">ldind.u2</span></span>|<span data-ttu-id="a1c4a-2947">Ładuje wartość pod `addr` adresem`int32`nastosjako. `unsigned int16`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2947">Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2948">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2949">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2949">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2950">Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2950">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2951">Pobrana wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2951">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2952">`int32` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub \*) na stosie jako. `unsigned int16` `ldind.u2`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2952">The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="a1c4a-2953">Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2953">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="a1c4a-2954">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2954">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2955">Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2955">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2956">Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2956">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="a1c4a-2957">Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2957">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="a1c4a-2958">Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2958">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="a1c4a-2959">W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2959">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="a1c4a-2960">Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2960">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="a1c4a-2961"><xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2961"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-2962">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.u2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2962">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2963">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2963">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2964">Ładuje wartość typu <see langword="unsigned int32" /> <see langword="int32" /> na stosie oceny pośrednio.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2964">Loads a value of type <see langword="unsigned int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2965">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2965">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2966">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2966">Format</span></span>|<span data-ttu-id="a1c4a-2967">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2967">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2968">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2968">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2969">4B</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2969">4B</span></span>|<span data-ttu-id="a1c4a-2970">ldind. U4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2970">ldind.u4</span></span>|<span data-ttu-id="a1c4a-2971">Ładuje wartość pod `addr` adresem`int32`nastosjako. `unsigned int32`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2971">Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="a1c4a-2972">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2972">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2973">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2973">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2974">Adres jest zdjęte ze stosu; zostanie pobrana wartość znajdująca się pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2974">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2975">Pobrana wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2975">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2976">`int32` `native int` `&`Instrukcja pośrednio wczytuje wartość z podanego adresu (typu, lub \*) na stosie jako. `unsigned int32` `ldind.u4`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2976">The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="a1c4a-2977">Wszystkie instrukcje są skrótami <xref:System.Reflection.Emit.OpCodes.Ldobj> do instrukcji, która określa odpowiednią wbudowaną klasę wartości. `ldind`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2977">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="a1c4a-2978">Należy zauważyć, że wartości całkowite mniejsze niż 4 bajty są `int32` rozszerzane `native int`do (nie), gdy są ładowane do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2978">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="a1c4a-2979">Wartości zmiennoprzecinkowe są konwertowane na `F` typ podczas ładowania na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2979">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-2980">Poprawnie sformułowany język pośredni (MSIL) firmy Microsoft zapewnia, `ldind` że instrukcje są używane w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2980">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="a1c4a-2981">Adres na początku wypychany na stosie musi być wyrównany do naturalnego rozmiaru obiektów na komputerze lub <xref:System.NullReferenceException> może wystąpić ( <xref:System.Reflection.Emit.OpCodes.Unaligned> patrz instrukcja prefiksu dla środków zapobiegawczych).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2981">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="a1c4a-2982">Wyniki wszystkich instrukcji MSIL, które zwracają adresy (na przykład <xref:System.Reflection.Emit.OpCodes.Ldloca> i <xref:System.Reflection.Emit.OpCodes.Ldarga>) są bezpiecznie wyrównane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2982">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="a1c4a-2983">W przypadku typów danych o rozmiarze większym niż 1 bajt, porządkowanie bajtów jest zależne od docelowego procesora CPU.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2983">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="a1c4a-2984">Kod, który zależy od porządkowania bajtów, może nie działać na wszystkich platformach.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2984">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="a1c4a-2985"><xref:System.NullReferenceException>może być zgłaszane w przypadku wykrycia nieprawidłowego adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2985"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="a1c4a-2986">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldind.u4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2986">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-2987">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2987">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-2988">Wypchnij liczbę elementów tablicy jednowymiarowej o wartości zero na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2988">Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-2989">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2989">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-2990">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2990">Format</span></span>|<span data-ttu-id="a1c4a-2991">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2991">Assembly Format</span></span>|<span data-ttu-id="a1c4a-2992">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2992">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-2993">8E</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2993">8E</span></span>|<span data-ttu-id="a1c4a-2994">ldlen</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2994">ldlen</span></span>|<span data-ttu-id="a1c4a-2995">Wypchnij Długość (typu `natural unsigned int`) tablicy na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2995">Pushes the length (of type `natural unsigned int`) of an array on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-2996">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2996">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-2997">Odwołanie do obiektu tablicy jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2997">An object reference to an array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-2998">Odwołanie do tablicy jest zdjęte z stosu, a długość jest obliczana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2998">The array reference is popped from the stack and the length is computed.</span></span>  
  
3.  <span data-ttu-id="a1c4a-2999">Długość jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-2999">The length is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3000">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3000">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="a1c4a-3001">Długość jest zwracana jako `natural unsigned int`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3001">The length is returned as a `natural unsigned int`.</span></span>  
  
 <span data-ttu-id="a1c4a-3002"><xref:System.NullReferenceException>jest zgłaszany, jeśli odwołanie do tablicy jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3002"><xref:System.NullReferenceException> is thrown if the array reference is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-3003">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldlen` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3003">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3004">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3004">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3005">Ładuje zmienną lokalną pod określonym indeksem na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3005">Loads the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3006">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3006">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3007">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3007">Format</span></span>|<span data-ttu-id="a1c4a-3008">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3008">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3009">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3009">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3010">FE 0C < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3010">FE 0C < `unsigned int16` ></span></span>|<span data-ttu-id="a1c4a-3011">ldloc`index`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3011">ldloc `index`</span></span>|<span data-ttu-id="a1c4a-3012">Ładuje zmienną lokalną przy indeksie `index` na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3012">Loads the local variable at index `index` onto stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3013">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3013">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3014">Wartość zmiennej lokalnej w określonym indeksie jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3014">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3015">`ldloc` Instrukcja wypycha zawartość lokalnego numeru zmiennej przy użyciu przekazanego indeksu do stosu oceny, gdzie zmienne lokalne są numerowane od 0 do wewnątrz.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3015">The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="a1c4a-3016">Zmienne lokalne są inicjowane na wartość 0 przed wprowadzeniem metody tylko wtedy, gdy flaga inicjacji w metodzie ma wartość true.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3016">Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</span></span> <span data-ttu-id="a1c4a-3017">Dostępne są 65 535 (2 ^ 16-1) zmienne lokalne (0 – 65534).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3017">There are 65,535 (2^16-1) local variables possible (0-65,534).</span></span> <span data-ttu-id="a1c4a-3018">Indeks 65 535 jest nieprawidłowy, ponieważ prawdopodobnie implementacje będą używały 2-bajtowej liczby całkowitej do śledzenia zarówno indeksu lokalnego, jak i łącznej liczby elementów lokalnych danej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3018">Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</span></span> <span data-ttu-id="a1c4a-3019">Jeśli indeks 65535 był prawidłowy, będzie wymagał szerszej liczby całkowitej do śledzenia liczby elementów lokalnych w takiej metodzie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3019">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="a1c4a-3020">Instrukcje `ldloc.0`, `ldloc.1`, `ldloc.2`i zapewniająwydajnekodowaniedouzyskiwaniadostępudopierwszychczterechzmiennychlokalnych.`ldloc.3`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3020">The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables.</span></span>  
  
 <span data-ttu-id="a1c4a-3021">Typ wartości jest taki sam jak typ zmiennej lokalnej, która jest określona w nagłówku metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3021">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="a1c4a-3022">Zobacz partycja I. lokalne zmienne, które są mniejsze niż 4 bajty, są `int32` rozszerzane do typu podczas ładowania na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3022">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="a1c4a-3023">Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3023">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="a1c4a-3024">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `ldloc` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3024">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3025">Elemencie ILGenerator. emisji (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3025">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="a1c4a-3026">Elemencie ILGenerator. emisji (OpCode, krótkie)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3026">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3027">Ładuje zmienną lokalną pod indeksem 0 na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3027">Loads the local variable at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3028">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3028">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3029">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3029">Format</span></span>|<span data-ttu-id="a1c4a-3030">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3030">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3031">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3031">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3032">06</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3032">06</span></span>|<span data-ttu-id="a1c4a-3033">ldloc. 0</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3033">ldloc.0</span></span>|<span data-ttu-id="a1c4a-3034">Ładuje zmienną lokalną pod indeksem 0 na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3034">Loads the local variable at index 0 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3035">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3035">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3036">Wartość zmiennej lokalnej na indeksie 0 jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3036">The local variable value at the index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3037">`ldloc.0`to szczególnie wydajne kodowanie dla <xref:System.Reflection.Emit.OpCodes.Ldloc>, umożliwiające dostęp do zmiennej lokalnej przy indeksie 0.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3037">`ldloc.0` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0.</span></span>  
  
 <span data-ttu-id="a1c4a-3038">Typ wartości jest taki sam jak typ zmiennej lokalnej, która jest określona w nagłówku metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3038">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="a1c4a-3039">Zmienne lokalne o długości mniejszej niż 4 bajty są rozszerzane `int32` do typu podczas ładowania na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3039">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="a1c4a-3040">Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3040">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="a1c4a-3041">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldloc.0` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3041">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3042">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3042">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3043">Ładuje zmienną lokalną pod indeksem 1 na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3043">Loads the local variable at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3044">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3044">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3045">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3045">Format</span></span>|<span data-ttu-id="a1c4a-3046">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3046">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3047">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3047">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3048">07</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3048">07</span></span>|<span data-ttu-id="a1c4a-3049">ldloc. 1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3049">ldloc.1</span></span>|<span data-ttu-id="a1c4a-3050">Ładuje zmienną lokalną pod indeksem 1 na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3050">Loads the local variable at index 1 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3051">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3051">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3052">Wartość zmiennej lokalnej na indeksie 1 jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3052">The local variable value at the index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3053">`ldloc.1`to szczególnie wydajne kodowanie dla <xref:System.Reflection.Emit.OpCodes.Ldloc>, umożliwiające dostęp do zmiennej lokalnej przy użyciu indeksu 1.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3053">`ldloc.1` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1.</span></span>  
  
 <span data-ttu-id="a1c4a-3054">Typ wartości jest taki sam jak typ zmiennej lokalnej, która jest określona w nagłówku metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3054">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="a1c4a-3055">Zmienne lokalne o długości mniejszej niż 4 bajty są rozszerzane `int32` do typu podczas ładowania na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3055">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="a1c4a-3056">Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3056">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="a1c4a-3057">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldloc.1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3057">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3058">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3058">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3059">Ładuje zmienną lokalną pod indeksem 2 na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3059">Loads the local variable at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3060">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3060">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3061">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3061">Format</span></span>|<span data-ttu-id="a1c4a-3062">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3062">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3063">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3063">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3064">08</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3064">08</span></span>|<span data-ttu-id="a1c4a-3065">ldloc. 2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3065">ldloc.2</span></span>|<span data-ttu-id="a1c4a-3066">Ładuje zmienną lokalną pod indeksem 2 na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3066">Loads the local variable at index 2 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3067">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3067">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3068">Wartość zmiennej lokalnej na indeksie 2 jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3068">The local variable value at the index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3069">`ldloc.2`to szczególnie wydajne kodowanie dla <xref:System.Reflection.Emit.OpCodes.Ldloc>, umożliwiające dostęp do zmiennej lokalnej przy użyciu indeksu 2.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3069">`ldloc.2` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2.</span></span>  
  
 <span data-ttu-id="a1c4a-3070">Typ wartości jest taki sam jak typ zmiennej lokalnej, która jest określona w nagłówku metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3070">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="a1c4a-3071">Zmienne lokalne o długości mniejszej niż 4 bajty są rozszerzane `int32` do typu podczas ładowania na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3071">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="a1c4a-3072">Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3072">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="a1c4a-3073">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldloc.2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3073">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3074">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3074">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3075">Ładuje zmienną lokalną pod indeksem 3 na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3075">Loads the local variable at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3076">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3076">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3077">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3077">Format</span></span>|<span data-ttu-id="a1c4a-3078">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3078">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3079">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3079">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3080">09</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3080">09</span></span>|<span data-ttu-id="a1c4a-3081">ldloc. 3</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3081">ldloc.3</span></span>|<span data-ttu-id="a1c4a-3082">Ładuje zmienną lokalną pod indeksem 3 na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3082">Loads the local variable at index 3 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3083">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3083">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3084">Wartość zmiennej lokalnej na indeksie 3 jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3084">The local variable value at the index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3085">`ldloc.3`to szczególnie wydajne kodowanie dla <xref:System.Reflection.Emit.OpCodes.Ldloc>, umożliwiające dostęp do zmiennej lokalnej przy użyciu indeksu 3.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3085">`ldloc.3` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3.</span></span>  
  
 <span data-ttu-id="a1c4a-3086">Typ wartości jest taki sam jak typ zmiennej lokalnej, która jest określona w nagłówku metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3086">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="a1c4a-3087">Zmienne lokalne o długości mniejszej niż 4 bajty są rozszerzane `int32` do typu podczas ładowania na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3087">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="a1c4a-3088">Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3088">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="a1c4a-3089">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldloc.3` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3089">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3090">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3090">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3091">Ładuje zmienną lokalną pod określonym indeksem do stosu ewaluacyjnego, krótkiej formy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3091">Loads the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3092">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3092">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3093">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3093">Format</span></span>|<span data-ttu-id="a1c4a-3094">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3094">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3095">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3095">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3096">11 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3096">11 < `unsigned int8` ></span></span>|<span data-ttu-id="a1c4a-3097">ldloc.s `index`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3097">ldloc.s `index`</span></span>|<span data-ttu-id="a1c4a-3098">Ładuje zmienną lokalną przy indeksie `index` do stosu, krótkiej formy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3098">Loads the local variable at index `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-3099">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3099">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3100">Wartość zmiennej lokalnej w określonym indeksie jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3100">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3101">`ldloc.s` Instrukcja wypycha zawartość lokalnego numeru zmiennej przy użyciu przekazanego indeksu do stosu oceny, gdzie zmienne lokalne są numerowane od 0 do wewnątrz.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3101">The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="a1c4a-3102">Zmienne lokalne są inicjowane na wartość 0 przed wprowadzeniem metody, jeśli flaga inicjacji w metodzie ma wartość true.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3102">Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</span></span> <span data-ttu-id="a1c4a-3103">W krótkim formularzu istnieją 256 (2 ^ 8) zmiennych lokalnych (0-255), co jest bardziej wydajnym kodowaniem niż `ldloc`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3103">There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.</span></span>  
  
 <span data-ttu-id="a1c4a-3104">Typ wartości jest taki sam jak typ zmiennej lokalnej, która jest określona w nagłówku metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3104">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="a1c4a-3105">Zobacz partycja I. lokalne zmienne, które są mniejsze niż 4 bajty, są `int32` rozszerzane do typu podczas ładowania na stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3105">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="a1c4a-3106">Wartości zmiennoprzecinkowe są rozwinięte do ich rozmiaru natywnego ( `F`Type).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3106">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="a1c4a-3107">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `ldloc.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3107">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3108">Elemencie ILGenerator. emisji (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3108">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="a1c4a-3109">Elemencie ILGenerator. emisji (OpCode, Byte)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3109">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3110">Ładuje adres zmiennej lokalnej w określonym indeksie na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3110">Loads the address of the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3111">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3112">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3112">Format</span></span>|<span data-ttu-id="a1c4a-3113">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3113">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3114">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3115">FE OD <`unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3115">FE OD < `unsigned int16` ></span></span>|<span data-ttu-id="a1c4a-3116">ldloca `index`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3116">ldloca `index`</span></span>|<span data-ttu-id="a1c4a-3117">Ładuje adres zmiennej lokalnej na `index` stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3117">Loads the address of the local variable at `index` onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3118">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3119">Adres przechowywany w zmiennej lokalnej o określonym indeksie jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3119">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3120">`ldloca` Instrukcja wypchnięcie adresu zmiennej lokalnej w przekazanym indeksie na stos, gdzie zmienne lokalne są numerowane od 0 do wewnątrz.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3120">The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="a1c4a-3121">Wartość wypchnięcia na stosie jest już prawidłowo wyrównana do użycia z instrukcjami takimi <xref:System.Reflection.Emit.OpCodes.Stind_I>jak <xref:System.Reflection.Emit.OpCodes.Ldind_I> i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3121">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="a1c4a-3122">Wynik jest wskaźnikiem przejściowym (Type `*`).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3122">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="a1c4a-3123">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldloca` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3123">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3124">Elemencie ILGenerator. emisji (OpCode, krótkie)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3124">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3125">Ładuje adres zmiennej lokalnej w określonym indeksie na stos oceny, skróconej postaci.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3125">Loads the address of the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3126">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3126">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3127">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3127">Format</span></span>|<span data-ttu-id="a1c4a-3128">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3128">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3129">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3129">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3130">12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3130">12 < `unsigned int8` ></span></span>|<span data-ttu-id="a1c4a-3131">ldloca.s `index`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3131">ldloca.s `index`</span></span>|<span data-ttu-id="a1c4a-3132">Ładuje adres zmiennej lokalnej na `index` stosie oceny, skróconej postaci.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3132">Loads the address of the local variable at `index` onto the evaluation stack, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-3133">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3133">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3134">Adres przechowywany w zmiennej lokalnej o określonym indeksie jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3134">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3135">`ldloca.s` Instrukcja wypchnięcie adresu zmiennej lokalnej w przekazanym indeksie na stos, gdzie zmienne lokalne są numerowane od 0 do wewnątrz.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3135">The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="a1c4a-3136">Wartość wypchnięcia na stosie jest już prawidłowo wyrównana do użycia z instrukcjami takimi <xref:System.Reflection.Emit.OpCodes.Stind_I>jak <xref:System.Reflection.Emit.OpCodes.Ldind_I> i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3136">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="a1c4a-3137">Wynik jest wskaźnikiem przejściowym (Type `*`).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3137">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="a1c4a-3138">`ldloca.s` Instrukcja zapewnia wydajne kodowanie do użycia z lokalnymi zmiennymi od 0 do 255.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3138">The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="a1c4a-3139">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldloca.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3139">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3140">Elemencie ILGenerator. emisji (OpCode, Byte)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3140">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3141">Wypchnięcie odwołania o wartości null <see langword="O" />(Type) do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3141">Pushes a null reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3142">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3142">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3143">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3143">Format</span></span>|<span data-ttu-id="a1c4a-3144">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3144">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3145">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3145">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3146">14</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3146">14</span></span>|<span data-ttu-id="a1c4a-3147">ldnull</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3147">ldnull</span></span>|<span data-ttu-id="a1c4a-3148">Wypchnij odwołanie o wartości null na stosie</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3148">push a null reference onto the stack</span></span>|  
  
 <span data-ttu-id="a1c4a-3149">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3149">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3150">Odwołanie do obiektu o wartości null jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3150">A null object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3151">`ldnull`wypchnięcie odwołania o wartości null `O`(typ) na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3151">`ldnull` pushes a null reference (type `O`) on the stack.</span></span> <span data-ttu-id="a1c4a-3152">Jest on używany do inicjowania lokalizacji przed ich wypełnieniem danymi lub kiedy stają się one przestarzałe.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3152">This is used to initialize locations before they are populated with data, or when they become deprecated.</span></span>  
  
 <span data-ttu-id="a1c4a-3153">`ldnull`zawiera odwołanie o wartości null, które jest niezależne od rozmiaru.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3153">`ldnull` provides a null reference that is size-independent.</span></span>  
  
 <span data-ttu-id="a1c4a-3154">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldnull` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3154">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3155">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3155">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3156">Kopiuje obiekt typu wartości wskazywany przez adres na początku stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3156">Copies the value type object pointed to by an address to the top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3157">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3157">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3158">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3158">Format</span></span>|<span data-ttu-id="a1c4a-3159">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3159">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3160">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3160">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3161">71 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3161">71 < `T` ></span></span>|<span data-ttu-id="a1c4a-3162">ldobj `class`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3162">ldobj `class`</span></span>|<span data-ttu-id="a1c4a-3163">Skopiuj wystąpienie typu `class` wartości do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3163">Copy instance of value type `class` to the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3164">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3164">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3165">Adres obiektu typu wartości jest wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3165">The address of a value type object is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3166">Adres jest zdjęte ze stosu, a wystąpienie pod tym konkretnym adresem jest wyszukiwane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3166">The address is popped from the stack and the instance at that particular address is looked up.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3167">Wartość obiektu przechowywanego w tym adresie jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3167">The value of the object stored at that address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3168">`ldobj` Instrukcja służy do przekazywania typu wartości jako parametru.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3168">The `ldobj` instruction is used to pass a value type as a parameter.</span></span>  
  
 <span data-ttu-id="a1c4a-3169">`&` `*` `native int`Instrukcja kopiuje wartość wskazywaną przez `addrOfValObj` (z typu, lub) na górze stosu. `ldobj`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3169">The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack.</span></span> <span data-ttu-id="a1c4a-3170">Liczba kopiowanych bajtów zależy od rozmiaru klasy (określony przez `class` parametr).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3170">The number of bytes copied depends on the size of the class (as specified by the `class` parameter).</span></span> <span data-ttu-id="a1c4a-3171">`class` Parametr jest tokenem metadanych reprezentującym typ wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3171">The `class` parameter is a metadata token representing the value type.</span></span>  
  
 <span data-ttu-id="a1c4a-3172">Operację `ldobj` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3172">The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-3173"><xref:System.TypeLoadException>jest zgłaszany, jeśli nie można znaleźć klasy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3173"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="a1c4a-3174">Jest to zwykle wykrywane, gdy instrukcja języka pośredniego (MSIL) firmy Microsoft jest konwertowana na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3174">This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="a1c4a-3175">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldobj` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3175">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3176">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3176">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3177">Wypchnij wartość pola statycznego na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3177">Pushes the value of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3178">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3178">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3179">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3179">Format</span></span>|<span data-ttu-id="a1c4a-3180">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3180">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3181">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3181">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3182">7E < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3182">7E < `T` ></span></span>|<span data-ttu-id="a1c4a-3183">elementu ldsfld`field`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3183">ldsfld `field`</span></span>|<span data-ttu-id="a1c4a-3184">Wypchnij wartość `field` na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3184">Push the value of `field` on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3185">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3185">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3186">Wartość określonego pola jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3186">The value of the specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3187">`ldsfld` Instrukcja wypycha wartość statycznego (współużytkowanego przez wszystkie wystąpienia klasy) na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3187">The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="a1c4a-3188">Zwracanym typem jest skojarzona z tokenem `field`przekazywania metadanych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3188">The return type is that associated with the passed metadata token `field`.</span></span>  
  
 <span data-ttu-id="a1c4a-3189">`ldsfld` Instrukcja może<xref:System.Reflection.Emit.OpCodes.Volatile> mieć prefiks.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3189">The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="a1c4a-3190">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldsfld` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3190">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3191">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3191">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3192">Wypchnięcie adresu pola statycznego na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3192">Pushes the address of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3193">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3193">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3194">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3194">Format</span></span>|<span data-ttu-id="a1c4a-3195">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3195">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3196">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3196">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3197">7F < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3197">7F < `T` ></span></span>|<span data-ttu-id="a1c4a-3198">ldsflda `field`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3198">ldsflda `field`</span></span>|<span data-ttu-id="a1c4a-3199">Wypchnij adres `field` na stosie</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3199">Push the address of `field` on the stack</span></span>|  
  
 <span data-ttu-id="a1c4a-3200">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3200">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3201">Adres określonego pola jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3201">The address of a specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3202">`ldsflda` Instrukcja wypycha adres statyczny (współdzielony przez wszystkie wystąpienia klasy) na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3202">The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="a1c4a-3203">Adres może być reprezentowany jako przejściowy wskaźnik (typ `*`), jeśli token `field` metadanych odwołuje się do typu, którego pamięć jest zarządzana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3203">The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed.</span></span> <span data-ttu-id="a1c4a-3204">W przeciwnym razie odnosi się do niezarządzanego wskaźnika `native int`(Type).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3204">Otherwise, it corresponds to an unmanaged pointer (type `native int`).</span></span> <span data-ttu-id="a1c4a-3205">Zwróć uwagę `field` , że może to być statyczna globalna z przypisanym względnym adresem wirtualnym (przesunięcie pola od adresu podstawowego, w którym zawierający plik PE jest ładowany do pamięci), gdzie pamięć jest niezarządzana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3205">Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</span></span>  
  
 <span data-ttu-id="a1c4a-3206">`ldsflda` Instrukcja może<xref:System.Reflection.Emit.OpCodes.Volatile> mieć prefiks.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3206">The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="a1c4a-3207"><xref:System.MissingFieldException>jest zgłaszany, jeśli nie znaleziono pola w metadanych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3207"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="a1c4a-3208">Jest to zazwyczaj zaznaczone, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3208">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="a1c4a-3209">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldsflda` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3209">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3210">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3210">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3211">Wypchnij nowe odwołanie do obiektu do literału ciągu przechowywanego w metadanych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3211">Pushes a new object reference to a string literal stored in the metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3212">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3212">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3213">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3213">Format</span></span>|<span data-ttu-id="a1c4a-3214">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3214">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3215">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3215">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3216">72 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3216">72 < `T` ></span></span>|<span data-ttu-id="a1c4a-3217">ldstr`mdToken`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3217">ldstr `mdToken`</span></span>|<span data-ttu-id="a1c4a-3218">Wypchnięcie obiektu ciągu dla tokenu `mdToken`ciągu metadanych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3218">Pushes a string object for the metadata string token `mdToken`.</span></span>|  
  
 <span data-ttu-id="a1c4a-3219">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3219">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3220">Odwołanie do obiektu do ciągu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3220">An object reference to a string is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3221">Instrukcja wypycha odwołanie do obiektu (typ `O`) do nowego obiektu ciągu reprezentującego określony literał ciągu przechowywany w metadanych. `ldstr`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3221">The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata.</span></span> <span data-ttu-id="a1c4a-3222">`ldstr` Instrukcja przypisuje wymaganą ilość pamięci i wykonuje konwersję formatu wymaganą do przekonwertowania literału ciągu z formularza używanego w pliku do formatu ciągu wymaganego w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3222">The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</span></span>  
  
 <span data-ttu-id="a1c4a-3223">Common Language Infrastructure (CLI) gwarantuje, że wynik dwóch `ldstr` instrukcji odnoszący się do dwóch tokenów metadanych, które mają taką samą sekwencję znaków, zwracają dokładnie ten sam obiekt String (proces znany jako "ciąg".</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3223">The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</span></span>  
  
 <span data-ttu-id="a1c4a-3224">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldstr` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3224">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3225">Elemencie ILGenerator. emisji (OpCode, String)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3225">ILGenerator.Emit(OpCode, string)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3226">Konwertuje token metadanych na reprezentację środowiska uruchomieniowego, wypychając go do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3226">Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3227">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3227">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3228">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3228">Format</span></span>|<span data-ttu-id="a1c4a-3229">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3229">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3230">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3230">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3231">D0 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3231">D0 < `T` ></span></span>|<span data-ttu-id="a1c4a-3232">ldtoken`token`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3232">ldtoken `token`</span></span>|<span data-ttu-id="a1c4a-3233">Konwertuje token metadanych na reprezentację środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3233">Converts a metadata token to its runtime representation.</span></span>|  
  
 <span data-ttu-id="a1c4a-3234">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3234">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3235">Przeniesiony token jest konwertowany na a `RuntimeHandle` i wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3235">The passed token is converted to a `RuntimeHandle` and pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3236">Instrukcja wypchnięcie `RuntimeHandle` dla określonego tokenu metadanych. `ldtoken`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3236">The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token.</span></span> <span data-ttu-id="a1c4a-3237">`RuntimeHandle` Może być`fieldref/fielddef` ,a`methodref/methoddef`, lub .`typeref/typedef`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3237">A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.</span></span>  
  
 <span data-ttu-id="a1c4a-3238">Wartość wypchnięcia na stosie może być używana w wywołaniach `Reflection` metod w bibliotece klas systemu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3238">The value pushed on the stack can be used in calls to `Reflection` methods in the system class library.</span></span>  
  
 <span data-ttu-id="a1c4a-3239">Aby uzyskać informacje na temat dojść do środowiska uruchomieniowego, <xref:System.RuntimeFieldHandle>zobacz <xref:System.RuntimeTypeHandle>następujące klasy <xref:System.RuntimeMethodHandle>:,, i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3239">For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.</span></span>  
  
 <span data-ttu-id="a1c4a-3240">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `ldtoken` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3240">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3241">ILGenerator.Emit(OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3241">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="a1c4a-3242">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3242">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
-   <span data-ttu-id="a1c4a-3243">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3243">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3244">Wypchnij niezarządzany wskaźnik ( <see langword="native int" />typ) do kodu natywnego implementującego określoną metodę wirtualną skojarzoną z określonym obiektem na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3244">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3245">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3245">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3246">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3246">Format</span></span>|<span data-ttu-id="a1c4a-3247">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3247">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3248">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3248">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3249">FE 07 <`T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3249">FE 07 < `T` ></span></span>|<span data-ttu-id="a1c4a-3250">ldvirtftn `method`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3250">ldvirtftn `method`</span></span>|<span data-ttu-id="a1c4a-3251">Wypchnięcie wskaźnika do metody `method` wirtualnej obiektu na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3251">Pushes the pointer to an object's virtual method `method` on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3252">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3252">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3253">Odwołanie do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3253">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3254">Odwołanie do obiektu jest zdjęte ze stosu i adres punktu wejścia do metody (określony przez token `method`metadanych) jest wyszukiwany.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3254">The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3255">Wskaźnik do `method` jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3255">The pointer to `method` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3256">Uzyskany niezarządzany wskaźnik został wypchnięte do stosu przez `ldvirtftn` instrukcję, można wywołać przy użyciu <xref:System.Reflection.Emit.OpCodes.Calli> instrukcji, jeśli odwołuje się do metody zarządzanej (lub zastępczej przechodzenia z kodu zarządzanego do niezarządzanego).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3256">The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="a1c4a-3257">Wskaźnik niezarządzany wskazuje na kod natywny przy użyciu konwencji wywoływania CLR.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3257">The unmanaged pointer points to native code using the CLR calling convention.</span></span> <span data-ttu-id="a1c4a-3258">Tego wskaźnika metody nie należy przekazywać do niezarządzanego kodu natywnego jako procedury wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3258">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="a1c4a-3259">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ldvirtftn` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3259">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3260">ILGenerator.Emit(OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3260">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3261">Zamyka chroniony region kodu, bezwarunkowo przenosząc kontrolę do określonej instrukcji docelowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3261">Exits a protected region of code, unconditionally transferring control to a specific target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3262">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3262">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3263">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3263">Format</span></span>|<span data-ttu-id="a1c4a-3264">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3264">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3265">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3265">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3266">DD < `int32` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3266">DD < `int32` ></span></span>|<span data-ttu-id="a1c4a-3267">Pozostaw`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3267">leave `target`</span></span>|<span data-ttu-id="a1c4a-3268">Zamyka chroniony region kodu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3268">Exits a protected region of code.</span></span>|  
  
 <span data-ttu-id="a1c4a-3269">Dla tej instrukcji nie określono zachowania przejścia stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3269">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-3270">`leave` Instrukcja bezwarunkowo przenosi kontrolę do konkretnej instrukcji docelowej, reprezentowanej przez 4-bajtowe przesunięcia od początku instrukcji po bieżącej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3270">The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-3271">`br` `try` `filter`Instrukcja jest podobna do instrukcji, ale może służyć do zamykania, lub `catch` bloku, a normalne instrukcje gałęzi mogą być używane tylko w takim bloku, aby przetransferować kontrolę w obrębie `leave` go.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3271">The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="a1c4a-3272">Instrukcja opróżnia stos oceny i zapewnia, że są wykonywane odpowiednie bloki otaczające `finally`. `leave`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3272">The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="a1c4a-3273">Nie można użyć `leave` instrukcji, aby `finally` wyjść z bloku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3273">You cannot use a `leave` instruction to exit a `finally` block.</span></span> <span data-ttu-id="a1c4a-3274">Aby ułatwić generowanie kodu dla programów obsługi wyjątków, jest on prawidłowy z wewnątrz bloku catch, aby użyć `leave` instrukcji do przetransferowania kontroli do dowolnej instrukcji w `try` ramach skojarzonego bloku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3274">To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="a1c4a-3275">Jeśli instrukcja zawiera jeden lub więcej kodów prefiksów, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3275">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="a1c4a-3276">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `leave` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3276">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3277">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3277">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3278">Zamyka chroniony region kodu, bezwarunkowo przenosząc kontrolę do instrukcji docelowej (krótka wersja).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3278">Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3279">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3279">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3280">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3280">Format</span></span>|<span data-ttu-id="a1c4a-3281">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3281">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3282">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3282">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3283">DE < `int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3283">DE < `int8` ></span></span>|<span data-ttu-id="a1c4a-3284">Pozostaw. s`target`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3284">leave.s `target`</span></span>|<span data-ttu-id="a1c4a-3285">Wyjdź z chronionego regionu kodu, krótkiej formy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3285">Exit a protected region of code, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-3286">Dla tej instrukcji nie określono zachowania przejścia stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3286">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-3287">`leave.s` Instrukcja bezwarunkowo przenosi kontrolę do przekazaną instrukcję docelową, reprezentowane jako 1-bajtowe przesunięcie przesunięcia od początku instrukcji po bieżącej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3287">The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-3288">`br` `try` `filter`Instrukcja jest podobna do instrukcji, ale może służyć do zamykania, lub `catch` bloku, a normalne instrukcje gałęzi mogą być używane tylko w takim bloku, aby przetransferować kontrolę w obrębie `leave.s` go.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3288">The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="a1c4a-3289">Instrukcja opróżnia stos oceny i zapewnia, że są wykonywane odpowiednie bloki otaczające `finally`. `leave.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3289">The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="a1c4a-3290">Nie można użyć `leave.s` instrukcji, aby `finally` wyjść z bloku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3290">You cannot use a `leave.s` instruction to exit a `finally` block.</span></span> <span data-ttu-id="a1c4a-3291">Aby ułatwić generowanie kodu dla programów obsługi wyjątków, jest on prawidłowy z wewnątrz bloku catch, aby użyć `leave.s` instrukcji do przetransferowania kontroli do dowolnej instrukcji w `try` ramach skojarzonego bloku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3291">To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="a1c4a-3292">Jeśli instrukcja zawiera jeden lub więcej kodów prefiksów, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3292">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="a1c4a-3293">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `leave.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3293">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3294">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3294">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3295">Przydziela określoną liczbę bajtów z lokalnej puli pamięci dynamicznej i wypycha adres (przejściowy wskaźnik, typ <see langword="*" />) pierwszego przydzielonego bajtu na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3295">Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <see langword="*" />) of the first allocated byte onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3296">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3296">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3297">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3297">Format</span></span>|<span data-ttu-id="a1c4a-3298">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3298">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3299">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3299">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3300">FE 0F</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3300">FE 0F</span></span>|<span data-ttu-id="a1c4a-3301">localloc</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3301">localloc</span></span>|<span data-ttu-id="a1c4a-3302">Przydziel miejsce ze sterty lokalnej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3302">Allocate space from the local heap.</span></span>|  
  
 <span data-ttu-id="a1c4a-3303">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3303">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3304">Liczba bajtów do przydzielenia jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3304">The number of bytes to be allocated is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3305">Liczba bajtów zdjęte ze stosu; ilość pamięci odpowiadająca rozmiarowi jest przypisywany ze sterty lokalnej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3305">The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3306">Wskaźnik do pierwszego bajtu przydzieloną pamięci jest wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3306">A pointer to the first byte of the allocated memory is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3307">Instrukcja przypisuje `natural unsigned int`(typu) bajty z lokalnej puli pamięci dynamicznej i zwraca adres (wskaźnik przejściowy, typ `*`) pierwszego przydzielonego bajtu. `size` `localloc`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3307">The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte.</span></span> <span data-ttu-id="a1c4a-3308">Blok zwróconej pamięci jest inicjowany do wartości 0 tylko wtedy, gdy flaga inicjacji metody `true`to.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3308">The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`.</span></span> <span data-ttu-id="a1c4a-3309">Gdy bieżąca metoda jest wykonywana a <xref:System.Reflection.Emit.OpCodes.Ret>, lokalna Pula pamięci jest udostępniana do ponownego użycia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3309">When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.</span></span>  
  
 <span data-ttu-id="a1c4a-3310">Otrzymany adres jest wyrównany w taki sposób, że dowolny typ danych pierwotnych może być przechowywany `stind` przy użyciu instrukcji ( <xref:System.Reflection.Emit.OpCodes.Stind_I4>takich jak `ldind` ) i ładowany przy użyciu instrukcji ( <xref:System.Reflection.Emit.OpCodes.Ldind_I4>takich jak).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3310">The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span></span>  
  
 <span data-ttu-id="a1c4a-3311">`catch` `finally` `fault` Instrukcja nie może wystąpić `filter`w bloku,, lub. `localloc`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3311">The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block.</span></span>  
  
 <span data-ttu-id="a1c4a-3312"><xref:System.StackOverflowException>jest zgłaszany w przypadku braku wystarczającej ilości pamięci do obsługi żądania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3312"><xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request.</span></span>  
  
 <span data-ttu-id="a1c4a-3313">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `localloc` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3313">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3314">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3314">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3315">Wypchnij wpisane odwołanie do wystąpienia określonego typu na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3315">Pushes a typed reference to an instance of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3316">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3316">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3317">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3317">Format</span></span>|<span data-ttu-id="a1c4a-3318">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3318">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3319">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3319">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3320">C6 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3320">C6 < `T` ></span></span>|<span data-ttu-id="a1c4a-3321">mkrefany`class`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3321">mkrefany `class`</span></span>|<span data-ttu-id="a1c4a-3322">Wypchnięcie wpisany odwołanie typu `class` na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3322">Pushes a typed reference of type `class` onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3323">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3323">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3324">Wskaźnik do fragmentu danych jest wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3324">A pointer to piece of data is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3325">Wskaźnik jest zdjęte i konwertowany na wpisane odwołanie typu `class`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3325">The pointer is popped and converted to a typed reference of type `class`.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3326">Wpisane odwołanie jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3326">The typed reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3327">`mkrefany` Instrukcja obsługuje przekazywanie dynamicznie wpisanych odwołań.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3327">The `mkrefany` instruction supports the passing of dynamically typed references.</span></span> <span data-ttu-id="a1c4a-3328">Wskaźnik musi być typu `&`, `*`, lub `native int`i zawierać prawidłowy adres elementu danych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3328">The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data.</span></span> <span data-ttu-id="a1c4a-3329">`Class`jest tokenem klasy opisującym typ danych, do których odwołuje się wskaźnik.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3329">`Class` is the class token describing the type of the data referenced by the pointer.</span></span> <span data-ttu-id="a1c4a-3330">`Mkrefany`Wypchnij odwołanie do wpisanej wartości na stosie, dostarczając nieprzezroczysty deskryptor wskaźnika i typu `class`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3330">`Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.</span></span>  
  
 <span data-ttu-id="a1c4a-3331">Jedyną poprawną operacją dozwoloną w przypadku odwołania z określonym typem jest przekazanie go do metody, która wymaga określenia typu jako parametru.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3331">The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</span></span> <span data-ttu-id="a1c4a-3332">Wywoływany może następnie użyć <xref:System.Reflection.Emit.OpCodes.Refanytype> instrukcji i <xref:System.Reflection.Emit.OpCodes.Refanyval> w celu pobrania odpowiednio typu (klasy) i adresu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3332">The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.</span></span>  
  
 <span data-ttu-id="a1c4a-3333"><xref:System.TypeLoadException>jest zgłaszany `class` , jeśli nie można znaleźć.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3333"><xref:System.TypeLoadException> is thrown if `class` cannot be found.</span></span> <span data-ttu-id="a1c4a-3334">Jest to zwykle wykrywane, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3334">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="a1c4a-3335">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `mkrefany` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3335">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3336">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3336">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3337">Mnoży dwie wartości i wypycha wynik na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3337">Multiplies two values and pushes the result on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3338">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3338">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3339">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3339">Format</span></span>|<span data-ttu-id="a1c4a-3340">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3340">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3341">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3341">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3342">5A</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3342">5A</span></span>|<span data-ttu-id="a1c4a-3343">mul</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3343">mul</span></span>|<span data-ttu-id="a1c4a-3344">Mnoży dwie wartości na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3344">Multiplies two values on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3345">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3345">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3346">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3346">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3347">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3347">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3348">`value2`i `value1` są zdjęte ze stosu; jest mnożony przez `value2`. `value1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3348">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3349">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3349">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3350">Instrukcja `mul` jest `value2` mnożona przez i wypycha wynik na stosie. `value1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3350">The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="a1c4a-3351">Operacje całkowite w trybie dyskretnym obcinają górne bity przy przepełnieniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3351">Integer operations silently truncate the upper bits on overflow.</span></span>  
  
 <span data-ttu-id="a1c4a-3352">Zobacz <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> , aby uzyskać określoną liczbę całkowitą operacji mnożenia z obsługą przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3352">See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.</span></span>  
  
 <span data-ttu-id="a1c4a-3353">W przypadku typów zmiennoprzecinkowych 0 \* nieskończoność = NaN.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3353">For floating-point types, 0 \* infinity = NaN.</span></span>  
  
 <span data-ttu-id="a1c4a-3354">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `mul` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3354">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3355">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3355">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3356">Mnoży dwie wartości całkowite, wykonuje sprawdzanie przepełnienia i wypycha wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3356">Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3357">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3357">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3358">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3358">Format</span></span>|<span data-ttu-id="a1c4a-3359">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3359">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3360">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3360">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3361">D8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3361">D8</span></span>|<span data-ttu-id="a1c4a-3362">mul.ovf</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3362">mul.ovf</span></span>|<span data-ttu-id="a1c4a-3363">Mnoży dwie wartości całkowite na stosie za pomocą sprawdzania przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3363">Multiplies two integer values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="a1c4a-3364">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3364">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3365">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3365">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3366">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3366">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3367">`value2`i `value1` są zdjęte ze stosu; jest mnożony przez `value2`, ze sprawdzaniem przepełnienia. `value1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3367">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3368">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3368">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3369">Instrukcja mnoży liczbę całkowitą `value1` przez liczbę całkowitą `value2` i wypycha wynik na stosie. `mul.ovf`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3369">The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="a1c4a-3370">Wyjątek jest zgłaszany, jeśli wynik nie będzie pasować do typu wynikowego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3370">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-3371"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3371"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-3372">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `mul.ovf` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3372">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3373">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3373">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3374">Mnoży dwie wartości bez znaku, wykonuje sprawdzanie przepełnienia i wypycha wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3374">Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3375">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3375">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3376">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3376">Format</span></span>|<span data-ttu-id="a1c4a-3377">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3377">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3378">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3378">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3379">D9</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3379">D9</span></span>|<span data-ttu-id="a1c4a-3380">mul.ovf.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3380">mul.ovf.un</span></span>|<span data-ttu-id="a1c4a-3381">Mnoży dwie niepodpisane wartości ze stosu za pomocą sprawdzania przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3381">Multiplies two unsigned values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="a1c4a-3382">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3382">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3383">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3383">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3384">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3384">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3385">`value2`i `value1` są zdjęte ze stosu; jest mnożony przez `value2`, ze sprawdzaniem przepełnienia. `value1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3385">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3386">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3386">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3387">Instrukcja mnoży liczbę całkowitą `value1` bez znaku przez liczbę całkowitą `value2` bez znaku i wypycha wynik na stosie. `mul.ovf.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3387">The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="a1c4a-3388">Wyjątek jest zgłaszany, jeśli wynik nie będzie pasować do typu wynikowego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3388">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-3389"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3389"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-3390">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `mul.ovf.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3390">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3391">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3391">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3392">Wyklucza wartość i wypycha wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3392">Negates a value and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3393">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3393">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3394">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3394">Format</span></span>|<span data-ttu-id="a1c4a-3395">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3395">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3396">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3396">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3397">65</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3397">65</span></span>|<span data-ttu-id="a1c4a-3398">neg</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3398">neg</span></span>|<span data-ttu-id="a1c4a-3399">Negacja wartości obecnie znajdującej się na szczycie stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3399">Negates the value currently on top of the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3400">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3400">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3401">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3401">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3402">Wartość jest zdjęte ze stosu i Negacja.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3402">A value is popped from the stack and negated.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3403">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3403">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3404">`neg` Instrukcja powoduje negację wartości i wypchnięcie wyniku na szczycie stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3404">The `neg` instruction negates value and pushes the result on top of the stack.</span></span> <span data-ttu-id="a1c4a-3405">Zwracany typ jest taki sam jak typ argumentu operacji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3405">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="a1c4a-3406">Negacja wartości całkowitych jest negacją standardową.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3406">Negation of integral values is standard two's complement negation.</span></span> <span data-ttu-id="a1c4a-3407">W szczególności Negacja najbardziej ujemnej liczby (która nie ma pozytywnego odpowiednika) daje najbardziej ujemną liczbę.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3407">In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</span></span> <span data-ttu-id="a1c4a-3408">Aby wykryć ten przepełnienie <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> , Użyj zamiast tego instrukcji (czyli Odejmij od 0).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3408">To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).</span></span>  
  
 <span data-ttu-id="a1c4a-3409">Negacja liczby zmiennoprzecinkowej nie może przekroczyć, a Negacja NaN zwraca NaN.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3409">Negating a floating-point number cannot overflow, and negating NaN returns NaN.</span></span>  
  
 <span data-ttu-id="a1c4a-3410">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `neg` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3410">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3411">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3411">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3412">Wypchnięcie odwołania do obiektu do nowej tablicy jednowymiarowej opartej na zero, której elementy są określonego typu na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3412">Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3413">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3413">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3414">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3414">Format</span></span>|<span data-ttu-id="a1c4a-3415">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3415">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3416">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3416">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3417">8D < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3417">8D < `T` ></span></span>|<span data-ttu-id="a1c4a-3418">newarr`etype`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3418">newarr `etype`</span></span>|<span data-ttu-id="a1c4a-3419">Tworzy nową tablicę z elementami typu `etype`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3419">Creates a new array with elements of type `etype`.</span></span>|  
  
 <span data-ttu-id="a1c4a-3420">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3420">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3421">Liczba elementów w tablicy jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3421">The number of elements in the array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3422">Liczba elementów jest zdjęte z stosu i tworzona jest tablica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3422">The number of elements is popped from the stack and the array is created.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3423">Odwołanie do obiektu do nowej tablicy jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3423">An object reference to the new array is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3424">Instrukcja wypycha odwołanie do obiektu (typ `O`) do nowej tablicy jednowymiarowej, której elementy są typu `etype` (token metadanych opisujący typ). `newarr`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3424">The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type).</span></span> <span data-ttu-id="a1c4a-3425">Liczba elementów w nowej tablicy powinna być określona jako `native int`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3425">The number of elements in the new array should be specified as a `native int`.</span></span> <span data-ttu-id="a1c4a-3426">Prawidłowy indeks tablicy zakresu od zera do maksymalnej liczby elementów minus jeden.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3426">Valid array indexes range from zero to the maximum number of elements minus one.</span></span>  
  
 <span data-ttu-id="a1c4a-3427">Elementy tablicy mogą być dowolnego typu, w tym typów wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3427">The elements of an array can be any type, including value types.</span></span>  
  
 <span data-ttu-id="a1c4a-3428">Jednowymiarowe tablice liczb są tworzone przy użyciu tokenu metadanych odwołującego się do odpowiedniego typu wartości (<xref:System.Int32>itd.).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3428">Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on).</span></span> <span data-ttu-id="a1c4a-3429">Elementy tablicy są inicjowane na 0 dla odpowiedniego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3429">Elements of the array are initialized to 0 of the appropriate type.</span></span>  
  
 <span data-ttu-id="a1c4a-3430">Tablice jednowymiarowe oparte na niezerowym i wielowymiarowe tablice są tworzone <xref:System.Reflection.Emit.OpCodes.Newobj> przy użyciu `newarr`zamiast.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3430">Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`.</span></span> <span data-ttu-id="a1c4a-3431">Często są one tworzone przy użyciu metod <xref:System.Array> klasy w .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3431">More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.</span></span>  
  
 <span data-ttu-id="a1c4a-3432"><xref:System.OutOfMemoryException>jest zgłaszany w przypadku braku wystarczającej ilości pamięci do spełnienia żądania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3432"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="a1c4a-3433"><xref:System.OverflowException>jest zgłaszany `numElems` , jeśli jest mniejszy niż 0.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3433"><xref:System.OverflowException> is thrown if `numElems` is less than 0.</span></span>  
  
 <span data-ttu-id="a1c4a-3434">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `newarr` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3434">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3435">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3435">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3436">Tworzy nowy obiekt lub nowe wystąpienie typu wartości, wypchnięcie odwołania do obiektu (typu <see langword="O" />) na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3436">Creates a new object or a new instance of a value type, pushing an object reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3437">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3437">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3438">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3438">Format</span></span>|<span data-ttu-id="a1c4a-3439">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3439">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3440">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3440">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3441">73 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3441">73 < `T` ></span></span>|<span data-ttu-id="a1c4a-3442">newobj `ctor`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3442">newobj `ctor`</span></span>|<span data-ttu-id="a1c4a-3443">Alokuje niezainicjowany typ obiektu lub wartości i wywołuje metodę `ctor`konstruktora.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3443">Allocates an uninitialized object or value type and calls the constructor method `ctor`.</span></span>|  
  
 <span data-ttu-id="a1c4a-3444">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3444">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3445">Argumenty `arg1` przez`argn` są wypychane na stosie w sekwencji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3445">Arguments `arg1` through `argn` are pushed on the stack in sequence.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3446">Argumenty `argn` `ctor` przez `arg1` są zdjęte ze stosu i przechodzą do tworzenia obiektów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3446">Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3447">Odwołanie do nowego obiektu jest wypychane do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3447">A reference to the new object is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3448">`newobj` Instrukcja tworzy nowy obiekt lub nowe wystąpienie typu wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3448">The `newobj` instruction creates a new object or a new instance of a value type.</span></span> <span data-ttu-id="a1c4a-3449">`Ctor`jest tokenem metadanych ( `methodref` lub `methoddef` , który musi być oznaczony jako Konstruktor), który wskazuje nazwę, klasę i podpis konstruktora do wywołania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3449">`Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</span></span>  
  
 <span data-ttu-id="a1c4a-3450">Instrukcja przydziela nowe wystąpienie klasy skojarzonej z `ctor` i inicjuje wszystkie pola w nowym wystąpieniu do 0 (odpowiedniego typu) lub odwołania o wartości null zgodnie z potrzebami. `newobj`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3450">The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</span></span> <span data-ttu-id="a1c4a-3451">Następnie wywołuje konstruktora `ctor` z podanym argumentami wraz z nowo utworzonym wystąpieniem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3451">It then calls the constructor `ctor` with the given arguments along with the newly created instance.</span></span> <span data-ttu-id="a1c4a-3452">Po wywołaniu konstruktora, aktualnie zainicjowany odwołanie do obiektu (Type `O`) jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3452">After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3453">Z punktu widzenia konstruktora Niezainicjowany obiekt jest argumentem 0, a pozostałe argumenty przekazane do newobj są zgodne z kolejnością.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3453">From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</span></span>  
  
 <span data-ttu-id="a1c4a-3454">Wszystkie tablice jednowymiarowe oparte na zero są tworzone przy użyciu <xref:System.Reflection.Emit.OpCodes.Newarr>, nie `newobj`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3454">All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`.</span></span> <span data-ttu-id="a1c4a-3455">Z drugiej strony, wszystkie inne tablice (więcej niż jeden wymiar lub jednowymiarowe, ale nie zero) są tworzone przy użyciu `newobj`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3455">On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.</span></span>  
  
 <span data-ttu-id="a1c4a-3456">Typy wartości nie są zwykle tworzone przy `newobj`użyciu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3456">Value types are not usually created using `newobj`.</span></span> <span data-ttu-id="a1c4a-3457">Są one zazwyczaj przydzieleni jako argumenty lub zmienne lokalne, przy `newarr` użyciu (dla tablic jednowymiarowych lub z jednowymiarowe) lub jako pola obiektów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3457">They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects.</span></span> <span data-ttu-id="a1c4a-3458">Po przydzieleniu są one inicjowane przy użyciu <xref:System.Reflection.Emit.OpCodes.Initobj>.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3458">Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>.</span></span> <span data-ttu-id="a1c4a-3459">`newobj` Jednakże instrukcji można użyć do utworzenia nowego wystąpienia typu wartości na stosie, który można następnie przesłać jako argument, przechowywany w lokalnej itd.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3459">However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</span></span>  
  
 <span data-ttu-id="a1c4a-3460"><xref:System.OutOfMemoryException>jest zgłaszany w przypadku braku wystarczającej ilości pamięci do spełnienia żądania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3460"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="a1c4a-3461"><xref:System.MissingMethodException>jest zgłaszany, jeśli nie `ctor` można odnaleźć metody konstruktora o wskazanej nazwie, klasie i podpisie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3461"><xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found.</span></span> <span data-ttu-id="a1c4a-3462">Jest to zwykle wykrywane, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3462">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="a1c4a-3463">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `newobj` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3463">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3464">ILGenerator.Emit(OpCode, ConstructorInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3464">ILGenerator.Emit(OpCode, ConstructorInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3465">Wypełnia miejsce, jeśli są poprawione poprawki kodów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3465">Fills space if opcodes are patched.</span></span> <span data-ttu-id="a1c4a-3466">Nie wykonano żadnej znaczącej operacji, chociaż można użyć cyklu przetwarzania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3466">No meaningful operation is performed although a processing cycle can be consumed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3467">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3467">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3468">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3468">Format</span></span>|<span data-ttu-id="a1c4a-3469">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3469">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3470">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3470">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3471">00</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3471">00</span></span>|<span data-ttu-id="a1c4a-3472">NOP</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3472">nop</span></span>|<span data-ttu-id="a1c4a-3473">Wykonuje operację bez zachowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3473">Performs an operation without behavior.</span></span>|  
  
 <span data-ttu-id="a1c4a-3474">Nie ma żadnego zachowania przejściowego stosu zdefiniowanego dla tej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3474">There is no stack transitional behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-3475">`nop` Operacja nic nie robi.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3475">The `nop` operation does nothing.</span></span> <span data-ttu-id="a1c4a-3476">Jest ona przeznaczona do wypełniania miejsca, jeśli są poprawione.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3476">It is intended to fill in space if opcodes are patched.</span></span>  
  
 <span data-ttu-id="a1c4a-3477">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `nop` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3477">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3478">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3478">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3479">Oblicza liczbę całkowitą komplementarności wartości całkowitej na szczycie stosu i wypycha wynik do stosu oceny jako ten sam typ.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3479">Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3480">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3480">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3481">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3481">Format</span></span>|<span data-ttu-id="a1c4a-3482">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3482">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3483">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3483">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3484">66</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3484">66</span></span>|<span data-ttu-id="a1c4a-3485">not</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3485">not</span></span>|<span data-ttu-id="a1c4a-3486">Oblicza liczbę całkowitą komplementarności wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3486">Computes the bitwise complement of a value.</span></span>|  
  
 <span data-ttu-id="a1c4a-3487">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3487">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3488">`value`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3488">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3489">`value`jest zdjęte z stosu i obliczany jest jego komplementarny uzupełniający.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3489">`value` is popped from the stack and its bitwise complement computed.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3490">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3490">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3491">`not` Instrukcja oblicza całkowite uzupełnienie wartości całkowitej i wypycha wynik do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3491">The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</span></span> <span data-ttu-id="a1c4a-3492">Zwracany typ jest taki sam jak typ argumentu operacji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3492">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="a1c4a-3493">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `not` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3493">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3494">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3494">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3495">Oblicz komplementarną wartość całkowitą dwóch wartości całkowitych na stosie i wypchnij wynik na stos oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3495">Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3496">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3496">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3497">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3497">Format</span></span>|<span data-ttu-id="a1c4a-3498">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3498">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3499">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3499">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3500">60</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3500">60</span></span>|<span data-ttu-id="a1c4a-3501">lub</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3501">or</span></span>|<span data-ttu-id="a1c4a-3502">Oblicza bitową lub dwie wartości całkowite, zwraca liczbę całkowitą.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3502">Computes the bitwise OR of two integer values, returns an integer.</span></span>|  
  
 <span data-ttu-id="a1c4a-3503">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3503">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3504">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3504">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3505">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3505">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3506">`value2`i `value1` są zdjęte ze stosu i ich bitowe lub obliczone.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3506">`value2` and `value1` are popped from the stack and their bitwise OR computed.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3507">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3507">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3508">`or` Instrukcja oblicza bitową lub dwie wartości korzystającego stosu, wypychając wynik do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3508">The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3509">`Or`jest operacją specyficzną dla liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3509">`Or` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="a1c4a-3510">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `or` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3510">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3511">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3511">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3512">Usuwa wartość aktualnie znajdującą się na szczycie stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3512">Removes the value currently on top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3513">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3513">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3514">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3514">Format</span></span>|<span data-ttu-id="a1c4a-3515">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3515">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3516">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3516">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3517">26</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3517">26</span></span>|<span data-ttu-id="a1c4a-3518">skakując</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3518">pop</span></span>|<span data-ttu-id="a1c4a-3519">Pop wartość najwyższej wartości ze stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3519">Pops the top value from the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3520">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3520">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3521">Górna wartość jest zdjęte ze stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3521">The top value is popped from the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3522">`pop` Instrukcja usuwa górny element ze stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3522">The `pop` instruction removes the top element from the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3523">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `pop` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3523">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3524">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3524">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3525">Jest to instrukcja zastrzeżona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3525">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3526">Jest to instrukcja zastrzeżona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3526">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3527">Jest to instrukcja zastrzeżona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3527">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3528">Jest to instrukcja zastrzeżona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3528">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3529">Jest to instrukcja zastrzeżona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3529">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3530">Jest to instrukcja zastrzeżona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3530">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3531">Jest to instrukcja zastrzeżona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3531">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3532">Jest to instrukcja zastrzeżona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3532">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3533">Określa, że kolejna operacja adresu tablicy nie sprawdza typu w czasie wykonywania i zwraca zarządzany wskaźnik, którego zmienność jest ograniczone.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3533">Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3534">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3534">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3535">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3535">Format</span></span>|<span data-ttu-id="a1c4a-3536">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3536">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3537">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3537">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3538">FE 1E</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3538">FE 1E</span></span>|<span data-ttu-id="a1c4a-3539">trybie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3539">readonly.</span></span>|<span data-ttu-id="a1c4a-3540">Określ, że kolejna operacja adresu tablicy nie sprawdza typu w czasie wykonywania i zwraca zarządzany wskaźnik z ograniczoną zmienność.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3540">Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</span></span>|  
  
 <span data-ttu-id="a1c4a-3541">Ten prefiks może występować tylko bezpośrednio przed `ldelema` instrukcją i wywołuje metodę specjalną `Address` w tablicach.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3541">This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays.</span></span> <span data-ttu-id="a1c4a-3542">Jego wpływ na następną operację to dwa cele:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3542">Its effect on the subsequent operation is twofold:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3543">W czasie wykonywania nie jest wykonywana żadna operacja sprawdzania typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3543">At run time, no type check operation is performed.</span></span> <span data-ttu-id="a1c4a-3544">Należy zauważyć, że zwykle jest to niejawne sprawdzenie `ldelema` typu `stelem` dla instrukcji i, jeśli są używane w tablicach typu referencyjnego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3544">Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays.</span></span> <span data-ttu-id="a1c4a-3545">Nie ma potrzeby sprawdzania typu w czasie wykonywania dla klas wartości, więc `readonly` w takim przypadku jest to no-op.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3545">There is never a run-time type check for value classes, so `readonly` is a no-op in that case.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3546">Weryfikator traktuje wynik operacji address-of jako zarządzany wskaźnik z ograniczoną zmienność.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3546">The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</span></span>  
  
 <span data-ttu-id="a1c4a-3547">Wskaźnik jest uznawany za ograniczony zmienność, ponieważ typ definiujący określa, czy wartość może być mutacja.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3547">The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</span></span> <span data-ttu-id="a1c4a-3548">W przypadku klas wartości, które uwidaczniają brak pól publicznych lub metod, które aktualizują wartość w miejscu, wskaźnik jest tylko do odczytu (w związku z tym nazwą prefiksu).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3548">For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</span></span> <span data-ttu-id="a1c4a-3549">W szczególności klasy reprezentujące typy pierwotne (na przykład system. Int32) nie ujawniają mutacje i w ten sposób są tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3549">In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</span></span>  
  
 <span data-ttu-id="a1c4a-3550">Zarządzany wskaźnik ograniczony w ten sposób może być używany tylko w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3550">A managed pointer restricted in this fashion can be used only in the following ways:</span></span>  
  
-   <span data-ttu-id="a1c4a-3551">`object` Jako parametr `ldfld`instrukcji, `ldflda`, ,`stfld`lub`constrained callvirt` . `call`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3551">As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions.</span></span>  
  
-   <span data-ttu-id="a1c4a-3552">Jako parametr do instrukcji lub jednej z `ldind`instrukcji. `ldobj` `pointer`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3552">As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions.</span></span>  
  
-   <span data-ttu-id="a1c4a-3553">`source` Jako parametr`cpobj` do instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3553">As the `source` parameter to the `cpobj` instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-3554">Wszystkie inne operacje `stobj`niedozwolone, w tym `initobj`operacje,, lub `mkrefany` , lub dowolnych `stind` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3554">All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions.</span></span>  
  
 <span data-ttu-id="a1c4a-3555">Celem `readonly` prefiksu jest uniknięcie sprawdzania typu podczas pobierania elementu z tablicy w kodzie ogólnym.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3555">The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code.</span></span> <span data-ttu-id="a1c4a-3556">Na przykład wyrażenie `arr[i].m()`, gdzie typ elementu tablicy `arr` jest typem ogólnym, który jest ograniczony do posiadania interfejsu z metodą `m`, może kompilować do poniższego MSIL.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3556">For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.</span></span>  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 <span data-ttu-id="a1c4a-3557">Bez prefiksu `ldelema` , instrukcja wykona sprawdzanie typu w przypadku, gdzie! 0 było typem referencyjnym. `readonly`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3557">Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type.</span></span> <span data-ttu-id="a1c4a-3558">Ten typ nie tylko jest nieefektywny, ale jest semantycznie nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3558">Not only is this type check inefficient, but it is semantically incorrect.</span></span> <span data-ttu-id="a1c4a-3559">Sprawdzanie typu dla `ldelema` jest dokładnym odpowiednikiem, który jest zbyt silny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3559">The type check for `ldelema` is an exact match, which is too strong.</span></span> <span data-ttu-id="a1c4a-3560">Jeśli tablica posiada podklasy typu! 0, w powyższym kodzie nie można sprawdzić typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3560">If the array held subclasses of type !0, the code above would fail the type check.</span></span>  
  
 <span data-ttu-id="a1c4a-3561">Adres elementu tablicy jest pobierany, a nie sam element, w celu uzyskania dojścia dla `arr[i]` tego samego typu wartości i typów referencyjnych, co może być przekazaniem `constrained callvirt` do instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3561">The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-3562">Ogólnie rzecz biorąc, byłoby niebezpieczne, aby pominąć sprawdzanie czasu wykonywania, jeśli tablica posiada elementy typu referencyjnego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3562">In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</span></span> <span data-ttu-id="a1c4a-3563">Aby zapewnić bezpieczeństwo, należy upewnić się, że żadne modyfikacje w tablicy nie są wykonywane za pomocą tego wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3563">To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</span></span> <span data-ttu-id="a1c4a-3564">Upewnij się, że reguły weryfikatora.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3564">The verifier rules ensure this.</span></span> <span data-ttu-id="a1c4a-3565">Zarządzany wskaźnik można przesłać jako obiekt wywołania metody wystąpienia, dlatego nie jest on ściśle mówiący tylko do odczytu dla typów wartościowych, ale nie ma problemu z bezpieczeństwem typu dla typów wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3565">The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</span></span>  
  
 <span data-ttu-id="a1c4a-3566">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `readonly` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3566">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3567">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3567">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3568">Pobiera token typu osadzony w określonym odwołaniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3568">Retrieves the type token embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3569">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3569">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3570">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3570">Format</span></span>|<span data-ttu-id="a1c4a-3571">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3571">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3572">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3572">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3573">FE 1D</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3573">FE 1D</span></span>|<span data-ttu-id="a1c4a-3574">refanytype</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3574">refanytype</span></span>|<span data-ttu-id="a1c4a-3575">Wypchnięcie tokenu typu przechowywanego w określonym odwołaniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3575">Pushes the type token stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="a1c4a-3576">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3576">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3577">Odwołanie do typu wartości jest wypychane do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3577">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3578">Wpisane odwołanie to zdjęte z stosu i pobrano odpowiadający mu token typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3578">The typed reference is popped from the stack and its corresponding type token retrieved.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3579">Token typu jest wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3579">The type token is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3580">Wpisane odwołanie zawiera token typu i adres do wystąpienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3580">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="a1c4a-3581">`refanytype` Instrukcja pobiera token typu osadzony w określonym odwołaniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3581">The `refanytype` instruction retrieves the type token embedded in the typed reference.</span></span> <span data-ttu-id="a1c4a-3582">Zapoznaj <xref:System.Reflection.Emit.OpCodes.Mkrefany> się z instrukcjami dotyczącymi tworzenia wpisanych odwołań.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3582">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.</span></span>  
  
 <span data-ttu-id="a1c4a-3583">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `refanytype` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3583">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3584">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3584">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3585">Pobiera adres (Type <see langword="&amp;" />) osadzony w określonym odwołaniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3585">Retrieves the address (type <see langword="&amp;" />) embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3586">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3586">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3587">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3587">Format</span></span>|<span data-ttu-id="a1c4a-3588">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3588">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3589">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3589">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3590">C2 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3590">C2 < `T` ></span></span>|<span data-ttu-id="a1c4a-3591">refanyval`type`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3591">refanyval `type`</span></span>|<span data-ttu-id="a1c4a-3592">Wypchnięcie adresu przechowywanego w określonym odwołaniu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3592">Pushes the address stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="a1c4a-3593">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3593">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3594">Odwołanie do typu wartości jest wypychane do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3594">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3595">Odwołanie z określonym typem jest zdjęte z stosu i pobierany jest odpowiedni adres.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3595">The typed reference is popped from the stack and the corresponding address retrieved.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3596">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3596">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3597">Wpisane odwołanie zawiera token typu i adres do wystąpienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3597">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="a1c4a-3598">`refanyval` Instrukcja Pobiera adres osadzony w odwołanym typie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3598">The `refanyval` instruction retrieves the address embedded in the a typed reference.</span></span> <span data-ttu-id="a1c4a-3599">Typ osadzony w odwołaniu określonym na stosie musi być zgodny z typem określonym przez `type` (token metadanych, a `typedef` lub a `typeref`).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3599">The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`).</span></span> <span data-ttu-id="a1c4a-3600">Zapoznaj <xref:System.Reflection.Emit.OpCodes.Mkrefany> się z instrukcjami dotyczącymi powiązanej zawartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3600">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.</span></span>  
  
 <span data-ttu-id="a1c4a-3601"><xref:System.InvalidCastException>jest zgłaszany `type` , jeśli nie jest identyczny z typem przechowywanym w odwołaniu typu (w `type` tym przypadku jest klasą dostarczaną do <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrukcji, która konstruuje wspomniane odwołanie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3601"><xref:System.InvalidCastException> is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference).</span></span>  
  
 <span data-ttu-id="a1c4a-3602"><xref:System.TypeLoadException>jest zgłaszany `type` , jeśli nie można znaleźć.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3602"><xref:System.TypeLoadException> is thrown if `type` cannot be found.</span></span>  
  
 <span data-ttu-id="a1c4a-3603">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `refanyval` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3603">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3604">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3604">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3605">Dzieli dwie wartości i wypchnięcia reszty na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3605">Divides two values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3606">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3606">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3607">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3607">Format</span></span>|<span data-ttu-id="a1c4a-3608">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3608">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3609">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3609">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3610">5D</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3610">5D</span></span>|<span data-ttu-id="a1c4a-3611">REM</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3611">rem</span></span>|<span data-ttu-id="a1c4a-3612">Wypchnięcie reszty dzielenia `value1` przez `value2` stos.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3612">Pushes the remainder of dividing `value1` by `value2` onto the stack.</span></span>|  
  
  
 <span data-ttu-id="a1c4a-3613">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3613">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3614">`value1` Jest wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3614">A `value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3615">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3615">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3616">`value2`i `value1` są zdjęte ze stosu i resztą wartości `value1` `div` `value2` obliczanej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3616">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3617">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3617">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3618">`result` = `value1``rem` spełnia`value2` następujące warunki:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3618">`result` = `value1` `rem` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="a1c4a-3619">`result` = `value1` - `value2``×` (`value1` )i:`div` `value2`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3619">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), and:</span></span>  
  
 <span data-ttu-id="a1c4a-3620">0 = &#124; `result` &#124; < &#124; (`result`) = `div` Sign (`value1`), gdzie jest instrukcją dzielenia, która jest obcinana do zera. `value2` &#124;</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3620">0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero.</span></span>  
  
 <span data-ttu-id="a1c4a-3621">Jeśli `value2` ma wartość zero `value1` lub jest nieskończoność, wynikiem jest NaN.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3621">If `value2` is zero or `value1` is infinity the result is NaN.</span></span> <span data-ttu-id="a1c4a-3622">Jeśli `value2` jest nieskończoność, wynik jest `value1` (Negacja `-infinity`).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3622">If `value2` is infinity, the result is `value1` (negated for `-infinity`).</span></span>  
  
 <span data-ttu-id="a1c4a-3623"><xref:System.DivideByZeroException> Jeśli`value2` wartość jest równa zero, operacje całkowite generują.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3623">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="a1c4a-3624">Należy pamiętać, że na platformach <xref:System.OverflowException> opartych na procesorze Intel jest zgłaszany podczas obliczania (Minint `rem` -1).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3624">Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1).</span></span>  
  
 <span data-ttu-id="a1c4a-3625">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `rem` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3625">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3626">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3626">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3627">Dzieli dwie wartości bez znaku i wypchnięcie reszty na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3627">Divides two unsigned values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3628">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3628">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3629">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3629">Format</span></span>|<span data-ttu-id="a1c4a-3630">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3630">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3631">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3631">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3632">5E</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3632">5E</span></span>|<span data-ttu-id="a1c4a-3633">rem.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3633">rem.un</span></span>|<span data-ttu-id="a1c4a-3634">Wypychanie pozostałej części dzielenia bez `value1` znaku przez `value2` niepodpisane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3634">Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3635">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3635">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3636">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3636">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3637">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3637">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3638">`value2`i `value1` są zdjęte ze stosu i resztą wartości `value1` `div` `value2` obliczanej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3638">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3639">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3639">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3640">`result` = `value1``rem.un` spełnia`value2` następujące warunki:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3640">`result` = `value1` `rem.un` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="a1c4a-3641">`result` = `value1` - `value2`x (`value1` `div.un` )i`value2`:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3641">`result` = `value1` - `value2` x(`value1` `div.un` `value2`), and:</span></span>  
  
 <span data-ttu-id="a1c4a-3642">0 = `result`  <  ,gdzie`div.un` jest instrukcją dzielenia bez znaku. `value2`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3642">0 = `result` < `value2`, where `div.un` is the unsigned division instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-3643">`rem.un` Instrukcja obliczyiwypycha`result` ją na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3643">The `rem.un` instruction computes `result` and pushes it on the stack.</span></span> <span data-ttu-id="a1c4a-3644">`Rem.un`traktuje swoje argumenty jako liczby całkowite bez znaku <xref:System.Reflection.Emit.OpCodes.Rem> , a jednocześnie traktuje je jako liczby całkowite ze znakiem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3644">`Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.</span></span>  
  
 <span data-ttu-id="a1c4a-3645">`Rem.un`nie jest określony dla liczb zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3645">`Rem.un` is unspecified for floating-point numbers.</span></span>  
  
 <span data-ttu-id="a1c4a-3646"><xref:System.DivideByZeroException> Jeśli`value2` wartość jest równa zero, operacje całkowite generują.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3646">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="a1c4a-3647">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `rem.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3647">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3648">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3648">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3649">Zwraca z bieżącej metody, wypchnięcie wartości zwracanej (jeśli istnieje) z stosu oceny wywoływanych elementów do stosu oceny wywołującego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3649">Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3650">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3650">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3651">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3651">Format</span></span>|<span data-ttu-id="a1c4a-3652">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3652">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3653">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3653">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3654">2A</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3654">2A</span></span>|<span data-ttu-id="a1c4a-3655">RET</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3655">ret</span></span>|<span data-ttu-id="a1c4a-3656">Zwraca z metody, która może zwracać wartość.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3656">Returns from method, possibly returning a value.</span></span>|  
  
 <span data-ttu-id="a1c4a-3657">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3657">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3658">Wartość zwracana jest zdjęte z stosu oceny wywoływanej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3658">The return value is popped from the callee evaluation stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3659">Wartość zwracana uzyskana w kroku 1 jest wypychana do stosu oceny elementu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3659">The return value obtained in step 1 is pushed onto the caller evaluation stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3660">Jeśli wartość zwracana nie występuje na stosie oceny wywoływanej, żadna wartość nie jest zwracana (brak zachowań stosu dla metody wywoływanej ani wywołującej).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3660">If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</span></span>  
  
 <span data-ttu-id="a1c4a-3661">Typ wartości zwracanej, jeśli istnieje, bieżącej metody Określa typ wartości, która ma zostać pobrana z góry stosu i kopiowany na stos metody, która wywołała bieżącą metodę.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3661">The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</span></span> <span data-ttu-id="a1c4a-3662">Stos oceny dla bieżącej metody musi być pusty, z wyjątkiem wartości, która ma zostać zwrócona.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3662">The evaluation stack for the current method must be empty except for the value to be returned.</span></span>  
  
 <span data-ttu-id="a1c4a-3663">`filter``try` `finally` `catch`Instrukcja nie może być użyta do przetransferowania kontroli z,, lub bloku. `ret`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3663">The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block.</span></span> <span data-ttu-id="a1c4a-3664">Z poziomu programu `try` lub `catch`, należy użyć <xref:System.Reflection.Emit.OpCodes.Leave> instrukcji z miejscem docelowym `ret` instrukcji, która znajduje się poza wszystkimi otaczającymi blokami wyjątków.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3664">From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks.</span></span> <span data-ttu-id="a1c4a-3665">Ze względu `finally` na `filter` to, że bloki i są logicznie częścią obsługi wyjątków, a nie metodą, w której kod jest osadzony, prawidłowo wygenerowane instrukcje języka pośredniego firmy Microsoft (MSIL) nie wykonują metody powrotu z wewnątrz `filter` lub .`finally`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3665">Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.</span></span>  
  
 <span data-ttu-id="a1c4a-3666">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `ret` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3666">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3667">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3667">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3668">Ponownie generuje bieżący wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3668">Rethrows the current exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3669">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3669">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3670">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3670">Format</span></span>|<span data-ttu-id="a1c4a-3671">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3671">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3672">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3672">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3673">FE 1A</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3673">FE 1A</span></span>|<span data-ttu-id="a1c4a-3674">Rethrow</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3674">rethrow</span></span>|<span data-ttu-id="a1c4a-3675">Ponownie generuje bieżący wyjątek</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3675">Rethrows the current exception</span></span>|  
  
 <span data-ttu-id="a1c4a-3676">Nie zdefiniowano zachowania przejścia stosu dla tej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3676">No stack transition behavior is defined for this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-3677">Instrukcja jest dozwolona tylko w treści `catch` procedury obsługi. `rethrow`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3677">The `rethrow` instruction is only permitted within the body of a `catch` handler.</span></span> <span data-ttu-id="a1c4a-3678">Zgłasza ten sam wyjątek, który został przechwycony przez ten program obsługi.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3678">It throws the same exception that was caught by this handler.</span></span>  
  
 <span data-ttu-id="a1c4a-3679">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `rethrow` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3679">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3680">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3680">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3681">Przenosi wartość całkowitą z lewej (w zerach) o określoną liczbę bitów, wypychając wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3681">Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3682">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3682">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3683">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3683">Format</span></span>|<span data-ttu-id="a1c4a-3684">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3684">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3685">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3685">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3686">62</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3686">62</span></span>|<span data-ttu-id="a1c4a-3687">shl</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3687">shl</span></span>|<span data-ttu-id="a1c4a-3688">Przesuwa liczbę całkowitą z lewej strony (przesunięcie w zerach).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3688">Shifts an integer to the left (shifting in zeros).</span></span>|  
  
 <span data-ttu-id="a1c4a-3689">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3689">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3690">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3690">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3691">Liczba bitów do przesunięcia jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3691">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3692">Liczba bitów, które mają zostać przesunięte, a wartość to zdjęte ze stosu; wartość jest przesunięta w lewo o określoną liczbę bitów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3692">The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3693">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3693">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3694">Instrukcja przenosi wartość ( `int32` `int64` Type lub`native int`) w lewo o określoną liczbę bitów. `shl`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3694">The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits.</span></span> <span data-ttu-id="a1c4a-3695">Liczba bitów jest wartością typu `int32` lub. `native int`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3695">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="a1c4a-3696">Wartość zwracana jest nieokreślona, jeśli liczba bitów do przesunięcia jest większa lub równa szerokości (w bitach) podanej wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3696">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="a1c4a-3697">`Shl`Wstawia zerowy bit w najmniejszej pozycji na każdej przesunięcia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3697">`Shl` inserts a zero bit in the lowest position on each shift.</span></span>  
  
 <span data-ttu-id="a1c4a-3698">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `shl` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3698">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3699">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3699">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3700">Przenosi wartość całkowitą (w znak) o prawo o określoną liczbę bitów, wypychając wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3700">Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3701">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3701">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3702">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3702">Format</span></span>|<span data-ttu-id="a1c4a-3703">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3703">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3704">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3704">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3705">63</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3705">63</span></span>|<span data-ttu-id="a1c4a-3706">SHR</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3706">shr</span></span>|<span data-ttu-id="a1c4a-3707">Przesuwa liczbę całkowitą do prawej strony (przesunięcie w znak).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3707">Shifts an integer to the right (shifting in sign).</span></span>|  
  
 <span data-ttu-id="a1c4a-3708">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3708">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3709">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3709">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3710">Liczba bitów do przesunięcia jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3710">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3711">Liczba bitów, które mają zostać przesunięte, a wartość to zdjęte ze stosu; wartość jest przesunięta w prawo o określoną liczbę bitów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3711">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3712">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3712">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3713">Instrukcja przesuwa wartość ( `int32` `int64` Type lub`native int`) bezpośrednio przez określoną liczbę bitów. `shr.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3713">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="a1c4a-3714">Liczba bitów jest wartością typu `int32` lub. `native int`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3714">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="a1c4a-3715">Wartość zwracana jest nieokreślona, jeśli liczba bitów do przesunięcia jest większa lub równa szerokości (w bitach) podanej wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3715">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="a1c4a-3716">`Shr`replikuje bit wysokiej kolejności przy każdej zmianie, zachowując znak oryginalnej wartości w `result`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3716">`Shr` replicates the high order bit on each shift, preserving the sign of the original value in the `result`.</span></span>  
  
 <span data-ttu-id="a1c4a-3717">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `shr` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3717">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3718">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3718">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3719">Przesuwa liczbę całkowitą bez znaku (w zerach) z prawej strony o określoną liczbę bitów, wypychając wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3719">Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3720">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3720">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3721">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3721">Format</span></span>|<span data-ttu-id="a1c4a-3722">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3722">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3723">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3723">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3724">64</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3724">64</span></span>|<span data-ttu-id="a1c4a-3725">SHR. un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3725">shr.un</span></span>|<span data-ttu-id="a1c4a-3726">Przesuwa liczbę całkowitą do prawej strony (przesunięcie w zerach).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3726">Shifts an integer to the right (shifting in zeroes).</span></span>|  
  
 <span data-ttu-id="a1c4a-3727">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3727">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3728">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3728">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3729">Liczba bitów do przesunięcia jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3729">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3730">Liczba bitów, które mają zostać przesunięte, a wartość to zdjęte ze stosu; wartość jest przesunięta w prawo o określoną liczbę bitów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3730">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3731">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3731">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3732">Instrukcja przesuwa wartość ( `int32` `int64` Type lub`native int`) bezpośrednio przez określoną liczbę bitów. `shr.un`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3732">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="a1c4a-3733">Liczba bitów jest wartością typu `int32` `int64` lub `native int`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3733">The number of bits is a value of type `int32`, `int64` or `native int`.</span></span> <span data-ttu-id="a1c4a-3734">Wartość zwracana jest nieokreślona, jeśli liczba bitów do przesunięcia jest większa lub równa szerokości (w bitach) podanej wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3734">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="a1c4a-3735">`Shr.un`Wstawia zerowy bit w najwyższej pozycji w każdej przesunięciu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3735">`Shr.un` inserts a zero bit in the highest position on each shift.</span></span>  
  
 <span data-ttu-id="a1c4a-3736">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `shr.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3736">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3737">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3737">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3738">Wypchnięcie rozmiaru, w bajtach, dla podanego typu wartości na stos szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3738">Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3739">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3739">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3740">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3740">Format</span></span>|<span data-ttu-id="a1c4a-3741">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3741">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3742">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3742">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3743">FE 1C < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3743">FE 1C < `T` ></span></span>|<span data-ttu-id="a1c4a-3744">sizeof`valType`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3744">sizeof `valType`</span></span>|<span data-ttu-id="a1c4a-3745">Wypchnij rozmiar (w bajtach) typu wartości jako `unsigned int32`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3745">Push the size, in bytes, of a value type as an `unsigned int32`.</span></span>|  
  
 <span data-ttu-id="a1c4a-3746">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3746">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3747">Rozmiar (w bajtach) podanego typu wartości (`valType`) jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3747">The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3748">`valType`musi być tokenem metadanych (a `typeref` lub `typedef`), który określa typ wartości, typ odwołania lub parametr typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3748">`valType` must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter.</span></span>  
  
 <span data-ttu-id="a1c4a-3749">W przypadku typu odwołania zwracanym rozmiarem jest rozmiar wartości odniesienia odpowiedniego typu (4 bajty w systemach 32-bitowych), a nie rozmiar danych przechowywanych w obiektach, do których odwołuje się wartość referencyjna.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3749">For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</span></span> <span data-ttu-id="a1c4a-3750">Parametru typu ogólnego można używać tylko w treści typu lub metody, która go definiuje.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3750">A generic type parameter can be used only in the body of the type or method that defines it.</span></span> <span data-ttu-id="a1c4a-3751">Gdy ten typ lub metoda jest tworzona, parametr typu ogólnego jest zastępowany przez typ wartości lub typ referencyjny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3751">When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</span></span>  
  
 <span data-ttu-id="a1c4a-3752">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `sizeof` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3752">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3753">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3753">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3754">Przechowuje wartość na górze stosu oceny w gnieździe argumentu w określonym indeksie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3754">Stores the value on top of the evaluation stack in the argument slot at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3755">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3755">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3756">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3756">Format</span></span>|<span data-ttu-id="a1c4a-3757">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3757">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3758">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3758">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3759">FE 0B < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3759">FE 0B < `unsigned int16` ></span></span>|<span data-ttu-id="a1c4a-3760">starg`num`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3760">starg `num`</span></span>|<span data-ttu-id="a1c4a-3761">Wystawia górną wartość ze stosu i zapisuje ją w gnieździe `num`argumentu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3761">Pops the top value from the stack and stores it in argument slot `num`.</span></span>|  
  
 <span data-ttu-id="a1c4a-3762">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3762">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3763">Wartość znajdująca się na szczycie stosu jest zdjęte i umieszczona w gnieździe `num`argumentu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3763">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="a1c4a-3764">Instrukcja wystawia wartość ze stosu i umieści ją w gnieździe `num`argumentu. `starg`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3764">The `starg` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="a1c4a-3765">Typ wartości musi być zgodny z typem argumentu, jak określono w podpisie bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3765">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="a1c4a-3766">W przypadku procedur, które pobierają listę argumentów zmiennych `starg` , instrukcja może być używana tylko dla początkowych argumentów stałych, a nie dla zmiennych części sygnatury.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3766">For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="a1c4a-3767">Przeprowadzenie zapisu w argumentach, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcina wartość w miarę przenoszenia z stosu do argumentu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3767">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="a1c4a-3768">Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3768">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="a1c4a-3769">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `starg` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3770">Elemencie ILGenerator. emisji (OpCode, krótkie)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3770">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3771">Przechowuje wartość na górze stosu oceny w gnieździe argumentu w określonym indeksie, skróconej postaci.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3771">Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3772">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3773">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3773">Format</span></span>|<span data-ttu-id="a1c4a-3774">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3774">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3775">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3776">10 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3776">10 < `unsigned int8` ></span></span>|<span data-ttu-id="a1c4a-3777">starg. s`num`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3777">starg.s `num`</span></span>|<span data-ttu-id="a1c4a-3778">Wystawia najwyższą wartość ze stosu i zapisuje ją w gnieździe `num`argumentów, krótką formą.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3778">Pops the top value from the stack and stores it in argument slot `num`, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-3779">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3780">Wartość znajdująca się na szczycie stosu jest zdjęte i umieszczona w gnieździe `num`argumentu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3780">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="a1c4a-3781">Instrukcja wystawia wartość ze stosu i umieści ją w gnieździe `num`argumentu. `starg.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3781">The `starg.s` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="a1c4a-3782">Typ wartości musi być zgodny z typem argumentu, jak określono w podpisie bieżącej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3782">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="a1c4a-3783">`starg.s` Instrukcja zapewnia wydajne kodowanie do użycia z pierwszych 256 argumentów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3783">The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments.</span></span>  
  
 <span data-ttu-id="a1c4a-3784">W przypadku procedur, które pobierają listę argumentów zmiennych `starg.s` , instrukcja może być używana tylko dla początkowych argumentów stałych, a nie dla zmiennych części sygnatury.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3784">For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="a1c4a-3785">Przeprowadzenie zapisu w argumentach, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcina wartość w miarę przenoszenia z stosu do argumentu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3785">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="a1c4a-3786">Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3786">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="a1c4a-3787">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `starg.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3787">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3788">Elemencie ILGenerator. emisji (OpCode, Byte)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3788">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3789">Zastępuje element Array w danym indeksie wartością na stosie ewaluacyjnym, którego typ jest określony w instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3789">Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3790">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3790">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3791">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3791">Format</span></span>|<span data-ttu-id="a1c4a-3792">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3792">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3793">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3793">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3794">< A4`T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3794">A4 < `T` ></span></span>|<span data-ttu-id="a1c4a-3795">stelem`typeTok`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3795">stelem `typeTok`</span></span>|<span data-ttu-id="a1c4a-3796">Zamienia element array na podany indeks o wartości typu `typeTok` na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3796">Replaces the array element at the supplied index with a value of type `typeTok` on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3797">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3797">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3798">Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3798">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3799">Wartość `index`indeksu, do elementu w `array` jest wypychana na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3799">An index value, `index`, to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3800">Wartość typu określonego w instrukcji jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3800">A value of the type specified in the instruction is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3801">Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3801">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="a1c4a-3802">Instrukcja zastępuje wartość elementu w dostarczonym indeksie liczonym od zera w tablicy `array` jednowymiarowej z wartością. `stelem`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3802">The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value.</span></span> <span data-ttu-id="a1c4a-3803">Wartość ma typ określony przez token `typeTok` w instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3803">The value has the type specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-3804">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3804">Arrays are objects, and hence represented by a value of type `O`.</span></span> <span data-ttu-id="a1c4a-3805">Indeks jest typem `native int`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3805">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="a1c4a-3806"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3806"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-3807"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3807"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-3808"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3808"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-3809">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3809">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3810">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3810">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3811">Zastępuje element Array w danym indeksie <see langword="native int" /> wartością na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3811">Replaces the array element at a given index with the <see langword="native int" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3812">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3812">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3813">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3813">Format</span></span>|<span data-ttu-id="a1c4a-3814">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3814">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3815">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3815">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3816">9B</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3816">9B</span></span>|<span data-ttu-id="a1c4a-3817">stelem.i</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3817">stelem.i</span></span>|<span data-ttu-id="a1c4a-3818">Zastępuje element tablicy w podanym indeksie `native int` wartością na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3818">Replaces an array element at the supplied index with the `native int` value on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3819">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3819">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3820">Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3820">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3821">Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3821">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3822">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3822">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3823">Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3823">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="a1c4a-3824">Instrukcja zastępuje wartość elementu `index` w `array` tablicy`native int` jednowymiarowej wartością wypychaną na stos. `stelem.i`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3824">The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3825">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3825">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="a1c4a-3826">Indeks jest typem `native int`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3826">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="a1c4a-3827"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3827"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-3828"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3828"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-3829"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3829"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-3830">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.i` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3830">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3831">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3831">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3832">Zastępuje element Array w danym indeksie <see langword="int8" /> wartością na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3832">Replaces the array element at a given index with the <see langword="int8" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3833">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3833">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3834">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3834">Format</span></span>|<span data-ttu-id="a1c4a-3835">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3835">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3836">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3836">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3837">9C</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3837">9C</span></span>|<span data-ttu-id="a1c4a-3838">stelem.i1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3838">stelem.i1</span></span>|<span data-ttu-id="a1c4a-3839">Zastępuje element tablicy w podanym indeksie `int8` wartością na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3839">Replaces an array element at the supplied index with the `int8` value on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3840">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3840">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3841">Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3841">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3842">Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3842">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3843">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3843">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3844">Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3844">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="a1c4a-3845">Instrukcja zastępuje wartość elementu `index` w `array` tablicy`int8` jednowymiarowej wartością wypychaną na stos. `stelem.i1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3845">The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3846">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3846">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="a1c4a-3847">Indeks jest typem `native int`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3847">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="a1c4a-3848"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3848"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-3849"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3849"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-3850"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3850"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-3851">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.i1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3851">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3852">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3852">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3853">Zastępuje element Array w danym indeksie <see langword="int16" /> wartością na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3853">Replaces the array element at a given index with the <see langword="int16" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3854">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3855">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3855">Format</span></span>|<span data-ttu-id="a1c4a-3856">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3856">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3857">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3858">9D</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3858">9D</span></span>|<span data-ttu-id="a1c4a-3859">stelem.i2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3859">stelem.i2</span></span>|<span data-ttu-id="a1c4a-3860">Zastępuje element tablicy w podanym indeksie `int16` wartością na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3860">Replaces an array element at the supplied index with the `int16` value on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3861">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3862">Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3862">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3863">Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3863">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3864">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3864">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3865">Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3865">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="a1c4a-3866">Instrukcja zastępuje wartość elementu `index` w `array` tablicy`int16` jednowymiarowej wartością wypychaną na stos. `stelem.i2`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3866">The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3867">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3867">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="a1c4a-3868">Indeks jest typem `native int`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3868">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="a1c4a-3869"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3869"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-3870"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3870"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-3871"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3871"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-3872">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.i2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3872">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3873">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3873">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3874">Zastępuje element Array w danym indeksie <see langword="int32" /> wartością na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3874">Replaces the array element at a given index with the <see langword="int32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3875">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3875">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3876">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3876">Format</span></span>|<span data-ttu-id="a1c4a-3877">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3877">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3878">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3878">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3879">9E</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3879">9E</span></span>|<span data-ttu-id="a1c4a-3880">stelem.i4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3880">stelem.i4</span></span>|<span data-ttu-id="a1c4a-3881">Zastępuje element tablicy w podanym indeksie `int32` wartością na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3881">Replaces an array element at the supplied index with the `int32` value on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3882">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3882">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3883">Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3883">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3884">Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3884">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3885">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3885">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3886">Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3886">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="a1c4a-3887">Instrukcja zastępuje wartość elementu `index` w `array` tablicy`int32` jednowymiarowej wartością wypychaną na stos. `stelem.i4`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3887">The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3888">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3888">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="a1c4a-3889">Indeks jest typem `native int`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3889">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="a1c4a-3890"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3890"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-3891"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3891"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-3892"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3892"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-3893">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.i4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3893">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3894">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3894">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3895">Zastępuje element Array w danym indeksie <see langword="int64" /> wartością na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3895">Replaces the array element at a given index with the <see langword="int64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3896">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3896">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3897">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3897">Format</span></span>|<span data-ttu-id="a1c4a-3898">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3898">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3899">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3899">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3900">9F</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3900">9F</span></span>|<span data-ttu-id="a1c4a-3901">stelem.i8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3901">stelem.i8</span></span>|<span data-ttu-id="a1c4a-3902">Zastępuje element tablicy w podanym indeksie `int64` wartością na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3902">Replaces an array element at the supplied index with the `int64` value on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3903">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3903">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3904">Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3904">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3905">Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3905">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3906">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3906">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3907">Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3907">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="a1c4a-3908">Instrukcja zastępuje wartość elementu `index` w `array` tablicy`int64` jednowymiarowej wartością wypychaną na stos. `stelem.i8`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3908">The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3909">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3909">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="a1c4a-3910">Indeks jest typem `native int`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3910">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="a1c4a-3911"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3911"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-3912"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3912"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-3913"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3913"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-3914">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.i8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3914">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3915">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3915">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3916">Zastępuje element Array w danym indeksie <see langword="float32" /> wartością na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3916">Replaces the array element at a given index with the <see langword="float32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3917">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3917">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3918">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3918">Format</span></span>|<span data-ttu-id="a1c4a-3919">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3919">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3920">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3920">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3921">A0</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3921">A0</span></span>|<span data-ttu-id="a1c4a-3922">stelem.r4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3922">stelem.r4</span></span>|<span data-ttu-id="a1c4a-3923">Zastępuje element tablicy w podanym indeksie `float32` wartością na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3923">Replaces an array element at the supplied index with the `float32` value on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3924">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3924">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3925">Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3925">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3926">Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3926">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3927">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3927">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3928">Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3928">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="a1c4a-3929">Instrukcja zastępuje wartość elementu `index` w `array` tablicy`float32` jednowymiarowej wartością wypychaną na stos. `stelem.r4`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3929">The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3930">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3930">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="a1c4a-3931">Indeks jest typem `native int`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3931">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="a1c4a-3932"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3932"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-3933"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3933"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-3934"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3934"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-3935">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.r4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3935">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3936">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3936">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3937">Zastępuje element Array w danym indeksie <see langword="float64" /> wartością na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3937">Replaces the array element at a given index with the <see langword="float64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3938">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3938">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3939">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3939">Format</span></span>|<span data-ttu-id="a1c4a-3940">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3940">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3941">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3941">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3942">A1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3942">A1</span></span>|<span data-ttu-id="a1c4a-3943">stelem.r8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3943">stelem.r8</span></span>|<span data-ttu-id="a1c4a-3944">Zastępuje element tablicy w podanym indeksie `float64` wartością na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3944">Replaces an array element at the supplied index with the `float64` value on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3945">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3945">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3946">Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3946">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3947">Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3947">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3948">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3948">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3949">Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3949">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="a1c4a-3950">Instrukcja zastępuje wartość elementu `index` w `array` tablicy`float64` jednowymiarowej wartością wypychaną na stos. `stelem.r8`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3950">The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3951">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3951">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="a1c4a-3952">Indeks jest typem `native int`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3952">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="a1c4a-3953"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3953"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-3954"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3954"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-3955"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3955"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-3956">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.r8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3956">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3957">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3957">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3958">Zamienia element Array w danym indeksie na wartość Ref obiektu (Type <see langword="O" />) na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3958">Replaces the array element at a given index with the object ref value (type <see langword="O" />) on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3959">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3959">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3960">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3960">Format</span></span>|<span data-ttu-id="a1c4a-3961">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3961">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3962">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3962">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3963">A2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3963">A2</span></span>|<span data-ttu-id="a1c4a-3964">stelem.ref</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3964">stelem.ref</span></span>|<span data-ttu-id="a1c4a-3965">Zastępuje element tablicy w podanym indeksie `ref` wartością (typ `O`) na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3965">Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack.</span></span>|  
  
 <span data-ttu-id="a1c4a-3966">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3966">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3967">Odwołanie do obiektu do tablicy `array`, jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3967">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3968">Prawidłowy indeks elementu w `array` elemencie jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3968">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3969">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3969">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="a1c4a-3970">Wartość, indeks i odwołanie do tablicy są zdjęte ze stosu. wartość jest umieszczana w elemencie Array w danym indeksie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3970">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="a1c4a-3971">Instrukcja zastępuje wartość elementu w podanym indeksie w tablicy `array` jednowymiarowej o `ref` wartości (Type `O`) wypchnięcia na stosie. `stelem.ref`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3971">The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-3972">Tablice są obiektami, dlatego reprezentowane przez wartość typu `O`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3972">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="a1c4a-3973">Indeks jest typem `native int`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3973">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="a1c4a-3974">Należy zauważyć `stelem.ref` , że niejawnie rzutuje podaną wartość na `array` typ elementu przed przypisaniem wartości do elementu Array.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3974">Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element.</span></span> <span data-ttu-id="a1c4a-3975">To rzutowanie może zakończyć się niepowodzeniem, nawet w przypadku zweryfikowanego kodu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3975">This cast can fail, even for verified code.</span></span> <span data-ttu-id="a1c4a-3976">W `stelem.ref` rezultacie instrukcja może zgłosić <xref:System.InvalidCastException>.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3976">Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>.</span></span> <span data-ttu-id="a1c4a-3977">W przypadku tablic jednowymiarowych, które nie są oparte na zerach i dla <xref:System.Array> tablic wielowymiarowych, <xref:System.Array.SetValue%2A> Klasa udostępnia metodę.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3977">For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.</span></span>  
  
 <span data-ttu-id="a1c4a-3978"><xref:System.NullReferenceException>jest zgłaszany `array` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3978"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-3979"><xref:System.IndexOutOfRangeException>jest zgłaszany `index` , jeśli jest ujemna lub większa niż `array`granica.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3979"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="a1c4a-3980"><xref:System.ArrayTypeMismatchException>jest zgłaszany `array` , jeśli nie zawiera elementów wymaganego typu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3980"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="a1c4a-3981">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stelem.ref` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3981">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-3982">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3982">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-3983">Zamienia wartość przechowywaną w polu odwołania do obiektu lub wskaźnika z nową wartością.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3983">Replaces the value stored in the field of an object reference or pointer with a new value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-3984">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3984">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-3985">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3985">Format</span></span>|<span data-ttu-id="a1c4a-3986">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3986">Assembly Format</span></span>|<span data-ttu-id="a1c4a-3987">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3987">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-3988">7D < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-3988">7D < `T` ></span></span>|<span data-ttu-id="a1c4a-3989">stfld`field`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3989">stfld `field`</span></span>|<span data-ttu-id="a1c4a-3990">Zamienia wartość `field` obiektu na nową wartość.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3990">Replaces the value of `field` of the object with a new value.</span></span>|  
  
 <span data-ttu-id="a1c4a-3991">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3991">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-3992">Odwołanie do obiektu lub wskaźnik jest wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3992">An object reference or pointer is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-3993">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3993">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-3994">Wartość i odwołanie do obiektu/wskaźnik są zdjęte ze stosu; wartość `field` w obiekcie jest zastępowana podaną wartością.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3994">The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value.</span></span>  
  
 <span data-ttu-id="a1c4a-3995">`native int` `O` `*` `&`Instrukcja zastępuje wartość pola obiektu (typu) lub za pośrednictwem wskaźnika (typu, lub) z daną wartością. `stfld`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3995">The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value.</span></span> <span data-ttu-id="a1c4a-3996">`Field`jest tokenem metadanych, który odwołuje się do odwołania do elementu członkowskiego pola.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3996">`Field` is a metadata token that refers to a field member reference.</span></span> <span data-ttu-id="a1c4a-3997">Instrukcja może mieć prefiks jednego lub obu elementów <xref:System.Reflection.Emit.OpCodes.Unaligned> i <xref:System.Reflection.Emit.OpCodes.Volatile>. `stfld`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3997">The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="a1c4a-3998"><xref:System.NullReferenceException>jest zgłaszany, jeśli odwołanie do obiektu lub wskaźnik jest odwołaniem null, a pole nie jest statyczne.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3998"><xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static.</span></span>  
  
 <span data-ttu-id="a1c4a-3999"><xref:System.MissingFieldException>jest zgłaszany `field` , jeśli nie zostanie znaleziony w metadanych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-3999"><xref:System.MissingFieldException> is thrown if `field` is not found in the metadata.</span></span> <span data-ttu-id="a1c4a-4000">Jest to zwykle sprawdzane, gdy instrukcja języka pośredniego (MSIL) firmy Microsoft jest konwertowana na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4000">This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="a1c4a-4001">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stfld` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4001">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4002">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4002">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4003">Przechowuje wartość typu <see langword="native int" /> pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4003">Stores a value of type <see langword="native int" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4004">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4004">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4005">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4005">Format</span></span>|<span data-ttu-id="a1c4a-4006">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4006">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4007">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4007">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4008">DF</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4008">DF</span></span>|<span data-ttu-id="a1c4a-4009">stind.i</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4009">stind.i</span></span>|<span data-ttu-id="a1c4a-4010">`native int` Przechowuje wartość pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4010">Stores a `native int` value at a given address.</span></span>|  
  
 <span data-ttu-id="a1c4a-4011">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4011">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4012">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4012">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4013">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4013">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4014">Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4014">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="a1c4a-4015">`&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (Type, lub). `native int` `stind.i`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4015">The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="a1c4a-4016">Operacja bezpiecznego typu wymaga, aby `stind.i` instrukcja była używana w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4016">Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="a1c4a-4017">Operację `stind.i` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4017">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-4018"><xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4018"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="a1c4a-4019">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.i` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4019">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4020">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4020">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4021">Przechowuje wartość typu <see langword="int8" /> pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4021">Stores a value of type <see langword="int8" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4022">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4022">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4023">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4023">Format</span></span>|<span data-ttu-id="a1c4a-4024">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4024">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4025">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4025">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4026">52</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4026">52</span></span>|<span data-ttu-id="a1c4a-4027">stind. I1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4027">stind.i1</span></span>|<span data-ttu-id="a1c4a-4028">`int8` Przechowuje wartość pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4028">Stores an `int8` value at a given address.</span></span>|  
  
 <span data-ttu-id="a1c4a-4029">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4029">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4030">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4030">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4031">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4031">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4032">Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4032">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="a1c4a-4033">`&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (typu, lub). `int8` `stind.i1`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4033">The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="a1c4a-4034">Operacja bezpiecznego typu wymaga, aby `stind.i1` instrukcja była używana w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4034">Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="a1c4a-4035">Operację `stind.i1` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4035">The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-4036"><xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4036"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="a1c4a-4037">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.i1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4037">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4038">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4038">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4039">Przechowuje wartość typu <see langword="int16" /> pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4039">Stores a value of type <see langword="int16" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4040">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4040">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4041">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4041">Format</span></span>|<span data-ttu-id="a1c4a-4042">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4042">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4043">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4043">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4044">53</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4044">53</span></span>|<span data-ttu-id="a1c4a-4045">stind. I2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4045">stind.i2</span></span>|<span data-ttu-id="a1c4a-4046">`int16` Przechowuje wartość pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4046">Stores an `int16` value at a given address.</span></span>|  
  
 <span data-ttu-id="a1c4a-4047">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4047">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4048">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4048">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4049">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4049">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4050">Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4050">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="a1c4a-4051">`&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (typu, lub). `int16` `stind.i2`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4051">The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="a1c4a-4052">Operacja bezpiecznego typu wymaga, aby `stind.2i` instrukcja była używana w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4052">Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="a1c4a-4053">Operację `stind.i2` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4053">The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-4054"><xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4054"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="a1c4a-4055">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.i2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4055">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4056">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4056">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4057">Przechowuje wartość typu <see langword="int32" /> pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4057">Stores a value of type <see langword="int32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4058">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4058">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4059">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4059">Format</span></span>|<span data-ttu-id="a1c4a-4060">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4060">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4061">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4061">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4062">54</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4062">54</span></span>|<span data-ttu-id="a1c4a-4063">stind.i4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4063">stind.i4</span></span>|<span data-ttu-id="a1c4a-4064">`int32` Przechowuje wartość pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4064">Stores an `int32` value at a given address.</span></span>|  
  
 <span data-ttu-id="a1c4a-4065">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4065">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4066">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4066">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4067">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4067">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4068">Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4068">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="a1c4a-4069">`&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (typu, lub). `int32` `stind.i4`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4069">The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="a1c4a-4070">Operacja bezpiecznego typu wymaga, aby `stind.i4` instrukcja była używana w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4070">Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="a1c4a-4071">Operację `stind.i4` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4071">The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-4072"><xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4072"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="a1c4a-4073">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.i4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4073">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4074">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4074">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4075">Przechowuje wartość typu <see langword="int64" /> pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4075">Stores a value of type <see langword="int64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4076">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4076">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4077">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4077">Format</span></span>|<span data-ttu-id="a1c4a-4078">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4078">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4079">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4079">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4080">55</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4080">55</span></span>|<span data-ttu-id="a1c4a-4081">stind.i8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4081">stind.i8</span></span>|<span data-ttu-id="a1c4a-4082">`int64` Przechowuje wartość pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4082">Stores an `int64` value at a given address.</span></span>|  
  
 <span data-ttu-id="a1c4a-4083">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4083">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4084">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4084">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4085">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4085">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4086">Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4086">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="a1c4a-4087">`&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (typu, lub). `int64` `stind.i8`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4087">The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="a1c4a-4088">Operacja bezpiecznego typu wymaga, aby `stind.i8` instrukcja była używana w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4088">Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="a1c4a-4089">Operację `stind.i` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4089">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-4090"><xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4090"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="a1c4a-4091">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.i8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4091">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4092">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4092">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4093">Przechowuje wartość typu <see langword="float32" /> pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4093">Stores a value of type <see langword="float32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4094">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4094">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4095">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4095">Format</span></span>|<span data-ttu-id="a1c4a-4096">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4096">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4097">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4097">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4098">56</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4098">56</span></span>|<span data-ttu-id="a1c4a-4099">stind.r4</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4099">stind.r4</span></span>|<span data-ttu-id="a1c4a-4100">`float32` Przechowuje wartość pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4100">Stores a `float32` value at a given address.</span></span>|  
  
 <span data-ttu-id="a1c4a-4101">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4101">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4102">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4102">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4103">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4103">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4104">Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4104">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="a1c4a-4105">`&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (Type, lub). `float32` `stind.r4`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4105">The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="a1c4a-4106">Operacja bezpiecznego typu wymaga, aby `stind.r4` instrukcja była używana w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4106">Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="a1c4a-4107">Operację `stind.r4` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4107">The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-4108"><xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4108"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="a1c4a-4109">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.r4` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4109">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4110">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4110">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4111">Przechowuje wartość typu <see langword="float64" /> pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4111">Stores a value of type <see langword="float64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4112">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4112">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4113">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4113">Format</span></span>|<span data-ttu-id="a1c4a-4114">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4114">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4115">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4115">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4116">57</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4116">57</span></span>|<span data-ttu-id="a1c4a-4117">stind.r8</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4117">stind.r8</span></span>|<span data-ttu-id="a1c4a-4118">`float64` Przechowuje wartość pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4118">Stores a `float64` value at a given address.</span></span>|  
  
 <span data-ttu-id="a1c4a-4119">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4119">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4120">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4120">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4121">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4121">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4122">Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4122">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="a1c4a-4123">`&` `*` `native int`Instrukcja przechowuje wartość pod podanym adresem (Type, lub). `float64` `stind.r8`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4123">The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="a1c4a-4124">Operacja bezpiecznego typu wymaga, aby `stind.r8` instrukcja była używana w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4124">Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="a1c4a-4125">Operację `stind.r8` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4125">The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-4126"><xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4126"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="a1c4a-4127">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.r8` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4127">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4128">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4128">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4129">Przechowuje wartość odwołania do obiektu pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4129">Stores a object reference value at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4130">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4130">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4131">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4131">Format</span></span>|<span data-ttu-id="a1c4a-4132">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4132">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4133">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4133">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4134">51</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4134">51</span></span>|<span data-ttu-id="a1c4a-4135">stind.ref</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4135">stind.ref</span></span>|<span data-ttu-id="a1c4a-4136">Przechowuje wartość odwołania do obiektu ( `O`Type) pod podanym adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4136">Stores an object reference (type `O`) value at a given address.</span></span>|  
  
 <span data-ttu-id="a1c4a-4137">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4137">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4138">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4138">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4139">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4139">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4140">Wartość i adres są zdjęte ze stosu; wartość jest przechowywana pod adresem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4140">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="a1c4a-4141">Instrukcja przechowuje wartość odwołania do obiektu pod podanym adresem (typu `native int`, `*`lub `&`). `stind.ref`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4141">The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="a1c4a-4142">Operacja bezpiecznego typu wymaga, aby `stind.ref` instrukcja była używana w sposób spójny z typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4142">Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="a1c4a-4143">Operację `stind.ref` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4143">The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-4144"><xref:System.NullReferenceException>jest zgłaszany `addr` , jeśli nie jest w sposób naturalny wyrównany dla typu argumentu implikowanego przez sufiks instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4144"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="a1c4a-4145">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stind.ref` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4145">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4146">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4146">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4147">Pop bieżącą wartość od góry stosu oceny i zapisuje ją na liście zmiennych lokalnych pod określonym indeksem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4147">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4148">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4148">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4149">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4149">Format</span></span>|<span data-ttu-id="a1c4a-4150">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4150">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4151">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4151">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4152">FE 0E < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-4152">FE 0E < `unsigned int16` ></span></span>|<span data-ttu-id="a1c4a-4153">stloc`index`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4153">stloc `index`</span></span>|<span data-ttu-id="a1c4a-4154">Pop wartość ze stosu i zapisuje ją w zmiennej `index`lokalnej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4154">Pops a value from the stack and stores it in local variable `index`.</span></span>|  
  
 <span data-ttu-id="a1c4a-4155">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4155">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4156">Wartość jest zdjęte na stosie i umieszczona w zmiennej `index`lokalnej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4156">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="a1c4a-4157">Instrukcja wystawia górną wartość na stosie szacowania i przenosi ją do lokalnego numeru `index`zmiennej, gdzie zmienne lokalne są numerowane od 0 do wewnątrz. `stloc`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4157">The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="a1c4a-4158">Typ wartości musi być zgodny z typem zmiennej lokalnej, jak określono w lokalnym podpisie metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4158">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="a1c4a-4159">Przechowywanie w zmiennych lokalnych, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcinają wartość w miarę przenoszenia ze stosu do zmiennej lokalnej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4159">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="a1c4a-4160">Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4160">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="a1c4a-4161">Poprawne instrukcje języka pośredniego firmy Microsoft (MSIL `index` ) wymagają, aby był prawidłowym indeksem lokalnym.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4161">Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index.</span></span> <span data-ttu-id="a1c4a-4162">`stloc` Dla`index` instrukcji musi znajdować się w zakresie od 0 do 65534 włącznie (w odniesieniu do 65535 jest nieprawidłowy).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4162">For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</span></span> <span data-ttu-id="a1c4a-4163">Przyczyna wykluczenia 65535 jest pragmatyczna: prawdopodobnie implementacje będą używały 2-bajtowej liczby całkowitej do śledzenia zarówno lokalnego indeksu, jak i łącznej liczby elementów lokalnych danej metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4163">The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</span></span> <span data-ttu-id="a1c4a-4164">Jeśli indeks 65535 był prawidłowy, będzie wymagał szerszej liczby całkowitej do śledzenia liczby elementów lokalnych w takiej metodzie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4164">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="a1c4a-4165">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `stloc` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4165">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4166">Elemencie ILGenerator. emisji (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4166">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="a1c4a-4167">Elemencie ILGenerator. emisji (OpCode, krótkie)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4167">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4168">Pop bieżąca wartość od góry stosu oceny i zapisuje ją na liście zmiennych lokalnych pod indeksem 0.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4168">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4169">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4169">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4170">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4170">Format</span></span>|<span data-ttu-id="a1c4a-4171">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4171">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4172">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4172">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4173">0A</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4173">0A</span></span>|<span data-ttu-id="a1c4a-4174">stloc. 0</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4174">stloc.0</span></span>|<span data-ttu-id="a1c4a-4175">Pop wartość ze stosu do zmiennej lokalnej 0.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4175">Pops a value from the stack into local variable 0.</span></span>|  
  
 <span data-ttu-id="a1c4a-4176">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4176">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4177">Wartość jest zdjęte na stosie i umieszczona w zmiennej lokalnej indeksowane przez 0.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4177">A value is popped off of the stack and placed in the local variable indexed by 0.</span></span>  
  
 <span data-ttu-id="a1c4a-4178">`stloc.0` Instrukcja wystawia górną wartość na stosie szacowania i przenosi ją do zmiennej lokalnej indeksowanej przez 0.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4178">The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</span></span> <span data-ttu-id="a1c4a-4179">Typ wartości musi być zgodny z typem zmiennej lokalnej, jak określono w lokalnym podpisie metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4179">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="a1c4a-4180">`stloc.0`jest szczególnie wydajnym kodowaniem do przechowywania wartości w zmiennej lokalnej 0.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4180">`stloc.0` is an especially efficient encoding for storing values in local variable 0.</span></span>  
  
 <span data-ttu-id="a1c4a-4181">Przechowywanie w zmiennych lokalnych, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcinają wartość w miarę przenoszenia ze stosu do zmiennej lokalnej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4181">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="a1c4a-4182">Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4182">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="a1c4a-4183">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stloc.0` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4183">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4184">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4184">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4185">Pop bieżąca wartość od góry stosu oceny i zapisuje ją na liście zmiennych lokalnych pod indeksem 1.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4185">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4186">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4186">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4187">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4187">Format</span></span>|<span data-ttu-id="a1c4a-4188">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4188">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4189">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4189">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4190">0B</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4190">0B</span></span>|<span data-ttu-id="a1c4a-4191">stloc. 1</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4191">stloc.1</span></span>|<span data-ttu-id="a1c4a-4192">Pop wartość ze stosu do zmiennej lokalnej 1.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4192">Pops a value from the stack into local variable 1.</span></span>|  
  
 <span data-ttu-id="a1c4a-4193">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4193">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4194">Wartość jest zdjęte na stosie i umieszczona w zmiennej lokalnej indeksowanej przez 1.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4194">A value is popped off of the stack and placed in the local variable indexed by 1.</span></span>  
  
 <span data-ttu-id="a1c4a-4195">`stloc.1` Instrukcja wystawia górną wartość na stosie szacowania i przenosi ją do zmiennej lokalnej indeksowanej przez 1.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4195">The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</span></span> <span data-ttu-id="a1c4a-4196">Typ wartości musi być zgodny z typem zmiennej lokalnej, jak określono w lokalnym podpisie metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4196">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="a1c4a-4197">`stloc.1`jest szczególnie wydajnym kodowaniem do przechowywania wartości w zmiennej lokalnej 1.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4197">`stloc.1` is an especially efficient encoding for storing values in local variable 1.</span></span>  
  
 <span data-ttu-id="a1c4a-4198">Przechowywanie w zmiennych lokalnych, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcinają wartość w miarę przenoszenia ze stosu do zmiennej lokalnej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4198">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="a1c4a-4199">Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4199">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="a1c4a-4200">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stloc.1` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4200">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4201">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4201">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4202">Pop bieżąca wartość od góry stosu oceny i zapisuje ją na liście zmiennych lokalnych pod indeksem 2.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4202">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4203">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4203">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4204">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4204">Format</span></span>|<span data-ttu-id="a1c4a-4205">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4205">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4206">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4206">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4207">0C</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4207">0C</span></span>|<span data-ttu-id="a1c4a-4208">stloc. 2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4208">stloc.2</span></span>|<span data-ttu-id="a1c4a-4209">Pop wartość ze stosu do zmiennej lokalnej 2</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4209">Pops a value from the stack into local variable 2</span></span>|  
  
 <span data-ttu-id="a1c4a-4210">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4210">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4211">Wartość jest zdjęte na stosie i umieszczona w zmiennej lokalnej indeksowanej przez 2.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4211">A value is popped off of the stack and placed in the local variable indexed by 2.</span></span>  
  
 <span data-ttu-id="a1c4a-4212">`stloc.2` Instrukcja wystawia górną wartość na stosie szacowania i przenosi ją do zmiennej lokalnej indeksowanej przez 2.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4212">The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</span></span> <span data-ttu-id="a1c4a-4213">Typ wartości musi być zgodny z typem zmiennej lokalnej, jak określono w lokalnym podpisie metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4213">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="a1c4a-4214">`stloc.2`jest szczególnie wydajnym kodowaniem do przechowywania wartości w zmiennej lokalnej 2.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4214">`stloc.2` is an especially efficient encoding for storing values in local variable 2.</span></span>  
  
 <span data-ttu-id="a1c4a-4215">Przechowywanie w zmiennych lokalnych, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcinają wartość w miarę przenoszenia ze stosu do zmiennej lokalnej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4215">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="a1c4a-4216">Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4216">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="a1c4a-4217">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stloc.2` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4217">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4218">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4218">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4219">Pop bieżąca wartość od góry stosu oceny i zapisuje ją na liście zmiennych lokalnych pod indeksem 3.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4219">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4220">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4220">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4221">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4221">Format</span></span>|<span data-ttu-id="a1c4a-4222">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4222">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4223">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4223">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4224">0D</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4224">0D</span></span>|<span data-ttu-id="a1c4a-4225">stloc. 3</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4225">stloc.3</span></span>|<span data-ttu-id="a1c4a-4226">Pop wartość ze stosu do zmiennej lokalnej 3</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4226">Pops a value from the stack into local variable 3</span></span>|  
  
 <span data-ttu-id="a1c4a-4227">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4227">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4228">Wartość jest zdjęte na stosie i umieszczona w zmiennej lokalnej indeksowanej przez 3.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4228">A value is popped off of the stack and placed in the local variable indexed by 3.</span></span>  
  
 <span data-ttu-id="a1c4a-4229">`stloc.3` Instrukcja wystawia górną wartość na stosie szacowania i przenosi ją do zmiennej lokalnej indeksowanej przez 3.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4229">The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</span></span> <span data-ttu-id="a1c4a-4230">Typ wartości musi być zgodny z typem zmiennej lokalnej, jak określono w lokalnym podpisie metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4230">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="a1c4a-4231">`stloc.3`jest szczególnie wydajnym kodowaniem do przechowywania wartości w zmiennej lokalnej 3.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4231">`stloc.3` is an especially efficient encoding for storing values in local variable 3.</span></span>  
  
 <span data-ttu-id="a1c4a-4232">Przechowywanie w zmiennych lokalnych, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcinają wartość w miarę przenoszenia ze stosu do zmiennej lokalnej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4232">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="a1c4a-4233">Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4233">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="a1c4a-4234">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stloc.3` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4234">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4235">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4235">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4236">Pop bieżącą wartość od góry stosu oceny i zapisuje ją na liście zmiennych lokalnych w <paramref name="index" /> (krótka wersja).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4236">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <paramref name="index" /> (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4237">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4237">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4238">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4238">Format</span></span>|<span data-ttu-id="a1c4a-4239">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4239">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4240">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4240">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4241">13 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-4241">13 < `unsigned int8` ></span></span>|<span data-ttu-id="a1c4a-4242">stloc. s`index`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4242">stloc.s `index`</span></span>|<span data-ttu-id="a1c4a-4243">Pop wartość ze stosu i zapisuje ją w zmiennej `index`lokalnej, skróconej postaci.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4243">Pops a value from the stack and stores it in local variable `index`, short form.</span></span>|  
  
 <span data-ttu-id="a1c4a-4244">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4244">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4245">Wartość jest zdjęte na stosie i umieszczona w zmiennej `index`lokalnej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4245">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="a1c4a-4246">Instrukcja wystawia górną wartość na stosie szacowania i przenosi ją do lokalnego numeru `index`zmiennej, gdzie zmienne lokalne są numerowane od 0 do wewnątrz. `stloc.s`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4246">The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="a1c4a-4247">Typ wartości musi być zgodny z typem zmiennej lokalnej, jak określono w lokalnym podpisie metody.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4247">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="a1c4a-4248">`stloc.s` Instrukcja zapewnia wydajne kodowanie zmiennych lokalnych od 0 do 255.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4248">The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="a1c4a-4249">Przechowywanie w zmiennych lokalnych, które przechowują wartość całkowitą o długości mniejszej niż 4 bajty, obcinają wartość w miarę przenoszenia ze stosu do zmiennej lokalnej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4249">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="a1c4a-4250">Wartości zmiennoprzecinkowe są zaokrąglane z rozmiaru macierzystego (Type `F`) do rozmiaru skojarzonego z argumentem.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4250">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="a1c4a-4251">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `stloc.s` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4251">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4252">Elemencie ILGenerator. emisji (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4252">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="a1c4a-4253">Elemencie ILGenerator. emisji (OpCode, Byte)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4253">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4254">Kopiuje wartość określonego typu ze stosu oceny do podanego adresu pamięci.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4254">Copies a value of a specified type from the evaluation stack into a supplied memory address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4255">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4255">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4256">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4256">Format</span></span>|<span data-ttu-id="a1c4a-4257">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4257">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4258">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4258">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4259">81 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-4259">81 < `T` ></span></span>|<span data-ttu-id="a1c4a-4260">stobj `class`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4260">stobj `class`</span></span>|<span data-ttu-id="a1c4a-4261">Przechowuje wartość typu `class` ze stosu do pamięci.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4261">Stores a value of type `class` from the stack into memory.</span></span>|  
  
 <span data-ttu-id="a1c4a-4262">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4262">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4263">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4263">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4264">Obiekt typu wartości typu `class` jest wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4264">A value type object of type `class` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4265">Obiekt i adres są zdjęte ze stosu; Obiekt typu wartości jest przechowywany w adresie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4265">The object and the address are popped from the stack; the value type object is stored at the address.</span></span>  
  
 <span data-ttu-id="a1c4a-4266">Instrukcja kopiuje obiekt typu wartości do adresu określonego przez adres (wskaźnik typu `native int`, `*`lub `&`). `stobj`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4266">The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`).</span></span> <span data-ttu-id="a1c4a-4267">Liczba kopiowanych bajtów zależy od rozmiaru klasy reprezentowanej przez `class`, tokenu metadanych reprezentującego typ wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4267">The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.</span></span>  
  
 <span data-ttu-id="a1c4a-4268">Operację `stobj` instrukcji można zmienić za pomocą instrukcji bezpośrednio poprzedzającej <xref:System.Reflection.Emit.OpCodes.Volatile> lub <xref:System.Reflection.Emit.OpCodes.Unaligned> przedrostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4268">The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-4269"><xref:System.TypeLoadException>jest zgłaszany, jeśli nie można znaleźć klasy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4269"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="a1c4a-4270">Jest to zwykle wykrywane, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4270">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
 <span data-ttu-id="a1c4a-4271">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stobj` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4271">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4272">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4272">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4273">Zastępuje wartość pola statycznego wartością ze stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4273">Replaces the value of a static field with a value from the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4274">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4274">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4275">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4275">Format</span></span>|<span data-ttu-id="a1c4a-4276">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4276">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4277">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4277">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4278">80 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-4278">80 < `T` ></span></span>|<span data-ttu-id="a1c4a-4279">stsfld`field`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4279">stsfld `field`</span></span>|<span data-ttu-id="a1c4a-4280">Zamienia wartość `field` przy użyciu podanej wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4280">Replaces the value in `field` with a supplied value.</span></span>|  
  
 <span data-ttu-id="a1c4a-4281">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4281">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4282">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4282">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4283">Wartość jest zdjęte ze stosu i przechowywana w `field`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4283">A value is popped from the stack and stored in `field`.</span></span>  
  
 <span data-ttu-id="a1c4a-4284">`stsfld` Instrukcja zastępuje wartość pola statycznego wartością ze stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4284">The `stsfld` instruction replaces the value of a static field with a value from the stack.</span></span> <span data-ttu-id="a1c4a-4285">`field`jest tokenem metadanych, który musi odwoływać się do statycznego elementu członkowskiego pola.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4285">`field` is a metadata token that must refer to a static field member.</span></span>  
  
 <span data-ttu-id="a1c4a-4286">Instrukcja może być poprzedzona przez <xref:System.Reflection.Emit.OpCodes.Volatile>. `stsfld`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4286">The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="a1c4a-4287"><xref:System.MissingFieldException>jest zgłaszany, jeśli nie znaleziono pola w metadanych.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4287"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="a1c4a-4288">Jest to zazwyczaj zaznaczone, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4288">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="a1c4a-4289">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `stsfld` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4289">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4290">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4290">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4291">Odejmuje jedną wartość od drugiej i wypycha wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4291">Subtracts one value from another and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4292">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4292">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4293">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4293">Format</span></span>|<span data-ttu-id="a1c4a-4294">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4294">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4295">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4295">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4296">59</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4296">59</span></span>|<span data-ttu-id="a1c4a-4297">sub</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4297">sub</span></span>|<span data-ttu-id="a1c4a-4298">Odejmuje jedną wartość od innej, zwracając nową wartość liczbową.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4298">Subtracts one value from another, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="a1c4a-4299">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4299">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4300">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4300">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4301">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4301">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4302">`value2`i `value1` są zdjęte ze stosu; jest odejmowany od `value1`. `value2`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4302">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1`.</span></span>  
  
4.  <span data-ttu-id="a1c4a-4303">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4303">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-4304">Nie wykryto przepełnienia dla operacji całkowitych (Aby uzyskać prawidłową <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>obsługę przepełnienia, zobacz).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4304">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span></span>  
  
 <span data-ttu-id="a1c4a-4305">Zawijanie liczb całkowitych, a nie nasycenie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4305">Integer subtraction wraps, rather than saturates.</span></span> <span data-ttu-id="a1c4a-4306">Na przykład: przy założeniu 8-bitowych liczb całkowitych, gdzie `value1` jest ustawiona na 0 i `value2` jest ustawiona na 1, wynik "opakowany" będzie 255.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4306">For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the "wrapped" result will be 255.</span></span>  
  
 <span data-ttu-id="a1c4a-4307">Przepełnienie zmiennoprzecinkowe `+inf` zwraca`PositiveInfinity`() `-inf` lub`NegativeInfinity`().</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4307">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="a1c4a-4308">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `sub` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4308">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4309">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4309">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4310">Odejmuje jedną wartość całkowitą od innej, wykonuje sprawdzanie przepełnienia i wypycha wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4310">Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4311">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4311">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4312">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4312">Format</span></span>|<span data-ttu-id="a1c4a-4313">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4313">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4314">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4314">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4315">DA</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4315">DA</span></span>|<span data-ttu-id="a1c4a-4316">sub.ovf</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4316">sub.ovf</span></span>|<span data-ttu-id="a1c4a-4317">Odejmuje jedną wartość całkowitą od innej ze sprawdzaniem przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4317">Subtracts one integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="a1c4a-4318">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4318">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4319">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4319">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4320">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4320">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4321">`value2`i `value1` są zdjęte ze stosu; jest odejmowany od `value1` do sprawdzenia przepełnienia. `value2`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4321">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="a1c4a-4322">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4322">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-4323"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4323"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-4324">Ta operacja jest wykonywana w przypadku liczb całkowitych ze znakiem; dla wartości zmiennoprzecinkowych Użyj <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4324">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="a1c4a-4325">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `sub.ovf` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4325">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4326">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4326">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4327">Odejmuje jedną liczbę całkowitą bez znaku z innego, wykonuje sprawdzanie przepełnienia i wypycha wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4327">Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4328">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4328">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4329">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4329">Format</span></span>|<span data-ttu-id="a1c4a-4330">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4330">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4331">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4331">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4332">DB</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4332">DB</span></span>|<span data-ttu-id="a1c4a-4333">sub.ovf.un</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4333">sub.ovf.un</span></span>|<span data-ttu-id="a1c4a-4334">Odejmuje jedną liczbę całkowitą bez znaku z innej ze sprawdzaniem przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4334">Subtracts one unsigned integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="a1c4a-4335">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4335">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4336">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4336">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4337">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4337">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4338">`value2`i `value1` są zdjęte ze stosu; jest odejmowany od `value1` do sprawdzenia przepełnienia. `value2`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4338">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="a1c4a-4339">Wynik jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4339">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-4340"><xref:System.OverflowException>jest zgłaszany, jeśli wynik nie może być reprezentowany w typie wyniku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4340"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="a1c4a-4341">Ta operacja jest wykonywana w przypadku liczb całkowitych ze znakiem; dla wartości zmiennoprzecinkowych Użyj <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4341">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="a1c4a-4342">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `sub.ovf.un` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4342">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4343">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4343">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4344">Implementuje tabelę skoku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4344">Implements a jump table.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4345">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4345">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4346">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4346">Format</span></span>|<span data-ttu-id="a1c4a-4347">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4347">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4348">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4348">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4349">45 < `unsigned int32` > < `int32` >... <`int32` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-4349">45 < `unsigned int32` > < `int32` >... < `int32` ></span></span>|<span data-ttu-id="a1c4a-4350">Przełącz (`N`, `t1`, `t2`... `tN`)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4350">switch (`N`, `t1`, `t2`... `tN`)</span></span>|<span data-ttu-id="a1c4a-4351">Skacze do jednej `N` z wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4351">Jumps to one of `N` values.</span></span>|  
  
 <span data-ttu-id="a1c4a-4352">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4352">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4353">Wartość jest wypychana do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4353">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4354">Wartość jest zdjęte na stosie, a wykonywanie jest przenoszone do instrukcji w przesunięciu indeksowanym przez wartość, gdzie wartość jest mniejsza niż `N`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4354">The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`.</span></span>  
  
 <span data-ttu-id="a1c4a-4355">`switch` Instrukcja implementuje tabelę skoku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4355">The `switch` instruction implements a jump table.</span></span> <span data-ttu-id="a1c4a-4356">Format instrukcji jest `unsigned int32` reprezentujący liczbę elementów docelowych `N`, po których następuje `N` wartość Int32 określająca cele skoku.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4356">The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets.</span></span> <span data-ttu-id="a1c4a-4357">Te elementy docelowe są reprezentowane jako przesunięcia (dodatnie lub ujemne) od początku instrukcji zgodnie z tą `switch` instrukcją.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4357">These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-4358">Instrukcja umieszcza wartość na stosie i porównuje ją, jako liczbę całkowitą bez znaku, do `N`. `switch`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4358">The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`.</span></span> <span data-ttu-id="a1c4a-4359">Jeśli wartość jest mniejsza niż `N`, wykonanie jest transferowane do obiektu docelowego indeksowanego przez wartość, gdzie cele są numerowane od 0 (na przykład wartość 0 przyjmuje pierwszy element docelowy, a wartość 1 przyjmuje drugi element docelowy itd.).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4359">If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</span></span> <span data-ttu-id="a1c4a-4360">Jeśli wartość jest większa lub równa `N`, wykonanie kontynuuje się przy następnej instrukcji (przekroczenie).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4360">If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).</span></span>  
  
 <span data-ttu-id="a1c4a-4361">Jeśli instrukcja docelowa zawiera co najmniej jeden kod prefiksu, formant można przesłać tylko do pierwszego z tych prefiksów.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4361">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="a1c4a-4362">Ta instrukcja umożliwia sterowanie transferami `try`do `catch`i z bloków `finally` ,, `filter`i.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4362">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span> <span data-ttu-id="a1c4a-4363">(Takie transfery są poważnie ograniczone i należy zamiast tego użyć instrukcji Opuść).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4363">(Such transfers are severely restricted and must use the leave instruction instead).</span></span>  
  
 <span data-ttu-id="a1c4a-4364">Poniższe <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `switch` używać kodu operacji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4364">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode.</span></span> <span data-ttu-id="a1c4a-4365">`Label[]` Argument jest tablicą etykiet reprezentujących przesunięcie 32-bitowe.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4365">The `Label[]` argument is an array of Labels representing 32-bit offsets.</span></span>  
  
-   <span data-ttu-id="a1c4a-4366">Elemencie ILGenerator. emisji (OpCode, etykieta [])</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4366">ILGenerator.Emit(OpCode, Label[])</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1c4a-4367">Poniższy przykład kodu ilustruje użycie `Switch` kodu w celu wygenerowania tabeli skoku przy użyciu <xref:System.Reflection.Emit.Label>tablicy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4367">The following code sample illustrates the use of the `Switch` opcode to generate a jump table using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4368">Wykonuje instrukcję wywoływanego wywołania metody w taki sposób, aby ramka stosu bieżącej metody została usunięta przed wykonaniem rzeczywistej instrukcji wywołania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4368">Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4369">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4370">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4370">Format</span></span>|<span data-ttu-id="a1c4a-4371">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4371">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4372">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4373">FE 14</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4373">FE 14</span></span>|<span data-ttu-id="a1c4a-4374">drugorzędn.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4374">tail.</span></span>|<span data-ttu-id="a1c4a-4375">Kolejne wywołanie kończy bieżące metody</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4375">Subsequent call terminates current methods</span></span>|  
  
 <span data-ttu-id="a1c4a-4376">Nie ma żadnego zachowania przejścia stosu zdefiniowanego dla tej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4376">There is no stack transition behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="a1c4a-4377">Instrukcja prefiksu musi występować bezpośrednio <xref:System.Reflection.Emit.OpCodes.Call>przed instrukcją, <xref:System.Reflection.Emit.OpCodes.Callvirt> <xref:System.Reflection.Emit.OpCodes.Calli>, lub. `tail`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4377">The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction.</span></span> <span data-ttu-id="a1c4a-4378">Wskazuje, że ramka stosu bieżącej metody powinna zostać usunięta przed wykonaniem instrukcji Call.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4378">It indicates that the current method's stack frame should be removed before the call instruction is executed.</span></span> <span data-ttu-id="a1c4a-4379">Oznacza to również, że wartość zwracana z następującego wywołania jest również wartością zwracaną przez bieżącą metodę, a wywołanie może zostać przekonwertowane na uskok metody krzyżowej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4379">It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</span></span>  
  
 <span data-ttu-id="a1c4a-4380">Stos musi być pusty, z wyjątkiem argumentów, które są transferowane przez następujące wywołanie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4380">The stack must be empty except for the arguments being transferred by the following call.</span></span> <span data-ttu-id="a1c4a-4381">Instrukcja po instrukcji Call musi być RET. W związku z tym jedyną prawidłową sekwencją kodu `calli` jest `callvirt` `tail. call` (lub lub).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4381">The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`).</span></span> <span data-ttu-id="a1c4a-4382">Poprawne instrukcje języka pośredniego firmy Microsoft (MSIL) nie mogą `call` odgałęziać do instrukcji, ale może odgałęziać się do kolejnego <xref:System.Reflection.Emit.OpCodes.Ret>.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4382">Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.</span></span>  
  
 <span data-ttu-id="a1c4a-4383">Nie można odrzucić bieżącej ramki, gdy kontrolka jest przekazywana z niezaufanego kodu do zaufanego kodu, ponieważ mogłoby to spowodować zagrożenie dla kodu zabezpieczenia tożsamości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4383">The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</span></span> <span data-ttu-id="a1c4a-4384">W związku z tym sprawdzanie zabezpieczeń .NET Framework może `tail` spowodować zignorowanie i pozostawienie standardowej <xref:System.Reflection.Emit.OpCodes.Call> instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4384">The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span> <span data-ttu-id="a1c4a-4385">Podobnie, aby zezwolić na zakończenie synchronizowanego regionu po wywołaniu wywołania, `tail` prefiks jest ignorowany, gdy jest używany do zamykania metody oznaczonej jako zsynchronizowane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4385">Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.</span></span>  
  
 <span data-ttu-id="a1c4a-4386">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `tail` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4386">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4387">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4387">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst"><span data-ttu-id="a1c4a-4388">Wystąpienie obiektu opcode.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4388">An instance of an Opcode object.</span></span></param>
        <summary><span data-ttu-id="a1c4a-4389">Zwraca wartość true lub false, jeśli podany element opcode przyjmuje jednobajtowy argument.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4389">Returns true or false if the supplied opcode takes a single byte argument.</span></span></summary>
        <returns><span data-ttu-id="a1c4a-4390"><see langword="true" />lub <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4390"><see langword="true" /> or <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4391">Ta metoda może służyć do znajdowania, które kody operacji MSIL są "krótkie", do użycia w zoptymalizowanym kodzie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4391">This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</span></span>  
  
 <span data-ttu-id="a1c4a-4392">`TakesSingleByteArgument``true` zwraca<xref:System.Reflection.Emit.OpCode> czy wystąpienie przyjmuje jeden dwubajtowy argument w następujących przypadkach:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4392">`TakesSingleByteArgument` returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:</span></span>  
  
-   <span data-ttu-id="a1c4a-4393">Kod operacji wykonuje instrukcję Branch dla adresu o rozmiarze bajtowym (na przykład <xref:System.Reflection.Emit.OpCodes.Br_S> i <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4393">The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span></span>  
  
-   <span data-ttu-id="a1c4a-4394">Kod operacji wypchnij wartość bajtową na stos (na przykład <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4394">The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span></span>  
  
-   <span data-ttu-id="a1c4a-4395">Kod operacji odwołuje się do zmiennej lub argumentu za pośrednictwem skróconej formy o rozmiarze bajtowym ( <xref:System.Reflection.Emit.OpCodes.Ldloc_S> na <xref:System.Reflection.Emit.OpCodes.Stloc_S>przykład i).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4395">The opcode references a variable or argument via the byte-sized "short form" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span></span>  
  
 <span data-ttu-id="a1c4a-4396">W przeciwnym razie zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4396">Otherwise, it returns `false`.</span></span>  
  
 <span data-ttu-id="a1c4a-4397">W poniższym przykładzie pokazano `TakesSingleByteArgument` `OpCodes` sposób użycia przez odzwierciedlenie w klasie i testowaniu, aby sprawdzić, czy każde `OpCode` pole przyjmuje jednobajtowy argument.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4397">The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4398">Zgłasza obiekt wyjątku aktualnie na stosie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4398">Throws the exception object currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4399">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4399">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4400">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4400">Format</span></span>|<span data-ttu-id="a1c4a-4401">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4401">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4402">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4402">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4403">7A</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4403">7A</span></span>|<span data-ttu-id="a1c4a-4404">throw</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4404">throw</span></span>|<span data-ttu-id="a1c4a-4405">Zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4405">Throws an exception.</span></span>|  
  
 <span data-ttu-id="a1c4a-4406">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4406">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4407">Odwołanie do obiektu (do wyjątku) jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4407">An object reference (to an exception) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4408">Odwołanie do obiektu jest zdjęte ze stosu i zgłoszono wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4408">The object reference is popped from the stack and the exception thrown.</span></span>  
  
 <span data-ttu-id="a1c4a-4409">Instrukcja zgłasza obiekt wyjątku (Type `O`) aktualnie na stosie. `throw`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4409">The `throw` instruction throws the exception object (type `O`) currently on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-4410"><xref:System.NullReferenceException>jest zgłaszany, jeśli odwołanie do obiektu jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4410"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-4411">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `throw` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4411">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4412">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4412">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4413">Wskazuje, że adres, który obecnie korzystającego stosu oceny, może nie być wyrównany do naturalnego <see langword="ldind" />rozmiaru bezpośrednio następującego, <see langword="stind" /> <see langword="ldfld" /> <see langword="initblk" />, <see langword="stfld" /> <see langword="ldobj" /> <see langword="stobj" />,,, lub <see langword="cpblk" /> instrukcja.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4413">Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, or <see langword="cpblk" /> instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4414">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4414">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4415">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4415">Format</span></span>|<span data-ttu-id="a1c4a-4416">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4416">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4417">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4417">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4418">FE 12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-4418">FE 12 < `unsigned int8` ></span></span>|<span data-ttu-id="a1c4a-4419">niewyrównany.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4419">unaligned.</span></span> `alignment`|<span data-ttu-id="a1c4a-4420">Wskazuje, że dalsza instrukcja wskaźnika może być niewyrównana.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4420">Indicates that the subsequent pointer instruction may be unaligned.</span></span>|  
  
 <span data-ttu-id="a1c4a-4421">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4421">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4422">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4422">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-4423">`Unaligned`Określa, że adres (niezarządzany wskaźnik `native int`,) na stosie, może nie być wyrównany do naturalnego rozmiaru bezpośrednio następujących `ldobj` `ldind` `stobj`, `stind` `ldfld` `stfld`,,,, `initblk` lub`cpblk` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4423">`Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="a1c4a-4424">Oznacza to, że w <xref:System.Reflection.Emit.OpCodes.Ldind_I4> przypadku instrukcji wyrównanie adresu nie może być do 4-bajtowej granicy.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4424">That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary.</span></span> <span data-ttu-id="a1c4a-4425">Dla `initblk` i`cpblk` domyślne wyrównanie jest zależne od architektury (4 bajty na 32-bitowych procesorach CPU, 8-bajtowych na 64-bitowych procesorach).</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4425">For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</span></span> <span data-ttu-id="a1c4a-4426">Generatory kodu, które nie ograniczają danych wyjściowych do 32-bitowego rozmiaru wyrazu, muszą być używane `unaligned` , jeśli wyrównanie nie jest znane w czasie kompilacji do 8-bajtowego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4426">Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.</span></span>  
  
 <span data-ttu-id="a1c4a-4427">Wartość wyrównania musi być równa 1, 2 lub 4 i oznacza, że wygenerowany kod powinien przyjąć, że adres jest odpowiednio bajtowy, dwubajtowy lub cztery bajty.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4427">The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</span></span> <span data-ttu-id="a1c4a-4428">Należy zauważyć, że wskaźniki przejściowe (Type `*`) są zawsze wyrównane.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4428">Note that transient pointers (type `*`) are always aligned.</span></span>  
  
 <span data-ttu-id="a1c4a-4429">Mimo że wyrównanie `cpblk` instrukcji logicznej wymaga dwóch liczb (jeden dla źródła i jeden dla miejsca docelowego), nie ma zauważalnego wpływu na wydajność, jeśli określono tylko niższą liczbę.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4429">While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</span></span>  
  
 <span data-ttu-id="a1c4a-4430">Prefiksy `volatile` i mogą być łączone w dowolnej kolejności. `unaligned`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4430">The `unaligned` and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="a1c4a-4431">Muszą one bezpośrednio poprzedzać `ldind`instrukcje `stind`, `ldfld` `stfld` `stobj`,,, `ldobj`,, lub`cpblk` . `initblk`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4431">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="a1c4a-4432">Tylko prefiks jest dozwolony <xref:System.Reflection.Emit.OpCodes.Ldsfld> dla instrukcji i <xref:System.Reflection.Emit.OpCodes.Stsfld>. <xref:System.Reflection.Emit.OpCodes.Volatile></span><span class="sxs-lookup"><span data-stu-id="a1c4a-4432">Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="a1c4a-4433">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> przeciążenia metod mogą `unaligned` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4434">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4434">ILGenerator.Emit(OpCode, Label)</span></span>  
  
-   <span data-ttu-id="a1c4a-4435">Elemencie ILGenerator. emisji (opcode, Byte)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4435">ILGenerator.Emit(Opcode, Byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4436">Konwertuje opakowaną reprezentację typu wartości na postać nieopakowaną.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4436">Converts the boxed representation of a value type to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4437">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4437">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4438">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4438">Format</span></span>|<span data-ttu-id="a1c4a-4439">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4439">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4440">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4440">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4441">79 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-4441">79 < `T` ></span></span>|<span data-ttu-id="a1c4a-4442">Unbox`valType`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4442">unbox `valType`</span></span>|<span data-ttu-id="a1c4a-4443">Wyodrębnia dane typu wartości z, `obj`w zapakowanym obszarze.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4443">Extracts the value type data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="a1c4a-4444">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4444">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4445">Odwołanie do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4445">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4446">Odwołanie do obiektu jest zdjęte z stosu i rozpakowane do wskaźnika typu wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4446">The object reference is popped from the stack and unboxed to a value type pointer.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4447">Wskaźnik typu wartości jest wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4447">The value type pointer is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-4448">Typ wartości ma dwie oddzielne reprezentacje w Common Language Infrastructure (interfejs wiersza polecenia):</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4448">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="a1c4a-4449">Formularz "RAW" używany, gdy typ wartości jest osadzony w innym obiekcie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4449">A 'raw' form used when a value type is embedded within another object.</span></span>  
  
-   <span data-ttu-id="a1c4a-4450">Formularz "opakowany", w którym dane w typie wartości są opakowane (opakowane) do obiektu, tak aby mógł istnieć jako niezależna jednostka.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4450">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="a1c4a-4451">Instrukcja konwertuje odwołanie do obiektu (typ `O`), opakowaną reprezentację typu wartości do wskaźnika typu wartości (zarządzany wskaźnik, typ `&`), jego nieopakowany formularz. `unbox`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4451">The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form.</span></span> <span data-ttu-id="a1c4a-4452">Podany typ wartości (`valType`) jest tokenem metadanych wskazującym typ wartości, która znajduje się w zapakowanym obiekcie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4452">The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.</span></span>  
  
 <span data-ttu-id="a1c4a-4453">W przeciwieństwie <xref:System.Reflection.Emit.OpCodes.Box>do, co jest wymagane, aby utworzyć kopię typu wartości do użycia w obiekcie, `unbox` nie jest wymagana do kopiowania typu wartości z obiektu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4453">Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object.</span></span> <span data-ttu-id="a1c4a-4454">Zwykle po prostu oblicza adres typu wartości, który jest już obecny w obiekcie zapakowanym.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4454">Typically it simply computes the address of the value type that is already present inside of the boxed object.</span></span>  
  
 <span data-ttu-id="a1c4a-4455"><xref:System.InvalidCastException>jest zgłaszany, jeśli obiekt nie jest opakowany jako `valType`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4455"><xref:System.InvalidCastException> is thrown if the object is not boxed as `valType`.</span></span>  
  
 <span data-ttu-id="a1c4a-4456"><xref:System.NullReferenceException>jest zgłaszany, jeśli odwołanie do obiektu jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4456"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-4457"><xref:System.TypeLoadException>jest zgłaszany, jeśli nie `valType` można znaleźć typu wartości.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4457"><xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found.</span></span> <span data-ttu-id="a1c4a-4458">Jest to zwykle wykrywane, gdy instrukcje języka pośredniego (MSIL) firmy Microsoft są konwertowane na kod natywny, a nie w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4458">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="a1c4a-4459">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `unbox` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4459">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4460">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4460">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4461">Konwertuje opakowaną reprezentację typu określonego w instrukcji na postać nieopakowaną.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4461">Converts the boxed representation of a type specified in the instruction to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4462">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4462">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4463">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4463">Format</span></span>|<span data-ttu-id="a1c4a-4464">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4464">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4465">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4465">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4466">A5 < `T` ></span><span class="sxs-lookup"><span data-stu-id="a1c4a-4466">A5 < `T` ></span></span>|<span data-ttu-id="a1c4a-4467">Unbox. any`typeTok`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4467">unbox.any `typeTok`</span></span>|<span data-ttu-id="a1c4a-4468">Wyodrębnij dane z `obj`, zapakowanych reprezentacji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4468">Extract the data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="a1c4a-4469">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4469">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4470">Odwołanie `obj` do obiektu jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4470">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4471">Odwołanie do obiektu jest zdjęte z stosu i rozpakowane do typu określonego w instrukcji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4471">The object reference is popped from the stack and unboxed to the type specified in the instruction.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4472">Typ referencyjny lub odwołanie do obiektu jest wypychany do stosu.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4472">The resulting object reference or value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-4473">W `unbox.any` przypadku zastosowania do formy opakowanej typu wartości instrukcja wyodrębnia wartość zawartej w `obj` (typu `O`) i dlatego jest równoznaczna z `unbox` operatorem `ldobj`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4473">When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`.</span></span>  
  
 <span data-ttu-id="a1c4a-4474">W przypadku zastosowania do typu `unbox.any` odwołania instrukcja ma ten sam skutek co. `castclass` `typeTok`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4474">When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`.</span></span>  
  
 <span data-ttu-id="a1c4a-4475">Jeśli argument `typeTok` jest parametrem typu ogólnego, zachowanie środowiska uruchomieniowego jest określane przez typ określony dla tego parametru typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4475">If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</span></span>  
  
 <span data-ttu-id="a1c4a-4476"><xref:System.InvalidCastException>jest zgłaszany `obj` , jeśli nie jest typu opakowanego.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4476"><xref:System.InvalidCastException> is thrown if `obj` is not a boxed type.</span></span>  
  
 <span data-ttu-id="a1c4a-4477"><xref:System.NullReferenceException>jest zgłaszany `obj` , jeśli jest odwołaniem o wartości null.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4477"><xref:System.NullReferenceException> is thrown if `obj` is a null reference.</span></span>  
  
 <span data-ttu-id="a1c4a-4478">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `unbox.any` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4478">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4479">Elemencie ILGenerator. emisji (OpCode, typ)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4479">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4480">Określa, że adres, który jest obecnie korzystającego stosu oceny, może być nietrwały, a wyniki odczytywania tej lokalizacji nie mogą być buforowane lub nie można pominąć wielu magazynów dla tej lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4480">Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4481">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4481">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4482">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4482">Format</span></span>|<span data-ttu-id="a1c4a-4483">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4483">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4484">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4484">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4485">FE 13</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4485">FE 13</span></span>|<span data-ttu-id="a1c4a-4486">volatile.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4486">volatile.</span></span>|<span data-ttu-id="a1c4a-4487">Wskazuje, że kolejne odwołanie do wskaźnika jest nietrwałe.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4487">Indicates that the subsequent pointer reference is volatile.</span></span>|  
  
 <span data-ttu-id="a1c4a-4488">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4488">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4489">Adres jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4489">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-4490">`volatile`.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4490">`volatile`.</span></span> <span data-ttu-id="a1c4a-4491">Określa, że adres jest adresem nietrwałym (oznacza to, że można odwoływać się zewnętrznie do bieżącego wątku wykonywania) i wyniki odczytywania tej lokalizacji nie mogą być buforowane lub nie można pominąć wielu magazynów dla tej lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4491">specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span> <span data-ttu-id="a1c4a-4492">Oznaczanie dostępu jako `volatile` ma wpływ tylko na jeden dostęp; inne dostęp do tej samej lokalizacji muszą być oznaczone osobno.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4492">Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately.</span></span> <span data-ttu-id="a1c4a-4493">Dostęp do lokalizacji nietrwałych nie musi być wykonywany niepodzielnie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4493">Access to volatile locations need not be performed atomically.</span></span>  
  
 <span data-ttu-id="a1c4a-4494">Prefiksy `volatile` i mogą być łączone w dowolnej kolejności. <xref:System.Reflection.Emit.OpCodes.Unaligned></span><span class="sxs-lookup"><span data-stu-id="a1c4a-4494">The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="a1c4a-4495">Muszą one bezpośrednio poprzedzać `ldind`instrukcje `stind`, `ldfld` `stfld` `stobj`,,, `ldobj`,, lub`cpblk` . `initblk`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4495">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="a1c4a-4496">Tylko prefiks jest dozwolony <xref:System.Reflection.Emit.OpCodes.Ldsfld> dla instrukcji i <xref:System.Reflection.Emit.OpCodes.Stsfld>. `volatile`</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4496">Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="a1c4a-4497">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `volatile` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4497">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4498">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4498">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1c4a-4499">Oblicza bitową wartość XOR dla pierwszych dwóch wartości na stosie oceny, wypychając wynik do stosu oceny.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4499">Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1c4a-4500">W poniższej tabeli przedstawiono format zestawu języka pośredniego w formacie szesnastkowym i Microsoft (MSIL) instrukcji wraz z krótkim podsumowaniem odwołania:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4500">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="a1c4a-4501">Format</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4501">Format</span></span>|<span data-ttu-id="a1c4a-4502">Format zestawu</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4502">Assembly Format</span></span>|<span data-ttu-id="a1c4a-4503">Opis</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4503">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="a1c4a-4504">61</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4504">61</span></span>|<span data-ttu-id="a1c4a-4505">xor</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4505">xor</span></span>|<span data-ttu-id="a1c4a-4506">Oblicza bitową XOR z dwóch wartości całkowitych i zwraca liczbę całkowitą.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4506">Computes the bitwise XOR of two integer values and returns an integer.</span></span>|  
  
 <span data-ttu-id="a1c4a-4507">Zachowanie przejściowe stosu, w kolejności sekwencyjnej, to:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4507">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="a1c4a-4508">`value1`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4508">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="a1c4a-4509">`value2`jest wypychany na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4509">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="a1c4a-4510">`value2`i `value1` są zdjęte z stosu i obliczone przez niego bitowe XOR.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4510">`value2` and `value1` are popped from the stack and their bitwise XOR computed.</span></span>  
  
4.  <span data-ttu-id="a1c4a-4511">Bitowe XOR `value2` i `value1` jest wypychane na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4511">The bitwise XOR of `value2` and `value1` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-4512">`xor` Instrukcja oblicza bitową wartość XOR dla pierwszych dwóch wartości na stosie i pozostawia wynik na stosie.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4512">The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="a1c4a-4513">`Xor`jest operacją specyficzną dla liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4513">`Xor` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="a1c4a-4514">Następujące <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Przeciążenie metody może `xor` używać kodu operacji:</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4514">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:</span></span>  
  
-   <span data-ttu-id="a1c4a-4515">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="a1c4a-4515">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

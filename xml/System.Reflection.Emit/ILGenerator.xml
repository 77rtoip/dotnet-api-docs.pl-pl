<Type Name="ILGenerator" FullName="System.Reflection.Emit.ILGenerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4ae648b40d93ecd1388e8d955baed090cd4920b9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36643502" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ILGenerator : System.Runtime.InteropServices._ILGenerator" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit ILGenerator extends System.Object implements class System.Runtime.InteropServices._ILGenerator" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ILGenerator" />
  <TypeSignature Language="VB.NET" Value="Public Class ILGenerator&#xA;Implements _ILGenerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class ILGenerator : System::Runtime::InteropServices::_ILGenerator" />
  <TypeSignature Language="F#" Value="type ILGenerator = class&#xA;    interface _ILGenerator" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._ILGenerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ILGenerator))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="1989c-101">Generuje instrukcje języka pośredniego (MSIL) firmy Microsoft.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1989c-101">Generates Microsoft intermediate language (MSIL) instructions.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-102"><xref:System.Reflection.Emit.ILGenerator> Służy do generowania treści metody dla metody i konstruktory w dynamicznych zestawach (reprezentowane przez <xref:System.Reflection.Emit.MethodBuilder> i <xref:System.Reflection.Emit.ConstructorBuilder> klasy) oraz metod dynamicznych autonomicznej (reprezentowane przez <xref:System.Reflection.Emit.DynamicMethod> klasy).</span><span class="sxs-lookup"><span data-stu-id="1989c-102"><xref:System.Reflection.Emit.ILGenerator> is used to generate method bodies for methods and constructors in dynamic assemblies (represented by the <xref:System.Reflection.Emit.MethodBuilder> and <xref:System.Reflection.Emit.ConstructorBuilder> classes) and for standalone dynamic methods (represented by the <xref:System.Reflection.Emit.DynamicMethod> class).</span></span> <span data-ttu-id="1989c-103">Aby uzyskać <xref:System.Reflection.Emit.ILGenerator>, użyj <xref:System.Reflection.Emit.ConstructorBuilder.GetILGenerator%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A?displayProperty=nameWithType>, i <xref:System.Reflection.Emit.MethodBuilder.GetILGenerator%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="1989c-103">To obtain an <xref:System.Reflection.Emit.ILGenerator>, use the <xref:System.Reflection.Emit.ConstructorBuilder.GetILGenerator%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Emit.MethodBuilder.GetILGenerator%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="1989c-104">MSIL jest używane jako dane wejściowe kompilatora just-in-time (JIT).</span><span class="sxs-lookup"><span data-stu-id="1989c-104">MSIL is used as input to a just-in-time (JIT) compiler.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BeginCatchBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginCatchBlock (Type exceptionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginCatchBlock(class System.Type exceptionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginCatchBlock(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginCatchBlock (exceptionType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginCatchBlock(Type ^ exceptionType);" />
      <MemberSignature Language="F#" Value="abstract member BeginCatchBlock : Type -&gt; unit&#xA;override this.BeginCatchBlock : Type -&gt; unit" Usage="iLGenerator.BeginCatchBlock exceptionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptionType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="exceptionType">
          <span data-ttu-id="1989c-105">
            <see cref="T:System.Type" /> Obiekt, który reprezentuje wyjątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-105">The <see cref="T:System.Type" /> object that represents the exception.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-106">Rozpoczyna się bloku catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-106">Begins a catch block.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-107">Emituje instrukcji rozgałęzienia, do końca bieżącego bloku wyjątków.</span><span class="sxs-lookup"><span data-stu-id="1989c-107">Emits a branch instruction to the end of the current exception block.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1989c-108">Jeśli zwróci bloku filtru wyjątków `constant exception_execute_handler` (zobacz dokumentację wspólnej infrastruktury instrukcji ustawiony język), argument `BeginCatchBlock` nie jest zaznaczone.</span><span class="sxs-lookup"><span data-stu-id="1989c-108">If the filter exception block returns the `constant exception_execute_handler` (see the documentation for the Common Language Infrastructure Instruction Set), the argument to the `BeginCatchBlock` is not checked.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-109">Poniższy przykład kodu pokazuje użycie kontekstowe `BeginCatchBlock` metody.</span><span class="sxs-lookup"><span data-stu-id="1989c-109">The code sample below demonstrates the contextual usage of the `BeginCatchBlock` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1989c-110">Blok catch mieści się filtrowane wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-110">The catch block is within a filtered exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-111">
            <paramref name="exceptionType" /> jest <see langword="null" />, a nie zwróci wartość, która wskazuje, że koniec bloki powinien być wykonywany do momentu znajduje się ten blok catch bloku filtru wyjątków.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-111">
              <paramref name="exceptionType" /> is <see langword="null" />, and the exception filter block has not returned a value that indicates that finally blocks should be run until this catch block is located.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="1989c-112">Język pośredni firmy Microsoft (MSIL) generowany nie jest aktualnie poza blokiem wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-112">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptFilterBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginExceptFilterBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginExceptFilterBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptFilterBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginExceptFilterBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginExceptFilterBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginExceptFilterBlock : unit -&gt; unit&#xA;override this.BeginExceptFilterBlock : unit -&gt; unit" Usage="iLGenerator.BeginExceptFilterBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1989c-113">Rozpoczyna się bloku wyjątków filtrowanych wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-113">Begins an exception block for a filtered exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-114">Emituje instrukcji rozgałęzienia, do końca bieżącego bloku wyjątków.</span><span class="sxs-lookup"><span data-stu-id="1989c-114">Emits a branch instruction to the end of the current exception block.</span></span>  
  
 <span data-ttu-id="1989c-115">Jeśli bieżący <xref:System.Reflection.Emit.ILGenerator> jest skojarzony z <xref:System.Reflection.Emit.DynamicMethod> obiekt emitowanie Bloki wyjątków filtrowanych nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="1989c-115">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, emitting filtered exception blocks is not supported.</span></span> <span data-ttu-id="1989c-116"><xref:System.Reflection.Emit.DynamicILInfo> może służyć do tworzenia dynamicznych metody, że używa filtrowane Bloki wyjątków.</span><span class="sxs-lookup"><span data-stu-id="1989c-116"><xref:System.Reflection.Emit.DynamicILInfo> can be used to construct a dynamic method that uses filtered exception blocks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="1989c-117">Język pośredni firmy Microsoft (MSIL) generowany nie jest aktualnie poza blokiem wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-117">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</span>
          </span>
          <span data-ttu-id="1989c-118">- lub - to <see cref="T:System.Reflection.Emit.ILGenerator" /> należy <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-118">-or-  This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label BeginExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label BeginExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginExceptionBlock () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label BeginExceptionBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginExceptionBlock : unit -&gt; System.Reflection.Emit.Label&#xA;override this.BeginExceptionBlock : unit -&gt; System.Reflection.Emit.Label" Usage="iLGenerator.BeginExceptionBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1989c-119">Rozpoczyna się bloku wyjątków dla wyjątku nie są filtrowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-119">Begins an exception block for a non-filtered exception.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1989c-120">Etykieta dla końca bloku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-120">The label for the end of the block.</span>
          </span>
          <span data-ttu-id="1989c-121">Spowoduje to pozostawienie w odpowiednie miejsce do wykonywanie bloki instrukcji finally lub Zakończ try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-121">This will leave you in the correct place to execute finally blocks or to finish the try.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-122">Tworzenie bloku wyjątków rejestruje informacje o niektórych, ale faktycznie nie Emituj żadnych Microsoft język pośredni (MSIL) do strumienia.</span><span class="sxs-lookup"><span data-stu-id="1989c-122">Creating an exception block records some information, but does not actually emit any Microsoft intermediate language (MSIL) onto the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-123">Poniższy przykład kodu pokazuje użycie kontekstowe `BeginExceptionBlock` metody.</span><span class="sxs-lookup"><span data-stu-id="1989c-123">The code sample below demonstrates the contextual usage of the `BeginExceptionBlock` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFaultBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFaultBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFaultBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFaultBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFaultBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFaultBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginFaultBlock : unit -&gt; unit&#xA;override this.BeginFaultBlock : unit -&gt; unit" Usage="iLGenerator.BeginFaultBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1989c-124">Rozpoczyna się bloku wyjątków błędów w strumieniu język pośredni (MSIL) firmy Microsoft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-124">Begins an exception fault block in the Microsoft intermediate language (MSIL) stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-125">Jeśli bieżący <xref:System.Reflection.Emit.ILGenerator> jest skojarzony z <xref:System.Reflection.Emit.DynamicMethod> obiekt emitowanie Bloki wyjątków błędów nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="1989c-125">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, emitting exception fault blocks is not supported.</span></span> <span data-ttu-id="1989c-126"><xref:System.Reflection.Emit.DynamicILInfo> może służyć do tworzenia dynamicznych metody, która używa Bloki wyjątków błędów.</span><span class="sxs-lookup"><span data-stu-id="1989c-126"><xref:System.Reflection.Emit.DynamicILInfo> can be used to construct a dynamic method that uses exception fault blocks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-127">Poniższy przykładowy kod przedstawia użycie `BeginFaultBlock`.</span><span class="sxs-lookup"><span data-stu-id="1989c-127">The following code sample illustrates the use of `BeginFaultBlock`.</span></span>  
  
 [!code-cpp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CPP/ilgenerator_beginfaultblock.cpp#1)]
 [!code-csharp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CS/ilgenerator_beginfaultblock.cs#1)]
 [!code-vb[ILGenerator_BeginFaultBlock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/VB/ilgenerator_beginfaultblock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="1989c-128">MSIL generowaną nie jest aktualnie poza blokiem wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-128">The MSIL being generated is not currently in an exception block.</span>
          </span>
          <span data-ttu-id="1989c-129">- lub - to <see cref="T:System.Reflection.Emit.ILGenerator" /> należy <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-129">-or-  This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFinallyBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFinallyBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFinallyBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFinallyBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFinallyBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFinallyBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginFinallyBlock : unit -&gt; unit&#xA;override this.BeginFinallyBlock : unit -&gt; unit" Usage="iLGenerator.BeginFinallyBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1989c-130">Rozpoczyna się bloku finally w strumieniu instrukcji języka pośredniego (MSIL) firmy Microsoft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-130">Begins a finally block in the Microsoft intermediate language (MSIL) instruction stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1989c-131">Poniższy przykładowy kod przedstawia użycie `BeginFinallyBlock`.</span><span class="sxs-lookup"><span data-stu-id="1989c-131">The following code sample illustrates the use of `BeginFinallyBlock`.</span></span>  
  
 [!code-cpp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CPP/ILGenerator_BeginFinallyBlock_2.cpp#2)]
 [!code-csharp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CS/ilgenerator_beginfinallyblock_2.cs#2)]
 [!code-vb[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/VB/ilgenerator_beginfinallyblock_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="1989c-132">MSIL generowaną nie jest aktualnie poza blokiem wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-132">The MSIL being generated is not currently in an exception block.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginScope">
      <MemberSignature Language="C#" Value="public virtual void BeginScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginScope();" />
      <MemberSignature Language="F#" Value="abstract member BeginScope : unit -&gt; unit&#xA;override this.BeginScope : unit -&gt; unit" Usage="iLGenerator.BeginScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1989c-133">Rozpoczyna się leksykalne zakresu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-133">Begins a lexical scope.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-134">Ta metoda służy do wysyłania symboliczne informacje.</span><span class="sxs-lookup"><span data-stu-id="1989c-134">This method is used to emit symbolic information.</span></span> <span data-ttu-id="1989c-135">Zmienna lokalna zadeklarowana po <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A> ograniczone do odpowiadającego <xref:System.Reflection.Emit.ILGenerator.EndScope%2A> jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="1989c-135">Local variables declared after <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A> are scoped until the corresponding <xref:System.Reflection.Emit.ILGenerator.EndScope%2A> is called.</span></span>  
  
 <span data-ttu-id="1989c-136">Jeśli bieżący <xref:System.Reflection.Emit.ILGenerator> jest skojarzony z <xref:System.Reflection.Emit.DynamicMethod> obiektu, nie obsługuje symboliczne informacje.</span><span class="sxs-lookup"><span data-stu-id="1989c-136">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, it does not support symbolic information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-137">Poniższy przykładowy kod przedstawia użycie `BeginScope` i `EndScope`.</span><span class="sxs-lookup"><span data-stu-id="1989c-137">The following code sample illustrates the use of `BeginScope` and `EndScope`.</span></span>  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="1989c-138">To <see cref="T:System.Reflection.Emit.ILGenerator" /> należy <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-138">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeclareLocal">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1989c-139">Deklaruje zmienną lokalną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-139">Declares a local variable.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type) As LocalBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType);" />
      <MemberSignature Language="F#" Value="abstract member DeclareLocal : Type -&gt; System.Reflection.Emit.LocalBuilder&#xA;override this.DeclareLocal : Type -&gt; System.Reflection.Emit.LocalBuilder" Usage="iLGenerator.DeclareLocal localType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="localType">
          <span data-ttu-id="1989c-140">A <see cref="T:System.Type" /> obiekt, który reprezentuje typ zmiennej lokalnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-140">A <see cref="T:System.Type" /> object that represents the type of the local variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-141">Deklaruje zmienną lokalną określonego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-141">Declares a local variable of the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1989c-142">Zmienna lokalna zadeklarowana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-142">The declared local variable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-143">Zmienna lokalna jest tworzony w bieżącym zakresie leksykalne; na przykład, jeśli kod jest są emitowane w `for` pętli (`For` pętli w języku Visual Basic), zakres zmiennej jest pętli.</span><span class="sxs-lookup"><span data-stu-id="1989c-143">The local variable is created in the current lexical scope; for example, if code is being emitted in a `for` loop (`For` loop in Visual Basic), the scope of the variable is the loop.</span></span>  
  
 <span data-ttu-id="1989c-144">Zmienna lokalna utworzone za pomocą tego przeciążenia nie jest unieruchomiony.</span><span class="sxs-lookup"><span data-stu-id="1989c-144">A local variable created with this overload is not pinned.</span></span> <span data-ttu-id="1989c-145">Aby utworzyć zmienną przypięty do użycia za pomocą niezarządzanych wskaźników, użyj <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%28System.Type%2CSystem.Boolean%29> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="1989c-145">To create a pinned variable for use with unmanaged pointers, use the <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%28System.Type%2CSystem.Boolean%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-146">Poniższy przykład kodu pokazuje użycie `DeclareLocal` metody.</span><span class="sxs-lookup"><span data-stu-id="1989c-146">The following code example demonstrates the use of the `DeclareLocal` method.</span></span> <span data-ttu-id="1989c-147">Ten kod jest częścią większego przykładu kodu dla <xref:System.Reflection.Emit.LocalBuilder> klasy.</span><span class="sxs-lookup"><span data-stu-id="1989c-147">This code is part of a larger code example for the <xref:System.Reflection.Emit.LocalBuilder> class.</span></span>  
  
 [!code-cpp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/cpp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CPP/localbuilder_sample_4.cpp#2)]
 [!code-csharp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/csharp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CS/localbuilder_sample_4.cs#2)]
 [!code-vb[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/VB/localbuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-148">
            <paramref name="localType" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-148">
              <paramref name="localType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1989c-149">Typ zawierający został utworzony przez <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-149">The containing type has been created by the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type, pinned As Boolean) As LocalBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType, bool pinned);" />
      <MemberSignature Language="F#" Value="abstract member DeclareLocal : Type * bool -&gt; System.Reflection.Emit.LocalBuilder&#xA;override this.DeclareLocal : Type * bool -&gt; System.Reflection.Emit.LocalBuilder" Usage="iLGenerator.DeclareLocal (localType, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" />
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="localType">
          <span data-ttu-id="1989c-150">A <see cref="T:System.Type" /> obiekt, który reprezentuje typ zmiennej lokalnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-150">A <see cref="T:System.Type" /> object that represents the type of the local variable.</span>
          </span>
        </param>
        <param name="pinned">
          <span data-ttu-id="1989c-151">
            <see langword="true" /> Aby przypiąć obiektu w pamięci. w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-151">
              <see langword="true" /> to pin the object in memory; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-152">Deklaruje zmienną lokalną określonego typu, opcjonalnie przypinanie obiekt odwołuje się do zmiennej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-152">Declares a local variable of the specified type, optionally pinning the object referred to by the variable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1989c-153">A <see cref="T:System.Reflection.Emit.LocalBuilder" /> obiekt, który reprezentuje zmiennej lokalnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-153">A <see cref="T:System.Reflection.Emit.LocalBuilder" /> object that represents the local variable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-154">Zmienna lokalna jest tworzony w bieżącym zakresie leksykalne; na przykład, jeśli kod jest są emitowane w `for` pętli (`For` pętli w języku Visual Basic), zakres zmiennej jest pętli.</span><span class="sxs-lookup"><span data-stu-id="1989c-154">The local variable is created in the current lexical scope; for example, if code is being emitted in a `for` loop (`For` loop in Visual Basic), the scope of the variable is the loop.</span></span>  
  
 <span data-ttu-id="1989c-155">Niebezpieczny kod obiektu musi przypięty, przed jego można odwołać się do niezarządzanego wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="1989c-155">In unsafe code, an object must be pinned before it can be referred to by an unmanaged pointer.</span></span> <span data-ttu-id="1989c-156">Przypięciu przywoływanego obiektu nie można przenieść za wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="1989c-156">While the referenced object is pinned, it cannot be moved by garbage collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-157">
            <paramref name="localType" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-157">
              <paramref name="localType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1989c-158">Typ zawierający został utworzony przez <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-158">The containing type has been created by the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
          <span data-ttu-id="1989c-159">- lub - treści metody otaczającej metody została utworzona przez <see cref="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" /> metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-159">-or-  The method body of the enclosing method has been created by the <see cref="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="1989c-160">Metoda, z której ta <see cref="T:System.Reflection.Emit.ILGenerator" /> skojarzonego nie jest reprezentowany przez <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-160">The method with which this <see cref="T:System.Reflection.Emit.ILGenerator" /> is associated is not represented by a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineLabel">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label DefineLabel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label DefineLabel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DefineLabel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DefineLabel () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label DefineLabel();" />
      <MemberSignature Language="F#" Value="abstract member DefineLabel : unit -&gt; System.Reflection.Emit.Label&#xA;override this.DefineLabel : unit -&gt; System.Reflection.Emit.Label" Usage="iLGenerator.DefineLabel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1989c-161">Deklaruje nowej etykiety.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-161">Declares a new label.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1989c-162">Zwraca nową etykietę, który może służyć jako token dla rozgałęziania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-162">Returns a new label that can be used as a token for branching.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-163">Aby ustawić położenie etykiety w strumieniu, należy wywołać <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span><span class="sxs-lookup"><span data-stu-id="1989c-163">To set the position of the label within the stream, you must call <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span></span>  
  
 <span data-ttu-id="1989c-164">To jest tylko token i jeszcze nie reprezentuje dowolnej lokalizacji określonej w strumieniu.</span><span class="sxs-lookup"><span data-stu-id="1989c-164">This is just a token and does not yet represent any particular location within the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-165">Poniższy przykład kodu pokazuje użycie kontekstowe `DefineLabel` metody.</span><span class="sxs-lookup"><span data-stu-id="1989c-165">The code sample below demonstrates the contextual usage of the `DefineLabel` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.Label Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.Label Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.Label Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Emit">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1989c-166">Umieszcza instrukcje na strumieniu Microsoft języka pośredniego (MSIL) przy użyciu kompilatora just in time (JIT).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-166">Puts an instruction onto the Microsoft Intermediate Language (MSIL) stream for the just-in-time (JIT) compiler.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode -&gt; unit" Usage="iLGenerator.Emit opcode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-167">Instrukcja Microsoft języka pośredniego (MSIL) należy umieścić na strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-167">The Microsoft Intermediate Language (MSIL) instruction to be put onto the stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-168">Umieszcza określonej instrukcji do strumienia instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-168">Puts the specified instruction onto the stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-169">Jeśli `opcode` parametru wymaga argumentu, wywołująca musi zapewnić, że długość argumentu odpowiada długości zadeklarowany parametr.</span><span class="sxs-lookup"><span data-stu-id="1989c-169">If the `opcode` parameter requires an argument, the caller must ensure that the argument length matches the length of the declared parameter.</span></span> <span data-ttu-id="1989c-170">W przeciwnym razie będą nieprzewidywalne wyniki.</span><span class="sxs-lookup"><span data-stu-id="1989c-170">Otherwise, results will be unpredictable.</span></span> <span data-ttu-id="1989c-171">Na przykład instrukcja emitowanie wymaga argumentu 2-bajtowych, wywołujący zapewnia operand 4-bajtowych środowiska uruchomieniowego Emituj dwa dodatkowe bajty w strumieniu instrukcji.</span><span class="sxs-lookup"><span data-stu-id="1989c-171">For example, if the Emit instruction requires a 2-byte operand and the caller supplies a 4-byte operand, the runtime will emit two additional bytes to the instruction stream.</span></span> <span data-ttu-id="1989c-172">Te dodatkowe bajty będzie <xref:System.Reflection.Emit.OpCodes.Nop> instrukcje.</span><span class="sxs-lookup"><span data-stu-id="1989c-172">These extra bytes will be <xref:System.Reflection.Emit.OpCodes.Nop> instructions.</span></span>  
  
 <span data-ttu-id="1989c-173">Wartości instrukcji są zdefiniowane w <xref:System.Reflection.Emit.OpCodes>.</span><span class="sxs-lookup"><span data-stu-id="1989c-173">The instruction values are defined in <xref:System.Reflection.Emit.OpCodes>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-174">Poniższy przykład kodu pokazuje użycie `Emit` do generowania danych wyjściowych MSIL za pomocą wystąpienia <xref:System.Reflection.Emit.ILGenerator>.</span><span class="sxs-lookup"><span data-stu-id="1989c-174">The code sample below demonstrates the use of `Emit` to generate MSIL output via an instance of <xref:System.Reflection.Emit.ILGenerator>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, byte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, unsigned int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Byte arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * byte -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * byte -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-175">Instrukcja MSIL, które należy umieścić na strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-175">The MSIL instruction to be put onto the stream.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="1989c-176">Argument znaków przypisany do strumienia bezpośrednio po instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-176">The character argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-177">Umieszcza określonej instrukcji i argument znaków do strumienia język pośredni (MSIL) firmy Microsoft w instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-177">Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-178">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-178">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, double arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, double arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * double -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * double -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-179">Instrukcja MSIL, które należy umieścić na strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-179">The MSIL instruction to be put onto the stream.</span>
          </span>
          <span data-ttu-id="1989c-180">Zdefiniowane w <see langword="OpCodes" /> wyliczenia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-180">Defined in the <see langword="OpCodes" /> enumeration.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="1989c-181">Argument numeryczny przypisany do strumienia bezpośrednio po instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-181">The numerical argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-182">Umieszcza określonej instrukcji i argument numeryczny do strumienia język pośredni (MSIL) firmy Microsoft w instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-182">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-183">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-183">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, short arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int16 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int16)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, short arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * int16 -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * int16 -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-184">Instrukcja MSIL emitowany do strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-184">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="1989c-185">
            <see langword="Int" /> Argument przypisany do strumienia bezpośrednio po instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-185">The <see langword="Int" /> argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-186">Umieszcza określonej instrukcji i argument numeryczny do strumienia język pośredni (MSIL) firmy Microsoft w instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-186">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-187">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-187">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, int arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, int arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * int -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * int -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-188">Instrukcja MSIL, które należy umieścić na strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-188">The MSIL instruction to be put onto the stream.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="1989c-189">Argument numeryczny przypisany do strumienia bezpośrednio po instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-189">The numerical argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-190">Umieszcza określonej instrukcji i argument numeryczny do strumienia język pośredni (MSIL) firmy Microsoft w instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-190">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-191">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-191">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, long arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, long arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * int64 -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * int64 -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-192">Instrukcja MSIL, które należy umieścić na strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-192">The MSIL instruction to be put onto the stream.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="1989c-193">Argument numeryczny przypisany do strumienia bezpośrednio po instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-193">The numerical argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-194">Umieszcza określonej instrukcji i argument numeryczny do strumienia język pośredni (MSIL) firmy Microsoft w instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-194">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-195">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-195">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.ConstructorInfo con);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.ConstructorInfo con) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::ConstructorInfo ^ con);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.ConstructorInfo -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.ConstructorInfo -&gt; unit" Usage="iLGenerator.Emit (opcode, con)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-196">Instrukcja MSIL emitowany do strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-196">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="con">
          <span data-ttu-id="1989c-197">A <see langword="ConstructorInfo" /> reprezentujący konstruktora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-197">A <see langword="ConstructorInfo" /> representing a constructor.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-198">Umieszcza określonej instrukcji i token metadanych dla określonego konstruktora do strumienia język pośredni (MSIL) firmy Microsoft w instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-198">Puts the specified instruction and metadata token for the specified constructor onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-199">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-199">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="1989c-200">Lokalizacja `con` jest rejestrowany, dzięki czemu strumienia instrukcji można serwisować w razie potrzeby po trwałym modułu w pliku przenośny plik wykonywalny (PE).</span><span class="sxs-lookup"><span data-stu-id="1989c-200">The location of `con` is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-201">
            <paramref name="con" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-201">
              <paramref name="con" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="1989c-202">Ten wyjątek jest nowego w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-202">This exception is new in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::Label label);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label -&gt; unit" Usage="iLGenerator.Emit (opcode, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="label" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-203">Instrukcja MSIL emitowany do strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-203">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="label">
          <span data-ttu-id="1989c-204">Etykieta do gałęzi z tej lokalizacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-204">The label to which to branch from this location.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-205">Przełącza określony instrukcji do strumienia język pośredni (MSIL) firmy Microsoft i pozostawia miejsca do uwzględnienia etykietę, gdy gotowe poprawki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-205">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-206">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-206">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="1989c-207">Etykiety są tworzone przy użyciu <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>, i ich lokalizacji w strumieniu zostanie rozwiązany przy użyciu <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span><span class="sxs-lookup"><span data-stu-id="1989c-207">Labels are created using <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>, and their location within the stream is fixed by using <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span></span> <span data-ttu-id="1989c-208">Użycie instrukcji jednobajtowe etykieta może reprezentować skoku maksymalnie 127 bajtów wzdłuż strumienia.</span><span class="sxs-lookup"><span data-stu-id="1989c-208">If a single-byte instruction is used, the label can represent a jump of at most 127 bytes along the stream.</span></span> <span data-ttu-id="1989c-209">`opcode` musi reprezentować instrukcji rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="1989c-209">`opcode` must represent a branch instruction.</span></span> <span data-ttu-id="1989c-210">Ponieważ gałęzie względną instrukcje `label` zostaną zastąpione podczas procesu naprawy prawidłowe przesunięcie do gałęzi.</span><span class="sxs-lookup"><span data-stu-id="1989c-210">Because branches are relative instructions, `label` will be replaced with the correct offset to branch during the fixup process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-211">Poniższy przykładowy kod przedstawia tworzenie metodę dynamicznych z tabelą przeskoku.</span><span class="sxs-lookup"><span data-stu-id="1989c-211">The code sample below illustrates the creation of a dynamic method with a jump table.</span></span> <span data-ttu-id="1989c-212">W tabeli skoku jest utworzony przy użyciu tablicy <xref:System.Reflection.Emit.Label>.</span><span class="sxs-lookup"><span data-stu-id="1989c-212">The jump table is built using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label[] labels);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label[] labels) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, cli::array &lt;System::Reflection::Emit::Label&gt; ^ labels);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label[] -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label[] -&gt; unit" Usage="iLGenerator.Emit (opcode, labels)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="labels" Type="System.Reflection.Emit.Label[]" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-213">Instrukcja MSIL emitowany do strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-213">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="labels">
          <span data-ttu-id="1989c-214">Tablica obiektów etykiety, do którego ma zostać gałąź z tej lokalizacji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-214">The array of label objects to which to branch from this location.</span>
          </span>
          <span data-ttu-id="1989c-215">Wszystkich etykiet będą używane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-215">All of the labels will be used.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-216">Przełącza określony instrukcji do strumienia język pośredni (MSIL) firmy Microsoft i pozostawia miejsca do uwzględnienia etykietę, gdy gotowe poprawki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-216">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-217">Emituje tabeli przełącznika.</span><span class="sxs-lookup"><span data-stu-id="1989c-217">Emits a switch table.</span></span>  
  
 <span data-ttu-id="1989c-218">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-218">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="1989c-219">Etykiety są tworzone przy użyciu <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> i ich lokalizacji w strumieniu zostanie rozwiązany przy użyciu <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span><span class="sxs-lookup"><span data-stu-id="1989c-219">Labels are created using <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> and their location within the stream is fixed by using <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span></span> <span data-ttu-id="1989c-220">Użycie instrukcji jednobajtowe etykieta może reprezentować skoku maksymalnie 127 bajtów wzdłuż strumienia.</span><span class="sxs-lookup"><span data-stu-id="1989c-220">If a single-byte instruction is used, the label can represent a jump of at most 127 bytes along the stream.</span></span> <span data-ttu-id="1989c-221">`opcode` musi reprezentować instrukcji rozgałęzienia.</span><span class="sxs-lookup"><span data-stu-id="1989c-221">`opcode` must represent a branch instruction.</span></span> <span data-ttu-id="1989c-222">Ponieważ gałęzie względną instrukcje `label` zostaną zastąpione podczas procesu naprawy prawidłowe przesunięcie do gałęzi.</span><span class="sxs-lookup"><span data-stu-id="1989c-222">Because branches are relative instructions, `label` will be replaced with the correct offset to branch during the fixup process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-223">Poniższy przykładowy kod przedstawia tworzenie metodę dynamicznych z tabelą przeskoku.</span><span class="sxs-lookup"><span data-stu-id="1989c-223">The code sample below illustrates the creation of a dynamic method with a jump table.</span></span> <span data-ttu-id="1989c-224">W tabeli skoku jest utworzony przy użyciu tablicy <xref:System.Reflection.Emit.Label>.</span><span class="sxs-lookup"><span data-stu-id="1989c-224">The jump table is built using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-225">
            <paramref name="con" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-225">
              <paramref name="con" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="1989c-226">Ten wyjątek jest nowego w [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-226">This exception is new in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.LocalBuilder local);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.LocalBuilder local) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::LocalBuilder ^ local);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.LocalBuilder -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.LocalBuilder -&gt; unit" Usage="iLGenerator.Emit (opcode, local)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="local" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-227">Instrukcja MSIL emitowany do strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-227">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="local">
          <span data-ttu-id="1989c-228">Zmienna lokalna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-228">A local variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-229">Zapisuje określony instrukcji na Microsoft strumienia język pośredni (MSIL) następuje indeks danego zmiennej lokalnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-229">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the index of the given local variable.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-230">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-230">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1989c-231">Metoda nadrzędnej <paramref name="local" /> parametru jest niezgodny z metody skojarzony z tym <see cref="T:System.Reflection.Emit.ILGenerator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-231">The parent method of the <paramref name="local" /> parameter does not match the method associated with this <see cref="T:System.Reflection.Emit.ILGenerator" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-232">
            <paramref name="local" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-232">
              <paramref name="local" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1989c-233">
            <paramref name="opcode" /> jest instrukcją jednobajtowe i <paramref name="local" /> reprezentuje zmiennej lokalnej o indeks jest większy niż <see langword="Byte.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-233">
              <paramref name="opcode" /> is a single-byte instruction, and <paramref name="local" /> represents a local variable with an index greater than <see langword="Byte.MaxValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.SignatureHelper signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.SignatureHelper signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::SignatureHelper ^ signature);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.SignatureHelper -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.SignatureHelper -&gt; unit" Usage="iLGenerator.Emit (opcode, signature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="signature" Type="System.Reflection.Emit.SignatureHelper" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-234">Instrukcja MSIL emitowany do strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-234">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="signature">
          <span data-ttu-id="1989c-235">Obiekt pomocnika dla tworzenia token podpisu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-235">A helper for constructing a signature token.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-236">Umieszcza określonej instrukcji i token podpisu do strumienia język pośredni (MSIL) firmy Microsoft w instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-236">Puts the specified instruction and a signature token onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-237">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-237">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-238">
            <paramref name="signature" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-238">
              <paramref name="signature" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.FieldInfo -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.FieldInfo -&gt; unit" Usage="iLGenerator.Emit (opcode, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-239">Instrukcja MSIL emitowany do strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-239">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="field">
          <span data-ttu-id="1989c-240">A <see langword="FieldInfo" /> reprezentujących pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-240">A <see langword="FieldInfo" /> representing a field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-241">Umieszcza określonej instrukcji i token metadanych dla określonego pola do strumienia język pośredni (MSIL) firmy Microsoft w instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-241">Puts the specified instruction and metadata token for the specified field onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-242">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-242">The instruction values are defined in the `OpCodes` enumeration.</span></span> <span data-ttu-id="1989c-243">Lokalizacja `field` jest rejestrowany, dzięki czemu strumienia instrukcji można serwisować w razie potrzeby po trwałym modułu w pliku przenośny plik wykonywalny (PE).</span><span class="sxs-lookup"><span data-stu-id="1989c-243">The location of `field` is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo meth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo meth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ meth);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo -&gt; unit" Usage="iLGenerator.Emit (opcode, meth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="meth" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-244">Instrukcja MSIL emitowany do strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-244">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="meth">
          <span data-ttu-id="1989c-245">A <see langword="MethodInfo" /> reprezentujący metodę.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-245">A <see langword="MethodInfo" /> representing a method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-246">Zapisuje określony instrukcji na Microsoft strumienia język pośredni (MSIL), a następnie token metadanych dla podanej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-246">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-247">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-247">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="1989c-248">Lokalizacja `meth` jest rejestrowany, dzięki czemu strumienia instrukcji można serwisować w razie potrzeby po trwałym modułu w pliku przenośny plik wykonywalny (PE).</span><span class="sxs-lookup"><span data-stu-id="1989c-248">The location of `meth` is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 <span data-ttu-id="1989c-249">Jeśli `meth` reprezentuje metody ogólnej, musi być definicję metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="1989c-249">If `meth` represents a generic method, it must be a generic method definition.</span></span> <span data-ttu-id="1989c-250">Oznacza to, że jego [MethodInfo.IsGenericMethodDefinition](xref:System.Reflection.MethodBase.IsGenericMethodDefinition) właściwość musi być `true`.</span><span class="sxs-lookup"><span data-stu-id="1989c-250">That is, its [MethodInfo.IsGenericMethodDefinition](xref:System.Reflection.MethodBase.IsGenericMethodDefinition) property must be `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-251">
            <paramref name="meth" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-251">
              <paramref name="meth" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="1989c-252">
            <paramref name="meth" /> jest to metoda ogólna, dla którego <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-252">
              <paramref name="meth" /> is a generic method for which the <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public void Emit (System.Reflection.Emit.OpCode opcode, sbyte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Emit(System::Reflection::Emit::OpCode opcode, System::SByte arg);" />
      <MemberSignature Language="F#" Value="member this.Emit : System.Reflection.Emit.OpCode * sbyte -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-253">Instrukcja MSIL, które należy umieścić na strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-253">The MSIL instruction to be put onto the stream.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="1989c-254">Argument znaków przypisany do strumienia bezpośrednio po instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-254">The character argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-255">Umieszcza określonej instrukcji i argument znaków do strumienia język pośredni (MSIL) firmy Microsoft w instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-255">Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-256">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-256">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, float arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, float arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * single -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * single -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-257">Instrukcja MSIL, które należy umieścić na strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-257">The MSIL instruction to be put onto the stream.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="1989c-258">
            <see langword="Single" /> Argument przypisany do strumienia bezpośrednio po instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-258">The <see langword="Single" /> argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-259">Umieszcza określonej instrukcji i argument numeryczny do strumienia język pośredni (MSIL) firmy Microsoft w instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-259">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-260">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-260">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::String ^ str);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * string -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * string -&gt; unit" Usage="iLGenerator.Emit (opcode, str)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-261">Instrukcja MSIL emitowany do strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-261">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="str">
          <span data-ttu-id="1989c-262">
            <see langword="String" /> Być emitowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-262">The <see langword="String" /> to be emitted.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-263">Zapisuje określony instrukcji na Microsoft strumienia język pośredni (MSIL), a następnie token metadanych dla podanego ciągu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-263">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given string.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-264">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-264">The instruction values are defined in the `OpCodes` enumeration.</span></span> <span data-ttu-id="1989c-265">Lokalizacja `str` jest zarejestrowane dla przyszłych korekt, jeśli moduł jest utrwalona w pliku przenośny plik wykonywalny (PE).</span><span class="sxs-lookup"><span data-stu-id="1989c-265">The location of `str` is recorded for future fixups if the module is persisted to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, Type cls);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Type cls) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, Type ^ cls);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * Type -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * Type -&gt; unit" Usage="iLGenerator.Emit (opcode, cls)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="cls" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-266">Instrukcja MSIL, które należy umieścić na strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-266">The MSIL instruction to be put onto the stream.</span>
          </span>
        </param>
        <param name="cls">
          <span data-ttu-id="1989c-267">A <see langword="Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-267">A <see langword="Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-268">Zapisuje określony instrukcji na Microsoft strumienia język pośredni (MSIL), a następnie token metadanych dla danego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-268">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-269">Wartości instrukcji są zdefiniowane w `OpCodes` wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="1989c-269">The instruction values are defined in the `OpCodes` enumeration.</span></span> <span data-ttu-id="1989c-270">Lokalizacja `cls` jest rejestrowany, dzięki czemu tokenu można serwisować w razie potrzeby po trwałym modułu w pliku przenośny plik wykonywalny (PE).</span><span class="sxs-lookup"><span data-stu-id="1989c-270">The location of `cls` is recorded so that the token can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-271">
            <paramref name="cls" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-271">
              <paramref name="cls" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EmitCall">
      <MemberSignature Language="C#" Value="public virtual void EmitCall (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo methodInfo, Type[] optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCall(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo methodInfo, class System.Type[] optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCall(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ methodInfo, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberSignature Language="F#" Value="abstract member EmitCall : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo * Type[] -&gt; unit&#xA;override this.EmitCall : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo * Type[] -&gt; unit" Usage="iLGenerator.EmitCall (opcode, methodInfo, optionalParameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-272">Instrukcja MSIL emitowany do strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-272">The MSIL instruction to be emitted onto the stream.</span>
          </span>
          <span data-ttu-id="1989c-273">Musi być <see cref="F:System.Reflection.Emit.OpCodes.Call" />, <see cref="F:System.Reflection.Emit.OpCodes.Callvirt" />, lub <see cref="F:System.Reflection.Emit.OpCodes.Newobj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-273">Must be <see cref="F:System.Reflection.Emit.OpCodes.Call" />, <see cref="F:System.Reflection.Emit.OpCodes.Callvirt" />, or <see cref="F:System.Reflection.Emit.OpCodes.Newobj" />.</span>
          </span>
        </param>
        <param name="methodInfo">
          <span data-ttu-id="1989c-274">
            <see langword="varargs" /> Wywoływanej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-274">The <see langword="varargs" /> method to be called.</span>
          </span>
        </param>
        <param name="optionalParameterTypes">
          <span data-ttu-id="1989c-275">Typy argumentów opcjonalnych, jeśli metoda jest <see langword="varargs" /> metody; w przeciwnym razie <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-275">The types of the optional arguments if the method is a <see langword="varargs" /> method; otherwise, <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-276">Umieszcza <see langword="call" /> lub <see langword="callvirt" /> instrukcji do strumienia język pośredni (MSIL) firmy Microsoft do wywołania <see langword="varargs" /> metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-276">Puts a <see langword="call" /> or <see langword="callvirt" /> instruction onto the Microsoft intermediate language (MSIL) stream to call a <see langword="varargs" /> method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-277"><xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> Metoda jest używana do wysyłania wywołań `varargs` metody ponieważ nie istnieje żadne przeciążenia <xref:System.Reflection.Emit.ILGenerator.Emit%2A> metodę, która określa typy parametrów zmiennych argumentów.</span><span class="sxs-lookup"><span data-stu-id="1989c-277">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is used to emit calls to `varargs` methods because there is no overload of the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method that specifies the parameter types of the variable arguments.</span></span>  
  
 <span data-ttu-id="1989c-278">Aby emitować wywołania metod, które nie korzystają z <xref:System.Reflection.CallingConventions.VarArgs> konwencji wywoływania, użyj <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="1989c-278">To emit calls to methods that do not use the <xref:System.Reflection.CallingConventions.VarArgs> calling convention, use the <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29> method overload.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="1989c-279">Informacje o wersji</span><span class="sxs-lookup"><span data-stu-id="1989c-279">Version Information</span></span>  
 <span data-ttu-id="1989c-280">Począwszy od programu .NET Framework w wersji 2.0, <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> — metoda nie zgłosić wyjątek, jeśli określono opcjonalny parametr typu dla metody, która nie jest `varargs`.</span><span class="sxs-lookup"><span data-stu-id="1989c-280">Beginning with the .NET Framework version 2.0, the <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method does not throw an exception when optional parameter types are specified for a method that is not `varargs`.</span></span> <span data-ttu-id="1989c-281"><xref:System.InvalidProgramException> jest generowany, gdy jest wykonywane wywołanie.</span><span class="sxs-lookup"><span data-stu-id="1989c-281"><xref:System.InvalidProgramException> is thrown when the call is executed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-282">Poniższy przykład kodu emituje dwie metody `varargs` — metoda i wywołuje metodę `varargs` metody.</span><span class="sxs-lookup"><span data-stu-id="1989c-282">The following code example emits two methods, a `varargs` method and a method that calls the `varargs` method.</span></span> <span data-ttu-id="1989c-283">`EmitCall` Metoda jest używana do Emituj wywołanie `varargs` metody.</span><span class="sxs-lookup"><span data-stu-id="1989c-283">The `EmitCall` method is used to emit the call to the `varargs` method.</span></span>  
  
 [!code-cpp[Emit.ArgIterator#1](~/samples/snippets/cpp/VS_Snippets_CLR/Emit.ArgIterator/cpp/source.cpp#1)]
 [!code-csharp[Emit.ArgIterator#1](~/samples/snippets/csharp/VS_Snippets_CLR/Emit.ArgIterator/cs/source.cs#1)]
 [!code-vb[Emit.ArgIterator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Emit.ArgIterator/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1989c-284">
            <paramref name="opcode" /> nie określono wywołanie metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-284">
              <paramref name="opcode" /> does not specify a method call.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-285">
            <paramref name="methodInfo" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-285">
              <paramref name="methodInfo" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1989c-286">Konwencja wywoływania metody nie jest <see langword="varargs" />, ale podano typy parametrów opcjonalnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-286">The calling convention for the method is not <see langword="varargs" />, but optional parameter types are supplied.</span>
          </span>
          <span data-ttu-id="1989c-287">Wyjątek w wersji systemu .NET Framework 1.0 i 1.1, w kolejnych wersjach, nie wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-287">This exception is thrown in the .NET Framework versions 1.0 and 1.1, In subsequent versions, no exception is thrown.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitCalli">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1989c-288">Umieszcza <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instrukcji do strumienia język pośredni (MSIL) firmy Microsoft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-288">Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Runtime.InteropServices.CallingConvention unmanagedCallConv, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Runtime::InteropServices::CallingConvention unmanagedCallConv, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="abstract member EmitCalli : System.Reflection.Emit.OpCode * System.Runtime.InteropServices.CallingConvention * Type * Type[] -&gt; unit&#xA;override this.EmitCalli : System.Reflection.Emit.OpCode * System.Runtime.InteropServices.CallingConvention * Type * Type[] -&gt; unit" Usage="iLGenerator.EmitCalli (opcode, unmanagedCallConv, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="unmanagedCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-289">Instrukcja MSIL emitowany do strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-289">The MSIL instruction to be emitted onto the stream.</span>
          </span>
          <span data-ttu-id="1989c-290">Musi być <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-290">Must be <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</span>
          </span>
        </param>
        <param name="unmanagedCallConv">
          <span data-ttu-id="1989c-291">Niezarządzana konwencja wywołania do użycia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-291">The unmanaged calling convention to be used.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="1989c-292">
            <see cref="T:System.Type" /> Wyniku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-292">The <see cref="T:System.Type" /> of the result.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="1989c-293">Typy wymaganych argumentów instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-293">The types of the required arguments to the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-294">Umieszcza <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instrukcji do strumienia język pośredni (MSIL) firmy Microsoft, określając niezarządzana konwencja wywołania dla pośredniego wywołania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-294">Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream, specifying an unmanaged calling convention for the indirect call.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-295">Użyj <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> umieścić <xref:System.Reflection.Emit.OpCodes.Calli> instrukcji na strumienia.</span><span class="sxs-lookup"><span data-stu-id="1989c-295">Use <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> to put a <xref:System.Reflection.Emit.OpCodes.Calli> instruction onto the stream.</span></span> <span data-ttu-id="1989c-296">Nie używaj <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.</span><span class="sxs-lookup"><span data-stu-id="1989c-296">Do not use <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-297">W poniższym przykładzie kodu pokazano kontekstowe użycie <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> metodę do wywołania metody typu niezarządzanego zewnętrzny dynamiczne klasy.</span><span class="sxs-lookup"><span data-stu-id="1989c-297">The following code sample demonstrates the contextual usage of the <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> method to call an unmanaged type method external to the dynamic class.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type[] optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberSignature Language="F#" Value="abstract member EmitCalli : System.Reflection.Emit.OpCode * System.Reflection.CallingConventions * Type * Type[] * Type[] -&gt; unit&#xA;override this.EmitCalli : System.Reflection.Emit.OpCode * System.Reflection.CallingConventions * Type * Type[] * Type[] -&gt; unit" Usage="iLGenerator.EmitCalli (opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="1989c-298">Instrukcja MSIL emitowany do strumienia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-298">The MSIL instruction to be emitted onto the stream.</span>
          </span>
          <span data-ttu-id="1989c-299">Musi być <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-299">Must be <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="1989c-300">Konwencja wywoływania zarządzanych do użycia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-300">The managed calling convention to be used.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="1989c-301">
            <see cref="T:System.Type" /> Wyniku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-301">The <see cref="T:System.Type" /> of the result.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="1989c-302">Typy wymaganych argumentów instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-302">The types of the required arguments to the instruction.</span>
          </span>
        </param>
        <param name="optionalParameterTypes">
          <span data-ttu-id="1989c-303">Typy argumentów opcjonalnych dla <see langword="varargs" /> wywołania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-303">The types of the optional arguments for <see langword="varargs" /> calls.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-304">Umieszcza <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instrukcji do strumienia język pośredni (MSIL) firmy Microsoft, określając zarządzanych Konwencja wywoływania dla pośredniego wywołania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-304">Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream, specifying a managed calling convention for the indirect call.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-305">Użyj <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> umieścić <xref:System.Reflection.Emit.OpCodes.Calli> instrukcji na strumienia.</span><span class="sxs-lookup"><span data-stu-id="1989c-305">Use <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> to put a <xref:System.Reflection.Emit.OpCodes.Calli> instruction onto the stream.</span></span> <span data-ttu-id="1989c-306">Nie używaj <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.</span><span class="sxs-lookup"><span data-stu-id="1989c-306">Do not use <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.</span></span>  
  
 <span data-ttu-id="1989c-307">Jeśli `optionalParameterTypes` Określa argumenty opcjonalne `callingConvention` musi zawierać <xref:System.Reflection.CallingConventions.VarArgs?displayProperty=nameWithType> flagi.</span><span class="sxs-lookup"><span data-stu-id="1989c-307">If `optionalParameterTypes` specifies optional arguments, `callingConvention` must include the <xref:System.Reflection.CallingConventions.VarArgs?displayProperty=nameWithType> flag.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1989c-308">
            <paramref name="optionalParameterTypes" /> nie jest <see langword="null" />, ale <paramref name="callingConvention" /> nie obejmuje <see cref="F:System.Reflection.CallingConventions.VarArgs" /> flagi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-308">
              <paramref name="optionalParameterTypes" /> is not <see langword="null" />, but <paramref name="callingConvention" /> does not include the <see cref="F:System.Reflection.CallingConventions.VarArgs" /> flag.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitWriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1989c-309">Emituj wywołanie funkcji pomocnika <see cref="M:System.Console.WriteLine" /> z różnymi typami wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-309">Helper functions to emit a call to <see cref="M:System.Console.WriteLine" /> with different types of values.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.Emit.LocalBuilder localBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.Emit.LocalBuilder localBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::Emit::LocalBuilder ^ localBuilder);" />
      <MemberSignature Language="F#" Value="abstract member EmitWriteLine : System.Reflection.Emit.LocalBuilder -&gt; unit&#xA;override this.EmitWriteLine : System.Reflection.Emit.LocalBuilder -&gt; unit" Usage="iLGenerator.EmitWriteLine localBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localBuilder" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="localBuilder">
          <span data-ttu-id="1989c-310">Zmienna lokalna, którego wartość ma być wyświetlony w konsoli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-310">The local variable whose value is to be written to the console.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-311">Emituje Microsoft język pośredni (MSIL) należy wywołać <see cref="Overload:System.Console.WriteLine" /> z danym zmiennej lokalnej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-311">Emits the Microsoft intermediate language (MSIL) necessary to call <see cref="Overload:System.Console.WriteLine" /> with the given local variable.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-312">Typ `localBuilder` musi odpowiadać typowi parametru przeciążenia <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="1989c-312">The type of `localBuilder` must match the parameter type of an overload of the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-313">Poniższy przykład kodu pokazuje użycie kontekstowe <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> metodę, aby zapisać ciąg do konsoli w metodzie dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="1989c-313">The code sample below demonstrates the contextual usage of the <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> method to write a string to the console in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1989c-314">Typ <paramref name="localBuilder" /> jest <see cref="T:System.Reflection.Emit.TypeBuilder" /> lub <see cref="T:System.Reflection.Emit.EnumBuilder" />, które nie są obsługiwane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-314">The type of <paramref name="localBuilder" /> is <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.EnumBuilder" />, which are not supported.</span>
          </span>
          <span data-ttu-id="1989c-315">nie istnieje żadne przeciążenia - lub - <see cref="Overload:System.Console.WriteLine" /> która akceptuje typ <paramref name="localBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-315">-or-  There is no overload of <see cref="Overload:System.Console.WriteLine" /> that accepts the type of <paramref name="localBuilder" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-316">
            <paramref name="localBuilder" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-316">
              <paramref name="localBuilder" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.FieldInfo fld);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.FieldInfo fld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (fld As FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::FieldInfo ^ fld);" />
      <MemberSignature Language="F#" Value="abstract member EmitWriteLine : System.Reflection.FieldInfo -&gt; unit&#xA;override this.EmitWriteLine : System.Reflection.FieldInfo -&gt; unit" Usage="iLGenerator.EmitWriteLine fld" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fld" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="fld">
          <span data-ttu-id="1989c-317">Pola, którego wartość ma być wyświetlony w konsoli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-317">The field whose value is to be written to the console.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-318">Emituje Microsoft język pośredni (MSIL) należy wywołać <see cref="Overload:System.Console.WriteLine" /> z tego pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-318">Emits the Microsoft intermediate language (MSIL) necessary to call <see cref="Overload:System.Console.WriteLine" /> with the given field.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-319">Typ `fld` musi odpowiadać typowi parametru przeciążenia <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="1989c-319">The type of `fld` must match the parameter type of an overload of the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-320">W poniższym przykładzie kodu pokazano stosowania <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> metodę, aby zapisać ciąg do konsoli w metodzie dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="1989c-320">The following code sample demonstrates the use of the <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> method to write a string to the console in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1989c-321">Nie istnieje żadne przeciążenia <see cref="Overload:System.Console.WriteLine" /> metody odpowiedniej dla typu określonego pola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-321">There is no overload of the <see cref="Overload:System.Console.WriteLine" /> method that accepts the type of the specified field.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-322">
            <paramref name="fld" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-322">
              <paramref name="fld" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="1989c-323">Typ pola jest <see cref="T:System.Reflection.Emit.TypeBuilder" /> lub <see cref="T:System.Reflection.Emit.EnumBuilder" />, które nie są obsługiwane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-323">The type of the field is <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.EnumBuilder" />, which are not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member EmitWriteLine : string -&gt; unit&#xA;override this.EmitWriteLine : string -&gt; unit" Usage="iLGenerator.EmitWriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="1989c-324">Ciąg, który ma być drukowana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-324">The string to be printed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-325">Emituje język pośredni firmy Microsoft (MSIL), aby wywołać <see cref="Overload:System.Console.WriteLine" /> z ciągiem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-325">Emits the Microsoft intermediate language (MSIL) to call <see cref="Overload:System.Console.WriteLine" /> with a string.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-326">Ciąg musi mieć już zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="1989c-326">The string must have already been defined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-327">Poniższy przykład kodu pokazuje użycie kontekstowe `EmitWriteLine` metodę, aby zapisać ciąg do konsoli w metodzie dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="1989c-327">The code sample below demonstrates the contextual usage of the `EmitWriteLine` method to write a string to the console in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual void EndExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndExceptionBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndExceptionBlock();" />
      <MemberSignature Language="F#" Value="abstract member EndExceptionBlock : unit -&gt; unit&#xA;override this.EndExceptionBlock : unit -&gt; unit" Usage="iLGenerator.EndExceptionBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1989c-328">Kończy się blokiem wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-328">Ends an exception block.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1989c-329">Poniższy przykład kodu pokazuje użycie kontekstowe `EndExceptionBlock` metody.</span><span class="sxs-lookup"><span data-stu-id="1989c-329">The code sample below demonstrates the contextual usage of the `EndExceptionBlock` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="1989c-330">Blok końcowy wyjątek występuje w miejscu nieoczekiwany w strumieniu kodu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-330">The end exception block occurs in an unexpected place in the code stream.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="1989c-331">Język pośredni firmy Microsoft (MSIL) generowany nie jest aktualnie poza blokiem wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-331">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndScope">
      <MemberSignature Language="C#" Value="public virtual void EndScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndScope();" />
      <MemberSignature Language="F#" Value="abstract member EndScope : unit -&gt; unit&#xA;override this.EndScope : unit -&gt; unit" Usage="iLGenerator.EndScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1989c-332">Kończy się leksykalne zakresu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-332">Ends a lexical scope.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-333">Ta metoda służy do wysyłania symboliczne informacje.</span><span class="sxs-lookup"><span data-stu-id="1989c-333">This method is used to emit symbolic information.</span></span> <span data-ttu-id="1989c-334">Jest używana z <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A>.</span><span class="sxs-lookup"><span data-stu-id="1989c-334">It is used with <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A>.</span></span>  
  
 <span data-ttu-id="1989c-335">Jeśli bieżący <xref:System.Reflection.Emit.ILGenerator> jest skojarzony z <xref:System.Reflection.Emit.DynamicMethod> obiektu, nie obsługuje symboliczne informacje.</span><span class="sxs-lookup"><span data-stu-id="1989c-335">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, it does not support symbolic information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-336">Poniższy przykładowy kod przedstawia użycie `BeginScope` i `EndScope`.</span><span class="sxs-lookup"><span data-stu-id="1989c-336">The following code sample illustrates the use of `BeginScope` and `EndScope`.</span></span>  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="1989c-337">To <see cref="T:System.Reflection.Emit.ILGenerator" /> należy <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-337">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ILOffset">
      <MemberSignature Language="C#" Value="public virtual int ILOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ILOffset" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ILGenerator.ILOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ILOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ILOffset { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ILOffset : int" Usage="System.Reflection.Emit.ILGenerator.ILOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="1989c-338">Pobiera bieżący przesunięcie w bajtach w strumieniu język pośredni (MSIL) firmy Microsoft, emitowanego przez <see cref="T:System.Reflection.Emit.ILGenerator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-338">Gets the current offset, in bytes, in the Microsoft intermediate language (MSIL) stream that is being emitted by the <see cref="T:System.Reflection.Emit.ILGenerator" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="1989c-339">Przesunięcie w strumieniu MSIL emitowany następnej instrukcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-339">The offset in the MSIL stream at which the next instruction will be emitted.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-340">Ta metoda działa w sposób niewidoczny i może zostać wywołana z częściowo zaufanego kodu.</span><span class="sxs-lookup"><span data-stu-id="1989c-340">This method is transparent, and can be called from partially trusted code.</span></span>  
  
 <span data-ttu-id="1989c-341">Jeśli <xref:System.Reflection.Emit.ILGenerator.ILOffset%2A> przed wyemitowały żadnych instrukcji MSIL dostępu do właściwości, zwraca 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="1989c-341">If the <xref:System.Reflection.Emit.ILGenerator.ILOffset%2A> property is accessed before any MSIL instructions have been emitted, it returns 0 (zero).</span></span>  
  
 <span data-ttu-id="1989c-342">Podczas generowania MSIL dynamiczne języków tej właściwości można zamapować przesunięcia w strumieniu MSIL na numery wierszy kodu źródłowego.</span><span class="sxs-lookup"><span data-stu-id="1989c-342">When MSIL is generated for dynamic languages, this property can be used to map offsets in the MSIL stream to source code line numbers.</span></span> <span data-ttu-id="1989c-343">Wynikowe informacje mogą służyć do zapewnienia śladów stosu, gdy wyjątki zostaną zgłoszone.</span><span class="sxs-lookup"><span data-stu-id="1989c-343">The resulting information can be used to provide stack traces when exceptions are thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkLabel">
      <MemberSignature Language="C#" Value="public virtual void MarkLabel (System.Reflection.Emit.Label loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkLabel(valuetype System.Reflection.Emit.Label loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkLabel (loc As Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkLabel(System::Reflection::Emit::Label loc);" />
      <MemberSignature Language="F#" Value="abstract member MarkLabel : System.Reflection.Emit.Label -&gt; unit&#xA;override this.MarkLabel : System.Reflection.Emit.Label -&gt; unit" Usage="iLGenerator.MarkLabel loc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loc" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="loc">
          <span data-ttu-id="1989c-344">Etykiety, dla którego mają zostać ustawione indeksu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-344">The label for which to set an index.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-345">Oznacza bieżącą pozycję strumienia język pośredni (MSIL) firmy Microsoft przy użyciu danego etykiety.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-345">Marks the Microsoft intermediate language (MSIL) stream's current position with the given label.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-346">Etykiet nie można zdefiniować więcej niż raz.</span><span class="sxs-lookup"><span data-stu-id="1989c-346">A label cannot be defined more than once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1989c-347">Poniższy przykład kodu pokazuje użycie kontekstowe `MarkLabel` do zaimplementowania MSIL rozgałęzianie metody dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="1989c-347">The code sample below demonstrates the contextual usage of `MarkLabel` to implement MSIL branching in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1989c-348">
            <paramref name="loc" /> reprezentuje nieprawidłowy indeks w tablicy etykiety.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-348">
              <paramref name="loc" /> represents an invalid index into the label array.</span>
          </span>
          <span data-ttu-id="1989c-349">- lub - indeks dla <paramref name="loc" /> została już zdefiniowana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-349">-or-  An index for <paramref name="loc" /> has already been defined.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MarkSequencePoint">
      <MemberSignature Language="C#" Value="public virtual void MarkSequencePoint (System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkSequencePoint(class System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkSequencePoint (document As ISymbolDocumentWriter, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkSequencePoint(System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="abstract member MarkSequencePoint : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int * int * int -&gt; unit&#xA;override this.MarkSequencePoint : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int * int * int -&gt; unit" Usage="iLGenerator.MarkSequencePoint (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">
          <span data-ttu-id="1989c-350">Dokument, dla którego definiowany jest punkt sekwencji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-350">The document for which the sequence point is being defined.</span>
          </span>
        </param>
        <param name="startLine">
          <span data-ttu-id="1989c-351">Wiersz, w którym rozpoczyna się punktu sekwencji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-351">The line where the sequence point begins.</span>
          </span>
        </param>
        <param name="startColumn">
          <span data-ttu-id="1989c-352">Kolumna w wierszu, w którym rozpoczyna się punktu sekwencji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-352">The column in the line where the sequence point begins.</span>
          </span>
        </param>
        <param name="endLine">
          <span data-ttu-id="1989c-353">Wiersz, w którym zakończenia punktu sekwencji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-353">The line where the sequence point ends.</span>
          </span>
        </param>
        <param name="endColumn">
          <span data-ttu-id="1989c-354">Kolumna w wierszu, w którym zakończenia punktu sekwencji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-354">The column in the line where the sequence point ends.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-355">Oznacza punktu sekwencji w strumieniu język pośredni (MSIL) firmy Microsoft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-355">Marks a sequence point in the Microsoft intermediate language (MSIL) stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-356">Numery wierszy są indeksowane od 1.</span><span class="sxs-lookup"><span data-stu-id="1989c-356">Line numbers are indexed from 1.</span></span> <span data-ttu-id="1989c-357">Kolumny są indeksowane z zakresu od 0.</span><span class="sxs-lookup"><span data-stu-id="1989c-357">Columns are indexed from 0.</span></span>  
  
 <span data-ttu-id="1989c-358">Informacje symboliczne zwykle zawiera co najmniej jedno przesunięcie MSIL dla każdego wiersza źródłowego.</span><span class="sxs-lookup"><span data-stu-id="1989c-358">The symbolic information normally includes at least one MSIL offset for each source line.</span></span> <span data-ttu-id="1989c-359">Kompilatora just-in-time (JIT) jest skompilować metody, prosi o usługach dla profilowania listę przesunięć MSIL, które mają zostać zachowane.</span><span class="sxs-lookup"><span data-stu-id="1989c-359">When the just-in-time (JIT) compiler is about to compile a method, it asks the profiling services for a list of MSIL offsets that should be preserved.</span></span> <span data-ttu-id="1989c-360">Przesunięcia MSIL są nazywane *sekwencji punktów*.</span><span class="sxs-lookup"><span data-stu-id="1989c-360">These MSIL offsets are called *sequence points*.</span></span>  
  
 <span data-ttu-id="1989c-361">Jeśli bieżący <xref:System.Reflection.Emit.ILGenerator> jest skojarzony z <xref:System.Reflection.Emit.DynamicMethod> obiektu, nie obsługuje symboliczne informacje.</span><span class="sxs-lookup"><span data-stu-id="1989c-361">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, it does not support symbolic information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1989c-362">
            <paramref name="startLine" /> lub <paramref name="endLine" /> jest &lt;= 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-362">
              <paramref name="startLine" /> or <paramref name="endLine" /> is &lt;= 0.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="1989c-363">To <see cref="T:System.Reflection.Emit.ILGenerator" /> należy <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-363">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _ILGenerator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_ILGenerator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="1989c-364">Zarezerwowane do użytku w przyszłości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-364">Reserved for future use.</span>
          </span>
          <span data-ttu-id="1989c-365">Musi być wartością IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-365">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="1989c-366">Przekazana tablica nazw ma być mapowana.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-366">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="1989c-367">Liczba nazw, które mają być mapowane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-367">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="1989c-368">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-368">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="1989c-369">Tablica przydzielone przez obiekt wywołujący, która odbiera identyfikatory, odpowiadających nazwy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-369">Caller-allocated array that receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-370">Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-370">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-371">Ta metoda jest do uzyskiwania dostępu do zarządzanej klasy z kodem niezarządzanym i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="1989c-371">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="1989c-372">Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="1989c-372">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="1989c-373">Metoda jest wywoływana z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejsu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-373">The method is called late-bound using the COM <c>IDispatch</c> interface.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _ILGenerator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="1989c-374">Informacje o typie, który będzie zwracany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-374">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="1989c-375">Identyfikator regionalny dla informacji o typie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-375">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="1989c-376">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-376">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-377">Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-377">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-378">Ta metoda jest do uzyskiwania dostępu do zarządzanej klasy z kodem niezarządzanym i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="1989c-378">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="1989c-379">Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="1989c-379">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="1989c-380">Metoda jest wywoływana z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejsu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-380">The method is called late-bound using the COM <c>IDispatch</c> interface.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _ILGenerator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="1989c-381">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-381">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-382">Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-382">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-383">Ta metoda jest do uzyskiwania dostępu do zarządzanej klasy z kodem niezarządzanym i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="1989c-383">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="1989c-384">Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="1989c-384">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="1989c-385">Metoda jest wywoływana z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejsu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-385">The method is called late-bound using the COM <c>IDispatch</c> interface.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.Invoke">
      <MemberSignature Language="C#" Value="void _ILGenerator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _ILGenerator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_ILGenerator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="1989c-386">Określa element członkowski.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-386">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="1989c-387">Zarezerwowane do użytku w przyszłości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-387">Reserved for future use.</span>
          </span>
          <span data-ttu-id="1989c-388">Musi być wartością IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-388">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="1989c-389">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-389">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="1989c-390">Flagi opisujące kontekst wywołania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-390">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="1989c-391">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-391">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="1989c-392">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-392">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="1989c-393">Wskaźnik do struktury, która zawiera informacje o wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-393">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="1989c-394">Indeks pierwszego argumentu, który zawiera błąd.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-394">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-395">Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-395">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-396">Ta metoda jest do uzyskiwania dostępu do zarządzanej klasy z kodem niezarządzanym i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="1989c-396">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="1989c-397">Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz bibliotece MSDN.</span><span class="sxs-lookup"><span data-stu-id="1989c-397">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="1989c-398">Metoda jest wywoływana z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejsu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-398">The method is called late-bound using the COM <c>IDispatch</c> interface.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowException">
      <MemberSignature Language="C#" Value="public virtual void ThrowException (Type excType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ThrowException(class System.Type excType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.ThrowException(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ThrowException (excType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ThrowException(Type ^ excType);" />
      <MemberSignature Language="F#" Value="abstract member ThrowException : Type -&gt; unit&#xA;override this.ThrowException : Type -&gt; unit" Usage="iLGenerator.ThrowException excType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="excType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="excType">
          <span data-ttu-id="1989c-399">Klasa typu wyjątku, aby zgłosić.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-399">The class of the type of exception to throw.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-400">Emituje instrukcję do zgłoszenia wyjątku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-400">Emits an instruction to throw an exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1989c-401">W poniższym przykładzie kodu pokazano kontekstowe użycie `ThrowException` do zgłoszenia wyjątku wewnątrz MSIL metody dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="1989c-401">The following code sample demonstrates the contextual usage of `ThrowException` to throw an exception inside the MSIL of a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1989c-402">
            <paramref name="excType" /> nie jest <see cref="T:System.Exception" /> klasy lub klasy pochodnej z <see cref="T:System.Exception" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-402">
              <paramref name="excType" /> is not the <see cref="T:System.Exception" /> class or a derived class of <see cref="T:System.Exception" />.</span>
          </span>
          <span data-ttu-id="1989c-403">- lub - typ nie ma domyślnego konstruktora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-403">-or-  The type does not have a default constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-404">
            <paramref name="excType" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-404">
              <paramref name="excType" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UsingNamespace">
      <MemberSignature Language="C#" Value="public virtual void UsingNamespace (string usingNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UsingNamespace(string usingNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.UsingNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UsingNamespace (usingNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UsingNamespace(System::String ^ usingNamespace);" />
      <MemberSignature Language="F#" Value="abstract member UsingNamespace : string -&gt; unit&#xA;override this.UsingNamespace : string -&gt; unit" Usage="iLGenerator.UsingNamespace usingNamespace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usingNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usingNamespace">
          <span data-ttu-id="1989c-405">Przestrzeń nazw ma być używana podczas obliczania zmiennych lokalnych i obserwowanie bieżącego aktywnego zakresu leksykalne</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-405">The namespace to be used in evaluating locals and watches for the current active lexical scope</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1989c-406">Określa przestrzeń nazw, która ma być używana podczas obliczania zmiennych lokalnych i oczekuje na bieżący zasięg leksykalne active.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-406">Specifies the namespace to be used in evaluating locals and watches for the current active lexical scope.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1989c-407">Jeśli bieżący <xref:System.Reflection.Emit.ILGenerator> jest skojarzony z <xref:System.Reflection.Emit.DynamicMethod> obiektu, ta metoda nie jest obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="1989c-407">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, this method is not supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1989c-408">Długość <paramref name="usingNamespace" /> wynosi zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-408">Length of <paramref name="usingNamespace" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1989c-409">
            <paramref name="usingNamespace" /> jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-409">
              <paramref name="usingNamespace" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="1989c-410">To <see cref="T:System.Reflection.Emit.ILGenerator" /> należy <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1989c-410">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>
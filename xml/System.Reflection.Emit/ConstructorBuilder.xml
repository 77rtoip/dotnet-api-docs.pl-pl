<Type Name="ConstructorBuilder" FullName="System.Reflection.Emit.ConstructorBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="360f5c08783af29bcb979046bcb40524c4928445" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69089505" /></Metadata><TypeSignature Language="C#" Value="public sealed class ConstructorBuilder : System.Reflection.ConstructorInfo, System.Runtime.InteropServices._ConstructorBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ConstructorBuilder extends System.Reflection.ConstructorInfo implements class System.Runtime.InteropServices._ConstructorBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ConstructorBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConstructorBuilder&#xA;Inherits ConstructorInfo&#xA;Implements _ConstructorBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class ConstructorBuilder sealed : System::Reflection::ConstructorInfo, System::Runtime::InteropServices::_ConstructorBuilder" />
  <TypeSignature Language="F#" Value="type ConstructorBuilder = class&#xA;    inherit ConstructorInfo&#xA;    interface _ConstructorBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.ConstructorInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._ConstructorBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ConstructorBuilder))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje i reprezentuje konstruktora klasy dynamicznej.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.ConstructorBuilder>służy do pełnego opisywania konstruktora w języku pośrednim firmy Microsoft (MSIL), w tym nazwy, atrybutów, podpisu i treści konstruktora. Jest on używany w połączeniu z <xref:System.Reflection.Emit.TypeBuilder> klasą do tworzenia klas w czasie wykonywania. Wywołaj <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A> , aby pobrać wystąpienie <xref:System.Reflection.Emit.ConstructorBuilder>elementu.  
  
 Jeśli nie zdefiniujesz konstruktora dla typu dynamicznego, Konstruktor bez parametrów zostanie dostarczony automatycznie i wywoła konstruktora bez parametrów klasy bazowej.  
  
 Jeśli używasz <xref:System.Reflection.Emit.ConstructorBuilder> do definiowania konstruktora dla typu dynamicznego, nie zostanie podany Konstruktor bez parametrów. Dostępne są następujące opcje dla udostępniania konstruktora bez parametrów oprócz zdefiniowanego konstruktora:  
  
-   Jeśli potrzebujesz konstruktora bez parametrów, który po prostu wywołuje konstruktora bez parametrów klasy bazowej, możesz użyć <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A?displayProperty=nameWithType> metody, aby utworzyć jeden (i opcjonalnie ograniczyć dostęp do niego). Nie dostarczaj implementacji dla tego konstruktora bez parametrów. Jeśli to zrobisz, wyjątek jest zgłaszany podczas próby użycia konstruktora. Podczas <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> wywoływania metody nie jest zgłaszany żaden wyjątek.  
  
-   Jeśli chcesz, aby Konstruktor bez parametrów, który wykonuje coś więcej niż po prostu wywołuje konstruktora bez parametrów klasy bazowej lub wywołuje innego konstruktora klasy bazowej lub który wykonuje coś innego w całości, musisz użyć metody, <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> aby <xref:System.Reflection.Emit.ConstructorBuilder>Utwórz i podaj własną implementację.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje kontekstowe użycie elementu `ConstructorBuilder`.  
  
 [!code-cpp[System.Reflection.Emit.ConstructorBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ConstructorBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ConstructorBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ConstructorBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ConstructorBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ConstructorBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ConstructorBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ConstructorBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberSignature Language="F#" Value="member this.AddDeclarativeSecurity : System.Security.Permissions.SecurityAction * System.Security.PermissionSet -&gt; unit" Usage="constructorBuilder.AddDeclarativeSecurity (action, pset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">Akcja zabezpieczeń, która ma zostać podjęta, taka jak zapotrzebowanie, potwierdzenie i tak dalej.</param>
        <param name="pset">Zestaw uprawnień, do których odnosi się akcja.</param>
        <summary>Dodaje deklaratywne zabezpieczenia do tego konstruktora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.ConstructorBuilder.AddDeclarativeSecurity%2A>może być wywoływana kilka razy, z każdym wywołaniem określającym akcję zabezpieczeń (taką `Demand`jak `Assert`, i `Deny`) oraz zestawem uprawnień, których dotyczy dana akcja.  
  
> [!NOTE]
>  W .NET Framework wersje 1,0, 1,1 i 2,0, atrybuty zabezpieczeń deklaracyjne zastosowane do konstruktora przy użyciu tej metody są przechowywane w starym formacie metadanych XML. Zobacz emitowanie deklaratywnych atrybutów zabezpieczeń.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje użycie `AddDeclarativeSecurity`.  
  
 [!code-cpp[ConstructorBuilder_Attributes_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_Attributes_4/CPP/constructorbuilder_attributes_4.cpp#1)]
 [!code-csharp[ConstructorBuilder_Attributes_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_Attributes_4/CS/constructorbuilder_attributes_4.cs#1)]
 [!code-vb[ConstructorBuilder_Attributes_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_Attributes_4/VB/constructorbuilder_attributes_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="action" />jest nieprawidłowy (RequestMinimum, RequestOptional i RequestRefuse są nieprawidłowe).</exception>
        <exception cref="T:System.InvalidOperationException">Typ zawierający został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
—lub— 
Zestaw <paramref name="pset" /> uprawnień zawiera akcję, która została dodana wcześniej przez <see langword="AddDeclarativeSecurity" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pset" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ConstructorBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.ConstructorBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty dla tego konstruktora.</summary>
        <value>Atrybuty dla tego konstruktora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższy przykład kodu ilustruje użycie `Attributes`.  
  
 [!code-cpp[ConstructorBuilder_Attributes_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_Attributes_4/CPP/constructorbuilder_attributes_4.cpp#2)]
 [!code-csharp[ConstructorBuilder_Attributes_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_Attributes_4/CS/constructorbuilder_attributes_4.cs#2)]
 [!code-vb[ConstructorBuilder_Attributes_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_Attributes_4/VB/constructorbuilder_attributes_4.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ConstructorBuilder.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.ConstructorBuilder.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Reflection.CallingConventions" /> Pobiera wartość, która jest zależna od tego, czy typ deklarujący jest rodzajowy.</summary>
        <value><see cref="F:System.Reflection.CallingConventions.HasThis" />Jeśli typ deklarujący jest ogólny; w przeciwnym razie. <see cref="F:System.Reflection.CallingConventions.Standard" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ConstructorBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.ConstructorBuilder.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do <see cref="T:System.Type" /> obiektu dla typu, który deklaruje ten element członkowski.</summary>
        <value>Typ, który deklaruje ten element członkowski.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Składowa klasy (lub interfejsu) jest zadeklarowana lub dziedziczona z klasy podstawowej (lub interfejsu).  
  
 Poniższy przykład kodu ilustruje użycie `DeclaringType`.  
  
 [!code-cpp[ConstructorBuilder_Attributes_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_Attributes_4/CPP/constructorbuilder_attributes_4.cpp#2)]
 [!code-csharp[ConstructorBuilder_Attributes_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_Attributes_4/CS/constructorbuilder_attributes_4.cs#2)]
 [!code-vb[ConstructorBuilder_Attributes_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_Attributes_4/VB/constructorbuilder_attributes_4.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int iSequence, System.Reflection.ParameterAttributes attributes, string strParamName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 iSequence, valuetype System.Reflection.ParameterAttributes attributes, string strParamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (iSequence As Integer, attributes As ParameterAttributes, strParamName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int iSequence, System::Reflection::ParameterAttributes attributes, System::String ^ strParamName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="constructorBuilder.DefineParameter (iSequence, attributes, strParamName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iSequence" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="strParamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="iSequence">Pozycja parametru na liście parametrów. Parametry są indeksowane Zaczynając od liczby 1 pierwszego parametru.</param>
        <param name="attributes">Atrybuty parametru.</param>
        <param name="strParamName">Nazwa parametru. Nazwa może być ciągiem o wartości null.</param>
        <summary>Definiuje parametr tego konstruktora.</summary>
        <returns>Obiekt, który reprezentuje nowy parametr tego konstruktora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określisz wartość 0 (zero) `iSequence`dla, Metoda ta <xref:System.Reflection.Emit.ParameterBuilder> zwraca zamiast zgłaszać wyjątek. Nie trzeba niczego robić <xref:System.Reflection.Emit.ParameterBuilder>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="iSequence" />jest mniejsza niż 0 (zero) lub jest większa niż liczba parametrów konstruktora.</exception>
        <exception cref="T:System.InvalidOperationException">Typ zawierający został utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca atrybuty niestandardowe zdefiniowane dla tego konstruktora.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="constructorBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inherit">Kontroluje dziedziczenie atrybutów niestandardowych z klas bazowych. Ten parametr jest ignorowany.</param>
        <summary>Zwraca wszystkie atrybuty niestandardowe zdefiniowane dla tego konstruktora.</summary>
        <returns>Tablica obiektów reprezentująca wszystkie atrybuty niestandardowe konstruktora reprezentowanego przez to <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr `inherit` jest ignorowany, ponieważ Klasa nigdy nie dziedziczy konstruktorów z klas bazowych.  
  
 Aby uzyskać atrybuty niestandardowe, Zakończ Kompilowanie typu przez <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>wywołanie, pobranie konstruktora przez <xref:System.Type.GetConstructor%2A> wywołanie metody w zwracanym typie <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> , a następnie wywołanie metody na zwracanym <xref:System.Reflection.ConstructorInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="constructorBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType">Typ atrybutu niestandardowego.</param>
        <param name="inherit">Kontroluje dziedziczenie atrybutów niestandardowych z klas bazowych. Ten parametr jest ignorowany.</param>
        <summary>Zwraca atrybuty niestandardowe identyfikowane przez dany typ.</summary>
        <returns>Tablica obiektów, która reprezentuje atrybuty tego konstruktora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr `inherit` jest ignorowany, ponieważ Klasa nigdy nie dziedziczy konstruktorów z klas bazowych.  
  
 Aby uzyskać atrybuty niestandardowe, Zakończ Kompilowanie typu przez <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>wywołanie, pobranie konstruktora przez <xref:System.Type.GetConstructor%2A> wywołanie metody w zwracanym typie <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> , a następnie wywołanie metody na zwracanym <xref:System.Reflection.ConstructorInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Reflection.Emit.ILGenerator" /> Pobiera, który może być używany do emitowania treści metody dla tego konstruktora.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="constructorBuilder.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Reflection.Emit.ILGenerator" /> Pobiera dla tego konstruktora.</summary>
        <returns><see cref="T:System.Reflection.Emit.ILGenerator" /> Obiekt dla tego konstruktora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko uruchomieniowe generuje kod dla konstruktorów domyślnych. W związku z tym, jeśli zostanie podjęta próba `ILGenerator`uzyskania elementu, zostanie zgłoszony wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje użycie `GetILGenerator` metody.  
  
 [!code-cpp[System.Reflection.Emit.ConstructorBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ConstructorBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ConstructorBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ConstructorBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ConstructorBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ConstructorBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Konstruktor jest konstruktorem bez parametrów.  
  
—lub— 
Konstruktor ma <see cref="T:System.Reflection.MethodAttributes" /> flagę <see cref="T:System.Reflection.MethodImplAttributes" /> lub wskazuje, że nie powinien mieć treści metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="constructorBuilder.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="streamSize">Rozmiar strumienia MSIL w bajtach.</param>
        <summary><see cref="T:System.Reflection.Emit.ILGenerator" /> Pobiera obiekt z określonym rozmiarem strumienia MSIL, który może służyć do kompilowania treści metody dla tego konstruktora.</summary>
        <returns><see cref="T:System.Reflection.Emit.ILGenerator" /> Dla tego konstruktora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko uruchomieniowe generuje kod dla konstruktorów domyślnych. W związku z tym, Jeśli podjęto próbę `ILGenerator` uzyskania dla konstruktora bez parametrów, zgłaszany jest wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Konstruktor jest konstruktorem bez parametrów.  
  
—lub— 
Konstruktor ma <see cref="T:System.Reflection.MethodAttributes" /> flagę <see cref="T:System.Reflection.MethodImplAttributes" /> lub wskazuje, że nie powinien mieć treści metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="constructorBuilder.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca flagi implementacji metody dla tego konstruktora.</summary>
        <returns>Flagi implementacji metody dla tego konstruktora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższy przykład kodu ilustruje użycie `GetMethodImplementationFlags`.  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module GetModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Module GetModule() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.GetModule" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModule () As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Module ^ GetModule();" />
      <MemberSignature Language="F#" Value="member this.GetModule : unit -&gt; System.Reflection.Module" Usage="constructorBuilder.GetModule " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca odwołanie do modułu zawierającego ten Konstruktor.</summary>
        <returns>Moduł, który zawiera ten Konstruktor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższy przykład kodu ilustruje użycie `GetModule`.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CPP/source3.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CS/source3.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="constructorBuilder.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca parametry tego konstruktora.</summary>
        <returns>Tablica, która reprezentuje parametry tego konstruktora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest obsługiwana, dopóki <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> nie zostanie wywołana metoda. W .NET Framework wersje 1,0 i 1,1 <xref:System.InvalidOperationException> są zgłaszane. W .NET Framework <xref:System.NotSupportedException> jest zgłaszana wersja 2,0.  
  
   
  
## Examples  
 Przykładowy kod ilustruje użycie `GetParameters`.  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#4](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#4)]
 [!code-csharp[ConstructorBuilder_GetModule_4#4](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#4)]
 [!code-vb[ConstructorBuilder_GetModule_4#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />nie został wywołany dla tego typu konstruktora, w .NET Framework wersje 1,0 i 1,1.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />nie został wywołany w typie tego konstruktora, w .NET Framework w wersji 2,0.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.GetToken" />
      <MemberSignature Language="VB.NET" Value="Public Function GetToken () As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetToken();" />
      <MemberSignature Language="F#" Value="member this.GetToken : unit -&gt; System.Reflection.Emit.MethodToken" Usage="constructorBuilder.GetToken " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Reflection.Emit.MethodToken" /> Zwraca wartość reprezentującą token dla tego konstruktora.</summary>
        <returns><see cref="T:System.Reflection.Emit.MethodToken" /> Tego konstruktora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten przykładowy kod ilustruje użycie `GetToken`.  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#2)]
 [!code-csharp[ConstructorBuilder_GetModule_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#2)]
 [!code-vb[ConstructorBuilder_GetModule_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ConstructorBuilder.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.ConstructorBuilder.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia, czy zmienne lokalne w tym konstruktorze powinny być inicjowane przez zero.</summary>
        <value>Odczyt/zapis. Pobiera lub ustawia, czy zmienne lokalne w tym konstruktorze powinny być inicjowane przez zero.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywołuje Konstruktor dynamicznie odzwierciedlony przez to wystąpienie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="constructorBuilder.Invoke (invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameters" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="invokeAttr">Musi to być flaga bitowa z <see cref="T:System.Reflection.BindingFlags" />, taka jak InvokeMethod, niepubliczna i tak dalej.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie, przekształcenie typów argumentów, wywoływanie elementów członkowskich oraz pobieranie <see langword="MemberInfo" /> obiektów przy użyciu odbicia. Jeśli spinaczem <see langword="null" />jest, używany jest domyślny spinacz. Zobacz <see cref="T:System.Reflection.Binder" />.</param>
        <param name="parameters">Lista argumentów. Jest to tablica argumentów o tej samej liczbie, kolejności i typie co parametry konstruktora, które mają być wywoływane. Jeśli nie ma żadnych parametrów, należy to <see langword="null" />zrobić.</param>
        <param name="culture">Wystąpienie <see cref="T:System.Globalization.CultureInfo" /> używane do zarządzania przymusem typów. Jeśli jest to wartość null, <see cref="T:System.Globalization.CultureInfo" /> używany jest bieżący wątek. (Na przykład jest to konieczne do konwersji a <see cref="T:System.String" /> , która reprezentuje 1000 <see cref="T:System.Double" /> do wartości, ponieważ 1000 jest reprezentowana inaczej w różnych kulturach).</param>
        <summary>Dynamicznie wywołuje konstruktora reprezentowanego przez to wystąpienie dla danego obiektu, przekazując do określonych parametrów i w ramach ograniczeń danego spinacza.</summary>
        <returns>Wartość zwrócona przez wywołany Konstruktor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli Konstruktor nie ma parametrów, wartość `parameters` parametru powinna być. `null` W przeciwnym razie liczba, typ i kolejność elementów w `parameters` tablicy powinna być taka sama jak liczba, typ i kolejność parametrów dla konstruktora odzwierciedlonego przez to wystąpienie.  
  
 Na przykład jeśli Konstruktor odzwierciedlony przez to wystąpienie jest zadeklarowany jako Klasa publiczna pobierająca dwa ciągi, `parameters` parametr powinien być <xref:System.Object> tablicą o długości 2.  
  
> [!NOTE]
>  Ograniczenia dostępu są ignorowane dla w pełni zaufanego kodu. Oznacza to, że prywatne konstruktory, metody, pola i właściwości są dostępne i wywoływane przy użyciu odbicia za każdym razem, gdy kod jest w pełni zaufany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana. Można pobrać Konstruktor przy użyciu polecenia <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> i wywołać <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> zwracaną <see cref="T:System.Reflection.ConstructorInfo" />wartość.</exception>
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="constructorBuilder.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który musi zostać ponownie zainicjowany.</param>
        <param name="invokeAttr">Jedna z <see langword="BindingFlags" /> wartości, która określa wymagany typ powiązania.</param>
        <param name="binder">A <see langword="Binder" /> , który definiuje zestaw właściwości i umożliwia powiązanie, wymuszanie typów argumentów oraz wywoływanie elementów członkowskich przy użyciu odbicia. Jeśli <paramref name="binder" /> jest<see langword="null" />, jest używany obiekt Binder. defaultbinding.</param>
        <param name="parameters">Lista argumentów. Jest to tablica argumentów o tej samej liczbie, kolejności i typie co parametry konstruktora, które mają być wywoływane. Jeśli nie ma żadnych parametrów, powinna to być odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic).</param>
        <param name="culture"><see cref="T:System.Globalization.CultureInfo" /> Używany do zarządzania przymusem typów. Jeśli jest to wartość null, <see cref="T:System.Globalization.CultureInfo" /> używany jest bieżący wątek.</param>
        <summary>Dynamicznie wywołuje Konstruktor odzwierciedlony przez to wystąpienie z określonymi argumentami w ramach ograniczeń określonego <see langword="Binder" />.</summary>
        <returns>Wystąpienie klasy skojarzonej z konstruktorem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba, typ i kolejność elementów w tablicy parametrów powinna być taka sama jak liczba, typ i kolejność parametrów dla konstruktora odzwierciedlonego przez to wystąpienie.  
  
 Przed wywołaniem konstruktora program `Invoke` zapewnia, że obiekt wywołujący ma uprawnienia dostępu i że parametry mają poprawną liczbę, kolejność i typ.  
  
 Ograniczenia dostępu są ignorowane dla w pełni zaufanego kodu. Oznacza to, że prywatne konstruktory, metody, pola i właściwości są dostępne i wywoływane przy użyciu odbicia za każdym razem, gdy kod jest w pełni zaufany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana. Można pobrać Konstruktor przy użyciu polecenia <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> i wywołać <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /> zwracaną <see cref="T:System.Reflection.ConstructorInfo" />wartość.</exception>
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="constructorBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType">Typ atrybutu niestandardowego.</param>
        <param name="inherit">Kontroluje dziedziczenie atrybutów niestandardowych z klas bazowych. Ten parametr jest ignorowany.</param>
        <summary>Sprawdza, czy określony typ atrybutu niestandardowego jest zdefiniowany.</summary>
        <returns><see langword="true" />Jeśli określony typ atrybutu niestandardowego jest zdefiniowany; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Szczegółowe informacje na temat sposobu formatowania `binaryAttribute`można znaleźć w specyfikacji metadanych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana. Można pobrać Konstruktor przy użyciu polecenia <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> i wywołać <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> zwracaną <see cref="T:System.Reflection.ConstructorInfo" />wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ConstructorBuilder.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.ConstructorBuilder.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wewnętrzny uchwyt dla metody. Użyj tego uchwytu, aby uzyskać dostęp do bazowego uchwytu metadanych.</summary>
        <value>Wewnętrzny uchwyt dla metody. Użyj tego uchwytu, aby uzyskać dostęp do bazowego uchwytu metadanych.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ta właściwość nie jest obsługiwana w tej klasie.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ConstructorBuilder.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.ConstructorBuilder.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Reflection.MethodImplAttributes" /> Pobiera flagi określające atrybuty implementacji metody.</summary>
        <value>Flagi implementacji metody.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ConstructorBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.ConstructorBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł dynamiczny, w którym jest zdefiniowany ten Konstruktor.</summary>
        <value><see cref="T:System.Reflection.Module" /> Obiekt, który reprezentuje moduł dynamiczny, w którym jest zdefiniowany ten Konstruktor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca tę samą wartość, co <xref:System.Reflection.Emit.ConstructorBuilder.GetModule%2A> Metoda.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ConstructorBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.ConstructorBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę tego konstruktora.</summary>
        <value>Nazwa tego konstruktora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższy przykład kodu ilustruje użycie `Name`.  
  
 [!code-cpp[ConstructorBuilder_Name_5#2](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_Name_5/CPP/constructorbuilder_name_5.cpp#2)]
 [!code-csharp[ConstructorBuilder_Name_5#2](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_Name_5/CS/constructorbuilder_name_5.cs#2)]
 [!code-vb[ConstructorBuilder_Name_5#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_Name_5/VB/constructorbuilder_name_5.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ConstructorBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.ConstructorBuilder.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Przechowuje odwołanie do <see cref="T:System.Type" /> obiektu, z którego uzyskano ten obiekt.</summary>
        <value><see langword="Type" /> Obiekt, z którego uzyskano ten obiekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.ConstructorBuilder> Obiekt reprezentuje konstruktora dla określonej klasy. W celu uzyskania <xref:System.Reflection.ConstructorInfo> obiektu obiekt <xref:System.Type> , który reprezentuje klasę, która obsługuje konstruktora, jest wysyłany do zapytania. Ta właściwość zawiera odwołanie do tego <xref:System.Type> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MemberInfo.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ConstructorBuilder.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.ConstructorBuilder.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see langword="null" />.</summary>
        <value>Zwraca <see langword="null" />wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może zostać usunięta w przyszłej wersji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia atrybut niestandardowy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="constructorBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">Wystąpienie klasy pomocnika do definiowania atrybutu niestandardowego.</param>
        <summary>Ustaw atrybut niestandardowy przy użyciu niestandardowego konstruktora atrybutów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu ilustruje użycie `SetCustomAttribute` kontekstu a <xref:System.Reflection.Emit.ConstructorBuilder>, przekazując <xref:System.Reflection.Emit.CustomAttributeBuilder>.  
  
 [!code-cpp[ConstructorBuilder_SetCustomAttribute1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_SetCustomAttribute1/CPP/constructorbuilder_setcustomattribute1.cpp#1)]
 [!code-csharp[ConstructorBuilder_SetCustomAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_SetCustomAttribute1/CS/constructorbuilder_setcustomattribute1.cs#1)]
 [!code-vb[ConstructorBuilder_SetCustomAttribute1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_SetCustomAttribute1/VB/constructorbuilder_setcustomattribute1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="customBuilder" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="constructorBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">Konstruktor dla atrybutu niestandardowego.</param>
        <param name="binaryAttribute">Obiekt BLOB typu Byte reprezentujący atrybuty.</param>
        <summary>Ustaw atrybut niestandardowy przy użyciu określonego obiektu BLOB atrybutu niestandardowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowe informacje na temat sposobu formatowania `binaryAttribute`, zobacz specyfikację metadanych w dokumentacji ECMA Partition II. Dokumentacja jest dostępna w trybie online; Zobacz [standardy C# ECMA i Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) w MSDN i [Standard ECMA-335-Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w międzynarodowej witrynie sieci Web ECMA.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje użycie `SetCustomAttribute` kontekstu a <xref:System.Reflection.Emit.ConstructorBuilder>, przekazanie obiektu BLOB typu Byte.  
  
 [!code-cpp[ConstructorBuilder_SetCustomAttribute2#1](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_SetCustomAttribute2/CPP/constructorbuilder_setcustomattribute2.cpp#1)]
 [!code-csharp[ConstructorBuilder_SetCustomAttribute2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_SetCustomAttribute2/CS/constructorbuilder_setcustomattribute2.cs#1)]
 [!code-vb[ConstructorBuilder_SetCustomAttribute2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_SetCustomAttribute2/VB/constructorbuilder_setcustomattribute2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="con" />lub <paramref name="binaryAttribute" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetImplementationFlags">
      <MemberSignature Language="C#" Value="public void SetImplementationFlags (System.Reflection.MethodImplAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetImplementationFlags(valuetype System.Reflection.MethodImplAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetImplementationFlags (attributes As MethodImplAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetImplementationFlags(System::Reflection::MethodImplAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.SetImplementationFlags : System.Reflection.MethodImplAttributes -&gt; unit" Usage="constructorBuilder.SetImplementationFlags attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodImplAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">Flagi implementacji metody.</param>
        <summary>Ustawia flagi implementacji metody dla tego konstruktora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższy przykład kodu ilustruje użycie `SetImplementationFlags`.  
  
 [!code-cpp[ConstructorBuilder_SetImplementationFlags#1](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_SetImplementationFlags/CPP/constructorbuilder_setimplementationflags.cpp#1)]
 [!code-csharp[ConstructorBuilder_SetImplementationFlags#1](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_SetImplementationFlags/CS/constructorbuilder_setimplementationflags.cs#1)]
 [!code-vb[ConstructorBuilder_SetImplementationFlags#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_SetImplementationFlags/VB/constructorbuilder_setimplementationflags.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Typ zawierający został utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMethodBody">
      <MemberSignature Language="C#" Value="public void SetMethodBody (byte[] il, int maxStack, byte[] localSignature, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, System.Collections.Generic.IEnumerable&lt;int&gt; tokenFixups);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMethodBody(unsigned int8[] il, int32 maxStack, unsigned int8[] localSignature, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, class System.Collections.Generic.IEnumerable`1&lt;int32&gt; tokenFixups) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMethodBody (il As Byte(), maxStack As Integer, localSignature As Byte(), exceptionHandlers As IEnumerable(Of ExceptionHandler), tokenFixups As IEnumerable(Of Integer))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMethodBody(cli::array &lt;System::Byte&gt; ^ il, int maxStack, cli::array &lt;System::Byte&gt; ^ localSignature, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::ExceptionHandler&gt; ^ exceptionHandlers, System::Collections::Generic::IEnumerable&lt;int&gt; ^ tokenFixups);" />
      <MemberSignature Language="F#" Value="member this.SetMethodBody : byte[] * int * byte[] * seq&lt;System.Reflection.Emit.ExceptionHandler&gt; * seq&lt;int&gt; -&gt; unit" Usage="constructorBuilder.SetMethodBody (il, maxStack, localSignature, exceptionHandlers, tokenFixups)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="maxStack" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="localSignature" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exceptionHandlers" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt;" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="tokenFixups" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="il">Tablica zawierająca prawidłowe instrukcje MSIL.</param>
        <param name="maxStack">Maksymalna głębokość oceny stosu.</param>
        <param name="localSignature">Tablica bajtów, która zawiera serializowaną strukturę zmiennych lokalnych. Określ <see langword="null" /> , czy Konstruktor nie ma zmiennych lokalnych.</param>
        <param name="exceptionHandlers">Kolekcja zawierająca programy obsługi wyjątków dla konstruktora. Określ <see langword="null" /> , czy Konstruktor nie ma obsługi wyjątków.</param>
        <param name="tokenFixups">Kolekcja wartości reprezentujących przesunięcia w <paramref name="il" />, z których każdy określa początek tokenu, który może być modyfikowany. Określ <see langword="null" /> , czy Konstruktor nie ma tokenów, które mają być modyfikowane.</param>
        <summary>Tworzy treść konstruktora przy użyciu określonej tablicy bajtów instrukcji języka pośredniego (MSIL) firmy Microsoft.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="il" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStack" />jest wartością ujemną.  
  
—lub— 
Jedno z <paramref name="exceptionHandlers" /> Określa przesunięcie <paramref name="il" />poza.  
  
—lub— 
Jedno z <paramref name="tokenFixups" /> Określa przesunięcie, które znajduje się <paramref name="il" /> poza tablicą.</exception>
        <exception cref="T:System.InvalidOperationException">Typ zawierający poprzednio został utworzony za pomocą <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> metody.  
  
—lub— 
Ta metoda została wcześniej wywołana dla tego <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.SetSymCustomAttribute : string * byte[] -&gt; unit" Usage="constructorBuilder.SetSymCustomAttribute (name, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa atrybutu niestandardowego.</param>
        <param name="data">Wartość atrybutu niestandardowego.</param>
        <summary>Ustawia atrybut niestandardowy tego konstruktora skojarzony z informacjami symbolicznymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższy przykład kodu ilustruje użycie `SetSymCustomAttributes`.  
  
 [!code-cpp[ConstructorBuilder_SetSymCustomAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_SetSymCustomAttribute/CPP/constructorbuilder_setsymcustomattribute.cpp#1)]
 [!code-csharp[ConstructorBuilder_SetSymCustomAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_SetSymCustomAttribute/CS/constructorbuilder_setsymcustomattribute.cs#1)]
 [!code-vb[ConstructorBuilder_SetSymCustomAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_SetSymCustomAttribute/VB/constructorbuilder_setsymcustomattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Typ zawierający został utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
—lub— 
Moduł nie ma zdefiniowanego modułu zapisywania symboli. Na przykład moduł nie jest modułem debugowania.</exception>
      </Docs>
    </Member>
    <Member MemberName="Signature">
      <MemberSignature Language="C#" Value="public string Signature { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Signature" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ConstructorBuilder.Signature" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Signature As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Signature { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Signature : string" Usage="System.Reflection.Emit.ConstructorBuilder.Signature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podpis pola w postaci ciągu.</summary>
        <value>Podpis pola.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ConstructorBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ConstructorBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ConstructorBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _ConstructorBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ConstructorBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_ConstructorBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ConstructorBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetIDsOfNames`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ConstructorBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _ConstructorBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_ConstructorBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetTypeInfo`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ConstructorBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _ConstructorBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_ConstructorBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetTypeInfoCount`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ConstructorBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _ConstructorBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ConstructorBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.System#Runtime#InteropServices#_ConstructorBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _ConstructorBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ConstructorBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_ConstructorBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ConstructorBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::Invoke`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ConstructorBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="constructorBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca to <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> wystąpienie <see cref="T:System.String" />jako.</summary>
        <returns>Ciąg zawierający nazwę, atrybuty i wyjątki tego konstruktora, po którym następuje bieżący strumień języka pośredniego firmy Microsoft (MSIL).</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="MethodBuilder" FullName="System.Reflection.Emit.MethodBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c93c1a358d5c177a5835b41cbeaeae252a6af730" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30561769" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class MethodBuilder : System.Reflection.MethodInfo, System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit MethodBuilder extends System.Reflection.MethodInfo implements class System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.MethodBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MethodBuilder&#xA;Inherits MethodInfo&#xA;Implements _MethodBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBuilder sealed : System::Reflection::MethodInfo, System::Runtime::InteropServices::_MethodBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje i reprezentuje dynamiczne klasy — metoda (lub konstruktora).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder> Klasa jest używana do pełni opisano metody w języku pośrednim firmy Microsoft (MSIL) razem nazwy, atrybuty podpisu i metody. Jest on używany w połączeniu z <xref:System.Reflection.Emit.TypeBuilder> klasa do tworzenia klas w czasie wykonywania.  
  
## <a name="global-methods-and-methods-as-type-members"></a>Metody globalne i metod jako elementy członkowskie typu  
 Można użyć odbicia emisji do definiowania metod globalnych oraz do definiowania metod jako elementy członkowskie typu. Zwraca interfejsów API, które określają metody <xref:System.Reflection.Emit.MethodBuilder> obiektów.  
  
### <a name="global-methods"></a>Metody globalne  
 Metoda globalna jest definiowana za pomocą <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType> metody, która zwraca **MethodBuilder** obiektu.  
  
 Metody globalne muszą być statyczne. Jeśli dynamiczny moduł zawiera metody globalne <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType> metoda musi zostać wywołana przed wprowadzeniem trwałych modułu dynamicznego lub zawierający go zestaw dynamiczny, ponieważ środowisko uruchomieniowe języka wspólnego odłoży naprawienia modułu dynamicznego do wszystkich funkcji globalnych zostały zdefiniowane.  
  
 Globalnej metody natywnej jest definiowana za pomocą <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType> metody. Wywołanie platformy (PInvoke) nie może być deklarowana metod, abstrakcyjna lub wirtualna. Zestawy środowiska wykonawczego <xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType> atrybutu dla platformy wywołania metody.  
  
### <a name="methods-as-members-of-types"></a>Metody jak elementy członkowskie typów  
 Metoda jest zdefiniowana jako element członkowski typu przy użyciu <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> metody, która zwraca <xref:System.Reflection.Emit.MethodBuilder> obiektu.  
  
 <xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A> Metoda jest używana do ustawiania atrybutów nazwy i parametru parametru lub wartości zwracanej. <xref:System.Reflection.Emit.ParameterBuilder> Obiektu zwróconego przez tę metodę reprezentuje parametr lub wartości zwracanej. <xref:System.Reflection.Emit.ParameterBuilder> Obiekt może służyć do konfigurowania przekazywanie, ustaw wartość stała oraz stosowanie atrybutów niestandardowych.  
  
## <a name="attributes"></a>Atrybuty  
 Elementy członkowskie <xref:System.Reflection.MethodAttributes> wyliczenie zdefiniuj dokładne znak dynamicznej metody:  
  
-   Metody statyczne są określane za pomocą <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType> atrybutu.  
  
-   Końcowe metodach (metody, których nie można zastąpić) są określane za pomocą <xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType> atrybutu.  
  
-   Metody wirtualne są określane za pomocą <xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType> atrybutu.  
  
-   Metody abstrakcyjne są określane za pomocą <xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType> atrybutu.  
  
-   Kilka atrybutów określają metodę widoczności. Zobacz opis <xref:System.Reflection.MethodAttributes> wyliczenia.  
  
-   Należy ustawić metod, które implementują przeciążone operatory <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> atrybutu.  
  
-   Należy ustawić finalizatory <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> atrybutu.  
  
## <a name="known-issues"></a>Znane problemy  
  
-   Mimo że <xref:System.Reflection.Emit.MethodBuilder> jest pochodną <xref:System.Reflection.MethodInfo>, niektóre metody abstrakcyjne zdefiniowane w <xref:System.Reflection.MethodInfo> klasy nie są w pełni zaimplementowane w <xref:System.Reflection.Emit.MethodBuilder>. Te <xref:System.Reflection.Emit.MethodBuilder> throw metody <xref:System.NotSupportedException>. Na przykład <xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType> metoda nie jest w pełni zaimplementowana. Można uwzględnić w tych metod pobierając otaczającego przy użyciu typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metody.  
  
-   Modyfikatory niestandardowe są obsługiwane w programie .NET Framework w wersji 2.0. Nie są obsługiwane we wcześniejszych wersjach.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Reflection.Emit.MethodBuilder> klasy można utworzyć metody w ramach typu dynamicznego.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">Akcja zabezpieczeń (żądanie, Assert i tak dalej).</param>
        <param name="pset">Zestaw uprawnień, które dotyczą akcji.</param>
        <summary>Dodaje zabezpieczenia deklaratywne dla tej metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> może być wywołany kilka razy z każdym wywołaniu określenie akcji zabezpieczeń (takich jak `Demand`, `Assert`, i `Deny`) oraz zestaw uprawnień, które dotyczą akcji.  
  
> [!NOTE]
>  W wersji systemu .NET Framework 1.0, 1.1 i 2.0, zabezpieczenia deklaratywne atrybuty zastosować do metody przy użyciu <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> metody są przechowywane w starym formacie XML w metadanych. Zobacz emitowanie deklaratywne atrybuty zabezpieczeń.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia użycie kontekstowe `AddDeclarativeSecurity` wymagające funkcji wywołującej metodę na nieograniczony uprawnienia.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="action" /> Jest nieprawidłowy (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, i <see langword="RequestRefuse" /> są nieprawidłowe).</exception>
        <exception cref="T:System.InvalidOperationException">Typ zawierający został utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Zestaw uprawnień <paramref name="pset" /> zawiera akcję, która została dodana wcześniej przez <see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />.  
  
 —lub—  
  
 Dla bieżącej metody <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pset" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty dla tej metody.</summary>
        <value>Tylko do odczytu. Pobiera <see langword="MethodAttributes" /> dla tej metody.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca konwencja wywołania metody.</summary>
        <value>Tylko do odczytu. Konwencja wywołania metody.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Nie jest obsługiwana dla tego typu.</summary>
        <value>Nieobsługiwane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.MethodBuilder> zawsze reprezentuje definicję metody rodzajowej i dlatego nie można wywołać.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> i <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType>. Informacje o typach ogólny, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="CreateMethodBody">
      <MemberSignature Language="C#" Value="public void CreateMethodBody (byte[] il, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateMethodBody(unsigned int8[] il, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMethodBody (il As Byte(), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMethodBody(cli::array &lt;System::Byte&gt; ^ il, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="il">Tablica zawierająca prawidłowy instrukcje MSIL. Jeśli ten parametr ma <see langword="null" />, treści metody jest wyczyszczone.</param>
        <param name="count">Liczba bajtów prawidłowy w tablicy MSIL. Ta wartość jest ignorowana, jeśli jest MSIL <see langword="null" />.</param>
        <summary>Tworzy treści metody, przy użyciu tablicy bajtów dostarczony instrukcji języka pośredniego (MSIL) firmy Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy treści metody z `il`, tablica zawierająca instrukcje MSIL jako kody operacji. Liczba bajtów prawidłowy MSIL wynosi liczba.  
  
> [!NOTE]
>  To jest aktualnie nie pełni obsługiwany. Użytkownik nie może dostarczyć lokalizację tokenu naprawy i programy obsługi wyjątków.  
  
   
  
## Examples  
 W przykładzie poniżej prosta metoda, która dodaje dwie liczb całkowitych jest generowany przez kod operacji przy użyciu `CreateMethodBody`.  
  
 [!code-cpp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CPP/source.cpp#1)]
 [!code-csharp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CS/source.cs#1)]
 [!code-vb[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> Nie jest w zasięgu indeksy tablicy dostarczony instrukcja MSIL i <paramref name="il" /> nie jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ zawierający został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Ta metoda została wywołana wcześniej w tym <see langword="MethodBuilder" /> z <paramref name="il" /> argument, który nie był <see langword="null" />.  
  
 —lub—  
  
 Dla bieżącej metody <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca typ, który deklaruje tej metody.</summary>
        <value>Tylko do odczytu. Typ, który deklaruje tej metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przedstawia użycie `Type` właściwości.  
  
 [!code-cpp[MethodBuilderClass_TypeSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CPP/methodbuilderclass.cpp#1)]
 [!code-csharp[MethodBuilderClass_TypeSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CS/methodbuilderclass.cs#1)]
 [!code-vb[MethodBuilderClass_TypeSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilderClass_TypeSample/VB/methodbuilderclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">Tablica ciągów, które reprezentują nazwy parametrów typu ogólnego.</param>
        <summary>Ustawia liczbę parametrów typu ogólnego dla bieżącej metody, określa ich nazwy i zwraca tablicę <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> obiektów, które mogą służyć do definiowania ich ograniczenia.</summary>
        <returns>Tablica <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> obiekty reprezentujące parametrów typu metody ogólnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metody sprawia, że bieżącej metody jest rodzajowy. Nie istnieje sposób aby cofnąć tę zmianę. Wywołanie tej metody po raz drugi powoduje <xref:System.InvalidOperationException>.  
  
 Parametry typu ogólnego metody może zostać później pobrana przy użyciu <xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A> metody.  
  
 Według Konwencji jednej wielkiej litery jest nazwa parametru typu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> i <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>. Informacje o typach ogólny, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy typu dynamicznego `DemoType`, zawierającą dynamiczna Metoda ogólna `DemoMethod`. Ta metoda ma dwa parametry typu ogólnego, z których jeden jest używany jako parametr, a drugi jako typ zwracany.  
  
 Podczas wykonywania kodu zostanie zapisany jako DemoGenericMethod1.dll zestawu dynamicznego, a przy [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
> [!NOTE]
>  W tym przykładzie kodu generuje treści prosta metoda, która zwraca jedynie odwołanie o wartości null. Na przykład kodu z więcej treści metody pełni rozwinięte, które tworzy i używa typów ogólnych, zobacz [porady: definiowanie metody ogólnej przy emisja odbicia](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md).  
  
 [!code-cpp[GenericMethodBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#1)]
 [!code-csharp[GenericMethodBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#1)]
 [!code-vb[GenericMethodBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Parametry typu ogólnego są już zdefiniowane dla tej metody.  
  
 —lub—  
  
 Metoda została już zakończona.  
  
 —lub—  
  
 <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> Dla bieżącej metody została wywołana metoda.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="names" /> jest <see langword="null" />.  
  
 —lub—  
  
 Element <paramref name="names" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="names" /> jest pusta tablica.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.DefineMethod" />
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string strParamName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string strParamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, strParamName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ strParamName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="strParamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja parametru na liście parametrów. Parametry są indeksowane, począwszy od pierwszego parametru; numer 1 liczba 0 jest zwracana wartość metody.</param>
        <param name="attributes">Atrybuty parametru parametru.</param>
        <param name="strParamName">Nazwa parametru. Nazwa może być pustym ciągiem.</param>
        <summary>Ustawia atrybuty parametrów i nazwę parametru tej metody lub wartości zwracanej tej metody. Zwraca ParameterBuilder, który może służyć do zastosowania atrybutów niestandardowych.</summary>
        <returns>Zwraca <see langword="ParameterBuilder" /> obiekt, który reprezentuje parametr tej metody lub wartości zwracanej przez tę metodę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.ParameterBuilder> Obiektu zwracane przez tę metodę można użyć wartości domyślnej dla parametru lub atrybutów niestandardowych.  
  
 Parametr numerowanie rozpoczyna się od 1, więc `position` 1 dla pierwszego parametru. Jeśli `position` wynosi zero, ta metoda ma wpływ na wartość zwracaną.  
  
> [!NOTE]
>  W wersji systemu .NET Framework 1.0 i 1.1, jest zwracany wyjątek, jeśli `position` wynosi zero, więc nie można użyć tej metody można zmodyfikować atrybutów wartości zwracanej w tych wersjach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Metoda nie ma parametrów.  
  
 —lub—  
  
 <paramref name="position" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="position" /> jest większa niż liczba parametrów metody.</exception>
        <exception cref="T:System.InvalidOperationException">Typ zawierający został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Dla bieżącej metody <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z tym <see langword="MethodBuilder" /> wystąpienia.</param>
        <summary>Określa, czy dany obiekt jest taki sam jak to wystąpienie.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> jest wystąpieniem <see langword="MethodBuilder" /> i jest taki sam, jak ten obiekt, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Równość jest określana przez mających taką samą nazwę, atrybuty i podpis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwróć Podstawowa implementacja metody.</summary>
        <returns>Podstawowa implementacja tej metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zawsze zwraca bieżącą `MethodBuilder` obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca atrybuty niestandardowe zdefiniowane dla tej metody.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Określa, czy przeszukać łańcuch dziedziczenia tego elementu członkowskiego w celu znalezienia atrybutów niestandardowych.</param>
        <summary>Zwraca atrybuty niestandardowe zdefiniowane dla tej metody.</summary>
        <returns>Zwraca tablicę obiektów reprezentującą wszystkie atrybuty niestandardowe tej metody.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana. Pobrać za pomocą metody <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> i Wywołaj <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> w zwróconym <see cref="T:System.Reflection.MethodInfo" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Typ atrybutu niestandardowego.</param>
        <param name="inherit">Określa, czy przeszukać łańcuch dziedziczenia tego elementu członkowskiego w celu znalezienia atrybutów niestandardowych.</param>
        <summary>Zwraca atrybuty niestandardowe określone przez danego typu.</summary>
        <returns>Zwraca tablicę obiektów reprezentujących atrybuty tej metody, które są typu <paramref name="attributeType" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana. Pobrać za pomocą metody <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> i Wywołaj <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> w zwróconym <see cref="T:System.Reflection.MethodInfo" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> obiektów, które reprezentują parametry typu metody, jeśli jest ona typu ogólnego.</summary>
        <returns>Tablica <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> obiekty reprezentujące parametrów typu, jeśli metody jest rodzajowy, lub <see langword="null" /> Jeśli metoda nie jest rodzajowa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametry typu metody ogólnej również są zwracane przez <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metodę, która służy do definiowania ich.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> i <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>. Informacje o typach ogólny, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tę metodę.</summary>
        <returns>Bieżące wystąpienie klasy <see cref="T:System.Reflection.Emit.MethodBuilder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.MethodBuilder> nie może służyć do bezpośrednio Emituj skonstruowane metody rodzajowej. Metoda emitowany jest ogólną definicją metody.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> i <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>. Informacje o typach ogólny, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżąca metoda nie jest rodzajowa. Oznacza to <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> zwraca właściwość <see langword="false" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość skrótu dla tej metody.</summary>
        <returns>Wartość skrótu dla tej metody.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see langword="ILGenerator" /> dla tej metody.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see langword="ILGenerator" /> dla tej metody za pomocą domyślny język pośredni firmy Microsoft (MSIL) strumienia rozmiar 64 bajtów.</summary>
        <returns>Zwraca <see langword="ILGenerator" /> obiektu dla tej metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje użycie kontekstowe `GetILGenerator` metody, tworzenie i emisji dynamicznego zestawu, który oblicza iloczyn dwóch punktów w przestrzeni 3D.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda nie powinna mieć treści, ponieważ jego <see cref="T:System.Reflection.MethodAttributes" /> lub <see cref="T:System.Reflection.MethodImplAttributes" /> flagi, na przykład, ponieważ ma ona <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> flagi.  
  
 —lub—  
  
 Metoda jest metodą podstawową, ale nie definicję metody rodzajowej. Oznacza to <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (size As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">Rozmiar strumienia MSIL, w bajtach.</param>
        <summary>Zwraca <see langword="ILGenerator" /> dla tej metody za pomocą określonego języka pośredniego firmy Microsoft (MSIL) strumienia rozmiar.</summary>
        <returns>Zwraca <see langword="ILGenerator" /> obiektu dla tej metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje użycie kontekstowe `GetILGenerator` metody, tworzenie i emisji dynamicznego zestawu, który oblicza iloczyn dwóch punktów w przestrzeni 3D.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda nie powinna mieć treści, ponieważ jego <see cref="T:System.Reflection.MethodAttributes" /> lub <see cref="T:System.Reflection.MethodImplAttributes" /> flagi, na przykład, ponieważ ma ona <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> flagi.  
  
 —lub—  
  
 Metoda jest metodą podstawową, ale nie definicję metody rodzajowej. Oznacza to <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca flagi implementacji metody.</summary>
        <returns>Zwraca flagi implementacji metody.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module GetModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Module GetModule() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetModule" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModule () As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Module ^ GetModule();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca odwołanie do modułu, która zawiera tę metodę.</summary>
        <returns>Zwraca odwołanie do modułu, która zawiera tę metodę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod przedstawia użycie `GetModule` metody do pobierania informacji o module generowane dynamicznie.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CPP/source3.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CS/source3.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca parametry tej metody.</summary>
        <returns>Tablica <see langword="ParameterInfo" /> obiektów, które reprezentują parametry metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod przedstawia użycie `GetParameters` do wykrywania informacji na temat parametrów przekazanych do metody generowane dynamicznie.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CPP/source4.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CS/source4.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/VB/source4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana. Pobrać za pomocą metody <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> i Wywołaj <see langword="GetParameters" /> w zwróconym <see cref="T:System.Reflection.MethodInfo" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetToken" />
      <MemberSignature Language="VB.NET" Value="Public Function GetToken () As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetToken();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see langword="MethodToken" /> reprezentujący tokenu dla tej metody.</summary>
        <returns>Zwraca <see langword="MethodToken" /> tej metody.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość logiczna określająca, czy zero zainicjować zmienne lokalne w tej metodzie. Wartość domyślna tej właściwości to <see langword="true" />.</summary>
        <value>
          <see langword="true" /> Jeśli zmiennych lokalnych w ramach tej metody powinna wynosić zero zainicjowana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest ustawiona na `true`, emitowany MSIL obejmuje inicjowanie zmiennych lokalnych. Jeśli wartość jest ustawiona na `false`, zmienne lokalne nie jest zainicjowany i nie jest wygenerowanego kodu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dla bieżącej metody <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />. (Get lub set.)</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wywołania określonej metody. Jeśli metoda jest statyczna, ten parametr zostanie zignorowany.</param>
        <param name="invokeAttr">Musi to być flagę z bitowego <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />i tak dalej.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie, koercja typy argumentów, wywołania elementów członkowskich i pobieranie MemberInfo obiektów za pomocą odbicia. Jeśli jest <see langword="null" />, używany jest domyślny integrator. Aby uzyskać więcej informacji, zobacz <see cref="T:System.Reflection.Binder" />.</param>
        <param name="parameters">Lista argumentów. To jest tablica argumentów, których liczba, kolejność i typ jako parametry metody do wywołania. Jeśli nie ma żadnych parametrów powinna to być <see langword="null" />.</param>
        <param name="culture">Wystąpienie <see cref="T:System.Globalization.CultureInfo" /> używane do sterowania koercja typów. Jeśli jest to wartość null, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku. (Należy pamiętać, że jest to konieczne, na przykład konwertowanie <see cref="T:System.String" /> reprezentujący 1000 do <see cref="T:System.Double" /> wartości, ponieważ 1000 jest inaczej reprezentowany przez innych kultur.)</param>
        <summary>Dynamicznie wywołuje metodę odzwierciedlone przez to wystąpienie dla danego obiektu, przekazywanie wraz z określonymi parametrami, a w obszarze ograniczenia dany obiekt wiążący.</summary>
        <returns>Zwraca obiekt zawierający wartość zwracaną wywoływanej metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda jest statyczna, `obj` parametru jest ignorowana. Dla metod niestatycznych `obj` powinien być wystąpienia klasy, która dziedziczy lub deklaruje metody i musi być taki sam typ jak tej klasy. Jeśli metoda nie ma parametrów, wartość `parameters` powinien być `null`. W przeciwnym razie liczbę, typ i kolejność elementów w tablicy parametrów powinny być identyczne z liczbę, typ i kolejność parametrów dla metody dostarczanej przez to wystąpienie.  
  
> [!NOTE]
>  Ograniczenia dostępu są ignorowane w pełni zaufanego kodu. Oznacza to konstruktory prywatne, pola, metody i właściwości są dostępne i wywoływane przy użyciu odbicia, jeśli kod jest w pełni zaufany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana. Pobrać za pomocą metody <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> i Wywołaj <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> w zwróconym <see cref="T:System.Reflection.MethodInfo" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Typ atrybutu niestandardowego.</param>
        <param name="inherit">Określa, czy przeszukać łańcuch dziedziczenia tego elementu członkowskiego w celu znalezienia atrybutów niestandardowych.</param>
        <summary>Sprawdza, czy jest definiowany typ określonego atrybutu niestandardowego.</summary>
        <returns>
          <see langword="true" /> Jeśli zdefiniowano typ określonego atrybutu niestandardowego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana. Pobrać za pomocą metody <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> i Wywołaj <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> w zwróconym <see cref="T:System.Reflection.MethodInfo" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy metoda to metoda rodzajowa.</summary>
        <value>
          <see langword="true" /> Jeśli metody jest rodzajowy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody jest rodzajowy, jeśli ma ona parametrów typu. Możesz wprowadzić metody rodzajowe przez wywołanie metody <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metody w celu dodania parametrów typu. Nie można cofnąć tej zmiany.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla stan metody. Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metody.  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżące <see cref="T:System.Reflection.Emit.MethodBuilder" /> obiekt reprezentuje definicję metody rodzajowej.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Reflection.Emit.MethodBuilder" /> obiekt reprezentuje definicję metody rodzajowej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.MethodBuilder> tylko może służyć do tworzenia definicji metody ogólnej; nie można bezpośrednio utworzyć skonstruowane metody rodzajowej. Jednak podklasą <xref:System.Reflection.Emit.MethodBuilder> może reprezentować skonstruowane metody rodzajowej.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla stan metody. Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metody.  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zgłasza wyjątek <see cref="T:System.NotSupportedException" /> we wszystkich przypadkach.</summary>
        <value>Zgłasza wyjątek <see cref="T:System.NotSupportedException" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ustalić, czy metoda w zestawie dynamicznym jest krytyczny dla zabezpieczeń, wykonać typu przez wywołanie metody <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, wywołaj <xref:System.Type.GetMethod%2A> metody na typ ukończone i get <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> właściwość powstałe w ten sposób <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">We wszystkich przypadkach. Ta właściwość nie jest obsługiwana w przypadku zestawów dynamicznych.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zgłasza wyjątek <see cref="T:System.NotSupportedException" /> we wszystkich przypadkach.</summary>
        <value>Zgłasza wyjątek <see cref="T:System.NotSupportedException" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ustalić, czy metoda w zestawie dynamicznym jest bezpieczny krytyczny dla zabezpieczeń, wykonać typu przez wywołanie metody <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, wywołaj <xref:System.Type.GetMethod%2A> metody na typ ukończone i get <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> właściwość powstałe w ten sposób <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">We wszystkich przypadkach. Ta właściwość nie jest obsługiwana w przypadku zestawów dynamicznych.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zgłasza wyjątek <see cref="T:System.NotSupportedException" /> we wszystkich przypadkach.</summary>
        <value>Zgłasza wyjątek <see cref="T:System.NotSupportedException" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ustalić, czy metoda w zestawie dynamicznym jest przezroczystym poziomie bezpieczeństwa, należy wykonać typu przez wywołanie metody <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, wywołaj <xref:System.Type.GetMethod%2A> metody na typ ukończone i get <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> właściwość powstałe w ten sposób <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">We wszystkich przypadkach. Ta właściwość nie jest obsługiwana w przypadku zestawów dynamicznych.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Tablica <see cref="T:System.Type" /> obiektów, które reprezentują argumentów typu dla metody ogólnej.</param>
        <summary>Zwraca utworzone na podstawie bieżącej definicji metody ogólnej przy użyciu argumentów typu ogólnego określonego metody rodzajowej.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący Metoda ogólna utworzone na podstawie bieżącej definicji metody ogólnej przy użyciu argumentów określonego typu ogólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy są emitowanie kodu dynamicznych, konieczne może być Emituj wywołanie do metody utworzone na podstawie definicję metody rodzajowej reprezentowany przez <xref:System.Reflection.Emit.MethodBuilder>, przed zakończeniem typu otaczającego. Można użyć <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> metodę w celu utworzenia <xref:System.Reflection.MethodInfo> dla takich skonstruowane — metoda i użyj <xref:System.Reflection.MethodInfo> w wywołaniu emitowany.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy skonstruowane — metoda z niekompletne ogólną definicją metody w niekompletnego typu.  
  
 Przykład tworzy modułu i zestawu przejściowego z jednego typu, dodaje metodę `M`i powoduje, że metoda ogólnego przez dodawanie parametru T typu przy użyciu <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metody. Parametr typu jest używany jako typ parametru metody, a także jako jej typu zwracanego. Definicja metody ogólnej nie zostanie podany, treści, a typ otaczający nie został zakończony. <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> Metody jest następnie umożliwia skonstruowane — metoda `M<String>` (`M(Of String)` w języku Visual Basic). Przykładowy kod ma żadnych danych wyjściowych, ponieważ podklasą klasy <xref:System.Reflection.MethodInfo> zwrócony przez <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> — metoda nie zezwala na jego parametrów odbicia.  
  
> [!NOTE]
>  Innym przykładem kodu, który używa <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>, zobacz <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>. <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> jest również bardzo często używane podczas emitowania kodu korzystającego z typów ogólnych. Zobacz [porady: definiowanie metody ogólnej za pomocą odbicia Emituj](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md).  
  
 [!code-cpp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cpp/source.cpp#1)]
 [!code-csharp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cs/source.cs#1)]
 [!code-vb[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wewnętrzne dojście metody. Dostęp do podstawowych dojście metadanych przy użyciu tego uchwytu.</summary>
        <value>Tylko do odczytu. Wewnętrzne dojście metody. Dostęp do podstawowych dojście metadanych przy użyciu tego uchwytu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana. Pobrać za pomocą metody <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> i Wywołaj <see cref="P:System.Reflection.MethodBase.MethodHandle" /> w zwróconym <see cref="T:System.Reflection.MethodInfo" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł, w którym zdefiniowany jest bieżąca metoda.</summary>
        <value>
          <see cref="T:System.Reflection.Module" /> , W którym reprezentowany przez bieżący element członkowski <see cref="T:System.Reflection.MemberInfo" /> jest definiowany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest udostępniana jako udogodnienie. Jest to równoważne przy użyciu <xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A> właściwości można pobrać typu, w którym zadeklarowany jest metoda, a następnie wywołania <xref:System.Type.Module%2A> właściwość powstałe w ten sposób <xref:System.Type> obiektu.  
  
 Ta właściwość jest również odpowiednikiem wywołania <xref:System.Reflection.Emit.MethodBuilder.GetModule%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę tej metody.</summary>
        <value>Tylko do odczytu. Pobiera ciąg zawierający prostą nazwę tej metody.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klasę, która został użyty w odbicia w celu uzyskania tego obiektu.</summary>
        <value>Tylko do odczytu. Typ używany do uzyskania tej metody.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.ParameterInfo" /> obiekt, który zawiera informacje o zwracany typ metody, takie jak czy zwracany typ ma niestandardowy modyfikatorów.</summary>
        <value>A <see cref="T:System.Reflection.ParameterInfo" /> obiekt, który zawiera informacje o typie zwracanym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Projektanci kompilatora mogą używać <xref:System.Reflection.ParameterInfo> obiektu zwróconego przez tę właściwość, aby dowiedzieć się, czy niestandardowe modyfikatory, takich jak <xref:Microsoft.VisualC.IsConstModifier>, zostały zastosowane do zwracanego typu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie utworzono typ deklarujący.</exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ zwrotny metody reprezentowany przez to <see cref="T:System.Reflection.Emit.MethodBuilder" />.</summary>
        <value>Zwracany typ metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od programu .NET Framework 2.0 i .NET Compact Framework w wersji 2.0, ten element członkowski jest dziedziczony z klasy podstawowej <xref:System.Reflection.MethodInfo>. Zobacz <xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca atrybuty niestandardowe zwracany typ metody.</summary>
        <value>Tylko do odczytu. Zwracany typ metody atrybutów niestandardowych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zawsze zwraca `null`. Pobierz <xref:System.Reflection.MethodInfo> po zawierający <xref:System.Type> został utworzony i jest wywoływane <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> na <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia atrybut niestandardowy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">Wystąpienia klasy pomocnika do opisywania atrybutu niestandardowego.</param>
        <summary>Ustawia atrybut niestandardowy za pomocą konstruktora atrybutów niestandardowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> Zakłócają metody <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metody, gdy dwie metody są używane w połączeniu. Zobacz sekcję uwag <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metody, aby uzyskać szczegółowe informacje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Dla bieżącej metody <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">Konstruktor atrybutu niestandardowego.</param>
        <param name="binaryAttribute">Obiekt blob bajtów reprezentujących atrybuty.</param>
        <summary>Ustawia przy użyciu określonego atrybutu niestandardowego obiektu blob atrybutu niestandardowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat formatu `binaryAttribute`, można znaleźć w dokumentacji infrastruktury języka wspólnego (CLI), szczególnie "partycji II: metadane definicji i semantyki". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> Zakłócają metody <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metody, gdy dwie metody są używane w połączeniu. Zobacz sekcję uwag <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metody, aby uzyskać szczegółowe informacje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> lub <paramref name="binaryAttribute" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Dla bieżącej metody <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetImplementationFlags">
      <MemberSignature Language="C#" Value="public void SetImplementationFlags (System.Reflection.MethodImplAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetImplementationFlags(valuetype System.Reflection.MethodImplAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetImplementationFlags (attributes As MethodImplAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetImplementationFlags(System::Reflection::MethodImplAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodImplAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">Można ustawić flagi implementacji.</param>
        <summary>Ustawia flagi implementacji dla tej metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> w połączeniu z metody <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> metody, należy pamiętać o potencjalnych interakcji. Na przykład za pomocą <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> metody w celu dodania <xref:System.Runtime.InteropServices.DllImportAttribute> również atrybut ustawia <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flagi. Jeśli następnie wywołaj <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metody <xref:System.Reflection.MethodImplAttributes.PreserveSig> flaga jest zastępowany. Istnieją dwa sposoby, aby zapobiec tej sytuacji:  
  
-   Wywołanie <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metoda przed wywołaniem <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> metody. <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> Metody zawsze szanuje istniejących flagi implementacji metod.  
  
-   Po ustawieniu flagi implementacji wywołania <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A> metodę istniejących flag, użyj bitowo lub Dodaj flagę użytkownika, a następnie wywołać <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> metody.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia użycie kontekstowe `SetImplementationFlags` metody do opisywania implementacji MSIL w treści metody.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Typ zawierający został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Dla bieżącej metody <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMarshal">
      <MemberSignature Language="C#" Value="public void SetMarshal (System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarshal(class System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarshal(System::Reflection::Emit::UnmanagedMarshal ^ unmanagedMarshal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedMarshal" Type="System.Reflection.Emit.UnmanagedMarshal" />
      </Parameters>
      <Docs>
        <param name="unmanagedMarshal">Przekazywanie informacji dla zwracanego typu tej metody.</param>
        <summary>Ustawia przekazywanie informacji dla zwracanego typu tej metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod przedstawia użycie kontekstowe `SetMarshal` metody do organizowania wyniki wywołania metody jako innego typu.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Typ zawierający został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Dla bieżącej metody <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMethodBody">
      <MemberSignature Language="C#" Value="public void SetMethodBody (byte[] il, int maxStack, byte[] localSignature, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, System.Collections.Generic.IEnumerable&lt;int&gt; tokenFixups);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMethodBody(unsigned int8[] il, int32 maxStack, unsigned int8[] localSignature, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, class System.Collections.Generic.IEnumerable`1&lt;int32&gt; tokenFixups) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMethodBody (il As Byte(), maxStack As Integer, localSignature As Byte(), exceptionHandlers As IEnumerable(Of ExceptionHandler), tokenFixups As IEnumerable(Of Integer))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMethodBody(cli::array &lt;System::Byte&gt; ^ il, int maxStack, cli::array &lt;System::Byte&gt; ^ localSignature, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::ExceptionHandler&gt; ^ exceptionHandlers, System::Collections::Generic::IEnumerable&lt;int&gt; ^ tokenFixups);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="maxStack" Type="System.Int32" />
        <Parameter Name="localSignature" Type="System.Byte[]" />
        <Parameter Name="exceptionHandlers" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt;" />
        <Parameter Name="tokenFixups" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="il">Tablica zawiera nieprawidłowy instrukcje MSIL.</param>
        <param name="maxStack">Stos maksymalną głębokość oceny.</param>
        <param name="localSignature">Tablica bajtów, które zawierają serializacji struktury zmiennej lokalnej. Określ <see langword="null" /> Jeśli metoda nie ma lokalnych zmiennych.</param>
        <param name="exceptionHandlers">Kolekcja, która zawiera programy obsługi wyjątków dla metody. Określ <see langword="null" /> Jeśli metoda nie ma żadnych programów obsługi wyjątków.</param>
        <param name="tokenFixups">Zbiór wartości, które reprezentują przesunięcia w <c>il</c>, z których każdy Określa początek token, który może być modyfikowany. Określ <see langword="null" /> Jeśli metoda nie ma żadnych tokenów, które mają być modyfikowane.</param>
        <summary>Tworzy treści metody przy użyciu określonej tablicy bajtów instrukcji języka pośredniego (MSIL) firmy Microsoft.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="il" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStack" /> jest ujemna.  
  
 —lub—  
  
 Jeden z <paramref name="exceptionHandlers" /> określa przesunięcie, poza <paramref name="il" />.  
  
 —lub—  
  
 Jeden z <paramref name="tokenFixups" /> określa przesunięcie znajdującego się poza <paramref name="il" /> tablicy.</exception>
        <exception cref="T:System.InvalidOperationException">Typ zawierający został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> metody.  
  
 —lub—  
  
 Ta metoda została wywołana wcześniej w tym <see cref="T:System.Reflection.Emit.MethodBuilder" /> obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParameters">
      <MemberSignature Language="C#" Value="public void SetParameters (params Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParameters(class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParameters (ParamArray parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParameters(... cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterTypes" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiekty reprezentujące typy parametrów.</param>
        <summary>Ustawia liczbę i typy parametrów metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeżeli liczba i typy parametrów są znane, gdy metoda jest określona, można można ustawić za pomocą dowolnego przeciążenia <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> metodę, która akceptuje tablicą typów parametrów. Jednak metoda ogólna może mieć parametrów, których typy zostały określone przez jedną lub więcej własne parametry typu ogólnego, których nie można zdefiniować dopiero po zdefiniowaniu metody. Użyj tej metody można ustawić w takim przypadku typy parametrów.  
  
 Jeśli typ zwracany ma opcjonalne lub wymagane Modyfikatory niestandardowych, takich jak <xref:System.Runtime.CompilerServices.IsConst>, użyj <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> przeciążenie metody.  
  
 Wywołanie tej metody zastępuje wszystkie typy parametrów, które zostały określone za pomocą <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metodę, aby wprowadzić ogólne metody. <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> Metoda służy do przydzielania jeden parametr metody, której typem zostanie określony za pomocą pierwszego parametru typu ogólnego. <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> Metoda jest używana do zapewniają metodę zwracanego typu określony przez drugi parametr typu ogólnego.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metody.  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżącej metody jest rodzajowy, ale nie jest ogólną definicją metody. Oznacza to <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="SetReturnType">
      <MemberSignature Language="C#" Value="public void SetReturnType (Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReturnType(class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReturnType (returnType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReturnType(Type ^ returnType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który reprezentuje typ zwracany metody.</param>
        <summary>Ustawia typ zwrotny metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia ustawienie zwracanego typu metody ogólnej, jeśli określono typ zwracany przez jeden z parametrów typu ogólnego metody. Jeśli typ zwracany ma opcjonalne lub wymagane Modyfikatory niestandardowych, takich jak <xref:System.Runtime.CompilerServices.IsConst>, użyj <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> przeciążenie metody.  
  
 Wywołanie tej metody zastępuje zwracanego typu za pomocą <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metodę, aby wprowadzić ogólne metody. <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> Metoda służy do przydzielania jeden parametr metody, której typem zostanie określony za pomocą pierwszego parametru typu ogólnego. <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> Metoda jest używana do zapewniają metodę zwracanego typu określony przez drugi parametr typu ogólnego.  
  
 Ten kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metody.  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżącej metody jest rodzajowy, ale nie jest ogólną definicją metody. Oznacza to <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="SetSignature">
      <MemberSignature Language="C#" Value="public void SetSignature (Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSignature(class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSignature (returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSignature(Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="returnTypeRequiredCustomModifiers">Tablica typów reprezentujący wymagane Modyfikatory niestandardowych, takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />, dla zwracanego typu metody. Jeśli typ zwracany jest Brak wymaganego modyfikatorów niestandardowych, określić <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Tablica typów reprezentujący opcjonalne Modyfikatory niestandardowych, takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />, dla zwracanego typu metody. Jeśli typ zwracany jest brak opcjonalne modyfikatorów niestandardowych, określić <see langword="null" />.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <param name="parameterTypeRequiredCustomModifiers">Tablica tablice typów. Każdej macierzy typy reprezentuje wymagane Modyfikatory niestandardowych do odpowiadającego mu parametru takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />. Jeśli określonego parametru Brak wymaganego modyfikatorów niestandardowych, określ <see langword="null" /> zamiast tablicę typów. Jeśli żaden z parametrów mają odpowiednie Modyfikatory niestandardowych, określ <see langword="null" /> zamiast tablicy tablic.</param>
        <param name="parameterTypeOptionalCustomModifiers">Tablica tablice typów. Każdej macierzy typy reprezentuje opcjonalne Modyfikatory niestandardowych do odpowiadającego mu parametru takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />. Jeśli określonego parametru brak opcjonalne modyfikatorów niestandardowych, określ <see langword="null" /> zamiast tablicę typów. Jeśli żaden z parametrów nie ma opcjonalne Modyfikatory niestandardowych, określ <see langword="null" /> zamiast tablicy tablic.</param>
        <summary>Ustawia podpis metody, w tym typ zwracany, typy parametrów i wymaganych i opcjonalnych Modyfikatory niestandardowy typ zwracany i typy parametrów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zwracany typ i liczbę i typy parametrów są znane, gdy metoda jest określona, może być ustalona przy użyciu dowolnego przeciążenia <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> metodę, która akceptuje tablicą typów parametrów. Jednak metoda ogólna może mieć parametrów, których typy zostały określone przez jedną lub więcej własne parametry typu ogólnego, których nie można zdefiniować dopiero po zdefiniowaniu metody. Użyj tej metody można ustawić w takim przypadku typy parametrów.  
  
 Jeśli typ zwracany ani typy parametrów nie mieć opcjonalne lub wymagane modyfikatorów niestandardowych, takich jak <xref:Microsoft.VisualC.IsConstModifier>, można użyć <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> i <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> metody.  
  
 Wywołanie tej metody zastępuje parametrów i typ zwracany za pomocą <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu zawiera kod źródłowy o nazwie przykładowy, który ma parametr typu klasy ogólnej `T`. Klasa ma pole o nazwie `Field`, typu `T`oraz metody rodzajowej `GM` z własną parametr typu `U`. — Metoda `GM` tworzy wystąpienie próbki, podstawiając własne parametr typu `U` dla parametru typu próbki i są przechowywane jego parametru wejściowego w `Field`. Ten kod źródłowy jest skompilowany, ale nie jest używany; można wyświetlić za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)i porównaj je z kodu emitowane przez klasę `Example`.  
  
 Kod w klasie `Example` zademonstrowano użycie <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> metoda emitowanie kodu ogólnego. `Main` Metody klasy `Example` tworzy dynamiczne zestawu zawierającego klasę o nazwie `Sample`i używa <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> metodę, aby wprowadzić ogólne przez dodanie parametru typu o nazwie `T`. Domyślny konstruktor i pole o nazwie `Field`, typu `T`, są dodawane do klasy `Sample`. Metoda `GM` zostanie dodany i zamieniło się przy użyciu metody ogólnej <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metody. Parametr typu `GM` nosi nazwę `U`. Parametr typu jest zdefiniowane, podpis `GM` jest dodawana przy użyciu <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> metody. Nie ma zwracanego typu i brak modyfikatorów wymagane lub niestandardowych więc wszystkie parametry tej metody są `null` z wyjątkiem `parameterTypes`, która określa typ parametru tylko metody; Ustaw parametr typu metody, `U`. Treść metody tworzy wystąpienia typu skonstruowane `Sample<U>` (`Sample(Of U)` w języku Visual Basic), przypisuje parametr metody `Field`, a następnie drukuje wartość `Field`. Zdefiniowano fikcyjny typu, aby pomieścić metoda punktu wejścia `Main`. W treści `Main`, statycznych `GM` wywołaniu metody w typie ogólnym skonstruowane `Sample<int>` (`Sample(Of Integer)` w języku Visual Basic), z typem <xref:System.String> podstawić `U`. <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType> Metoda służy do tworzenia <xref:System.Reflection.MethodInfo> dla statycznych `GM` metody skonstruowanego typu ogólnego `Sample<U>`i <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> metody jest następnie używany do tworzenia <xref:System.Reflection.MethodInfo> który można emitowanych w wywołaniu metody.  
  
 Po uruchomieniu przykładowy kod zapisuje emitowany zestawu jako TypeBuilderGetFieldExample.exe. Możesz uruchomić TypeBuilderGetFieldExample.exe i służy [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) porównywanie emitowany kodu kod `Sample` klasy, która ma zostać skompilowany w samej przykładu kodu.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżącej metody jest rodzajowy, ale nie jest ogólną definicją metody. Oznacza to <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa symboliczna atrybutu niestandardowego.</param>
        <param name="data">Obiekt blob bajt, reprezentujący wartość symboliczne atrybutu niestandardowego.</param>
        <summary>Ustaw symboliczne przy użyciu obiektu blob atrybutu niestandardowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od atrybutu niestandardowego metadanych ten atrybut niestandardowy jest skojarzony z Edytor symbolu.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia użycie kontekstowe `SetSymCustomAttribute` metodę w celu ustawienia wartości bajtu dla nazwy i klucza atrybutu niestandardowego dołączony do metody.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CPP/source2.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CS/source2.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Typ zawierający został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Moduł, który zawiera tę metodę nie jest modułem debugowania.  
  
 —lub—  
  
 Dla bieżącej metody <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Signature">
      <MemberSignature Language="C#" Value="public string Signature { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Signature" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Signature As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Signature { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podpis metody.</summary>
        <value>Tylko do odczytu. Ciąg zawierający podpis metody odzwierciedlone to <see langword="MethodBase" /> wystąpienia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielone przez obiekt wywołujący, która odbiera identyfikatory, odpowiadających nazwy.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawierający tablicę argumentów tablicy argumentu identyfikator DISPID dla argumentów nazwanych i liczbie liczba elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca to <see langword="MethodBuilder" /> wystąpienia jako ciąg.</summary>
        <returns>Zwraca ciąg zawierający nazwę, atrybuty, podpis metody, wyjątków i podpisu lokalnego tej metody następuje bieżący strumień język pośredni (MSIL) firmy Microsoft.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="DynamicILInfo" FullName="System.Reflection.Emit.DynamicILInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="71e9bad108c755bd0677f5ebcd531a5efa885218" /><Meta Name="ms.sourcegitcommit" Value="74239f3977d28923e5020663db2c4e91601bea79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/24/2019" /><Meta Name="ms.locfileid" Value="68437229" /></Metadata><TypeSignature Language="C#" Value="public class DynamicILInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DynamicILInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicILInfo" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicILInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicILInfo" />
  <TypeSignature Language="F#" Value="type DynamicILInfo = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia obsługę alternatywnych sposobów generowania języka pośredniego firmy Microsoft (MSIL) i metadanych dla metody dynamicznej, w tym metod tworzenia tokenów i wstawiania kodu, obsługi wyjątków i zmiennych lokalnych sygnatur obiektów BLOB.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa pozwala deweloperom pisać własne generatory MSIL zamiast korzystać <xref:System.Reflection.Emit.ILGenerator>z programu. <xref:System.Reflection.Emit.DynamicILInfo>  
  
 Aby utworzyć wystąpienia innych typów, wywołać metody i tak dalej, generowane MSIL musi zawierać tokeny dla tych jednostek. Klasa zawiera kilka przeciążeń <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> metody, które zwracają tokeny, które są prawidłowe w zakresie bieżącego <xref:System.Reflection.Emit.DynamicILInfo>. <xref:System.Reflection.Emit.DynamicILInfo> Na przykład jeśli trzeba wywołać Przeciążenie <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metody, można <xref:System.RuntimeMethodHandle> uzyskać dla tego przeciążenia <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> i przekazać go do metody, aby uzyskać token do osadzenia w MSIL.  
  
 Po utworzeniu <xref:System.Byte> tablic dla sygnatury zmiennej lokalnej, wyjątków i treści kodu można <xref:System.Reflection.Emit.DynamicILInfo.SetCode%2A>użyć metod, <xref:System.Reflection.Emit.DynamicILInfo.SetExceptions%2A>i <xref:System.Reflection.Emit.DynamicILInfo.SetLocalSignature%2A> , aby wstawić je do <xref:System.Reflection.Emit.DynamicMethod> skojarzonych z <xref:System.Reflection.Emit.DynamicILInfo> Stream.  
  
 Generowanie własnych metadanych i języka MSIL wymaga znajomości dokumentacji Common Language Infrastructure (CLI), szczególnie "partycja II: Definicja i semantyka metadanych "i" partycja III: Zestaw instrukcji CIL ". Dokumentacja jest dostępna w trybie online; Zobacz [standardy C# ECMA i Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) w MSDN i [Standard ECMA-335-Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w międzynarodowej witrynie sieci Web ECMA.  
  
> [!NOTE]
>  Nie należy używać <xref:System.Reflection.Emit.DynamicILInfo> do generowania kodu, który tworzy delegata do innej metody dynamicznej przez wywołanie konstruktora delegata bezpośrednio. Zamiast tego należy użyć <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metody, aby utworzyć delegata. Delegat, który został utworzony za pomocą konstruktora delegata, nie ma odwołania do docelowej metody dynamicznej. Metoda dynamiczna może zostać odkryta przez wyrzucanie elementów bezużytecznych, gdy delegat jest nadal w użyciu.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="DynamicMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicMethod DynamicMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Emit.DynamicMethod DynamicMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicILInfo.DynamicMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicMethod As DynamicMethod" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::DynamicMethod ^ DynamicMethod { System::Reflection::Emit::DynamicMethod ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicMethod : System.Reflection.Emit.DynamicMethod" Usage="System.Reflection.Emit.DynamicILInfo.DynamicMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicMethod</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metodę dynamiczną, której treść jest generowana przez bieżące wystąpienie.</summary>
        <value>Obiekt reprezentujący metodę dynamiczną, dla której bieżący <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiekt generuje kod. <see cref="T:System.Reflection.Emit.DynamicMethod" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicILInfo> Obiekt jest zawsze skojarzony z metodą dynamiczną. Celem <xref:System.Reflection.Emit.DynamicILInfo> klasy jest zapewnienie innym sposobem wstawiania strumienia MSIL, obsługi wyjątków i podpisu zmiennej lokalnej w metodzie dynamicznej dla deweloperów, którzy chcą generować MSIL bez <xref:System.Reflection.Emit.ILGenerator> użycia klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTokenFor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera token, który jest prawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący ciąg, pole, metodę, typ lub podpis w strumieniu MSIL dla skojarzonej metody dynamicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (byte[] signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(unsigned int8[] signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (signature As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(cli::array &lt;System::Byte&gt; ^ signature);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : byte[] -&gt; int" Usage="dynamicILInfo.GetTokenFor signature" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="signature">Tablica zawierająca sygnaturę.</param>
        <summary>Pobiera token, który jest prawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący podpis skojarzonej metody dynamicznej.</summary>
        <returns>Token, który może być osadzony w metadanych i w strumieniu MSIL dla skojarzonej metody dynamicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje na temat sygnatur obiektów blob, zobacz dokumentację Common Language Infrastructure (CLI), szczególnie "partycja II: Definicja i semantyka metadanych ". Dokumentacja jest dostępna w trybie online; Zobacz [standardy C# ECMA i Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) w MSDN i [Standard ECMA-335-Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w międzynarodowej witrynie sieci Web ECMA.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (System.Reflection.Emit.DynamicMethod method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(class System.Reflection.Emit.DynamicMethod method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As DynamicMethod) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(System::Reflection::Emit::DynamicMethod ^ method);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : System.Reflection.Emit.DynamicMethod -&gt; int" Usage="dynamicILInfo.GetTokenFor method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.Emit.DynamicMethod" />
      </Parameters>
      <Docs>
        <param name="method">Metoda dynamiczna, która ma zostać wywołana.</param>
        <summary>Pobiera token, który jest prawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący metodę dynamiczną, która ma zostać wywołana ze skojarzonej metody.</summary>
        <returns>Token, który może być osadzony w strumieniu MSIL dla skojarzonej metody dynamicznej jako obiekt docelowy instrukcji MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token zwracany przez to Przeciążenie metody umożliwia wywołanie metody dynamicznej z metody dynamicznej skojarzonej z bieżącym <xref:System.Reflection.Emit.DynamicILInfo> obiektem. Aby wywoływać skojarzoną metodę dynamiczną cyklicznie, przekaż wartość <xref:System.Reflection.Emit.DynamicILInfo.DynamicMethod%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeFieldHandle field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeFieldHandle field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (field As RuntimeFieldHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeFieldHandle field);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeFieldHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor field" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="field">Pole, do którego ma zostać uzyskany dostęp.</param>
        <summary>Pobiera token, który jest prawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący pole, do którego można uzyskać dostęp za pomocą skojarzonej metody dynamicznej.</summary>
        <returns>Token, który może być używany jako operand instrukcji MSIL, która uzyskuje dostęp do pól w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy uzyskać token dla dowolnego pola, do którego będzie uzyskiwany dostęp metoda dynamiczna skojarzona z bieżącym <xref:System.Reflection.Emit.DynamicILInfo> obiektem. Użyj metody, aby <xref:System.Reflection.FieldInfo> uzyskać dla pola, do którego chcesz <xref:System.Reflection.FieldInfo.FieldHandle%2A> uzyskać dostęp, a następnie użyj właściwości, aby uzyskać <xref:System.RuntimeFieldHandle>. <xref:System.Type.GetField%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeMethodHandle method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeMethodHandle method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As RuntimeMethodHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeMethodHandle method);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeMethodHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="method">Metoda do uzyskania dostępu.</param>
        <summary>Pobiera token, który jest prawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący metodę do uzyskania dostępu za pomocą skojarzonej metody dynamicznej.</summary>
        <returns>Token, który może być używany jako operand instrukcji MSIL, która uzyskuje dostęp do metod, takich jak <see cref="F:System.Reflection.Emit.OpCodes.Call" /> lub <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy uzyskać token dla każdej metody, która będzie używana przez metodę dynamiczną skojarzoną z bieżącym <xref:System.Reflection.Emit.DynamicILInfo> obiektem. Użyj metody, aby <xref:System.Reflection.MethodInfo> uzyskać dla metody, do której chcesz uzyskać dostęp, a następnie użyj <xref:System.RuntimeMethodHandle> właściwości,abyuzyskać.<xref:System.Reflection.MethodBase.MethodHandle%2A> <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>  
  
> [!NOTE]
>  Dla metody, która należy do typu ogólnego, należy użyć <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%29> przeciążenia metody i <xref:System.RuntimeTypeHandle> określić dla typu ogólnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeTypeHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeTypeHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (type As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeTypeHandle type);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="type">Typ, który ma być używany.</param>
        <summary>Pobiera token, który jest prawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący typ, który ma być używany w skojarzonej metodzie dynamicznej.</summary>
        <returns>Token, który może być używany jako operand instrukcji MSIL, która wymaga typu w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token zwracany przez to Przeciążenie metody umożliwia zdefiniowanie typu zmiennej lokalnej i emituje MSIL w celu utworzenia wystąpienia typu w metodzie dynamicznej skojarzonej z bieżącym <xref:System.Reflection.Emit.DynamicILInfo> obiektem.  
  
 Aby uzyskać <xref:System.RuntimeTypeHandle> reprezentującą typ, <xref:System.Type.TypeHandle%2A?displayProperty=nameWithType> należy użyć właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (string literal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(string literal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (literal As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(System::String ^ literal);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : string -&gt; int" Usage="dynamicILInfo.GetTokenFor literal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="literal" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="literal">Ciąg, który ma być używany.</param>
        <summary>Pobiera token, który jest prawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący literał ciągu, który ma być używany w skojarzonej metodzie dynamicznej.</summary>
        <returns>Token, który może być używany jako operand instrukcji MSIL, która wymaga ciągu, w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeFieldHandle field, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeFieldHandle field, valuetype System.RuntimeTypeHandle contextType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (field As RuntimeFieldHandle, contextType As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeFieldHandle * RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor (field, contextType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.RuntimeFieldHandle" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="contextType" Type="System.RuntimeTypeHandle" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="field">Pole, do którego ma zostać uzyskany dostęp.</param>
        <param name="contextType">Typ ogólny, do którego należy pole.</param>
        <summary>Pobiera token, który jest prawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący pole, do którego można uzyskać dostęp za pomocą skojarzonej metody dynamicznej; pole znajduje się w określonym typie ogólnym.</summary>
        <returns>Token, który może być używany jako operand instrukcji MSIL, która uzyskuje dostęp do pól w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy uzyskać token dla dowolnego pola, do którego będzie uzyskiwany dostęp metoda dynamiczna skojarzona z bieżącym <xref:System.Reflection.Emit.DynamicILInfo> obiektem. Użyj metody, aby <xref:System.Reflection.FieldInfo> uzyskać dla pola, do którego chcesz uzyskać dostęp, a następnie użyj <xref:System.RuntimeFieldHandle> właściwości,abyuzyskać.<xref:System.Reflection.FieldInfo.FieldHandle%2A> <xref:System.Type.GetField%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeMethodHandle method, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeMethodHandle method, valuetype System.RuntimeTypeHandle contextType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As RuntimeMethodHandle, contextType As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeMethodHandle * RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor (method, contextType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
        <Parameter Name="contextType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="method">Metoda.</param>
        <param name="contextType">Typ ogólny, do którego należy Metoda.</param>
        <summary>Pobiera token, który jest prawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący metodę na typie ogólnym.</summary>
        <returns>Token, który może być używany jako operand instrukcji MSIL, która uzyskuje dostęp do metod, takich jak <see cref="F:System.Reflection.Emit.OpCodes.Call" /> lub <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy uzyskać token dla każdej metody, która będzie wywoływana przez metodę dynamiczną skojarzoną z bieżącym <xref:System.Reflection.Emit.DynamicILInfo> obiektem. Użyj metody, aby <xref:System.Reflection.MethodInfo> uzyskać dla metody, którą chcesz wywołać, a następnie użyj <xref:System.RuntimeMethodHandle> właściwości,abyuzyskać.<xref:System.Reflection.MethodBase.MethodHandle%2A> <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCode">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia treść kodu skojarzonej metody dynamicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCode">
      <MemberSignature Language="C#" Value="public void SetCode (byte[] code, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCode(unsigned int8[] code, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCode (code As Byte(), maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCode(cli::array &lt;System::Byte&gt; ^ code, int maxStackSize);" />
      <MemberSignature Language="F#" Value="member this.SetCode : byte[] * int -&gt; unit" Usage="dynamicILInfo.SetCode (code, maxStackSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Byte[]" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="code">Tablica zawierająca strumień MSIL.</param>
        <param name="maxStackSize">Maksymalna liczba elementów na stosie operandów podczas wykonywania metody.</param>
        <summary>Ustawia treść kodu skojarzonej metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W strumieniu MSIL nie są wykonywane żadne sprawdzenia poprawności.  
  
 Wywołanie tej metody po raz drugi zastępuje pierwszy strumień MSIL z drugim.  
  
 Generowanie własnych metadanych i języka MSIL wymaga znajomości dokumentacji Common Language Infrastructure (CLI), szczególnie "partycja II: Definicja i semantyka metadanych "i" partycja III: Zestaw instrukcji CIL ". Dokumentacja jest dostępna w trybie online; Zobacz [standardy C# ECMA i Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) w MSDN i [Standard ECMA-335-Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w międzynarodowej witrynie sieci Web ECMA.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCode">
      <MemberSignature Language="C#" Value="public void SetCode (byte* code, int codeSize, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCode(unsigned int8* code, int32 codeSize, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCode(System::Byte* code, int codeSize, int maxStackSize);" />
      <MemberSignature Language="F#" Value="member this.SetCode : nativeptr&lt;byte&gt; * int * int -&gt; unit" Usage="dynamicILInfo.SetCode (code, codeSize, maxStackSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Byte*" />
        <Parameter Name="codeSize" Type="System.Int32" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="code">Wskaźnik do tablicy bajtów zawierającej strumień MSIL.</param>
        <param name="codeSize">Liczba bajtów w strumieniu MSIL.</param>
        <param name="maxStackSize">Maksymalna liczba elementów na stosie operandów podczas wykonywania metody.</param>
        <summary>Ustawia treść kodu skojarzonej metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W strumieniu MSIL nie są wykonywane żadne sprawdzenia poprawności.  
  
 Wywołanie tej metody po raz drugi zastępuje pierwszy strumień MSIL z drugim.  
  
 Generowanie własnych metadanych i języka MSIL wymaga znajomości dokumentacji Common Language Infrastructure (CLI), szczególnie "partycja II: Definicja i semantyka metadanych "i" partycja III: Zestaw instrukcji CIL ". Dokumentacja jest dostępna w trybie online; Zobacz [standardy C# ECMA i Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) w MSDN i [Standard ECMA-335-Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w międzynarodowej witrynie sieci Web ECMA.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="code" />jest <see langword="null" /> i<paramref name="codeSize" /> jest większe niż 0.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codeSize" />jest mniejsza niż 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetExceptions">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia metadane wyjątku dla skojarzonej metody dynamicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetExceptions">
      <MemberSignature Language="C#" Value="public void SetExceptions (byte[] exceptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetExceptions(unsigned int8[] exceptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetExceptions (exceptions As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetExceptions(cli::array &lt;System::Byte&gt; ^ exceptions);" />
      <MemberSignature Language="F#" Value="member this.SetExceptions : byte[] -&gt; unit" Usage="dynamicILInfo.SetExceptions exceptions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="exceptions">Tablica zawierająca metadane wyjątku.</param>
        <summary>Ustawia metadane wyjątku dla skojarzonej metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane wyjątku dla metody definiują lokalizację i rozmiar bloków All `try`, `catch`, `finally`, Filter i Fault. Aby uzyskać informacje na temat układu tych metadanych, zapoznaj się z dokumentacją Common Language Infrastructure (CLI), szczególnie "partycja II: Definicja i semantyka metadanych ". Dokumentacja jest dostępna w trybie online; Zobacz [standardy C# ECMA i Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) w MSDN i [Standard ECMA-335-Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w międzynarodowej witrynie sieci Web ECMA.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetExceptions">
      <MemberSignature Language="C#" Value="public void SetExceptions (byte* exceptions, int exceptionsSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetExceptions(unsigned int8* exceptions, int32 exceptionsSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetExceptions(System::Byte* exceptions, int exceptionsSize);" />
      <MemberSignature Language="F#" Value="member this.SetExceptions : nativeptr&lt;byte&gt; * int -&gt; unit" Usage="dynamicILInfo.SetExceptions (exceptions, exceptionsSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Byte*" />
        <Parameter Name="exceptionsSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exceptions">Wskaźnik do tablicy bajtów zawierającej metadane wyjątku.</param>
        <param name="exceptionsSize">Liczba bajtów metadanych wyjątku.</param>
        <summary>Ustawia metadane wyjątku dla skojarzonej metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane wyjątku dla metody definiują lokalizację i rozmiar bloków All `try`, `catch`, `finally`, Filter i Fault. Aby uzyskać informacje na temat układu tych metadanych, zapoznaj się z dokumentacją Common Language Infrastructure (CLI), szczególnie "partycja II: Definicja i semantyka metadanych "i" partycja III: Zestaw instrukcji CIL ". Dokumentacja jest dostępna w trybie online; Zobacz [standardy C# ECMA i Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) w MSDN i [Standard ECMA-335-Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w międzynarodowej witrynie sieci Web ECMA.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="exceptions" />jest <see langword="null" /> i<paramref name="exceptionSize" /> jest większe niż 0.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exceptionSize" />jest mniejsza niż 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetLocalSignature">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia podpis zmiennej lokalnej, który opisuje układ zmiennych lokalnych dla skojarzonej metody dynamicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetLocalSignature">
      <MemberSignature Language="C#" Value="public void SetLocalSignature (byte[] localSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLocalSignature(unsigned int8[] localSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetLocalSignature (localSignature As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLocalSignature(cli::array &lt;System::Byte&gt; ^ localSignature);" />
      <MemberSignature Language="F#" Value="member this.SetLocalSignature : byte[] -&gt; unit" Usage="dynamicILInfo.SetLocalSignature localSignature" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localSignature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="localSignature">Tablica zawierająca układ zmiennych lokalnych skojarzonych <see cref="T:System.Reflection.Emit.DynamicMethod" />.</param>
        <summary>Ustawia podpis zmiennej lokalnej, który opisuje układ zmiennych lokalnych dla skojarzonej metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podpis zmiennej lokalnej opisuje układ zmiennych lokalnych metody. Aby uprościć konstruowanie podpisu zmiennej lokalnej `static` , użyj metody (`Shared` w Visual Basic <xref:System.Reflection.Emit.SignatureHelper> ) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=nameWithType> , aby uzyskać dla podpisu lokalnego.  
  
 Aby uzyskać informacje na temat podpisów zmiennych lokalnych, zobacz dokumentację Common Language Infrastructure (CLI), szczególnie "partycja II: Definicja i semantyka metadanych ". Dokumentacja jest dostępna w trybie online; Zobacz [standardy C# ECMA i Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) w MSDN i [Standard ECMA-335-Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w międzynarodowej witrynie sieci Web ECMA.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLocalSignature">
      <MemberSignature Language="C#" Value="public void SetLocalSignature (byte* localSignature, int signatureSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLocalSignature(unsigned int8* localSignature, int32 signatureSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLocalSignature(System::Byte* localSignature, int signatureSize);" />
      <MemberSignature Language="F#" Value="member this.SetLocalSignature : nativeptr&lt;byte&gt; * int -&gt; unit" Usage="dynamicILInfo.SetLocalSignature (localSignature, signatureSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localSignature" Type="System.Byte*" />
        <Parameter Name="signatureSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="localSignature">Tablica zawierająca układ zmiennych lokalnych skojarzonych <see cref="T:System.Reflection.Emit.DynamicMethod" />.</param>
        <param name="signatureSize">Liczba bajtów w podpisie.</param>
        <summary>Ustawia podpis zmiennej lokalnej, który opisuje układ zmiennych lokalnych dla skojarzonej metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podpis zmiennej lokalnej opisuje układ zmiennych lokalnych metody. Aby uprościć konstruowanie podpisu zmiennej lokalnej `static` , użyj metody (`Shared` w Visual Basic <xref:System.Reflection.Emit.SignatureHelper> ) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=nameWithType> , aby uzyskać dla podpisu lokalnego.  
  
 Aby uzyskać informacje na temat podpisów zmiennych lokalnych, zobacz dokumentację Common Language Infrastructure (CLI), szczególnie "partycja II: Definicja i semantyka metadanych ". Dokumentacja jest dostępna w trybie online; Zobacz [standardy C# ECMA i Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) w MSDN i [Standard ECMA-335-Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w międzynarodowej witrynie sieci Web ECMA.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="localSignature" />jest <see langword="null" /> i<paramref name="signatureSize" /> jest większe niż 0.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="signatureSize" />jest mniejsza niż 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="DynamicILInfo" FullName="System.Reflection.Emit.DynamicILInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2f003344e2bc089bdad2d02073169a363261e857" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36469747" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DynamicILInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DynamicILInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicILInfo" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicILInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicILInfo" />
  <TypeSignature Language="F#" Value="type DynamicILInfo = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia obsługę alternatywnych metod Generowanie język pośredni firmy Microsoft (MSIL) i metadanych dla metody dynamicznej, tym metody do tworzenia tokenów i wstawianie kodu, obsługa wyjątków i zmiennych podpisu lokalnego obiektów blob.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicILInfo> Klasa umożliwia deweloperom pisanie własnych generatory MSIL zamiast <xref:System.Reflection.Emit.ILGenerator>.  
  
 Aby utworzyć wystąpienia innych typów, wywoływanie metod i tak dalej, MSIL generowania musi zawierać tokeny dla tych jednostek. <xref:System.Reflection.Emit.DynamicILInfo> Klasa udostępnia kilka przeciążeń <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> metodę, która zwraca tokeny prawidłowe w zakresie bieżącego <xref:System.Reflection.Emit.DynamicILInfo>. Na przykład, jeśli należy wywołać przeciążenia <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metody, można uzyskać <xref:System.RuntimeMethodHandle> który przeciążenia i przekaż go do <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> metody do uzyskania tokenu do osadzenia w Twojej MSIL.  
  
 Po utworzeniu <xref:System.Byte> tablic zmiennych podpisu lokalnego, wyjątków i treść kodu, można użyć <xref:System.Reflection.Emit.DynamicILInfo.SetCode%2A>, <xref:System.Reflection.Emit.DynamicILInfo.SetExceptions%2A>, i <xref:System.Reflection.Emit.DynamicILInfo.SetLocalSignature%2A> metod, aby wstawić je do <xref:System.Reflection.Emit.DynamicMethod> skojarzone z Twojej <xref:System.Reflection.Emit.DynamicILInfo> obiekt.  
  
 Generowanie własnego metadanych i MSIL wymaga znajomości dokumentacji infrastruktury języka wspólnego (CLI), szczególnie "Partycji II: metadane definicji i semantyki" i "Partycji III: CIL instrukcji Set". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
> [!NOTE]
>  Nie używaj <xref:System.Reflection.Emit.DynamicILInfo> do generowania kodu, który tworzy delegata do innej metody dynamicznej poprzez bezpośrednie wywoływanie konstruktora delegata. Zamiast tego należy użyć <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metodę w celu utworzenia delegata. Delegata, który jest utworzony za pomocą konstruktora delegata nie ma odwołanie do docelowej metody dynamicznej. Metody dynamicznej może można odzyskać przez odzyskiwanie pamięci podczas delegat jest nadal używane.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="DynamicMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicMethod DynamicMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Emit.DynamicMethod DynamicMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicILInfo.DynamicMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicMethod As DynamicMethod" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::DynamicMethod ^ DynamicMethod { System::Reflection::Emit::DynamicMethod ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicMethod : System.Reflection.Emit.DynamicMethod" Usage="System.Reflection.Emit.DynamicILInfo.DynamicMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicMethod</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metody dynamicznej, których treść jest generowany przez bieżące wystąpienie.</summary>
        <value>A <see cref="T:System.Reflection.Emit.DynamicMethod" /> obiekt reprezentujący metody dynamicznej, dla którego bieżący <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu jest generowanie kodu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.DynamicILInfo> obiekt zawsze jest skojarzony z metody dynamicznej. Celem <xref:System.Reflection.Emit.DynamicILInfo> klasa ma na celu dostarczenie innym sposobem Wstawianie strumienia MSIL, obsługa wyjątków i zmiennych podpisu lokalnego do dynamicznej metody dla deweloperów, którzy chcą generować MSIL bez użycia <xref:System.Reflection.Emit.ILGenerator> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTokenFor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera token jest nieprawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentująca ciągu, pole, metody, typu lub podpisu w strumieniu MSIL skojarzone metody dynamicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (byte[] signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(unsigned int8[] signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (signature As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(cli::array &lt;System::Byte&gt; ^ signature);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : byte[] -&gt; int" Usage="dynamicILInfo.GetTokenFor signature" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="signature">Tablica zawiera podpis.</param>
        <summary>Pobiera token jest nieprawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący podpis skojarzony metody dynamicznej.</summary>
        <returns>Token, który można ją osadzić w metadanych i strumienia MSIL skojarzone metody dynamicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uzyskać informacji o sygnaturze obiektów blob zobacz dokumentację infrastruktury języka wspólnego (CLI), szczególnie "partycji II: metadane definicji i semantyki". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (System.Reflection.Emit.DynamicMethod method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(class System.Reflection.Emit.DynamicMethod method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As DynamicMethod) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(System::Reflection::Emit::DynamicMethod ^ method);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : System.Reflection.Emit.DynamicMethod -&gt; int" Usage="dynamicILInfo.GetTokenFor method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.Emit.DynamicMethod" />
      </Parameters>
      <Docs>
        <param name="method">Dynamiczne metody do wywołania.</param>
        <summary>Pobiera token jest nieprawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący dynamiczne metoda wywoływana przez metodę skojarzone.</summary>
        <returns>Token, który można ją osadzić w strumieniu MSIL skojarzone metody dynamicznej, jako element docelowy instrukcja MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token zwracany przez przeciążenie tej metody umożliwia wywołanie metody dynamicznej z metody dynamicznej skojarzone z bieżącym <xref:System.Reflection.Emit.DynamicILInfo> obiektu. Aby wywołać rekursywnie skojarzone metody dynamicznej, należy przekazać wartość <xref:System.Reflection.Emit.DynamicILInfo.DynamicMethod%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeFieldHandle field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeFieldHandle field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (field As RuntimeFieldHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeFieldHandle field);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeFieldHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor field" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="field">Pole ma być uzyskiwany dostęp.</param>
        <summary>Pobiera token jest nieprawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentująca pole można uzyskać dostęp z skojarzone metody dynamicznej.</summary>
        <returns>Token, który może być używany jako argument instrukcji MSIL, który uzyskuje dostęp do pól w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy uzyskać token dla dowolnego pola, w której będą mieli dostęp przez metodę dynamicznego skojarzone z bieżącym <xref:System.Reflection.Emit.DynamicILInfo> obiektu. Użyj <xref:System.Type.GetField%2A?displayProperty=nameWithType> metodę, aby pobrać <xref:System.Reflection.FieldInfo> pola, którego chcesz uzyskać dostęp, następnie użyć <xref:System.Reflection.FieldInfo.FieldHandle%2A> właściwości do pobrania <xref:System.RuntimeFieldHandle>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeMethodHandle method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeMethodHandle method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As RuntimeMethodHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeMethodHandle method);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeMethodHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="method">Metoda ma być uzyskiwany dostęp.</param>
        <summary>Pobiera token jest nieprawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący metodę jako dostępne skojarzone metody dynamicznej.</summary>
        <returns>Token, który może być używany jako argument instrukcji MSIL, który uzyskuje dostęp do metod, takich jak <see cref="F:System.Reflection.Emit.OpCodes.Call" /> lub <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy uzyskać token dla dowolnej metody, której będą mieli dostęp przez metodę dynamicznego skojarzone z bieżącym <xref:System.Reflection.Emit.DynamicILInfo> obiektu. Użyj <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> metodę, aby pobrać <xref:System.Reflection.MethodInfo> chcesz uzyskać dostęp, a następnie użyj metody <xref:System.Reflection.MethodBase.MethodHandle%2A> właściwości do pobrania <xref:System.RuntimeMethodHandle>.  
  
> [!NOTE]
>  Dla metody, która należy do typu ogólnego, użyj <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%29> metoda przeciążenia i określ <xref:System.RuntimeTypeHandle> dla typu ogólnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeTypeHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeTypeHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (type As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeTypeHandle type);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="type">Typ, który ma być używany.</param>
        <summary>Pobiera token jest nieprawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący typ ma być używana podczas skojarzone metody dynamicznej.</summary>
        <returns>Token, który może być używany jako argument instrukcji MSIL, który wymaga typu, w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token zwracany przez przeciążenie tej metody umożliwia definiowanie typu zmiennej lokalnej i Emituj MSIL do utworzenia wystąpienia typu w metodzie dynamiczne skojarzone z bieżącym <xref:System.Reflection.Emit.DynamicILInfo> obiektu.  
  
 Aby uzyskać <xref:System.RuntimeTypeHandle> reprezentujący typ, użyj <xref:System.Type.TypeHandle%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (string literal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(string literal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (literal As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(System::String ^ literal);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : string -&gt; int" Usage="dynamicILInfo.GetTokenFor literal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="literal" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="literal">Ciąg, który ma być używany.</param>
        <summary>Pobiera token jest nieprawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący do użycia w metodzie dynamiczne skojarzone literału ciągu.</summary>
        <returns>Token, który może być używany jako argument instrukcji MSIL, który wymaga parametrów, w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeFieldHandle field, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeFieldHandle field, valuetype System.RuntimeTypeHandle contextType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (field As RuntimeFieldHandle, contextType As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeFieldHandle * RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor (field, contextType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.RuntimeFieldHandle" />
        <Parameter Name="contextType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="field">Pole ma być uzyskiwany dostęp.</param>
        <param name="contextType">Typ ogólny, których należy pole.</param>
        <summary>Pobiera token jest nieprawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentująca pole można uzyskać dostęp z skojarzone metody dynamicznej; to pole jest w określonym typie ogólnym.</summary>
        <returns>Token, który może być używany jako argument instrukcji MSIL, który uzyskuje dostęp do pól w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy uzyskać token dla dowolnego pola, w której będą mieli dostęp przez metodę dynamicznego skojarzone z bieżącym <xref:System.Reflection.Emit.DynamicILInfo> obiektu. Użyj <xref:System.Type.GetField%2A?displayProperty=nameWithType> metodę, aby pobrać <xref:System.Reflection.FieldInfo> dla pola chcesz uzyskać dostęp, a następnie użyj <xref:System.Reflection.FieldInfo.FieldHandle%2A> właściwości do pobrania <xref:System.RuntimeFieldHandle>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeMethodHandle method, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeMethodHandle method, valuetype System.RuntimeTypeHandle contextType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As RuntimeMethodHandle, contextType As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeMethodHandle * RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor (method, contextType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
        <Parameter Name="contextType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="method">Metoda.</param>
        <param name="contextType">Typ ogólny metoda należy do.</param>
        <summary>Pobiera token jest nieprawidłowy w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" />, reprezentujący metody dla typu ogólnego.</summary>
        <returns>Token, który może być używany jako argument instrukcji MSIL, który uzyskuje dostęp do metod, takich jak <see cref="F:System.Reflection.Emit.OpCodes.Call" /> lub <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, w zakresie bieżącego <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy uzyskać token dla dowolnej metody, która będzie wywoływana przez metodę dynamicznego skojarzone z bieżącym <xref:System.Reflection.Emit.DynamicILInfo> obiektu. Użyj <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> metodę, aby pobrać <xref:System.Reflection.MethodInfo> chcesz wywołać, a następnie użyj metody <xref:System.Reflection.MethodBase.MethodHandle%2A> właściwości do pobrania <xref:System.RuntimeMethodHandle>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCode">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia treść kodu skojarzone metody dynamicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCode">
      <MemberSignature Language="C#" Value="public void SetCode (byte[] code, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCode(unsigned int8[] code, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCode (code As Byte(), maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCode(cli::array &lt;System::Byte&gt; ^ code, int maxStackSize);" />
      <MemberSignature Language="F#" Value="member this.SetCode : byte[] * int -&gt; unit" Usage="dynamicILInfo.SetCode (code, maxStackSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Byte[]" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="code">Tablica zawiera strumienia MSIL.</param>
        <param name="maxStackSize">Maksymalna liczba elementów na stosie operand podczas wykonywania metody.</param>
        <summary>Ustawia treść kodu skojarzone metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie ważności są sprawdzane w strumieniu MSIL.  
  
 Wywołanie tej metody na drugim zamienia pierwszy strumienia MSIL drugiego.  
  
 Generowanie własnego metadanych i MSIL wymaga znajomości dokumentacji infrastruktury języka wspólnego (CLI), szczególnie "Partycji II: metadane definicji i semantyki" i "Partycji III: CIL instrukcji Set". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCode">
      <MemberSignature Language="C#" Value="public void SetCode (byte* code, int codeSize, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCode(unsigned int8* code, int32 codeSize, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCode(System::Byte* code, int codeSize, int maxStackSize);" />
      <MemberSignature Language="F#" Value="member this.SetCode : nativeptr&lt;byte&gt; * int * int -&gt; unit" Usage="dynamicILInfo.SetCode (code, codeSize, maxStackSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Byte*" />
        <Parameter Name="codeSize" Type="System.Int32" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="code">Wskaźnik do tablica bajtów zawierająca strumień MSIL.</param>
        <param name="codeSize">Liczba bajtów w strumieniu MSIL.</param>
        <param name="maxStackSize">Maksymalna liczba elementów na stosie operand podczas wykonywania metody.</param>
        <summary>Ustawia treść kodu skojarzone metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie ważności są sprawdzane w strumieniu MSIL.  
  
 Wywołanie tej metody na drugim zamienia pierwszy strumienia MSIL drugiego.  
  
 Generowanie własnego metadanych i MSIL wymaga znajomości dokumentacji infrastruktury języka wspólnego (CLI), szczególnie "partycji II: metadane definicji i semantyki" i "partycji III: zestaw instrukcji CIL." Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="code" /> jest <see langword="null" /> i <paramref name="codeSize" /> jest większa niż 0.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codeSize" /> jest mniejsza niż 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetExceptions">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia wyjątek metadane skojarzone metody dynamicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetExceptions">
      <MemberSignature Language="C#" Value="public void SetExceptions (byte[] exceptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetExceptions(unsigned int8[] exceptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetExceptions (exceptions As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetExceptions(cli::array &lt;System::Byte&gt; ^ exceptions);" />
      <MemberSignature Language="F#" Value="member this.SetExceptions : byte[] -&gt; unit" Usage="dynamicILInfo.SetExceptions exceptions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="exceptions">Tablica zawiera metadane wyjątku.</param>
        <summary>Ustawia wyjątek metadane skojarzone metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane wyjątku dla metody definiuje położenie i rozmiar wszystkich `try`, `catch`, `finally`, filtr i bloki błędów. Aby uzyskać informacje na układ metadanych w dokumentacji infrastruktury języka wspólnego (CLI), szczególnie "partycji II: metadane definicji i semantyki". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetExceptions">
      <MemberSignature Language="C#" Value="public void SetExceptions (byte* exceptions, int exceptionsSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetExceptions(unsigned int8* exceptions, int32 exceptionsSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetExceptions(System::Byte* exceptions, int exceptionsSize);" />
      <MemberSignature Language="F#" Value="member this.SetExceptions : nativeptr&lt;byte&gt; * int -&gt; unit" Usage="dynamicILInfo.SetExceptions (exceptions, exceptionsSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Byte*" />
        <Parameter Name="exceptionsSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exceptions">Wskaźnik do tablicy typu byte, zawierający metadane wyjątku.</param>
        <param name="exceptionsSize">Liczba bajtów wyjątek metadanych.</param>
        <summary>Ustawia wyjątek metadane skojarzone metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane wyjątku dla metody definiuje położenie i rozmiar wszystkich `try`, `catch`, `finally`, filtr i bloki błędów. Aby uzyskać informacje na układ metadanych w dokumentacji infrastruktury języka wspólnego (CLI), szczególnie "Partycji II: metadane definicji i semantyki" i "III: CIL instrukcji zestawu partycji". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="exceptions" /> jest <see langword="null" /> i <paramref name="exceptionSize" /> jest większa niż 0.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="exceptionSize" /> jest mniejsza niż 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetLocalSignature">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia lokalnej zmiennej podpisie, który opisano układ zmiennych lokalnych skojarzone metody dynamicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetLocalSignature">
      <MemberSignature Language="C#" Value="public void SetLocalSignature (byte[] localSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLocalSignature(unsigned int8[] localSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetLocalSignature (localSignature As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLocalSignature(cli::array &lt;System::Byte&gt; ^ localSignature);" />
      <MemberSignature Language="F#" Value="member this.SetLocalSignature : byte[] -&gt; unit" Usage="dynamicILInfo.SetLocalSignature localSignature" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localSignature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="localSignature">Tablica zawierająca układ zmiennych lokalnych skojarzonych z nim <see cref="T:System.Reflection.Emit.DynamicMethod" />.</param>
        <summary>Ustawia lokalnej zmiennej podpisie, który opisano układ zmiennych lokalnych skojarzone metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podpisu lokalnego zmiennej opisano układ metody zmiennych lokalnych. Aby uprościć konstruowania zmiennej podpisu lokalnego, należy użyć `static` (`Shared` w języku Visual Basic) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=nameWithType> metodę, aby pobrać <xref:System.Reflection.Emit.SignatureHelper> dla podpisu lokalnego.  
  
 Informacji na temat podpisów zmiennych lokalnych w dokumentacji infrastruktury języka wspólnego (CLI), szczególnie "partycji II: metadane definicji i semantyki". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLocalSignature">
      <MemberSignature Language="C#" Value="public void SetLocalSignature (byte* localSignature, int signatureSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLocalSignature(unsigned int8* localSignature, int32 signatureSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLocalSignature(System::Byte* localSignature, int signatureSize);" />
      <MemberSignature Language="F#" Value="member this.SetLocalSignature : nativeptr&lt;byte&gt; * int -&gt; unit" Usage="dynamicILInfo.SetLocalSignature (localSignature, signatureSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localSignature" Type="System.Byte*" />
        <Parameter Name="signatureSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="localSignature">Tablica zawierająca układ zmiennych lokalnych skojarzonych z nim <see cref="T:System.Reflection.Emit.DynamicMethod" />.</param>
        <param name="signatureSize">Liczba bajtów w podpisie.</param>
        <summary>Ustawia lokalnej zmiennej podpisie, który opisano układ zmiennych lokalnych skojarzone metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podpisu lokalnego zmiennej opisano układ metody zmiennych lokalnych. Aby uprościć konstruowania zmiennej podpisu lokalnego, należy użyć `static` (`Shared` w języku Visual Basic) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=nameWithType> metodę, aby pobrać <xref:System.Reflection.Emit.SignatureHelper> dla podpisu lokalnego.  
  
 Informacji na temat podpisów zmiennych lokalnych w dokumentacji infrastruktury języka wspólnego (CLI), szczególnie "partycji II: metadane definicji i semantyki". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localSignature" /> jest <see langword="null" /> i <paramref name="signatureSize" /> jest większa niż 0.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="signatureSize" /> jest mniejsza niż 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30561838" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeBuilder&#xA;Inherits TypeInfo&#xA;Implements _TypeBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeBuilder sealed : System::Reflection::TypeInfo, System::Runtime::InteropServices::_TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje i tworzy nowe wystąpienie klasy w czasie wykonywania.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder> klasy głównym służy do kontrolowania tworzenia klas dynamicznych w czasie wykonywania. Zapewnia zestaw procedur, które są używane do definiowania klas, dodawanie pól i metod i utworzyć klasę wewnątrz modułu. Nowy <xref:System.Reflection.Emit.TypeBuilder> można utworzyć przez wywołanie metody w module dynamicznym <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> metody, która zwraca <xref:System.Reflection.Emit.TypeBuilder> obiektu.  
  
 Emisja odbicia zawiera następujące opcje Definiowanie typów:  
  
-   Należy zdefiniować klasy ani interfejsu o podanej nazwie.  
  
-   Należy zdefiniować klasy ani interfejsu o podanej nazwie i atrybutów.  
  
-   Zdefiniuj klasę o podanej nazwie, atrybuty i klasy podstawowej.  
  
-   Zdefiniuj klasę o podanej nazwie, atrybuty klasy podstawowej i zestaw interfejsów, które implementuje w klasie.  
  
-   Zdefiniuj klasę o podanej nazwie, atrybuty klasy podstawowej i rozmiar pakowania.  
  
-   Zdefiniuj klasę o podanej nazwie, atrybuty klasy podstawowej i rozmiar klasy jako całość.  
  
-   Zdefiniuj klasę o podanej nazwie, atrybuty klasy podstawowej, rozmiar pakowania i rozmiar klasy jako całość.  
  
 Można utworzyć typu tablicy, typ wskaźnika lub typ byref do niekompletnego typu, który jest reprezentowany przez <xref:System.Reflection.Emit.TypeBuilder> obiektów, użyj <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> metody <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> metody, lub <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> metody odpowiednio.  
  
 Zanim będzie można użyć typu <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> metoda musi zostać wywołana. **Typu CreateType** utworzeniu typu. Następującej po wywołaniu **typu CreateType**, wywołujący może utworzyć wystąpienia typu przy użyciu <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i wywoływać elementy członkowskie tego typu za pomocą <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> metody. Błąd do wywoływania metod, które spowodują zmianę implementacji typu po **typu CreateType** została wywołana. Na przykład środowisko uruchomieniowe języka wspólnego zgłasza wyjątek, jeśli obiekt wywołujący próbuje dodać nowe elementy członkowskie do typu.  
  
 Inicjator klasy jest tworzona przy użyciu <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> metody. **DefineTypeInitializer** zwraca <xref:System.Reflection.Emit.ConstructorBuilder> obiektu.  
  
 Zagnieżdżone typy są definiowane przez wywoływanie jednej z <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> metody.  
  
## <a name="attributes"></a>Atrybuty  
 <xref:System.Reflection.Emit.TypeBuilder> Klasy używa <xref:System.Reflection.TypeAttributes> wyliczeniu, aby określić właściwości typu do utworzenia:  
  
-   Interfejsy są określane za pomocą <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> i <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> atrybutów.  
  
-   Klasy (klasy, które nie może zostać rozszerzony) są określane za pomocą <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> atrybutu.  
  
-   Kilka atrybutów określają widoczności typu. Zobacz opis <xref:System.Reflection.TypeAttributes> wyliczenia.  
  
-   Jeśli <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> jest określony, moduł ładujący klasy wychodzi poza pola w kolejności ich są odczytywane z metadanych. Moduł ładujący klasy uwzględnia rozmiar pakowania określony, ale ignoruje kompensacji określonego pola. Metadane zachowuje kolejność, w którym są emitowane definicje pól. Nawet w różnych scalania metadane nie spowoduje zmiany kolejności definicje pól. Moduł ładujący honoruje określone pole przesunięcia tylko wtedy, gdy <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> jest określona.  
  
## <a name="known-issues"></a>Znane problemy  
  
-   Emisja odbicia nie sprawdza, czy klasy nieabstrakcyjnej, która implementuje interfejs zaimplementowała wszystkie metody zadeklarowanej w interfejsie. Jednak jeśli klasa nie implementuje wszystkie metody zadeklarowany w interfejsie, środowisko uruchomieniowe nie załadować klasy.  
  
-   Mimo że <xref:System.Reflection.Emit.TypeBuilder> jest pochodną <xref:System.Type>, niektóre metody abstrakcyjne zdefiniowane w <xref:System.Type> klasy nie są w pełni zaimplementowane w <xref:System.Reflection.Emit.TypeBuilder> klasy. Te wywołania <xref:System.Reflection.Emit.TypeBuilder> metod generują <xref:System.NotSupportedException> wyjątku. Można uzyskać informacji dotyczących odpowiednich funkcji przez pobranie przy użyciu utworzony typ <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i w czasie wykonywania odbicia typu pobrane.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszym przykładzie pokazano, jak utworzyć typu dynamicznego z pola, konstruktora, właściwości i metody. Drugi przykład tworzy metodę dynamicznie z danych wejściowych użytkownika.  
  
 **Przykład, jeden**  
  
 Poniższy przykład kodu pokazuje sposób definiowania dynamicznego zestawu o jeden moduł. Moduł w zestawie przykład zawiera jeden typ `MyDynamicType`, który zawiera pole prywatne, właściwości, która pobiera i ustawia pole prywatne konstruktorów zainicjować pole prywatne i metody, która mnoży liczbę dostarczone przez użytkownika, przez pole prywatne wartości i zwraca wynik.  
  
 <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> Pole zostało określone podczas tworzenia zestawu. Kod zestawu jest używana bezpośrednio i zestawu jest także zapisane na dysku, dzięki czemu można zbadać z [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) lub używane w innym programie.  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu demonstruje sposób tworzenia typu dynamicznego przy użyciu `TypeBuilder`.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">Akcja zabezpieczeń do wykonania, takich jak żądanie, Assert i tak dalej.</param>
        <param name="pset">Zestaw uprawnień, które dotyczą akcji.</param>
        <summary>Zabezpieczenia deklaracyjne dodaje do tego typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `AddDeclarativeSecurity` może zostać wywołana kilka razy każdego wywołania akcji zabezpieczeń (takich jak żądanie, potwierdzenia lub Odmów) i zestaw uprawnień, które są stosowane do akcji.  
  
> [!NOTE]
>  W wersji systemu .NET Framework 1.0, 1.1 i 2.0 zabezpieczenia deklaratywne atrybuty zastosowane do typu przy użyciu tej metody są przechowywane w starym formacie XML w metadanych.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `AddDeclarativeSecurity` metoda umożliwiająca dodanie żądania zabezpieczeń do <xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> Flaga typu dynamicznego o nazwie `MyDynamicClass`, w zestawie o nazwie EmittedExample.dll. Przykład tworzy nie dane wyjściowe konsoli; Po uruchomieniu, można użyć [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do sprawdzenia EmittedExample.dll. W `MyDynamicClass`, otwórz `.class public auto ansi` instrukcji, aby zobaczyć deklaratywne uprawnień.  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="action" /> Jest nieprawidłowy (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, i <see langword="RequestRefuse" /> są nieprawidłowe).</exception>
        <exception cref="T:System.InvalidOperationException">Typ zawierający został utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Zestaw uprawnień <paramref name="pset" /> zawiera akcję, która została dodana wcześniej przez <see langword="AddDeclarativeSecurity" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pset" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInterfaceImplementation (interfaceType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInterfaceImplementation(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Interfejs, który implementuje tego typu.</param>
        <summary>Dodaje interfejs, który implementuje tego typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie kodu pokazano implementacji interfejsu na typ dynamicznie utworzony przy użyciu `AddInterfaceImplementation`.  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw dynamiczny, który zawiera ta definicja typu.</summary>
        <value>Tylko do odczytu. Pobiera zestaw dynamiczny, który zawiera ta definicja typu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca pełną nazwę tego typu kwalifikowana przez nazwę wyświetlaną zestawu.</summary>
        <value>Tylko do odczytu. Pełna nazwa tego typu kwalifikowana przez nazwę wyświetlaną zestawu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Format zwrócony ciąg jest złączeniem pełnej nazwy typu (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) i nazwy wyświetlanej zestawu (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>) oddzielone przecinkiem i spacją.  
  
 Zobacz <xref:System.Reflection.AssemblyName> opis format nazwy wyświetlanej zestawu.  
  
## <a name="version-information"></a>Informacje o wersji  
 W wersji systemu .NET Framework 1.0 i 1.1 wartość tej właściwości nie ma kultury lub klucza publicznego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ bazowy tego typu.</summary>
        <value>Tylko do odczytu. Pobiera typ bazowy tego typu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ CreateType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.Type" /> obiektu dla tej klasy. Po zdefiniowaniu pól i metod w klasie, <see langword="CreateType" /> jest wywoływana w celu załadowania jego <see langword="Type" /> obiektu.</summary>
        <returns>Zwraca nowy <see cref="T:System.Type" /> obiektu dla tej klasy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ten typ jest typem zagnieżdżonym <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metoda musi zostać wywołana na typ otaczający przed jest wywoływana na typu zagnieżdżonego.  
  
 Jeśli bieżący typ pochodzi od typu niekompletne lub implementuje interfejsy niekompletne, wywołanie <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metody w typie elementu nadrzędnego i typów interfejsów przed wywołaniem go w bieżącym typie.  
  
 Jeśli typ otaczający zawiera pola, które jest zdefiniowany jako typu zagnieżdżonego (na przykład pola, które jest zdefiniowany jako zagnieżdżony typ wyliczenia), typ wartości wywoływania <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> wygeneruje metody na typ otaczający <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> zdarzeń. Jest to spowodowane modułu ładującego nie można ustalić rozmiaru typ otaczający dopiero po ukończeniu typu zagnieżdżonego. Obiekt wywołujący powinien definiować obsługi dla <xref:System.AppDomain.TypeResolve> zdarzenie, aby ukończyć tworzenie definicji typu zagnieżdżonego przez wywołanie metody <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> na <xref:System.Reflection.Emit.TypeBuilder> obiekt, który reprezentuje typu zagnieżdżonego. Przykład kodu dla tego tematu przedstawiono sposób definiowania program obsługi zdarzeń.  
  
 Typ jest tworzony tylko raz, niezależnie od tego, jak często <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metoda jest wywoływana. Wszystkie wywołania zwracać taki sam <xref:System.Type> obiektu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób definiowania programu obsługi zdarzeń dla <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> zdarzeń, aby można było wywołać <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metody dla typu zagnieżdżonego podczas <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> wywołać w typie otaczającym.  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Typ otaczający nie został utworzony.  
  
 —lub—  
  
 Ten typ jest typem abstrakcyjnym i zawiera metody abstrakcyjnej.  
  
 —lub—  
  
 Ten typ nie jest klasą abstrakcyjną lub interfejs i ma metody bez treści metody.</exception>
        <exception cref="T:System.NotSupportedException">Typ zawiera nieprawidłowy kod języka pośredniego (MSIL) firmy Microsoft.  
  
 —lub—  
  
 Cel rozgałęzienia jest określona za pomocą przesunięcie 1-bajtowych, ale obiekt docelowy jest w odległości większej niż 127 bajtów w gałęzi.</exception>
        <exception cref="T:System.TypeLoadException">Nie można załadować typu. Na przykład zawiera <see langword="static" /> metodę, która ma konwencję wywołania <see cref="F:System.Reflection.CallingConventions.HasThis" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTypeInfo () As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::TypeInfo ^ CreateTypeInfo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.TypeInfo" /> obiekt, który reprezentuje tego typu.</summary>
        <returns>Obiekt, który reprezentuje tego typu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera metodę, która jest zadeklarowana bieżącego parametru typu ogólnego.</summary>
        <value>A <see cref="T:System.Reflection.MethodBase" /> reprezentujący metodę, która jest zadeklarowana bieżącego typu, jeśli typ bieżącego parametru typu ogólnego; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Gdy emitowanie kodu, parametru typu ogólnego jest reprezentowana przez <xref:System.Reflection.Emit.GenericTypeParameterBuilder> obiektu, a nie przez <xref:System.Reflection.Emit.TypeBuilder> obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca typ zadeklarowany tego typu.</summary>
        <value>Tylko do odczytu. Typ zadeklarowany tego typu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineConstructor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje nowego Konstruktora do typu dynamicznego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes">Atrybuty konstruktora.</param>
        <param name="callingConvention">Konwencja wywoływania konstruktora.</param>
        <param name="parameterTypes">Typy parametrów konstruktora.</param>
        <summary>Dodaje nowego Konstruktora do typu, podane atrybuty i podpisem.</summary>
        <returns>Konstruktor zdefiniowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie definiują konstruktora dla typu dynamicznego automatycznie podano konstruktora domyślnego i wywołuje konstruktor domyślny klasy podstawowej.  
  
 Po zdefiniowaniu konstruktora dla typu dynamicznego nie podano konstruktora domyślnego. Masz następujące opcje zapewniające konstruktora domyślnego oprócz konstruktora, zdefiniowane przez użytkownika:  
  
-   Jeśli chcesz domyślnego konstruktora, która po prostu wywołuje konstruktor domyślny klasy podstawowej, można użyć <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> metodę, aby utworzyć (i opcjonalnie ograniczyć dostęp do niego). Nie podawaj implementację tego konstruktora domyślnego. Jeśli to zrobisz, jest wyjątek podczas próby użycia konstruktora. Żaden wyjątek jest zgłaszany, gdy <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metoda jest wywoływana.  
  
-   Jeśli chcesz domyślnego konstruktora, który wykonuje coś więcej niż po prostu wywołanie domyślnego konstruktora klasy podstawowej lub innego konstruktora, który odwołuje klasy podstawowej, lub że jakiś sposób przetwarzającego całkowicie, należy użyć <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> metody, aby go utworzyć, i podaj swoje własne implementacji.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano stosowania `DefineConstructor` ustawić określonego podpisu i atrybutów konstruktora dla typu dynamicznego, a następnie wróć, odpowiadający jej <xref:System.Reflection.Emit.ConstructorBuilder> do uzupełnienia MSIL.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type(), requiredCustomModifiers As Type()(), optionalCustomModifiers As Type()()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="attributes">Atrybuty konstruktora.</param>
        <param name="callingConvention">Konwencja wywoływania konstruktora.</param>
        <param name="parameterTypes">Typy parametrów konstruktora.</param>
        <param name="requiredCustomModifiers">Tablica tablice typów. Każdej macierzy typy reprezentuje wymagane Modyfikatory niestandardowych do odpowiadającego mu parametru takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />. Jeśli określonego parametru Brak wymaganego modyfikatorów niestandardowych, określ <see langword="null" /> zamiast tablicę typów. Jeśli żaden z parametrów mają odpowiednie Modyfikatory niestandardowych, określ <see langword="null" /> zamiast tablicy tablic.</param>
        <param name="optionalCustomModifiers">Tablica tablice typów. Każdej macierzy typy reprezentuje opcjonalne Modyfikatory niestandardowych do odpowiadającego mu parametru takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />. Jeśli określonego parametru brak opcjonalne modyfikatorów niestandardowych, określ <see langword="null" /> zamiast tablicę typów. Jeśli żaden z parametrów nie ma opcjonalne Modyfikatory niestandardowych, określ <see langword="null" /> zamiast tablicy tablic.</param>
        <summary>Dodaje nowego Konstruktora do typu, podane atrybuty, sygnatury i Modyfikatory niestandardowych.</summary>
        <returns>Konstruktor zdefiniowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla projektantów kompilatory zarządzanych.  
  
> [!NOTE]
>  Więcej informacji o niestandardowych Modyfikatory znajduje się w dokumentacji ECMA partycji II metadanych. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Rozmiar <paramref name="requiredCustomModifiers" /> lub <paramref name="optionalCustomModifiers" /> nie równa się rozmiar <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Dla bieżącego typu dynamicznego <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDefaultConstructor (attributes As MethodAttributes) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineDefaultConstructor(System::Reflection::MethodAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">A <see langword="MethodAttributes" /> obiekt reprezentujący atrybuty, które mają być stosowane do konstruktora.</param>
        <summary>Definiuje konstruktora domyślnego. Konstruktor zdefiniowany w tym miejscu po prostu wywoła domyślny konstruktor obiektu nadrzędnego.</summary>
        <returns>Zwraca konstruktora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ automatycznie zdefiniowano konstruktora domyślnego, konieczne jest tę metodę można wywołać tylko w następujących sytuacjach:  
  
-   Zdefiniowano innego konstruktora i ma konstruktora domyślnego, która po prostu wywołuje konstruktor klasy podstawowej.  
  
-   Aby ustawić atrybutów konstruktora domyślnego do czegoś innego niż <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, i <xref:System.Reflection.MethodAttributes.RTSpecialName>.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano stosowania `DefineConstructor` ustawić określonego podpisu i atrybutów konstruktora dla typu dynamicznego, a następnie wróć, odpowiadający jej <xref:System.Reflection.Emit.ConstructorBuilder> do uzupełnienia MSIL.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Typ nadrzędny (typ podstawowy) nie ma domyślnego konstruktora.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Dla bieżącego typu dynamicznego <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEvent (name As String, attributes As EventAttributes, eventtype As Type) As EventBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EventBuilder ^ DefineEvent(System::String ^ name, System::Reflection::EventAttributes attributes, Type ^ eventtype);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attributes">Atrybuty zdarzenia.</param>
        <param name="eventtype">Typ zdarzenia.</param>
        <summary>Dodaje nowe zdarzenie do typu, o podanej nazwie, atrybuty i zdarzeń typu.</summary>
        <returns>Określonych zdarzeń.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="eventtype" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje nowe pole do typu dynamicznego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">Nazwa pola. <c>Nazwa pola</c> nie może zawierać osadzone wartości.</param>
        <param name="type">Typ pola</param>
        <param name="attributes">Atrybuty pola.</param>
        <summary>Dodaje nowe pole do typu, o podanej nazwie, atrybuty i typ pola.</summary>
        <returns>Zdefiniowane pola.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="fieldName" /> wynosi zero.  
  
 —lub—  
  
 <paramref name="type" /> jest System.Void.  
  
 —lub—  
  
 Całkowity rozmiar został określony dla klasy nadrzędnej tego pola.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fieldName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, cli::array &lt;Type ^&gt; ^ requiredCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalCustomModifiers, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">Nazwa pola. <c>Nazwa pola</c> nie może zawierać osadzone wartości.</param>
        <param name="type">Typ pola</param>
        <param name="requiredCustomModifiers">Tablica typów reprezentujący wymagane Modyfikatory niestandardowego pola, takie jak <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
        <param name="optionalCustomModifiers">Tablica typów reprezentujący opcjonalne Modyfikatory niestandardowego pola, takie jak <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
        <param name="attributes">Atrybuty pola.</param>
        <summary>Dodaje nowe pole z typem, o podanej nazwie, atrybuty, typ pola i Modyfikatory niestandardowych.</summary>
        <returns>Zdefiniowane pola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla projektantów kompilatory zarządzanych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="fieldName" /> wynosi zero.  
  
 —lub—  
  
 <paramref name="type" /> jest System.Void.  
  
 —lub—  
  
 Całkowity rozmiar został określony dla klasy nadrzędnej tego pola.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fieldName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">Tablica nazw parametrów typu ogólnego.</param>
        <summary>Definiuje parametry typu ogólnego dla bieżącego typu określenie ich liczbę oraz ich nazw i zwraca tablicę <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> obiektów, których można użyć do ustawienia ich ograniczenia.</summary>
        <returns>Tablica <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> obiektów, które mogą służyć do definiowania ograniczenia parametrów typu ogólnego dla bieżącego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody sprawia, że typ bieżącego typu ogólnego. Jeśli metoda jest wywoływana ponownie do tego samego typu <xref:System.InvalidOperationException> jest generowany.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy dwa parametry typu ogólnego typu i zapisuje je w zestawie GenericEmitExample1.dll. Można użyć [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Aby przejrzeć wygenerowane typy. Aby uzyskać bardziej szczegółowy opis etapy Definiowanie typu ogólnego dynamicznego, zobacz [porady: Definiowanie typu ogólnego z emisja odbicia](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Parametry typu ogólnego zostały już zdefiniowane dla tego typu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="names" /> jest <see langword="null" />.  
  
 —lub—  
  
 Element <paramref name="names" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="names" /> jest pusta tablica.</exception>
        <altmember cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa używana do odwoływania się do danych. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="data">Obiekt blob danych.</param>
        <param name="attributes">Atrybuty dla pola.</param>
        <summary>Określa pole danymi zainicjowanymi w sekcji .sdata pliku przenośny plik wykonywalny (PE).</summary>
        <returns>Pole danych referencyjnych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pole utworzonej za pomocą tej metody jest `static`, nawet jeśli nie zostanie uwzględniony `FieldAttributes.Static` w `attributes` parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.  
  
 —lub—  
  
 Rozmiar danych jest mniejsza niż lub równa zero, lub większa niż lub równa 0x3f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> lub <paramref name="data" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> została wcześniej wywołana.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje metodę do typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attributes">Atrybuty metody.</param>
        <summary>Dodaje nową metodę do typu, o określonych atrybutów nazwy i metody.</summary>
        <returns>A <see cref="T:System.Reflection.Emit.MethodBuilder" /> reprezentujący metodę nowo zdefiniowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia metody, jeśli nie znasz podpis metody w tym czasie można zdefiniować metody. Na przykład typy parametrów i typ zwracany metody rodzajowej może być określony przez parametry typu ogólnego metody, które muszą zostać określone, po dodaniu do typu metody. Parametry oraz zwracany typ metody można ustawić później za pomocą <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> metody.  
  
 To przeciążenie metody definiuje metodę o <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>. Jeśli musisz zdefiniować metody bez podpisu z różnych Konwencja wywoływania <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> przeciążenie metody.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje metody rodzajowej o nazwie `DemoMethod` których typ parametru i typ zwracany są określane przez jego parametrów typu ogólnego. Metoda jest określona bez podpisu, przy użyciu standardowej konwencji wywoływania. <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> Używa metody w celu `DemoMethod` metody rodzajowej i parametry nowo zdefiniowanego typu są następnie używane w celu podpisania i typ zwracany.  
  
 Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> metody.  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.  
  
 —lub—  
  
 Typ elementu nadrzędnego ta metoda jest interfejsem, a ta metoda nie jest wirtualny (<see langword="Overridable" /> w języku Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Dla bieżącego typu dynamicznego <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> jest właściwość <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attributes">Atrybuty metody.</param>
        <param name="callingConvention">Konwencja wywołania metody.</param>
        <summary>Dodaje nową metodę do typu, z określoną nazwą, atrybuty metody i Konwencja wywoływania.</summary>
        <returns>A <see cref="T:System.Reflection.Emit.MethodBuilder" /> reprezentujący metodę nowo zdefiniowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia metody, jeśli nie znasz podpis metody w tym czasie można zdefiniować metody. Na przykład typy parametrów i typ zwracany metody rodzajowej może być określony przez parametry typu ogólnego metody, które muszą zostać określone, po dodaniu do typu metody. Parametry oraz zwracany typ metody można ustawić później za pomocą <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.  
  
 —lub—  
  
 Typ elementu nadrzędnego ta metoda jest interfejsem, a ta metoda nie jest wirtualny (<see langword="Overridable" /> w języku Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Dla bieżącego typu dynamicznego <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> jest właściwość <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attributes">Atrybuty metody.</param>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <summary>Dodaje nową metodę do typu, z określoną nazwą, atrybuty metody i podpis metody.</summary>
        <returns>Metody zdefiniowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie kodu pokazano stosowania `DefineMethod` można ustawić określonego podpisu i atrybutów konstruktora dla typu dynamicznego i powrócić do odpowiadającego <xref:System.Reflection.Emit.MethodBuilder> do uzupełnienia MSIL.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.  
  
 —lub—  
  
 Typ elementu nadrzędnego ta metoda jest interfejsem, a ta metoda nie jest wirtualny (<see langword="Overridable" /> w języku Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Dla bieżącego typu dynamicznego <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attributes">Atrybuty metody.</param>
        <param name="callingConvention">Konwencja wywołania metody.</param>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <summary>Dodaje nową metodę do typu, z określoną nazwą, atrybuty metody, Konwencja wywoływania i podpis metody.</summary>
        <returns>A <see cref="T:System.Reflection.Emit.MethodBuilder" /> reprezentujący metodę nowo zdefiniowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie kodu pokazano stosowania `DefineMethod` można ustawić określonego podpisu i atrybutów konstruktora dla typu dynamicznego i powrócić do odpowiadającego <xref:System.Reflection.Emit.MethodBuilder> do uzupełnienia MSIL.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.  
  
 —lub—  
  
 Typ elementu nadrzędnego ta metoda jest interfejsem, a ta metoda nie jest wirtualny (<see langword="Overridable" /> w języku Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Dla bieżącego typu dynamicznego <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attributes">Atrybuty metody.</param>
        <param name="callingConvention">Konwencja wywołania metody.</param>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="returnTypeRequiredCustomModifiers">Tablica typów reprezentujący wymagane Modyfikatory niestandardowych, takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />, dla zwracanego typu metody. Jeśli typ zwracany jest Brak wymaganego modyfikatorów niestandardowych, określić <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Tablica typów reprezentujący opcjonalne Modyfikatory niestandardowych, takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />, dla zwracanego typu metody. Jeśli typ zwracany jest brak opcjonalne modyfikatorów niestandardowych, określić <see langword="null" />.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <param name="parameterTypeRequiredCustomModifiers">Tablica tablice typów. Każdej macierzy typy reprezentuje wymagane Modyfikatory niestandardowych do odpowiadającego mu parametru takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />. Jeśli określonego parametru Brak wymaganego modyfikatorów niestandardowych, określ <see langword="null" /> zamiast tablicę typów. Jeśli żaden z parametrów mają odpowiednie Modyfikatory niestandardowych, określ <see langword="null" /> zamiast tablicy tablic.</param>
        <param name="parameterTypeOptionalCustomModifiers">Tablica tablice typów. Każdej macierzy typy reprezentuje opcjonalne Modyfikatory niestandardowych do odpowiadającego mu parametru takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />. Jeśli określonego parametru brak opcjonalne modyfikatorów niestandardowych, określ <see langword="null" /> zamiast tablicę typów. Jeśli żaden z parametrów nie ma opcjonalne Modyfikatory niestandardowych, określ <see langword="null" /> zamiast tablicy tablic.</param>
        <summary>Dodaje nową metodę do typu, o określonej nazwie, atrybuty metody wywoływanie Konwencji, podpis metody i Modyfikatory niestandardowych.</summary>
        <returns>A <see cref="T:System.Reflection.Emit.MethodBuilder" /> obiekt reprezentujący metodę nowo dodany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, jeśli trzeba określić niestandardowy modyfikatorów. Jeśli musisz określić niestandardowe Modyfikatory po utworzeniu metody, jak na przykład metodą rodzajową, których typy parametrów są określane przez jego parametrów typu ogólnego służy <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> lub <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> przeciążenia metody, aby zdefiniować Metoda, a następnie użycie <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> metodę, aby określić parametr i zwracać typów z niestandardowych modyfikatorów.  
  
> [!NOTE]
>  Więcej informacji o niestandardowych Modyfikatory znajduje się w dokumentacji ECMA partycji II metadanych. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.  
  
 —lub—  
  
 Typ elementu nadrzędnego ta metoda jest interfejsem, a ta metoda nie jest wirtualny (<see langword="Overridable" /> w języku Visual Basic).  
  
 —lub—  
  
 Rozmiar <paramref name="parameterTypeRequiredCustomModifiers" /> lub <paramref name="parameterTypeOptionalCustomModifiers" /> nie równa się rozmiar <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Dla bieżącego typu dynamicznego <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineMethodOverride (methodInfoBody As MethodInfo, methodInfoDeclaration As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineMethodOverride(System::Reflection::MethodInfo ^ methodInfoBody, System::Reflection::MethodInfo ^ methodInfoDeclaration);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody">Treść metody, która ma być używany. To pole powinno być <see langword="MethodBuilder" /> obiektu.</param>
        <param name="methodInfoDeclaration">Metoda deklaracja, której ma być używany.</param>
        <summary>Określa treści podanej metody, która implementuje deklaracji podanej metody potencjalnie z inną nazwą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy używać tej metody można wyemitować metody przesłonięć lub implementacji interfejsów. Aby zastąpić metodę klasy podstawowej lub zaimplementować metodę interfejsu, że po prostu Emituj jako metody do przesłonięcia lub zaimplementowana, metody o tej samej nazwie i podpisie jak pokazano w przykładzie kodu.  
  
 <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> Metoda jest używana podczas treści metody i deklaracji metody mieć różne nazwy. Na przykład klasa może przesłaniać metody klasy podstawowej i udostępniają osobne implementacji dla elementu członkowskiego interfejsu o takiej samej nazwie, jak pokazano w przykładzie kodu.  
  
 `DefineMethodOverride` definiuje `methodimpl`, który składa się z pary tokenów metadanych. Jednego tokenu punktów do implementacji i innych punktów token deklaracji, który implementuje treści. Treść musi być zdefiniowana w typie implementację metody jest zdefiniowana na i treści musi być wirtualna (`Overridable` w języku Visual Basic). Deklaracja może pełnić metoda w interfejsie zaimplementowany przez typ, metoda w klasie pochodnej lub metody w typie. Deklaracja jest tylko do interfejsu, zmiany miejsca zdefiniowane dla interfejsu. Jeśli zgłoszenia do metody na typ podstawowy, zostanie zastąpiona miejsce dla metody i duplikaty dla przeciążonej również zostają zastąpione. Przeciążonej nie może być rzeczywiste metodę, która jest zadeklarowana. Jeśli metoda jest do tego samego typu, zastępuje gniazda, a duplikaty dla metod zastąpionego zostaną zastąpione.  
  
> [!NOTE]
>  Aby uzyskać więcej informacji na temat impls metody, zobacz `MethodImpl` w dokumentacji ECMA partycji II metadanych. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
> [!IMPORTANT]
>  Po <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> metoda jest wywoływana, niektóre funkcje `methodInfoBody` nie można zmienić. Na przykład nie można zastosować atrybutów do parametrów typu ogólnego `methodInfoBody` przy użyciu <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> metody. Jeśli musisz użyć <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> metody zrobić po wszystkich właściwości `methodInfoBody` zostały zdefiniowane.  
  
   
  
## Examples  
 Poniższy przykład kodu zawiera interfejs `I` za pomocą metody `M()`, klasę podstawową `A` implementującej interfejs i Klasa pochodna `C` który zastępuje implementację klasy podstawowej `M()` , a także zapewnia osobne jawnej implementacji `I.M()`.  
  
 `main()` Metody przykładowy kod przedstawia sposób Emituj klasy pochodnej `C`. Zastąpienie z `A.M()` odbywa się za pomocą metody emitowanie `M()` z tym samym podpisie. Jednak do oddzielnych implementacji programu `I.M()`, należy zdefiniować treści metody, a następnie użyć <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> do kojarzenia danej treści metody z <xref:System.Reflection.MethodInfo> reprezentujący `I.M()`. Nazwa treści metody nie ma znaczenia.  
  
 Przykład kodu tworzy wystąpienie klasy emitowany. Uzyskuje <xref:System.Reflection.MethodInfo> obiekt do `I.M()`, i używa go do wywołania emitowany klasy przez jawne implementacja interfejsu. Następnie uzyskuje <xref:System.Reflection.MethodInfo> obiekt do `A.M()`i używa go do wywołania emitowany klasy przesłonięcia tej metody.  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="methodInfoBody" /> nie należy do tej klasy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="methodInfoBody" /> lub <paramref name="methodInfoDeclaration" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Typ deklarujący <paramref name="methodInfoBody" /> nie jest reprezentowany przez ten typ <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineNestedType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje typu zagnieżdżonego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Krótka nazwa typu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <summary>Definiuje typu zagnieżdżonego, jego nazwę.</summary>
        <returns>Zdefiniowanego typu zagnieżdżonego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do tworzenia zagnieżdżonych typów nawet po <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metoda została wywołana dla typu otaczającego.  
  
 Zagnieżdżony typ musi być ukończone przed można uwzględnić w nim przy użyciu <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, lub <xref:System.Type.GetNestedTypes%2A>.  
  
 Zobacz opis <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> kolejności, w którym można ukończyć zagnieżdżone typy i zagnieżdżenia.  
  
 Zduplikowane nazwy nie jest zawsze utworzony, jeśli `name` jest taka sama jak nazwa wcześniej zdefiniowanego typu lub typu zagnieżdżonego. Na duplikaty, pełnej nazwy muszą być takie same, w tym przestrzeń nazw i wszystkie typy zagnieżdżenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero lub większa niż 1023.  
  
 —lub—  
  
 Ta operacja spowodowałaby utworzenie typu duplikat <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> w bieżącym zestawie.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Krótka nazwa typu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attr">Atrybuty typu.</param>
        <summary>Definiuje typem zagnieżdżonym podanej nazwy i atrybutów.</summary>
        <returns>Zdefiniowanego typu zagnieżdżonego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do tworzenia zagnieżdżonych typów nawet po <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metoda została wywołana dla typu otaczającego.  
  
 Zagnieżdżony typ musi być ukończone przed można uwzględnić w nim przy użyciu <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, lub <xref:System.Type.GetNestedTypes%2A>.  
  
 Zobacz opis <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> kolejności, w którym można ukończyć zagnieżdżone typy i zagnieżdżenia.  
  
 Zduplikowane nazwy nie jest zawsze utworzony, jeśli `name` jest taka sama jak nazwa wcześniej zdefiniowanego typu lub typu zagnieżdżonego. Na duplikaty, pełnej nazwy muszą być takie same, w tym przestrzeń nazw i wszystkie typy zagnieżdżenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie określono atrybutu zagnieżdżonych.  
  
 —lub—  
  
 Ten typ jest zapieczętowany.  
  
 —lub—  
  
 Ten typ jest tablicą.  
  
 —lub—  
  
 Ten typ jest interfejsem, ale typu zagnieżdżonego nie jest interfejsem.  
  
 —lub—  
  
 Długość <paramref name="name" /> wynosi zero lub większa niż 1023.  
  
 —lub—  
  
 Ta operacja spowodowałaby utworzenie typu duplikat <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> w bieżącym zestawie.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Krótka nazwa typu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attr">Atrybuty typu.</param>
        <param name="parent">Typ, rozszerzający typu zagnieżdżonego.</param>
        <summary>Definiuje typu zagnieżdżonego, jego nazwa, atrybuty i typ, który rozszerza.</summary>
        <returns>Zdefiniowanego typu zagnieżdżonego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do tworzenia zagnieżdżonych typów nawet po <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metoda została wywołana dla typu otaczającego.  
  
 Zagnieżdżony typ musi być ukończone przed można uwzględnić w nim przy użyciu <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, lub <xref:System.Type.GetNestedTypes%2A>.  
  
 Zobacz opis <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> kolejności, w którym można ukończyć zagnieżdżone typy i zagnieżdżenia.  
  
 Zduplikowane nazwy nie jest zawsze utworzony, jeśli `name` jest taka sama jak nazwa wcześniej zdefiniowanego typu lub typu zagnieżdżonego. Na duplikaty, pełnej nazwy muszą być takie same, w tym przestrzeń nazw i wszystkie typy zagnieżdżenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie określono atrybutu zagnieżdżonych.  
  
 —lub—  
  
 Ten typ jest zapieczętowany.  
  
 —lub—  
  
 Ten typ jest tablicą.  
  
 —lub—  
  
 Ten typ jest interfejsem, ale typu zagnieżdżonego nie jest interfejsem.  
  
 —lub—  
  
 Długość <paramref name="name" /> wynosi zero lub większa niż 1023.  
  
 —lub—  
  
 Ta operacja spowodowałaby utworzenie typu duplikat <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> w bieżącym zestawie.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Krótka nazwa typu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attr">Atrybuty typu.</param>
        <param name="parent">Typ, rozszerzający typu zagnieżdżonego.</param>
        <param name="typeSize">Całkowity rozmiar tego typu.</param>
        <summary>Definiuje typu zagnieżdżonego, biorąc pod uwagę jego nazwę, atrybuty, łączny rozmiar tego typu, a typ, który rozszerza.</summary>
        <returns>Zdefiniowanego typu zagnieżdżonego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do tworzenia zagnieżdżonych typów nawet po <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metoda została wywołana dla typu otaczającego.  
  
 Zagnieżdżony typ musi być ukończone przed można uwzględnić w nim przy użyciu <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, lub <xref:System.Type.GetNestedTypes%2A>.  
  
 Zobacz opis <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> kolejności, w którym można ukończyć zagnieżdżone typy i zagnieżdżenia.  
  
 Zduplikowane nazwy nie jest zawsze utworzony, jeśli `name` jest taka sama jak nazwa wcześniej zdefiniowanego typu lub typu zagnieżdżonego. Na duplikaty, pełnej nazwy muszą być takie same, w tym przestrzeń nazw i wszystkie typy zagnieżdżenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie określono atrybutu zagnieżdżonych.  
  
 —lub—  
  
 Ten typ jest zapieczętowany.  
  
 —lub—  
  
 Ten typ jest tablicą.  
  
 —lub—  
  
 Ten typ jest interfejsem, ale typu zagnieżdżonego nie jest interfejsem.  
  
 —lub—  
  
 Długość <paramref name="name" /> wynosi zero lub większa niż 1023.  
  
 —lub—  
  
 Ta operacja spowodowałaby utworzenie typu duplikat <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> w bieżącym zestawie.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">Krótka nazwa typu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attr">Atrybuty typu.</param>
        <param name="parent">Typ, rozszerzający typu zagnieżdżonego.</param>
        <param name="packSize">Rozmiar pakowania typu.</param>
        <summary>Definiuje typem zagnieżdżonym podanej nazwy, atrybuty, typ, który rozszerza oraz rozmiar pakowania.</summary>
        <returns>Zdefiniowanego typu zagnieżdżonego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do tworzenia zagnieżdżonych typów nawet po <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metoda została wywołana dla typu otaczającego.  
  
 Zagnieżdżony typ musi być ukończone przed można uwzględnić w nim przy użyciu <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, lub <xref:System.Type.GetNestedTypes%2A>.  
  
 Zobacz opis <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> kolejności, w którym można ukończyć zagnieżdżone typy i zagnieżdżenia.  
  
 Zduplikowane nazwy nie jest zawsze utworzony, jeśli `name` jest taka sama jak nazwa wcześniej zdefiniowanego typu lub typu zagnieżdżonego. Na duplikaty, pełnej nazwy muszą być takie same, w tym przestrzeń nazw i wszystkie typy zagnieżdżenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie określono atrybutu zagnieżdżonych.  
  
 —lub—  
  
 Ten typ jest zapieczętowany.  
  
 —lub—  
  
 Ten typ jest tablicą.  
  
 —lub—  
  
 Ten typ jest interfejsem, ale typu zagnieżdżonego nie jest interfejsem.  
  
 —lub—  
  
 Długość <paramref name="name" /> wynosi zero lub większa niż 1023.  
  
 —lub—  
  
 Ta operacja spowodowałaby utworzenie typu duplikat <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> w bieżącym zestawie.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Krótka nazwa typu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attr">Atrybuty typu.</param>
        <param name="parent">Typ, rozszerzający typu zagnieżdżonego.</param>
        <param name="interfaces">Interfejsy, które implementuje typu zagnieżdżonego.</param>
        <summary>Definiuje typu zagnieżdżonego, jego nazwa, atrybuty, typ, który rozszerza i interfejsów, które implementuje.</summary>
        <returns>Zdefiniowanego typu zagnieżdżonego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do tworzenia zagnieżdżonych typów nawet po <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metoda została wywołana dla typu otaczającego.  
  
 Zagnieżdżony typ musi być ukończone przed można uwzględnić w nim przy użyciu <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, lub <xref:System.Type.GetNestedTypes%2A>.  
  
 Zobacz opis <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> kolejności, w którym można ukończyć zagnieżdżone typy i zagnieżdżenia.  
  
 Zduplikowane nazwy nie jest zawsze utworzony, jeśli `name` jest taka sama jak nazwa wcześniej zdefiniowanego typu lub typu zagnieżdżonego. Na duplikaty, pełnej nazwy muszą być takie same, w tym przestrzeń nazw i wszystkie typy zagnieżdżenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie określono atrybutu zagnieżdżonych.  
  
 —lub—  
  
 Ten typ jest zapieczętowany.  
  
 —lub—  
  
 Ten typ jest tablicą.  
  
 —lub—  
  
 Ten typ jest interfejsem, ale typu zagnieżdżonego nie jest interfejsem.  
  
 —lub—  
  
 Długość <paramref name="name" /> wynosi zero lub większa niż 1023.  
  
 —lub—  
  
 Ta operacja spowodowałaby utworzenie typu duplikat <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> w bieżącym zestawie.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  
  
 —lub—  
  
 Element <paramref name="interfaces" /> tablica jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize, int typeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Krótka nazwa typu. <c>Nazwa</c> nie może zawierać osadzone wartości zerowe.</param>
        <param name="attr">Atrybuty typu.</param>
        <param name="parent">Typ, rozszerzający typu zagnieżdżonego.</param>
        <param name="packSize">Rozmiar pakowania typu.</param>
        <param name="typeSize">Całkowity rozmiar tego typu.</param>
        <summary>Definiuje typem zagnieżdżonym danej jego nazwę, atrybuty, rozmiar i typ, który rozszerza.</summary>
        <returns>Zdefiniowanego typu zagnieżdżonego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje <see langword="PInvoke" /> metody.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa <see langword="PInvoke" /> metody. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="dllName">Nazwa biblioteki dll, w którym <see langword="PInvoke" /> metoda jest zdefiniowana.</param>
        <param name="attributes">Atrybuty metody.</param>
        <param name="callingConvention">Konwencja wywołania metody.</param>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <param name="nativeCallConv">Natywną Konwencję wywoływania.</param>
        <param name="nativeCharSet">Zestaw znaków natywnego metody.</param>
        <summary>Definiuje <see langword="PInvoke" /> metody podanej nazwy, nazwa DLL, w którym jest zdefiniowany metody, atrybuty metody, konwencja wywołania metody, zwracany typ metody, typów parametrów, metody i <see langword="PInvoke" /> flagi.</summary>
        <returns>Zdefiniowanych <see langword="PInvoke" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybuty zaimportować niektóre biblioteki DLL (zobacz opis <xref:System.Runtime.InteropServices.DllImportAttribute>) nie można określić jako argumenty tej metody. Na przykład plik DLL import — atrybut <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> musi być dodany po `PInvoke` metody jest tworzony, jeśli metoda zwróci wartość. W przykładzie, jak to zrobić.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> metodę w celu utworzenia `PInvoke` metody oraz sposobu dodawania <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> Flaga flagi implementacji metod po utworzeniu <xref:System.Reflection.Emit.MethodBuilder>, za pomocą <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> i <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>metody.  
  
> [!IMPORTANT]
>  Aby uzyskać wartość zwracaną zera, należy dodać <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flagi.  
  
 W przykładzie jest tworzony z jednego modułu dynamicznego i jednego typu, zestawów dynamicznych `MyType`, który zawiera `PInvoke` metody. `PInvoke` Metody reprezentuje Win32 `GetTickCount` funkcji.  
  
 Po uruchomieniu przykładzie wykonuje `PInvoke` metody. Ponadto zapisuje zestawie dynamicznym jako PInvokeTest.dll. Można użyć [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do sprawdzenia `MyType` klasy i `static` (`Shared` w języku Visual Basic) `PInvoke` zawiera metody. Można skompilować programu Visual Basic lub C#, który używa statycznych `MyType.GetTickCount` metody, umieszczając odwołanie do biblioteki DLL, po uruchomieniu csc.exe lub vbc.exe; na przykład `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Metoda nie jest statyczne.  
  
 —lub—  
  
 Typ nadrzędny jest interfejsem.  
  
 —lub—  
  
 Metoda jest abstrakcyjna.  
  
 —lub—  
  
 Metoda została wcześniej określona.  
  
 —lub—  
  
 Długość <paramref name="name" /> lub <paramref name="dllName" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> lub <paramref name="dllName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ zawierający wcześniej utworzono za pomocą <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa <see langword="PInvoke" /> metody. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="dllName">Nazwa biblioteki dll, w którym <see langword="PInvoke" /> metoda jest zdefiniowana.</param>
        <param name="entryName">Nazwa punktu wejścia w bibliotece DLL.</param>
        <param name="attributes">Atrybuty metody.</param>
        <param name="callingConvention">Konwencja wywołania metody.</param>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <param name="nativeCallConv">Natywną Konwencję wywoływania.</param>
        <param name="nativeCharSet">Zestaw znaków natywnego metody.</param>
        <summary>Definiuje <see langword="PInvoke" /> metody podanej nazwy, nazwa DLL, w którym jest zdefiniowany metody, nazwę punktu wejścia, atrybuty metody, konwencja wywołania metody, zwracany typ metody, typy parametrów metody , a <see langword="PInvoke" /> flagi.</summary>
        <returns>Zdefiniowanych <see langword="PInvoke" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybuty zaimportować niektóre biblioteki DLL (zobacz opis <xref:System.Runtime.InteropServices.DllImportAttribute>) nie można określić jako argumenty tej metody. Na przykład plik DLL import — atrybut <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> musi być dodany po `PInvoke` metody jest tworzony, jeśli metoda zwróci wartość. W przykładzie, jak to zrobić.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> metodę w celu utworzenia `PInvoke` metody oraz sposobu dodawania <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> Flaga flagi implementacji metod po utworzeniu <xref:System.Reflection.Emit.MethodBuilder>, za pomocą <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> i <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> metody.  
  
> [!IMPORTANT]
>  Aby uzyskać wartość zwracaną zera, należy dodać <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flagi.  
  
 W przykładzie jest tworzony z jednego modułu dynamicznego i jednego typu, zestawów dynamicznych `MyType`, który zawiera `PInvoke` metody. `PInvoke` Metody reprezentuje Win32 `GetTickCount` funkcji.  
  
 Po uruchomieniu przykładzie wykonuje `PInvoke` metody. Ponadto zapisuje zestawie dynamicznym jako PInvokeTest.dll. Można użyć [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do sprawdzenia `MyType` klasy i `static` (`Shared` w języku Visual Basic) `PInvoke` zawiera metody. Można skompilować programu Visual Basic lub C#, który używa statycznych `MyType.GetTickCount` metody, umieszczając odwołanie do biblioteki DLL, po uruchomieniu csc.exe lub vbc.exe; na przykład `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Metoda nie jest statyczne.  
  
 —lub—  
  
 Typ nadrzędny jest interfejsem.  
  
 —lub—  
  
 Metoda jest abstrakcyjna.  
  
 —lub—  
  
 Metoda została wcześniej określona.  
  
 —lub—  
  
 Długość <paramref name="name" />, <paramref name="dllName" />, lub <paramref name="entryName" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />, <paramref name="dllName" />, lub <paramref name="entryName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ zawierający wcześniej utworzono za pomocą <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa <see langword="PInvoke" /> metody. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="dllName">Nazwa biblioteki dll, w którym <see langword="PInvoke" /> metoda jest zdefiniowana.</param>
        <param name="entryName">Nazwa punktu wejścia w bibliotece DLL.</param>
        <param name="attributes">Atrybuty metody.</param>
        <param name="callingConvention">Konwencja wywołania metody.</param>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="returnTypeRequiredCustomModifiers">Tablica typów reprezentujący wymagane Modyfikatory niestandardowych, takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />, dla zwracanego typu metody. Jeśli typ zwracany jest Brak wymaganego modyfikatorów niestandardowych, określić <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Tablica typów reprezentujący opcjonalne Modyfikatory niestandardowych, takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />, dla zwracanego typu metody. Jeśli typ zwracany jest brak opcjonalne modyfikatorów niestandardowych, określić <see langword="null" />.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <param name="parameterTypeRequiredCustomModifiers">Tablica tablice typów. Każdej macierzy typy reprezentuje wymagane Modyfikatory niestandardowych do odpowiadającego mu parametru takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />. Jeśli określonego parametru Brak wymaganego modyfikatorów niestandardowych, określ <see langword="null" /> zamiast tablicę typów. Jeśli żaden z parametrów mają odpowiednie Modyfikatory niestandardowych, określ <see langword="null" /> zamiast tablicy tablic.</param>
        <param name="parameterTypeOptionalCustomModifiers">Tablica tablice typów. Każdej macierzy typy reprezentuje opcjonalne Modyfikatory niestandardowych do odpowiadającego mu parametru takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />. Jeśli określonego parametru brak opcjonalne modyfikatorów niestandardowych, określ <see langword="null" /> zamiast tablicę typów. Jeśli żaden z parametrów nie ma opcjonalne Modyfikatory niestandardowych, określ <see langword="null" /> zamiast tablicy tablic.</param>
        <param name="nativeCallConv">Natywną Konwencję wywoływania.</param>
        <param name="nativeCharSet">Zestaw znaków natywnego metody.</param>
        <summary>Definiuje <see langword="PInvoke" /> metody podanej nazwy, nazwa DLL, w którym jest zdefiniowany metody, nazwę punktu wejścia, atrybuty metody, konwencja wywołania metody, zwracany typ metody, typy parametrów metody , <see langword="PInvoke" /> flagi i Modyfikatory niestandardowych parametrów i typ zwracany.</summary>
        <returns>A <see cref="T:System.Reflection.Emit.MethodBuilder" /> reprezentujący do zdefiniowanego <see langword="PInvoke" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybuty zaimportować niektóre biblioteki DLL (zobacz opis <xref:System.Runtime.InteropServices.DllImportAttribute>) nie można określić jako argumenty tej metody. Na przykład plik DLL import — atrybut <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> musi być dodany po `PInvoke` metody jest tworzony, jeśli metoda zwróci wartość. W przykładzie, jak to zrobić.  
  
> [!NOTE]
>  Więcej informacji o niestandardowych Modyfikatory znajduje się w dokumentacji ECMA partycji II metadanych. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia [\], typ\[\], typ\[\], typ\[\]\[\], typ\[ \] \<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A > metodę w celu utworzenia `PInvoke` metody oraz sposobu dodawania <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> Flaga flagi implementacji metod po utworzeniu <xref:System.Reflection.Emit.MethodBuilder>, za pomocą <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> i <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> metody.  
  
 W przykładzie jest tworzony z jednego modułu dynamicznego i jednego typu, zestawów dynamicznych `MyType`, który zawiera `PInvoke` metody. `PInvoke` Metody reprezentuje Win32 `GetTickCount` funkcji.  
  
> [!IMPORTANT]
>  Aby uzyskać wartość zwracaną zera, należy dodać <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flagi.  
  
> [!NOTE]
>  W przykładzie użyto przeciążenia, która nie określa niestandardowy modyfikatorów. Aby określić niestandardowe modyfikatorów, zmień przykładowy kod, aby użyć tego przeciążenia metody.  
  
 Po uruchomieniu przykładzie wykonuje `PInvoke` metody. Ponadto zapisuje zestawie dynamicznym jako PInvokeTest.dll. Można użyć [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do sprawdzenia `MyType` klasy i `static` (`Shared` w języku Visual Basic) `PInvoke` zawiera metody. Można skompilować programu Visual Basic lub C#, który używa statycznych `MyType.GetTickCount` metody, umieszczając odwołanie do biblioteki DLL, po uruchomieniu csc.exe lub vbc.exe; na przykład `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Metoda nie jest statyczne.  
  
 —lub—  
  
 Typ nadrzędny jest interfejsem.  
  
 —lub—  
  
 Metoda jest abstrakcyjna.  
  
 —lub—  
  
 Metoda została wcześniej określona.  
  
 —lub—  
  
 Długość <paramref name="name" />, <paramref name="dllName" />, lub <paramref name="entryName" /> wynosi zero.  
  
 —lub—  
  
 Rozmiar <paramref name="parameterTypeRequiredCustomModifiers" /> lub <paramref name="parameterTypeOptionalCustomModifiers" /> nie równa się rozmiar <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />, <paramref name="dllName" />, lub <paramref name="entryName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 Dla bieżącego typu dynamicznego <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje nową właściwość do typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attributes">Atrybuty właściwości.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="parameterTypes">Typy parametrów właściwości.</param>
        <summary>Dodaje nową właściwość typu, o podanej nazwie i podpisie właściwości.</summary>
        <returns>Właściwości zdefiniowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zdefiniować właściwości dynamicznych do uzyskania <xref:System.Reflection.Emit.PropertyBuilder> specyfikacji. Należy pamiętać, że `PropertyBuilder` musi mieć również odpowiedniego <xref:System.Reflection.Emit.MethodBuilder>, które będą znajdować się logiki IL dla właściwości.  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  
  
 —lub—  
  
 Żadnego z elementów <paramref name="parameterTypes" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attributes">Atrybuty właściwości.</param>
        <param name="callingConvention">Konwencja wywołania metody dostępu właściwości.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="parameterTypes">Typy parametrów właściwości.</param>
        <summary>Dodaje nową właściwość z typem, o podanej nazwie, atrybuty, konwencja wywołania i podpis właściwości.</summary>
        <returns>Właściwości zdefiniowane.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  
  
 —lub—  
  
 Żadnego z elementów <paramref name="parameterTypes" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attributes">Atrybuty właściwości.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="returnTypeRequiredCustomModifiers">Tablica typów reprezentujący wymagane Modyfikatory niestandardowych, takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />, dla typu zwracanych danych właściwości. Jeśli typ zwracany jest Brak wymaganego modyfikatorów niestandardowych, określić <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Tablica typów reprezentujący opcjonalne Modyfikatory niestandardowych, takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />, dla typu zwracanych danych właściwości. Jeśli typ zwracany jest brak opcjonalne modyfikatorów niestandardowych, określić <see langword="null" />.</param>
        <param name="parameterTypes">Typy parametrów właściwości.</param>
        <param name="parameterTypeRequiredCustomModifiers">Tablica tablice typów. Każdej macierzy typy reprezentuje wymagane Modyfikatory niestandardowych do odpowiadającego mu parametru takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />. Jeśli określonego parametru Brak wymaganego modyfikatorów niestandardowych, określ <see langword="null" /> zamiast tablicę typów. Jeśli żaden z parametrów mają odpowiednie Modyfikatory niestandardowych, określ <see langword="null" /> zamiast tablicy tablic.</param>
        <param name="parameterTypeOptionalCustomModifiers">Tablica tablice typów. Każdej macierzy typy reprezentuje opcjonalne Modyfikatory niestandardowych do odpowiadającego mu parametru takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />. Jeśli określonego parametru brak opcjonalne modyfikatorów niestandardowych, określ <see langword="null" /> zamiast tablicę typów. Jeśli żaden z parametrów nie ma opcjonalne Modyfikatory niestandardowych, określ <see langword="null" /> zamiast tablicy tablic.</param>
        <summary>Dodaje nową właściwość z typem, o podanej nazwie, właściwości podpisu i Modyfikatory niestandardowych.</summary>
        <returns>Właściwości zdefiniowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla projektantów kompilatory zarządzanych.  
  
> [!NOTE]
>  Więcej informacji o niestandardowych Modyfikatory znajduje się w dokumentacji ECMA partycji II metadanych. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />  
  
 —lub—  
  
 Żadnego z elementów <paramref name="parameterTypes" /> jest tablicy <see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attributes">Atrybuty właściwości.</param>
        <param name="callingConvention">Konwencja wywołania metody dostępu właściwości.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="returnTypeRequiredCustomModifiers">Tablica typów reprezentujący wymagane Modyfikatory niestandardowych, takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />, dla typu zwracanych danych właściwości. Jeśli typ zwracany jest Brak wymaganego modyfikatorów niestandardowych, określić <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Tablica typów reprezentujący opcjonalne Modyfikatory niestandardowych, takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />, dla typu zwracanych danych właściwości. Jeśli typ zwracany jest brak opcjonalne modyfikatorów niestandardowych, określić <see langword="null" />.</param>
        <param name="parameterTypes">Typy parametrów właściwości.</param>
        <param name="parameterTypeRequiredCustomModifiers">Tablica tablice typów. Każdej macierzy typy reprezentuje wymagane Modyfikatory niestandardowych do odpowiadającego mu parametru takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />. Jeśli określonego parametru Brak wymaganego modyfikatorów niestandardowych, określ <see langword="null" /> zamiast tablicę typów. Jeśli żaden z parametrów mają odpowiednie Modyfikatory niestandardowych, określ <see langword="null" /> zamiast tablicy tablic.</param>
        <param name="parameterTypeOptionalCustomModifiers">Tablica tablice typów. Każdej macierzy typy reprezentuje opcjonalne Modyfikatory niestandardowych do odpowiadającego mu parametru takich jak <see cref="T:System.Runtime.CompilerServices.IsConst" />. Jeśli określonego parametru brak opcjonalne modyfikatorów niestandardowych, określ <see langword="null" /> zamiast tablicę typów. Jeśli żaden z parametrów nie ma opcjonalne Modyfikatory niestandardowych, określ <see langword="null" /> zamiast tablicy tablic.</param>
        <summary>Dodaje nową właściwość typu, o podanej nazwie wywoływanie Konwencji, właściwości podpisu i Modyfikatory niestandardowych.</summary>
        <returns>Właściwości zdefiniowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla projektantów kompilatory zarządzanych.  
  
> [!NOTE]
>  Więcej informacji o niestandardowych Modyfikatory znajduje się w dokumentacji ECMA partycji II metadanych. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 To przeciążenie metody została wprowadzona w systemie [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  
  
 —lub—  
  
 Żadnego z elementów <paramref name="parameterTypes" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineTypeInitializer () As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineTypeInitializer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Definiuje inicjator dla tego typu.</summary>
        <returns>Zwraca inicjatora typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicjator utworzone zawsze jest publiczny.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia, Konstruktor inicjowania przy użyciu `DefineTypeInitializer`.  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Typ zawierający wcześniej utworzono za pomocą <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa używana do odwoływania się do danych. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="size">Rozmiar pola danych.</param>
        <param name="attributes">Atrybuty dla pola.</param>
        <summary>Określa pole niezainicjowanych danych w <see langword=".sdata" /> sekcji pliku przenośny plik wykonywalny (PE).</summary>
        <returns>Pole danych referencyjnych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pole utworzonej za pomocą tej metody jest `static`, nawet jeśli nie zostanie uwzględniony `FieldAttributes.Static` w `attributes` parametru.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano stosowania `DefineUninitializedData` można utworzyć niezainicjowanych danych pola w typu dynamicznego:  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.  
  
 —lub—  
  
 <paramref name="size" /> jest mniejsze niż lub równa zero, lub większa niż lub równa 0x003f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pełną ścieżkę tego typu.</summary>
        <value>Tylko do odczytu. Pobiera pełną ścieżkę tego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony ma format "enclosingTypeFullName + nestedTypeName" zagnieżdżone typy i "typeName" dla typów-nested.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą Kowariancja i ograniczeń specjalnych bieżącego parametru typu ogólnego.</summary>
        <value>Bitowe połączenie <see cref="T:System.Reflection.GenericParameterAttributes" /> wartości, które opisano Kowariancja i ograniczeń specjalnych bieżącego parametru typu ogólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Gdy emitowanie kodu, parametru typu ogólnego jest reprezentowana przez <xref:System.Reflection.Emit.GenericTypeParameterBuilder> obiektu, a nie przez <xref:System.Reflection.Emit.TypeBuilder> obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pozycję parametru typu na liście parametrów typu zadeklarowany parametr typu ogólnego.</summary>
        <value>Jeśli bieżący <see cref="T:System.Reflection.Emit.TypeBuilder" /> obiekt reprezentuje parametr typu ogólnego, pozycja parametru typu na liście parametrów typu typu ogólnego, który zadeklarowany parametr; w przeciwnym razie jest niezdefiniowana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Gdy emitowanie kodu, parametru typu ogólnego jest reprezentowana przez <xref:System.Reflection.Emit.GenericTypeParameterBuilder> obiektu, a nie przez <xref:System.Reflection.Emit.TypeBuilder> obiektu.  
  
 Jeśli bieżący <xref:System.Reflection.Emit.TypeBuilder> nie reprezentuje parametr typu ogólnego, wartość ta właściwość jest niezdefiniowana. Użyj <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> umożliwia określenie, czy bieżący <xref:System.Reflection.Emit.TypeBuilder> reprezentuje parametr typu ogólnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::ConstructorInfo ^ GetConstructor(Type ^ type, System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="type">Skonstruowanego typu ogólnego, którego konstruktor jest zwracany.</param>
        <param name="constructor">Konstruktor w definicji typu ogólnego <c>typu</c>, która określa, które konstruktora <c>typu</c> do zwrócenia.</param>
        <summary>Zwraca konstruktora określonego skonstruowanego typu ogólnego odpowiada określony Konstruktor definicji typu ogólnego.</summary>
        <returns>A <see cref="T:System.Reflection.ConstructorInfo" /> obiekt, który reprezentuje konstruktora <paramref name="type" /> odpowiadający <paramref name="constructor" />, który określa konstruktora należących do definicji typu ogólnego <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> Metody umożliwia uzyskanie <xref:System.Reflection.ConstructorInfo> obiekt, który reprezentuje konstruktora skonstruowanego typu ogólnego, którego definicja typu ogólnego jest reprezentowana przez <xref:System.Reflection.Emit.TypeBuilder> obiektu.  
  
 Na przykład, załóżmy, że masz <xref:System.Reflection.Emit.TypeBuilder> obiekt, który reprezentuje typ `G<T>` w składni języka C# (`G(Of T)` w języku Visual Basic `generic <T> ref class G` w języku C++) i <xref:System.Reflection.Emit.ConstructorBuilder> obiekt, który reprezentuje konstruktora `G<T>`. Załóżmy, że `G<T>` ma z parametrem typu metody ogólnej `U` tworzącą wystąpienie skonstruowanego typu `G<U>`. Aby Emituj kod w celu utworzenia wystąpienia typu skonstruowane, należy <xref:System.Reflection.ConstructorInfo> typu skonstruowany obiekt, który reprezentuje konstruktora tego — innymi słowy, który tworzy wystąpienie `G<U>`. Aby to zrobić, należy najpierw wywołać <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metoda <xref:System.Reflection.Emit.TypeBuilder> obiektu, określając <xref:System.Reflection.Emit.GenericTypeParameterBuilder> obiekt, który reprezentuje `U` jako argument typu. Następnie wywołaj <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> metody z wartością zwracaną z <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metody jako parametr `type` i <xref:System.Reflection.Emit.ConstructorBuilder> obiekt, który reprezentuje konstruktora `G<U>` jako parametr `constructor`. Wartość zwracana jest <xref:System.Reflection.ConstructorInfo> obiektów należy Emituj wywołanie funkcji. Przykład kodu pokazuje, w tym scenariuszu.  
  
   
  
## Examples  
 Poniższy przykład kodu zawiera kod źródłowy dla klasy ogólnej o nazwie `Sample` mający parametru typu o nazwie `T`. Klasa ma pole o nazwie `Field`, typu `T`i rodzajowy metodę o nazwie `GM` w jego własnej parametru typu o nazwie `U`. Metoda `GM` tworzy wystąpienie `Sample`, podstawiając własne parametru typu `U` dla parametru typu `Sample`i są przechowywane jego parametru wejściowego w `Field`. Ten kod źródłowy jest skompilowany, ale nie jest używany; można wyświetlić za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) i porównaj je z kodu emitowane przez klasę `Example`.  
  
 Kod w klasie `Example` zademonstrowano użycie <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> metodę Emituj Kod rodzajowy. `Main` Metody klasy `Example` tworzy dynamiczne zestawu zawierającego klasę o nazwie `Sample` i używa <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> metodę, aby wprowadzić ogólne przez dodanie parametru typu o nazwie `T`. Domyślny konstruktor i pole o nazwie `Field`, typu `T`, są dodawane do klasy `Sample`. Metoda `GM` zostanie dodany i zamieniło metody ogólnej przy użyciu <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> metody. Parametr typu `GM` nosi nazwę `U`. Po zdefiniowaniu parametru typu podpis `GM` jest dodawany przy użyciu <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> metody. Brak nie zwracany typ i nr wymagane lub niestandardowych modyfikatory, wszystkie parametry tej metody są `null` z wyjątkiem `parameterTypes`; `parameterTypes` ustawia typ parametru tylko metody `U`, parametru typu ogólnego metody. Treść metody tworzy wystąpienia typu skonstruowane `Sample<U>` (`Sample(Of U)` w języku Visual Basic), przypisuje parametr metody `Field`, a następnie drukuje wartość `Field`. <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> Metoda służy do tworzenia <xref:System.Reflection.ConstructorInfo> reprezentujący domyślny konstruktor obiektu skonstruowanego typu ogólnego `Sample<U>` w <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instrukcji, która tworzy wystąpienie.  
  
 Fikcyjny typ został zdefiniowany dla metody punktu wejścia `Main`. W treści `Main`, statycznych `GM` wywołaniu metody w typie ogólnym skonstruowane `Sample<int>` (`Sample(Of Integer)` w języku Visual Basic), z typem <xref:System.String> podstawić `U`.  
  
 Po uruchomieniu przykładowy kod zapisuje emitowany zestawu jako TypeBuilderGetFieldExample.exe. Możesz uruchomić TypeBuilderGetFieldExample.exe i służy [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) porównywanie emitowany kodu kod `Sample` klasy, która ma zostać skompilowany w samej przykładu kodu.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> reprezentuje typu ogólnego.  
  
 —lub—  
  
 <paramref name="type" /> nie jest typu <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 —lub—  
  
 Typ deklarujący <paramref name="constructor" /> nie jest definicją typu ogólnego.  
  
 —lub—  
  
 Typ deklarujący <paramref name="constructor" /> definicji typu ogólnego nie jest <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Musi to być flagę z bitowego <see cref="T:System.Reflection.BindingFlags" /> jako w <see langword="InvokeMethod" />, <see langword="NonPublic" />i tak dalej.</param>
        <summary>Zwraca tablicę <see cref="T:System.Reflection.ConstructorInfo" /> obiekty reprezentujące konstruktorów publicznych i niepublicznych zdefiniowane dla tej klasy, jak określono.</summary>
        <returns>Zwraca tablicę <see cref="T:System.Reflection.ConstructorInfo" /> obiektów reprezentującą określony konstruktorów zdefiniowanych dla tej klasy. Jeśli zdefiniowano ma konstruktorów, zwracana jest pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca atrybuty niestandardowe zdefiniowane dla tego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Określa, czy przeszukać łańcuch dziedziczenia tego elementu członkowskiego w celu znalezienia atrybutów.</param>
        <summary>Zwraca wszystkie atrybuty niestandardowe zdefiniowane dla tego typu.</summary>
        <returns>Zwraca tablicę obiektów reprezentującą wszystkie atrybuty niestandardowe tego typu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana dla typów niekompletne. Pobrać za pomocą typu <see cref="M:System.Type.GetType" /> i Wywołaj <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> w zwróconym <see cref="T:System.Type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Typ atrybutu do wyszukiwania. Zwracane są tylko atrybuty, które są przypisane do tego typu.</param>
        <param name="inherit">Określa, czy przeszukać łańcuch dziedziczenia tego elementu członkowskiego w celu znalezienia atrybutów.</param>
        <summary>Zwraca wszystkie atrybuty niestandardowe bieżącego typu, które są przypisane do określonego typu.</summary>
        <returns>Tablica z atrybutami niestandardowymi zdefiniowanymi dla bieżącego typu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana dla typów niekompletne. Pobrać za pomocą typu <see cref="M:System.Type.GetType" /> i Wywołaj <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> w zwróconym <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Typ musi być typem dostarczonym źródłowy system plików wykonywalnych.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołanie tej metody zawsze zwraca <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Ta metoda nie jest obsługiwana. Nie jest zwracana żadna wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zdarzenia do wyszukania.</param>
        <param name="bindingAttr">Bitowe połączenie <see cref="T:System.Reflection.BindingFlags" /> wartości, które ograniczą wyszukiwania.</param>
        <summary>Zwraca zdarzenia o określonej nazwie.</summary>
        <returns>
          <see cref="T:System.Reflection.EventInfo" /> Obiekt reprezentujący zdarzenie zadeklarowane lub dziedziczone przez ten typ o określonej nazwie lub <see langword="null" /> , jeśli nie ma żadnych wyników.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca zdarzenia zdefiniowane przez bieżącą <see cref="T:System.Reflection.Emit.TypeBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca zdarzenia publiczne zadeklarowane lub dziedziczone przez tego typu.</summary>
        <returns>Zwraca tablicę <see cref="T:System.Reflection.EventInfo" /> obiektów reprezentująca zdarzenia publiczne zadeklarowany lub dziedziczone przez tego typu. Jeśli brak publicznego zdarzeń, zwracana jest pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A> lub <xref:System.Reflection.Assembly.GetType%2A> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Bitowe połączenie <see cref="T:System.Reflection.BindingFlags" /> wartości, które ograniczą wyszukiwania.</param>
        <summary>Zwraca zdarzenia publicznego i niepublicznych zadeklarowanych przez tego typu.</summary>
        <returns>Zwraca tablicę <see cref="T:System.Reflection.EventInfo" /> obiekty reprezentujące zdarzenia zadeklarowane lub dziedziczone przez ten typ, spełniających określone powiązanie flagi. Jeśli brak zdarzeń pasujących, zwracana jest pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca pola zdefiniowane przez bieżącą <see cref="T:System.Reflection.Emit.TypeBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa pola, które ma być pobrana.</param>
        <param name="bindingAttr">Musi to być flagę z bitowego <see cref="T:System.Reflection.BindingFlags" /> jako w <see langword="InvokeMethod" />, <see langword="NonPublic" />i tak dalej.</param>
        <summary>Zwraca pola określone przez podanej nazwie.</summary>
        <returns>Zwraca <see cref="T:System.Reflection.FieldInfo" /> obiekt reprezentujący pole zadeklarowane lub dziedziczone przez ten typ z określoną nazwą i modyfikator publiczny lub niepubliczne. Jeśli nie mają odpowiedników następnie <see langword="null" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetField(Type ^ type, System::Reflection::FieldInfo ^ field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="type">Skonstruowanego typu ogólnego, których pole jest zwracany.</param>
        <param name="field">Pole w definicji typu ogólnego <c>typu</c>, która określa, które pole <c>typu</c> do zwrócenia.</param>
        <summary>Zwraca pole określonego skonstruowanego typu ogólnego odpowiada do określonego pola w definicji typu ogólnego.</summary>
        <returns>A <see cref="T:System.Reflection.FieldInfo" /> obiekt, który reprezentuje pole <paramref name="type" /> odpowiadający <paramref name="field" />, który określa pole należących do definicji typu ogólnego <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> Metody umożliwia uzyskanie <xref:System.Reflection.FieldInfo> obiekt, który reprezentuje pole skonstruowanego typu ogólnego, którego definicja typu ogólnego jest reprezentowana przez <xref:System.Reflection.Emit.TypeBuilder> obiektu.  
  
 Na przykład, załóżmy, że masz <xref:System.Reflection.Emit.TypeBuilder> obiekt, który reprezentuje typ `G<T>` w składni języka C# (`G(Of T)` w języku Visual Basic `generic <T> ref class G` w języku C++) i <xref:System.Reflection.Emit.FieldBuilder> obiekt, który reprezentuje pole `public T F` w składni języka C# (`Public F As T`w języku Visual Basic `public: T F` w języku C++) zdefiniowanego przez `G<T>`. Załóżmy, że `G<T>` ma z parametrem typu metody ogólnej `U` tworzącą wystąpienie skonstruowanego typu `G<U>` i pole wywołania `F` w tym wystąpieniu. Aby Emituj wywołanie funkcji, należy <xref:System.Reflection.FieldInfo> obiekt, który reprezentuje `F` na utworzony typ — innymi słowy, który jest typu `U` zamiast typu `T`. Aby to zrobić, należy najpierw wywołać <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metoda <xref:System.Reflection.Emit.TypeBuilder> obiektu, określając <xref:System.Reflection.Emit.GenericTypeParameterBuilder> obiekt, który reprezentuje `U` jako argument typu. Następnie wywołaj <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> metody z wartością zwracaną z <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metody jako parametr `type` i <xref:System.Reflection.Emit.FieldBuilder> obiekt, który reprezentuje `F` jako parametr `field`. Wartość zwracana jest <xref:System.Reflection.FieldInfo> obiektów należy Emituj wywołanie funkcji. Przykład kodu pokazuje, w tym scenariuszu.  
  
   
  
## Examples  
 Poniższy przykład kodu zawiera kod źródłowy dla klasy ogólnej o nazwie przykładowy, który ma parametr typu o nazwie `T`. Klasa ma pole o nazwie `Field`, typu `T`i rodzajowy metodę o nazwie `GM` w jego własnej parametru typu o nazwie `U`. Metoda `GM` tworzy wystąpienie `Sample`, podstawiając własne parametru typu `U` dla parametru typu `Sample`i są przechowywane jego parametru wejściowego w `Field`. Ten kod źródłowy jest skompilowany, ale nie jest używany; można wyświetlić za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) i porównaj je z kodu emitowane przez klasę `Example`.  
  
 Kod w klasie `Example` zademonstrowano użycie <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> metodę Emituj Kod rodzajowy. `Main` Metody klasy `Example` tworzy dynamiczne zestawu zawierającego klasę o nazwie `Sample`i używa <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> metodę, aby wprowadzić ogólne przez dodanie parametru typu o nazwie `T`. Domyślny konstruktor i pole o nazwie `Field`, typu `T`, są dodawane do klasy `Sample`. Metoda `GM` zostanie dodany i zamieniło metody ogólnej przy użyciu <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> metody. Parametr typu `GM` nosi nazwę `U`. Po zdefiniowaniu parametru typu podpis `GM` jest dodawany przy użyciu <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> metody. Brak nie zwracany typ i nr wymagane lub niestandardowych modyfikatory, wszystkie parametry tej metody są `null` z wyjątkiem `parameterTypes`; `parameterTypes` ustawia typ parametru tylko metody `U`, parametru typu ogólnego metody. Treść metody tworzy wystąpienia typu skonstruowane `Sample<U>` (`Sample(Of U)` w języku Visual Basic), przypisuje parametr metody `Field`, a następnie drukuje wartość `Field`. <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> Metoda służy do tworzenia <xref:System.Reflection.FieldInfo> reprezentująca pole skonstruowanego typu ogólnego `Sample<U>` w <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> i <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> instrukcje.  
  
 Fikcyjny typ został zdefiniowany dla metody punktu wejścia `Main`. W treści `Main`, statycznych `GM` wywołaniu metody w typie ogólnym skonstruowane `Sample<int>` (`Sample(Of Integer)` w języku Visual Basic), z typem <xref:System.String> podstawić `U`.  
  
 Po uruchomieniu przykładowy kod zapisuje emitowany zestawu jako TypeBuilderGetFieldExample.exe. Możesz uruchomić TypeBuilderGetFieldExample.exe i służy [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) porównywanie emitowany kodu kod `Sample` klasy, która ma zostać skompilowany w samej przykładu kodu.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> reprezentuje typu ogólnego.  
  
 —lub—  
  
 <paramref name="type" /> nie jest typu <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 —lub—  
  
 Typ deklarujący <paramref name="field" /> nie jest definicją typu ogólnego.  
  
 —lub—  
  
 Typ deklarujący <paramref name="field" /> definicji typu ogólnego nie jest <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Musi to być flagę z bitowego <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />i tak dalej.</param>
        <summary>Zwraca pola publicznego i niepubliczne, zadeklarowanych przez tego typu.</summary>
        <returns>Zwraca tablicę <see cref="T:System.Reflection.FieldInfo" /> obiekty reprezentujące publicznych i niepublicznych pól zadeklarowane lub dziedziczone przez ten typ. Jeśli nie ma żadnych pól określonych, zwracana jest pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> Metoda nie zwraca pola w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kodu nie zależy od kolejności, w którym pola są zwracane, że kolejność może się różnić.  
  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę <see cref="T:System.Type" /> obiekty reprezentujące argumentów typu ogólnego typu lub parametrów typu w definicji typu ogólnego.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów. Elementy tablicy reprezentuje argumentów typu ogólnego typu lub parametrów typu w definicji typu ogólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy tablicy zwracane są w kolejności, w którym są wyświetlane na liście parametrów typu dla definicji typu ogólnego.  
  
 A <xref:System.Reflection.Emit.TypeBuilder> obiekt reprezentuje definicji typu ogólnego, jeśli <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> użyto metody umożliwiają parametry typu ogólnego. Ta metoda pobiera <xref:System.Reflection.Emit.GenericTypeParameterBuilder> obiektów, które reprezentują parametry typu ogólnego.  
  
 Aby uzyskać więcej informacji na typach ogólnych odbicia i listę niezmiennej warunki terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericArguments" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje definicji typu ogólnego, z którego można uzyskać bieżącego typu.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt reprezentujący definicji typu ogólnego, z którego można uzyskać bieżącego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> metoda <xref:System.Reflection.Emit.TypeBuilder> obiektu, który <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> zwraca `true`, <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> właściwość zwraca bieżącego wystąpienia. A <xref:System.Reflection.Emit.TypeBuilder> że reprezentuje ogólnego typu jest zawsze definicji typu ogólnego.  
  
 Jeśli używasz <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metody do konstruowania typu ogólnego z <xref:System.Reflection.Emit.TypeBuilder> obiekt, który reprezentuje definicji typu ogólnego, za pomocą <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> metoda skonstruowanego typu otrzymuje w odpowiedzi <xref:System.Reflection.Emit.TypeBuilder> obiekt, który reprezentuje typ ogólny Definicja.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący typ nie jest rodzajowa. Oznacza to <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> zwraca <see langword="false" />.</exception>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa interfejsu.</param>
        <param name="ignoreCase">Jeśli <see langword="true" />, wyszukiwanie jest rozróżniana wielkość liter. Jeśli <see langword="false" />, wyszukiwanie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca interfejs implementowany (bezpośrednio lub pośrednio) z w pełni kwalifikowana nazwa zgodnego z nazwą danego interfejsu przez tę klasę.</summary>
        <returns>Zwraca <see cref="T:System.Type" /> obiekt reprezentujący zaimplementowany interfejs. Zwraca wartość null w przypadku nieznalezienia bez dopasowania nazwy interfejsu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <see cref="T:System.Type" /> Interfejsu, dla którego ma być pobrana mapowania.</param>
        <summary>Zwraca interfejs mapowania dla żądanego interfejsu.</summary>
        <returns>Zwraca mapowania żądanego interfejsu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę wszystkie interfejsy zaimplementowane dla tego typu i jego typów podstawowych.</summary>
        <returns>Zwraca tablicę <see cref="T:System.Type" /> obiekty reprezentujące zaimplementowanych interfejsów. Jeśli nie są zdefiniowane, zwracana jest pusta tablica.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu członkowskiego.</param>
        <param name="type">Typ elementu członkowskiego do zwrócenia.</param>
        <param name="bindingAttr">Musi to być flagę z bitowego <see cref="T:System.Reflection.BindingFlags" />, jak w <see langword="InvokeMethod" />, <see langword="NonPublic" />i tak dalej.</param>
        <summary>Zwraca wszystkie publiczne i niepubliczne elementy członkowskie zadeklarowane lub dziedziczone przez ten typ, jak określono.</summary>
        <returns>Zwraca tablicę <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publicznych i niepublicznych elementów członkowskich zdefiniowanych dla tego typu, jeśli <paramref name="nonPublic" /> jest używany; w przeciwnym razie zwracane są tylko publiczne elementy członkowskie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Musi to być flagę z bitowego <see cref="T:System.Reflection.BindingFlags" />, takich jak <see langword="InvokeMethod" />, <see langword="NonPublic" />i tak dalej.</param>
        <summary>Zwraca elementy publiczne i niepubliczne elementy członkowskie zadeklarowany lub dziedziczone przez ten typ.</summary>
        <returns>Zwraca tablicę <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publicznych i niepublicznych elementów członkowskich zadeklarowane lub dziedziczone przez ten typ. Jeśli nie ma żadnych członków zgodnych, zwracana jest pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodInfo ^ GetMethod(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">Skonstruowanego typu ogólnego, którego metoda jest zwracany.</param>
        <param name="method">Metoda w definicji typu ogólnego <c>typu</c>, który określa metodę <c>typu</c> do zwrócenia.</param>
        <summary>Zwraca metodę określonego skonstruowanego typu ogólnego odnosi się do określonej metody definicji typu ogólnego.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> obiekt, który reprezentuje metodę <paramref name="type" /> odpowiadający <paramref name="method" />, który określa metodę należących do definicji typu ogólnego <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> Metody umożliwia uzyskanie <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje metodę skonstruowanego typu ogólnego, którego definicja typu ogólnego jest reprezentowana przez <xref:System.Reflection.Emit.TypeBuilder> obiektu.  
  
 Na przykład, załóżmy, że masz <xref:System.Reflection.Emit.TypeBuilder> obiekt, który reprezentuje typ `G<T>` w składni języka C# (`G(Of T)` w języku Visual Basic `generic <T> ref class G` w języku C++) i <xref:System.Reflection.Emit.MethodBuilder> obiekt, który reprezentuje metodę `T M()` w składni języka C# (`Function M() As T`w języku Visual Basic `T M()` w języku C++) zdefiniowanego przez `G<T>`. Załóżmy, że `G<T>` ma z parametrem typu metody ogólnej `U` tworzącą wystąpienie skonstruowanego typu `G<U>` i wywołuje metodę `M` w tym wystąpieniu. Aby Emituj wywołanie funkcji, należy <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje `M` na utworzony typ — innymi słowy, który zwraca typ `U` zamiast typu `T`. Aby to zrobić, należy najpierw wywołać <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metoda <xref:System.Reflection.Emit.TypeBuilder> obiektu, określając <xref:System.Reflection.Emit.GenericTypeParameterBuilder> obiekt, który reprezentuje `U` jako argument typu. Następnie wywołaj <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> metody z wartością zwracaną z <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metody jako parametr `type` i <xref:System.Reflection.Emit.MethodBuilder> obiekt, który reprezentuje `T M()` jako parametr `method`. Wartość zwracana jest <xref:System.Reflection.MethodInfo> obiektów należy Emituj wywołanie funkcji. Przykład kodu pokazuje podobny do poniższego scenariusza.  
  
   
  
## Examples  
 Poniższy przykład kodu zawiera kod źródłowy dla klasy ogólnej o nazwie `Sample` mający parametru typu o nazwie `T`. Klasa ma pole o nazwie `Field`, typu `T`i rodzajowy metodę o nazwie `GM` w jego własnej parametru typu o nazwie `U`. Metoda `GM` tworzy wystąpienie `Sample`, podstawiając własne parametru typu `U` dla parametru typu `Sample`i są przechowywane jego parametru wejściowego w `Field`. Ten kod źródłowy jest skompilowany, ale nie jest używany; można wyświetlić za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) i porównaj je z kodu emitowane przez klasę `Example`.  
  
 Kod w klasie `Example` zademonstrowano użycie <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> metodę Emituj Kod rodzajowy. `Main` Metody klasy `Example` tworzy dynamiczne zestawu zawierającego klasę o nazwie `Sample` i używa <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> metodę, aby wprowadzić ogólne przez dodanie parametru typu o nazwie `T`. Domyślny konstruktor i pole o nazwie `Field`, typu `T`, są dodawane do klasy `Sample`. Metoda `GM` zostanie dodany i zamieniło metody ogólnej przy użyciu <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> metody. Parametr typu `GM` nosi nazwę `U`. Po zdefiniowaniu parametru typu podpis `GM` jest dodawany przy użyciu <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> metody. Brak nie zwracany typ i nr wymagane lub niestandardowych modyfikatory, wszystkie parametry tej metody są `null` z wyjątkiem `parameterTypes`; `parameterTypes` ustawia typ parametru tylko metody `U`, parametru typu ogólnego metody. Treść metody tworzy wystąpienia typu skonstruowane `Sample<U>` (`Sample(Of U)` w języku Visual Basic), przypisuje parametr metody `Field`, a następnie drukuje wartość `Field`. Fikcyjny typ został zdefiniowany dla metody punktu wejścia `Main`. W treści `Main`, statycznych `GM` wywołaniu metody w typie ogólnym skonstruowane `Sample<int>` (`Sample(Of Integer)` w języku Visual Basic), z typem <xref:System.String> podstawić `U`. <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> Metoda służy do tworzenia <xref:System.Reflection.MethodInfo> dla statycznych `GM` metody skonstruowanego typu ogólnego `Sample<U>`i <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> metody jest następnie używany do tworzenia <xref:System.Reflection.MethodInfo> który można emitowanych w wywołaniu metody.  
  
 Po uruchomieniu przykładowy kod zapisuje emitowany zestawu jako TypeBuilderGetFieldExample.exe. Możesz uruchomić TypeBuilderGetFieldExample.exe i służy [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) porównywanie emitowany kodu kod `Sample` klasy, która ma zostać skompilowany w samej przykładu kodu.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> jest to metoda ogólna, który nie jest ogólną definicją metody.  
  
 —lub—  
  
 <paramref name="type" /> reprezentuje typu ogólnego.  
  
 —lub—  
  
 <paramref name="type" /> nie jest typu <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 —lub—  
  
 Typ deklarujący <paramref name="method" /> nie jest definicją typu ogólnego.  
  
 —lub—  
  
 Typ deklarujący <paramref name="method" /> definicji typu ogólnego nie jest <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Musi to być flagę z bitowego <see cref="T:System.Reflection.BindingFlags" /> jako w <see langword="InvokeMethod" />, <see langword="NonPublic" />i tak dalej.</param>
        <summary>Zwraca wszystkie publiczne i niepublicznych metody zadeklarowane lub dziedziczone przez ten typ, jak określono.</summary>
        <returns>Zwraca tablicę <see cref="T:System.Reflection.MethodInfo" /> obiekty reprezentujące metod publicznych i niepublicznych zdefiniowana dla tego typu, jeśli <paramref name="nonPublic" /> jest używany; w przeciwnym razie zwracane są tylko metody publiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> Zawierającą nazwę typu zagnieżdżonego można pobrać.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
 —lub—  
  
 Zero, należy przeprowadzić wyszukiwanie z uwzględnieniem wielkości liter dla metod publicznych.</param>
        <summary>Zwraca typów zagnieżdżonych publicznego i niepubliczne, które są zadeklarowane przez tego typu.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt reprezentujący typu zagnieżdżonego, który spełnia określonych wymagań, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 Jeśli ten typ jest zakończone, na przykład, jeśli `CreateType` została wywołana dla tego typu, ale istnieją zagnieżdżone typy, które nie zostały zakończone, następnie `GetNestedTypes` zwróci tylko te typy zagnieżdżone dla którego `CreateType` została wywołana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Musi to być flagę z bitowego <see cref="T:System.Reflection.BindingFlags" />, jak w <see langword="InvokeMethod" />, <see langword="NonPublic" />i tak dalej.</param>
        <summary>Zwraca typy zagnieżdżone publicznego i niepubliczne, które są zadeklarowane lub dziedziczone przez ten typ.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujący wszystkie typy zagnieżdżone w obrębie bieżącego <see cref="T:System.Type" /> zgodnego z określonymi ograniczeniami wiązania.  
  
 Pusta tablica typu <see cref="T:System.Type" />, jeśli żaden z typów są zagnieżdżone w obrębie bieżącego <see cref="T:System.Type" />, lub jeśli żadna typy zagnieżdżone nie zgadza się z ograniczeniami wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 Jeśli ten typ jest zakończone, na przykład, jeśli `CreateType` została wywołana dla tego typu, ale istnieją zagnieżdżone typy, które nie zostały zakończone, następnie `GetNestedTypes` zwróci tylko te typy zagnieżdżone dla którego `CreateType` została wywołana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Ten atrybut wywołania. Musi to być flagę z bitowego <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />i tak dalej.</param>
        <summary>Zwraca wszystkie publiczne i niepublicznych właściwości zadeklarowane lub dziedziczone przez ten typ, jak określono.</summary>
        <returns>Zwraca tablicę <see langword="PropertyInfo" /> obiekty reprezentujące właściwości publiczne i niepublicznych zdefiniowana dla tego typu, jeśli <paramref name="nonPublic" /> jest używany; w przeciwnym razie zwracane są tylko właściwości publiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest zaimplementowana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator GUID tego typu.</summary>
        <value>Tylko do odczytu. Pobiera identyfikator GUID tego typu</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu członkowskiego do wywołania. Może to być Konstruktor, metody, właściwości lub pola. Należy określić atrybut odpowiedniego wywołania. Należy pamiętać, że można wywołać domyślny element członkowski klasy, przekazując pustego ciągu jako nazwy elementu członkowskiego.</param>
        <param name="invokeAttr">Atrybut wywołania. Musi to być flagę z bitowego <see langword="BindingFlags" />.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <see langword="MemberInfo" /> obiektów za pomocą odbicia. Jeśli jest <see langword="null" />, używany jest domyślny integrator. Zobacz <see cref="T:System.Reflection.Binder" />.</param>
        <param name="target">Obiekt do wywołania określonego elementu członkowskiego. Jeśli element członkowski jest statyczny, ten parametr zostanie zignorowany.</param>
        <param name="args">Lista argumentów. To jest Tablica obiektów, zawierającą numer, kolejność i typy parametrów elementu członkowskiego, do wywołania. Jeśli nie ma żadnych parametrów powinna to być wartość null.</param>
        <param name="modifiers">Tablica taką samą długość jak <c>argumentów</c> z elementami, które reprezentuje atrybuty skojarzone z argumentów elementu członkowskiego do wywołania. Parametr ma atrybuty skojarzone z nim w metadanych. Są one używane przez różne usługi współdziałania. Zobacz specyfikacji metadanych, aby uzyskać więcej informacji.</param>
        <param name="culture">Wystąpienie <see langword="CultureInfo" /> używane do sterowania koercja typów. Jeśli jest to wartość null, <see langword="CultureInfo" /> służy bieżącego wątku. (Należy pamiętać, że jest to konieczne, na przykład konwertowanie ciągu reprezentujący 1000 na wartość podwójną, ponieważ 1000 jest inaczej reprezentowany przez innych kultur).</param>
        <param name="namedParameters">Każdego parametru w <c>namedParameters</c> tablicy pobiera wartość w odpowiadający mu element w <c>argumentów</c> tablicy. Jeśli długość <c>argumentów</c> jest większa niż długość <c>namedParameters</c>, pozostałe wartości argumentu są przekazywane w kolejności.</param>
        <summary>Wywołuje określony element członkowski. Metodę, która ma zostać wywołana musi być dostępna i udostępnia specyficzny dopasowania z określona lista argumentów, w obszarze ograniczenia określonych atrybutów integratora i wywołanie.</summary>
        <returns>Zwraca wartość zwracaną wywołany element członkowski.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zostanie wywołany, jeśli liczba parametrów w deklaracji metody jest równa liczbie argumentów określona lista argumentów i można przekonwertować typu argumentu przez obiekt wiążący z typem parametru.  
  
 Obiekt wiążący znajdzie wszystkie metody dopasowania. Te metody są dostępne na podstawie typu powiązania żądanego (BindingFlags.InvokeMethod, BindingFlags.GetProperties itd.). Zbiór metod są filtrowane według nazwy, liczba argumentów i zestaw Modyfikatory wyszukiwania zdefiniowane w obiekt wiążący. Po wybraniu metody, zostanie wywołany. Ułatwienia dostępu, zostanie sprawdzony w tym momencie. Wyszukiwanie można kontrolować, które zestaw metod są przeszukiwane zależności atrybutu dostępności skojarzonego z metodą. `IBinder.BindToMethod` Metoda jest odpowiedzialna za wybranie wywoływanej metody. Domyślnego integratora wybierze najbardziej zgodne.  
  
> [!NOTE]
>  Ograniczenia dostępu są ignorowane w przypadku całkowicie zaufanego kodu. Oznacza to konstruktory prywatne, pola, metody i właściwości są dostępne i wywoływane przy użyciu odbicia, jeśli kod jest w pełni zaufany.  
  
 Ta metoda nie jest obecnie obsługiwana. Można pobrać przy użyciu typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana dla typów niekompletne.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAssignableFrom">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy określony typ można przypisać do tego obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">Obiekt do przetestowania.</param>
        <summary>Pobiera wartość wskazującą, czy określonej <see cref="T:System.Reflection.TypeInfo" /> obiektu można przypisać do tego obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="typeInfo" /> mogą być przypisane do tego obiektu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Obiekt do przetestowania.</param>
        <summary>Pobiera wartość wskazującą, czy określonej <see cref="T:System.Type" /> można przypisać do tego obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="c" /> parametr i typ bieżącego reprezentują ten sam typ, lub jeśli typ bieżącego znajduje się w hierarchii dziedziczenia <paramref name="c" />, lub jeśli typ bieżącego jest interfejsem który <paramref name="c" /> obsługuje. <see langword="false" /> Jeśli żaden z tych warunków nie jest prawidłowy lub <paramref name="c" /> jest <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten obiekt reprezentuje skonstruowanego typu ogólnego.</summary>
        <value>
          <see langword="true" /> Jeśli ten obiekt reprezentuje skonstruowanego typu ogólnego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCreated () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsCreated();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy bieżący typ dynamicznej została utworzona.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> metoda została wywołana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> wywołano metodę typu reprezentowanego przez <xref:System.Reflection.Emit.TypeBuilder> obiektu została ukończona. Wyjątki są zgłaszane na dalsze próby dodawanie członków lub zmień typ innych parametrów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Typ atrybutu do wyszukiwania. Zwracane są tylko atrybuty, które są przypisane do tego typu.</param>
        <param name="inherit">Określa, czy przeszukać łańcuch dziedziczenia tego elementu członkowskiego w celu znalezienia atrybutów.</param>
        <summary>Określa, czy atrybut niestandardowy jest stosowany do bieżącego typu.</summary>
        <returns>
          <see langword="true" /> Jeśli jeden lub więcej wystąpień <paramref name="attributeType" />, lub typ pochodzący od atrybutu <paramref name="attributeType" />, jest zdefiniowana dla tego typu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest obsługiwany dla parametrów niekompletnego typu ogólnego. Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta metoda nie jest obecnie obsługiwana dla typów niekompletne. Pobrać za pomocą typu <see cref="M:System.Type.GetType" /> i Wywołaj <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> w zwróconym <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> nie jest zdefiniowany.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest parametr typu ogólnego.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Reflection.Emit.TypeBuilder" /> obiekt reprezentuje parametr typu ogólnego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Gdy emitowanie kodu, parametru typu ogólnego jest reprezentowana przez <xref:System.Reflection.Emit.GenericTypeParameterBuilder> obiektu, a nie przez <xref:System.Reflection.Emit.TypeBuilder> obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest typem ogólnym.</summary>
        <value>
          <see langword="true" /> Jeśli typ reprezentowany przez bieżący <see cref="T:System.Reflection.Emit.TypeBuilder" /> obiekt jest ogólny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.TypeBuilder> obiekt reprezentuje definicji typu ogólnego, jeśli <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> użyto metody umożliwiają parametry typu ogólnego. Wystąpienie <xref:System.Reflection.Emit.TypeBuilder> klasy, która jest ogólna zawsze jest definicją typu ogólnego.  
  
 Aby uzyskać więcej informacji na typach ogólnych odbicia i listę niezmiennej warunki terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżące <see cref="T:System.Reflection.Emit.TypeBuilder" /> reprezentuje definicji typu ogólnego, z którego można skonstruować innych typów ogólnych.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Reflection.Emit.TypeBuilder" /> obiekt reprezentuje definicji typu ogólnego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.TypeBuilder> obiekt reprezentuje definicji typu ogólnego, jeśli <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> użyto metody umożliwiają parametry typu ogólnego. Wystąpienie <xref:System.Reflection.Emit.TypeBuilder> klasy, która jest ogólna zawsze jest definicją typu ogólnego.  
  
 A <xref:System.Reflection.Emit.TypeBuilder> może służyć do tworzenia definicji typu ogólnego, ale nie utworzone typy ogólne. Aby uzyskać skonstruowanego typu ogólnego, należy wywołać <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metoda <xref:System.Reflection.Emit.TypeBuilder> reprezentujący definicji typu ogólnego.  
  
 Aby uzyskać więcej informacji na typach ogólnych odbicia i listę niezmiennej warunki terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest krytyczny dla zabezpieczeń lub bezpieczny krytyczny dla zabezpieczeń i w związku z tym mogą wykonywać operacje krytyczne.</summary>
        <value>
          <see langword="true" /> w przypadku bieżącego typu zabezpieczeń krytyczne lub zabezpieczeń — bezpieczne krytyczne; <see langword="false" /> Jeśli jest niewidoczne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości typu określone przez środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
 Środowisko uruchomieniowe rozpoczyna oceny poziomów przezroczystości w zestawie. Na przykład jeśli zestaw dynamiczny jest krytyczny dla zabezpieczeń, adnotacje typów są ignorowane, a wszystkie typy są krytyczne dla zabezpieczeń.  
  
 Domyślnie zestawie dynamicznym dziedziczy przezroczystość zestawu, który emituje go. Można zastąpić to ustawienie domyślne przy użyciu <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, lub <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> przeciążenie metody i określanie atrybutów zabezpieczeń. Nie można podnieść poziomów zabezpieczeń dzięki temu; oznacza to, że kod o przezroczystym nie można wyemitować kodu krytyczny dla zabezpieczeń lub bezpieczny krytyczny dla zabezpieczeń. Atrybuty należy określić podczas tworzenia zestawu dynamicznego lub one uwzględnione dopiero zestawu został zapisany na dysku i ponownie załadowany.  
  
> [!NOTE]
>  Domyślne dziedziczenia jest ograniczona do oceny środowiska uruchomieniowego przezroczystości. Atrybuty nie są stosowane do zestawu dynamicznego. Jeśli chcesz dodać atrybuty zabezpieczeń, należy najpierw zastosować je samodzielnie.  
  
 Aby uzyskać więcej informacji na temat odbicia Emituj i przejrzystości, zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Bieżącego typu dynamicznego nie został utworzony przez wywołanie metody <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> metody.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest bezpieczny krytyczny dla zabezpieczeń; oznacza to, czy go mogą wykonywać operacje krytyczne i można uzyskać, sprawdzając kod przezroczysty.</summary>
        <value>
          <see langword="true" /> w przypadku bieżącego typu zabezpieczeń — bezpieczne krytyczne; <see langword="false" /> przypadku zabezpieczeń krytyczny ani przezroczysty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości typu określone przez środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
 Środowisko uruchomieniowe rozpoczyna oceny poziomów przezroczystości w zestawie. Na przykład jeśli zestaw dynamiczny jest krytyczny dla zabezpieczeń, adnotacje typów są ignorowane, a wszystkie typy są krytyczne dla zabezpieczeń.  
  
 Domyślnie zestawie dynamicznym dziedziczy przezroczystość zestawu, który emituje go. Można zastąpić to ustawienie domyślne przy użyciu <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, lub <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> przeciążenie metody i określanie atrybutów zabezpieczeń. Nie można podnieść poziomów zabezpieczeń dzięki temu; oznacza to, że kod o przezroczystym nie można wyemitować kodu krytyczny dla zabezpieczeń lub bezpieczny krytyczny dla zabezpieczeń. Atrybuty należy określić podczas tworzenia zestawu dynamicznego lub one uwzględnione dopiero zestawu został zapisany na dysku i ponownie załadowany.  
  
> [!NOTE]
>  Domyślne dziedziczenia jest ograniczona do oceny środowiska uruchomieniowego przezroczystości. Atrybuty nie są stosowane do zestawu dynamicznego. Jeśli chcesz dodać atrybuty zabezpieczeń, należy najpierw zastosować je samodzielnie.  
  
 Aby uzyskać więcej informacji na temat odbicia Emituj i przejrzystości, zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Bieżącego typu dynamicznego nie został utworzony przez wywołanie metody <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> metody.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest niewidoczny i dlatego nie można wykonać operacji krytyczne.</summary>
        <value>
          <see langword="true" /> Jeśli typ jest przezroczystym poziomie bezpieczeństwa; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości typu określone przez środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
 Środowisko uruchomieniowe rozpoczyna oceny poziomów przezroczystości w zestawie. Na przykład jeśli zestaw dynamiczny jest krytyczny dla zabezpieczeń, adnotacje typów są ignorowane, a wszystkie typy są krytyczne dla zabezpieczeń.  
  
 Domyślnie zestawie dynamicznym dziedziczy przezroczystość zestawu, który emituje go. Można zastąpić to ustawienie domyślne przy użyciu <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, lub <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> przeciążenie metody i określanie atrybutów zabezpieczeń. Nie można podnieść poziomów zabezpieczeń dzięki temu; oznacza to, że kod o przezroczystym nie można wyemitować kodu krytyczny dla zabezpieczeń lub bezpieczny krytyczny dla zabezpieczeń. Atrybuty należy określić podczas tworzenia zestawu dynamicznego lub one uwzględnione dopiero zestawu został zapisany na dysku i ponownie załadowany.  
  
> [!NOTE]
>  Domyślne dziedziczenia jest ograniczona do oceny środowiska uruchomieniowego przezroczystości. Atrybuty nie są stosowane do zestawu dynamicznego. Jeśli chcesz dodać atrybuty zabezpieczeń, należy najpierw zastosować je samodzielnie.  
  
 Aby uzyskać więcej informacji na temat odbicia Emituj i przejrzystości, zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Bieżącego typu dynamicznego nie został utworzony przez wywołanie metody <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> metody.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">A <see cref="T:System.Type" /> który ma być sprawdzony.</param>
        <summary>Określa, czy ten typ pochodzi z określonego typu.</summary>
        <returns>Tylko do odczytu. Zwraca <see langword="true" /> Jeśli ten typ jest taki sam jak typ <paramref name="c" />, lub jest podtypem typu <paramref name="c" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje tablicę bieżącego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje tablicą jednowymiarową bieżącego typu z dolną granicą zero.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt reprezentujący typ Jednowymiarowa tablica, której typ elementów jest bieżący typ z dolną granicą zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> Metody umożliwia generowanie typem tablicy w przypadku każdego typu elementu możliwe, w tym typów ogólnych.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy module dynamicznym abstrakcyjna o nazwie `Sample`, a metoda abstrakcyjna o nazwie `TestMethod`. `TestMethod` przyjmuje `ref` parametr (`ByRef` w języku Visual Basic) typu `Sample`, wskaźnik do typu `Sample`, a Tablica typu `Sample`. Zwraca jest tablicą dwuwymiarową typu `Sample`. Przykładowy kod zapisuje module dynamicznym na dysku, więc można sprawdzić za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">Liczba wymiarów tablicy.</param>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje bieżącego typu o określoną liczbę wymiarów tablicy.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt, który reprezentuje tablicą jednowymiarową bieżącego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> Metody umożliwia generowanie typem tablicy w przypadku każdego typu elementu możliwe, w tym typów ogólnych.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy module dynamicznym abstrakcyjna o nazwie `Sample`, a metoda abstrakcyjna o nazwie `TestMethod`. `TestMethod` przyjmuje `ref` parametr (`ByRef` w języku Visual Basic) typu `Sample`, wskaźnik do typu `Sample`, a Tablica typu `Sample`. Zwraca jest tablicą dwuwymiarową typu `Sample`. Przykładowy kod zapisuje module dynamicznym na dysku, więc można sprawdzić za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> nie jest wymiarem tablicy prawidłowe.</exception>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje bieżącego typu, gdy dane są przekazywane jako <see langword="ref" /> parametr (<see langword="ByRef" /> w języku Visual Basic).</summary>
        <returns>A <see cref="T:System.Type" /> obiekt, który reprezentuje bieżącego typu, gdy dane są przekazywane jako <see langword="ref" /> parametr (<see langword="ByRef" /> w języku Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> Metody umożliwia generowanie `ref` typów (`ByRef` w języku Visual Basic) dla parametru listy.  
  
> [!NOTE]
>  Używana jest składnia języka pośredniego (MSIL) firmy Microsoft, jeśli bieżący <xref:System.Reflection.Emit.TypeBuilder> reprezentuje `MyType`, a następnie będzie typ zwracany przez tę metodę `MyType&`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy module dynamicznym abstrakcyjna o nazwie `Sample`, a metoda abstrakcyjna o nazwie `TestMethod`. `TestMethod` przyjmuje `ref` parametr (`ByRef` w języku Visual Basic) typu `Sample`, wskaźnik do typu `Sample`, a Tablica typu `Sample`. Zwraca jest tablicą dwuwymiarową typu `Sample`. Przykładowy kod zapisuje module dynamicznym na dysku, więc można sprawdzić za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Tablica typów mają być zastępowane dla parametrów typu w bieżącej definicji typu ogólnego.</param>
        <summary>Zastępuje elementy tablicą typów parametrów typu bieżącej definicji typu ogólnego i zwraca wynikowy typ skonstruowane.</summary>
        <returns>A <see cref="T:System.Type" /> reprezentujący utworzony typ sformułowany, zastępując elementy <paramref name="typeArguments" /> parametrów typu bieżącego typu ogólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda emitowany kodu wymaga typu utworzone na podstawie bieżącej definicji typu ogólnego. Nie jest konieczne do wywołania <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metoda przed wywołaniem <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metoda <xref:System.Reflection.Emit.TypeBuilder> reprezentujący definicji typu ogólnego. Jeśli bieżący <xref:System.Reflection.Emit.TypeBuilder> nie reprezentuje definicji typu ogólnego, <xref:System.InvalidOperationException> jest generowany.  
  
 Obiekt zwrócony przez funkcje tej metody jako symbol zastępczy skonstruowanego typu ogólnego w kodzie emitowany. Jest on wystąpieniem klasy pochodzącej od <xref:System.Type> mającym ograniczoną możliwości. W szczególności:  
  
-   Aby uzyskać metody, pól i konstruktory one utworzone typy ogólne, użyj <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, i <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> przeciążenia metody.  
  
-   Dwa wystąpienia, które reprezentują ten sam typ skonstruowane porównuje jako równe. Na przykład w poniższym kodzie `t1.Equals(t2)` zwraca `false`:  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący typ nie reprezentuje definicji typu ogólnego. Oznacza to <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> zwraca <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> jest <see langword="null" />.  
  
 —lub—  
  
 Każdy z elementów <paramref name="typeArguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Type.Module" /> Właściwości z żadnym elementem <paramref name="typeArguments" /> jest <see langword="null" />.  
  
 —lub—  
  
 <see cref="P:System.Reflection.Module.Assembly" /> Właściwość modułu z żadnym elementem <paramref name="typeArguments" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje typ niezarządzany wskaźnik do typu bieżącej.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt, który reprezentuje typ niezarządzany wskaźnik do typu bieżącej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> Metody umożliwia generowanie typów wskaźnika do listy parametrów.  
  
> [!NOTE]
>  Używana jest składnia języka pośredniego (MSIL) firmy Microsoft, jeśli bieżący <xref:System.Reflection.Emit.TypeBuilder> reprezentuje `MyType`, a następnie będzie typ zwracany przez tę metodę `MyType*`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy module dynamicznym abstrakcyjna o nazwie `Sample`, a metoda abstrakcyjna o nazwie `TestMethod`. `TestMethod` przyjmuje `ref` parametr (`ByRef` w języku Visual Basic) typu `Sample`, wskaźnik do typu `Sample`, a Tablica typu `Sample`. Zwraca jest tablicą dwuwymiarową typu `Sample`. Przykładowy kod zapisuje module dynamicznym na dysku, więc można sprawdzić za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dynamiczny moduł zawierający definicję tego typu.</summary>
        <value>Tylko do odczytu. Pobiera dynamiczny moduł zawierający definicję tego typu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę tego typu.</summary>
        <value>Tylko do odczytu. Pobiera <see cref="T:System.String" /> nazwa tego typu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obszar nazw gdzie to <see langword="TypeBuilder" /> jest zdefiniowany.</summary>
        <value>Tylko do odczytu. Pobiera obszar nazw gdzie to <see langword="TypeBuilder" /> jest zdefiniowany.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackingSize As PackingSize" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::PackingSize PackingSize { System::Reflection::Emit::PackingSize get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar pakowania tego typu.</summary>
        <value>Tylko do odczytu. Pobiera rozmiar pakowania tego typu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca typ, który został użyty do uzyskania tego typu.</summary>
        <value>Tylko do odczytu. Typ, który został użyty do uzyskania tego typu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia atrybut niestandardowy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">Wystąpienia klasy pomocnika do definiowania atrybutu niestandardowego.</param>
        <summary>Wartość atrybutu niestandardowego za pomocą konstruktora atrybutów niestandardowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy z zabezpieczeniami w odbicia Emituj](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Dla bieżącego typu dynamicznego <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">Konstruktor atrybutu niestandardowego.</param>
        <param name="binaryAttribute">Obiekt blob bajtów reprezentujących atrybuty.</param>
        <summary>Ustawia przy użyciu określonego atrybutu niestandardowego obiektu blob atrybutu niestandardowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat formatu `binaryAttribute`, można znaleźć w dokumentacji infrastruktury języka wspólnego (CLI), szczególnie "partycji II: metadane definicji i semantyki". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy z zabezpieczeniami w odbicia Emituj](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> lub <paramref name="binaryAttribute" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Dla bieżącego typu dynamicznego <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParent (parent As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParent(Type ^ parent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent">Nowy typ podstawowy.</param>
        <summary>Ustawia typ bazowy tego typu obecnie konstruowanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `parent` jest `null`, <xref:System.Object> jest używany jako typ bazowy.  
  
 W wersji systemu .NET Framework 1.0 i 1.1, nie jest wyjątek Jeśli `parent` jest typ interfejsu, ale <xref:System.TypeLoadException> jest generowany, gdy <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metoda jest wywoływana.  
  
 <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> — Metoda nie sprawdza większość typów nieprawidłowy element nadrzędny. Na przykład nie odrzucić typie elementu nadrzędnego, który nie ma konstruktora domyślnego podczas bieżący typ ma domyślny konstruktor, nie go odrzucić typy zapieczętowane i nie odrzucić <xref:System.Delegate> typu. W takich przypadkach istnieją wyjątki zgłaszane przez <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 —lub—  
  
 <paramref name="parent" /> jest <see langword="null" />, a bieżące wystąpienie reprezentuje interfejs atrybutów, których nie obejmują <see cref="F:System.Reflection.TypeAttributes.Abstract" />.  
  
 —lub—  
  
 Dla bieżącego typu dynamicznego <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> właściwość jest <see langword="true" />, ale <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> jest właściwość <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" /> to interfejs. Ten warunek wyjątku jest nowa w programie .NET Framework w wersji 2.0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Size { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ całkowity rozmiar.</summary>
        <value>Tylko do odczytu. Pobiera łączny rozmiar tego typu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _TypeBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_TypeBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _TypeBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Otrzymuje wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _TypeBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _TypeBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_TypeBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nazwę typu z wyłączeniem przestrzeni nazw.</summary>
        <returns>Tylko do odczytu. Nazwa typu z wyłączeniem przestrzeni nazw.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Nieobsługiwane w modułach dynamicznych.</summary>
        <value>Tylko do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobrać za pomocą typu <xref:System.Type.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> i użyj odbicia dla typu pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nieobsługiwane w modułach dynamicznych.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeToken As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::TypeToken TypeToken { System::Reflection::Emit::TypeToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca token typu tego typu.</summary>
        <value>Tylko do odczytu. Zwraca <see langword="TypeToken" /> tego typu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Typ został wcześniej utworzony przy użyciu <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca typ podstawowy systemu dla tego <see langword="TypeBuilder" />.</summary>
        <value>Tylko do odczytu. Zwraca typ podstawowy system.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Ten typ jest wyliczeniem, ale nie ma podstawowego typu systemu.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberSignature Language="VB.NET" Value="Public Const UnspecifiedTypeSize As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int UnspecifiedTypeSize = 0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Przedstawia całkowity rozmiar dla typu jest nieokreślona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ModuleBuilder" FullName="System.Reflection.Emit.ModuleBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e03e44de84d13266ab510803fa5ed07fb43147cd" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48671004" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ModuleBuilder : System.Reflection.Module, System.Runtime.InteropServices._ModuleBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit ModuleBuilder extends System.Reflection.Module implements class System.Runtime.InteropServices._ModuleBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ModuleBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class ModuleBuilder&#xA;Inherits Module&#xA;Implements _ModuleBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class ModuleBuilder : System::Reflection::Module, System::Runtime::InteropServices::_ModuleBuilder" />
  <TypeSignature Language="F#" Value="type ModuleBuilder = class&#xA;    inherit Module&#xA;    interface _ModuleBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.Module</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._ModuleBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ModuleBuilder))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje i reprezentuje modułu w zestawie dynamicznym.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby pobrać wystąpienie obiektu <xref:System.Reflection.Emit.ModuleBuilder>, użyj <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie `ModuleBuilder` do tworzenia modułu dynamicznego. Należy pamiętać, że ModuleBuilder jest tworzony przez wywołanie <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> w <xref:System.Reflection.Emit.AssemblyBuilder>, a nie za pomocą konstruktora.  
  
 [!code-cpp[ModuleBuilder_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_Class/CPP/modulebuilder.cpp#1)]
 [!code-csharp[ModuleBuilder_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_Class/CS/modulebuilder.cs#1)]
 [!code-vb[ModuleBuilder_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_Class/VB/modulebuilder.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ModuleBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ModuleBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Emit.ModuleBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zestaw dynamiczny, zdefiniowanego w tym wystąpieniu programu <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
        <value>Zestaw dynamiczny zdefiniowane bieżącego modułu dynamicznego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly> Obiekt, który jest zwracany jest <xref:System.Reflection.Emit.AssemblyBuilder> , zdefiniowane w tym wystąpieniu programu <xref:System.Reflection.Emit.ModuleBuilder>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateGlobalFunctions">
      <MemberSignature Language="C#" Value="public void CreateGlobalFunctions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateGlobalFunctions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateGlobalFunctions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateGlobalFunctions();" />
      <MemberSignature Language="F#" Value="member this.CreateGlobalFunctions : unit -&gt; unit" Usage="moduleBuilder.CreateGlobalFunctions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się definicje funkcji globalnych i danych globalnych definicji dla tego modułu dynamicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna być wywoływana, gdy użytkownik jest wykonywane przy definiowaniu funkcje globalne w ramach tego modułu dynamicznego. Po wywołaniu tej funkcji, nie więcej nowych funkcji globalnych lub nowe dane globalne są dozwolone.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `CreateGlobalFunctions` do utworzenia metody statycznej globalnych z <xref:System.Reflection.Emit.MethodBuilder> implementowane za pomocą <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A>.  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#2)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#2)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta metoda została wywołana wcześniej.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDocument">
      <MemberSignature Language="C#" Value="public System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument (string url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument(string url, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDocument (url As String, language As Guid, languageVendor As Guid, documentType As Guid) As ISymbolDocumentWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ DefineDocument(System::String ^ url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="member this.DefineDocument : string * Guid * Guid * Guid -&gt; System.Diagnostics.SymbolStore.ISymbolDocumentWriter" Usage="moduleBuilder.DefineDocument (url, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolDocumentWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL dokumentu.</param>
        <param name="language">Identyfikator GUID, który identyfikuje języka dokumentu. Może to być <see cref="F:System.Guid.Empty" />.</param>
        <param name="languageVendor">Identyfikator GUID, który identyfikuje dostawcę języka dokumentu. Może to być <see cref="F:System.Guid.Empty" />.</param>
        <param name="documentType">Identyfikator GUID, który identyfikuje typ dokumentu. Może to być <see cref="F:System.Guid.Empty" />.</param>
        <summary>Definiuje dokumentu dla źródła.</summary>
        <returns>Dokument zdefiniowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Throw wcześniejszych wersji programu .NET Framework <xref:System.ArgumentException> zamiast <xref:System.ArgumentNullException> podczas `url` jest `null`.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje użycie `DefineDocument` można dołączyć dokument symbol zewnętrzny (w tym przypadku pierwotne pliku IL) do modułu dynamicznego.  
  
 [!code-cpp[ModuleBuilder_DefineDocument#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineDocument/CPP/modulebuilder_definedocument.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineDocument#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineDocument/CS/modulebuilder_definedocument.cs#1)]
 [!code-vb[ModuleBuilder_DefineDocument#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineDocument/VB/modulebuilder_definedocument.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> jest <see langword="null" />. Jest to zmiana z wcześniejszych wersji programu .NET Framework.</exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda jest wywoływana w module dynamiczne, który nie jest modułem debugowania.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEnum">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EnumBuilder DefineEnum (string name, System.Reflection.TypeAttributes visibility, Type underlyingType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EnumBuilder DefineEnum(string name, valuetype System.Reflection.TypeAttributes visibility, class System.Type underlyingType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEnum (name As String, visibility As TypeAttributes, underlyingType As Type) As EnumBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EnumBuilder ^ DefineEnum(System::String ^ name, System::Reflection::TypeAttributes visibility, Type ^ underlyingType);" />
      <MemberSignature Language="F#" Value="member this.DefineEnum : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.EnumBuilder" Usage="moduleBuilder.DefineEnum (name, visibility, underlyingType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EnumBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="visibility" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="underlyingType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Pełna ścieżka typu wyliczenia. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="visibility">Atrybuty typu wyliczenia. Atrybuty są wszystkie bity, zdefiniowane przez <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" />.</param>
        <param name="underlyingType">Podstawowy typ wyliczenia. Musi to być wbudowanej całkowitą.</param>
        <summary>Definiuje typ wyliczeniowy, który jest typem wartości z jednej niestatycznego pola o nazwie <paramref name="value__" /> określonego typu.</summary>
        <returns>Wyliczenie zdefiniowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyliczenia zdefiniowanych jest klasy pochodnej <xref:System.Enum>. `value__` Pole ma <xref:System.Reflection.FieldAttributes.Private> i <xref:System.Reflection.FieldAttributes.SpecialName> atrybutów zestawu.  
  
 Aby uzyskać więcej informacji na temat typów całkowitych wbudowanych, które można określić jako podstawowe typy wyliczenia, zobacz [Przegląd biblioteki klas](~/docs/standard/class-library-overview.md).  
  
> [!NOTE]
>  W wersjach programu .NET Framework 1.0 i 1.1 jest zdefiniowanie wyliczenia przy użyciu <xref:System.Reflection.Emit.TypeBuilder> ponieważ <xref:System.Reflection.Emit.EnumBuilder> emituje wyliczenia, której elementy są typu <xref:System.Int32> zamiast typu wyliczenia. W .NET Framework w wersji 2.0 <xref:System.Reflection.Emit.EnumBuilder> emituje wyliczenia, której elementy mają poprawnego typu.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `DefineEnum` Aby zaimplementować klasę wyliczeniową w modułu dynamicznego. W przykładzie zdefiniowano wyliczenia o nazwie `Elevation` zawierający podstawowym typem <xref:System.Int32>i tworzy dwa elementy: `Low`, o wartości 0, a `High`, o wartości 1. Po utworzeniu typu zestawu zostaje zapisana wraz z nazwą `TempAssembly.dll`. Możesz użyć [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) zbadać zawartość tego zestawu.  
  
> [!NOTE]
>  Przed programu .NET Framework w wersji 2.0 w tym przykładzie kodu nie generuje wyliczenie poprawne.  
  
 [!code-cpp[ModuleBuilder_DefineEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineEnum/CPP/modulebuilder_defineenum.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineEnum/CS/modulebuilder_defineenum.cs#1)]
 [!code-vb[ModuleBuilder_DefineEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineEnum/VB/modulebuilder_defineenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podano atrybuty inne niż atrybuty widoczności.  
  
—lub— 
Wyliczenie o podanej nazwie istnieje w zestawie nadrzędny tego modułu.  
  
—lub— 
Atrybuty widoczności nie są zgodne z zakresu wyliczenia. Na przykład <see cref="F:System.Reflection.TypeAttributes.NestedPublic" /> jest określona dla <paramref name="visibility" />, ale wyliczenia nie jest typem zagnieżdżonym.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineGlobalMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje metodę globalnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGlobalMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineGlobalMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineGlobalMethod : string * System.Reflection.MethodAttributes * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefineGlobalMethod (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attributes">Atrybuty metody. <c>atrybuty</c> musi zawierać <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <summary>Definiuje globalny metodę o określonej nazwie, atrybuty, typ zwracany i typy parametrów.</summary>
        <returns>Zdefiniowana metoda globalna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda globalna, który definiuje tę metodę nie jest używany, dopóki nie zostanie wywołana <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `DefineGlobalMethod` do utworzenia metody niezależnie od typu związany z bieżącą <xref:System.Reflection.Emit.ModuleBuilder>. Po utworzeniu metoda globalna <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> musi zostać wywołana w celu jego wykonania.  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#1)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#1)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Metoda nie jest statyczne. Oznacza to, że <paramref name="attributes" /> nie obejmuje <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
—lub— 
długość <paramref name="name" /> wynosi zero 
—lub— 
Element <see cref="T:System.Type" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> został wcześniej wywołany.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGlobalMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineGlobalMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineGlobalMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefineGlobalMethod (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attributes">Atrybuty metody. <c>atrybuty</c> musi zawierać <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Konwencja wywołania metody.</param>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <summary>Definiuje globalny metodę o określonej nazwie, atrybuty, Konwencja wywoływania, typ zwracany i typy parametrów.</summary>
        <returns>Zdefiniowana metoda globalna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można użyć globalnego metodę, która definiuje tę metodę, do momentu wywołania <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje użycie `DefineGlobalMethod` do utworzenia metody niezależnie od typu związany z bieżącą <xref:System.Reflection.Emit.ModuleBuilder>. Po utworzeniu metoda globalna <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> musi zostać wywołana w celu jego wykonania.  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#1)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#1)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Metoda nie jest statyczne. Oznacza to, że <paramref name="attributes" /> nie obejmuje <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
—lub— 
Element <see cref="T:System.Type" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> został wcześniej wywołany.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] requiredReturnTypeCustomModifiers, class System.Type[] optionalReturnTypeCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] requiredParameterTypeCustomModifiers, class System.Type[][] optionalParameterTypeCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGlobalMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, requiredReturnTypeCustomModifiers As Type(), optionalReturnTypeCustomModifiers As Type(), parameterTypes As Type(), requiredParameterTypeCustomModifiers As Type()(), optionalParameterTypeCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineGlobalMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ requiredReturnTypeCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalReturnTypeCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredParameterTypeCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalParameterTypeCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineGlobalMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefineGlobalMethod (name, attributes, callingConvention, returnType, requiredReturnTypeCustomModifiers, optionalReturnTypeCustomModifiers, parameterTypes, requiredParameterTypeCustomModifiers, optionalParameterTypeCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="requiredReturnTypeCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalReturnTypeCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredParameterTypeCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalParameterTypeCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody. <c>Nazwa</c> nie może zawierać osadzone znaki o wartości null.</param>
        <param name="attributes">Atrybuty metody. <c>atrybuty</c> musi zawierać <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Konwencja wywołania metody.</param>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="requiredReturnTypeCustomModifiers">Tablica typów reprezentujący Modyfikatory niestandardowe dla zwracanego typu, takie jak <see cref="T:System.Runtime.CompilerServices.IsConst" /> lub <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Jeśli zwracany typ nie ma żadnych Modyfikatory niestandardowe, należy określić <see langword="null" />.</param>
        <param name="optionalReturnTypeCustomModifiers">Tablica typów reprezentujący Modyfikatory niestandardowe opcjonalne dla zwracanego typu, takie jak <see cref="T:System.Runtime.CompilerServices.IsConst" /> lub <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. Jeśli typ zwracany jest brak opcjonalne modyfikatorów niestandardowych, należy określić <see langword="null" />.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <param name="requiredParameterTypeCustomModifiers">Tablica tablic typów. Tablic typów reprezentuje wymagane Modyfikatory niestandardowe dla odpowiedniego parametru metody globalne. Jeśli określonego argumentu nie Modyfikatory niestandardowe, należy określić <see langword="null" /> zamiast tablicy typów. Jeśli metoda globalna nie ma argumentów lub argumentów wymaganych modyfikatorów niestandardowych, określić <see langword="null" /> zamiast tablicy tablic.</param>
        <param name="optionalParameterTypeCustomModifiers">Tablica tablic typów. Tablic typów reprezentuje opcjonalne modyfikatorów niestandardowych do odpowiadającego mu parametru. Jeśli określonego argumentu nie opcjonalne modyfikatorów niestandardowych, określ <see langword="null" /> zamiast tablicy typów. Jeśli metoda globalna nie ma argumentów lub ma w żadnym z argumentów opcjonalnych modyfikatorów niestandardowych, określić <see langword="null" /> zamiast tablicy tablic.</param>
        <summary>Definiuje metodę globalne o określonej nazwie, atrybuty, Konwencja wywoływania, typ zwracany, Modyfikatory niestandardowe dla zwracanego typu, typy parametrów i Modyfikatory niestandardowe dla typów parametrów.</summary>
        <returns>Zdefiniowana metoda globalna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest udostępniana dla projektantów zarządzane kompilatory.  
  
 Nie można użyć globalnego metodę, która definiuje tę metodę, do momentu wywołania <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Metoda nie jest statyczne. Oznacza to, że <paramref name="attributes" /> nie obejmuje <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
—lub— 
Element <see cref="T:System.Type" /> tablica jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> Wcześniej wywoływana metoda.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineInitializedData : string * byte[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="moduleBuilder.DefineInitializedData (name, data, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa używana do odwoływania się do danych. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="data">Binarny dużych obiektów (BLOB) danych.</param>
        <param name="attributes">Atrybuty dla pola. Wartość domyślna to <see langword="Static" />.</param>
        <summary>Definiuje pole danych zainicjowanych sekcję .sdata przenośny plik wykonywalny (PE).</summary>
        <returns>Pole odwołania do wybranych danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldAttributes.Static> jest automatycznie uwzględniany we `attributes`.  
  
 Dane zdefiniowane przez tę metodę nie jest tworzony do momentu <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> metoda jest wywoływana.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A> metodę, aby zdefiniować pole danych zainicjowanych w `.sdata` części plików przenośnych plików wykonywalnych (PE).  
  
 [!code-cpp[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/CPP/modulebuilder_defineinitializeddata.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/CS/modulebuilder_defineinitializeddata.cs#1)]
 [!code-vb[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/VB/modulebuilder_defineinitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.  
  
—lub— 
Rozmiar <paramref name="data" /> jest mniejsza lub równa zero lub większa niż lub równa 0x3f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> lub <paramref name="data" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> został wcześniej wywołany.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineManifestResource">
      <MemberSignature Language="C#" Value="public void DefineManifestResource (string name, System.IO.Stream stream, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineManifestResource(string name, class System.IO.Stream stream, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineManifestResource(System::String ^ name, System::IO::Stream ^ stream, System::Reflection::ResourceAttributes attribute);" />
      <MemberSignature Language="F#" Value="member this.DefineManifestResource : string * System.IO.Stream * System.Reflection.ResourceAttributes -&gt; unit" Usage="moduleBuilder.DefineManifestResource (name, stream, attribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Wielkość liter nazwy zasobu.</param>
        <param name="stream">Strumień, który zawiera bajtów dla zasobu.</param>
        <param name="attribute">Wartość wyliczenia, która określa, czy zasób jest publicznych lub prywatnych.</param>
        <summary>Definiuje binarne dużych obiektów (BLOB reprezentujący zasobu manifestu do osadzenia w zestawu dynamicznego).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zasoby, które są rejestrowane w manifeście zestawu mogą być zarządzane zasoby lub manifest zasobów obiektów blob i każdy z nich może być uwzględniany w zestawie, łącząc lub przez osadzanie. Wszystkie cztery scenariusze są obsługiwane dla zestawów dynamicznych.  
  
-   Ta metoda umożliwia osadzanie manifestu zasobów obiektów BLOB w ramach zestawu dynamicznego.  
  
-   Aby Osadź zarządzany zasób do manifestu modułu zestawu dynamicznego lub w module satelity, należy użyć <xref:System.Reflection.Emit.ModuleBuilder.DefineResource%2A?displayProperty=nameWithType> metodę, aby uzyskać Edytor zasobów oraz <xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType> metodę, aby dodać nowy zasób.  
  
-   Aby połączyć zasobów zarządzanych w zestawie dynamicznym, użyj <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A?displayProperty=nameWithType> metodę, aby uzyskać Edytor zasobów oraz <xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType> metody w celu dodania zasobu połączonego.  
  
-   Aby połączyć zasobu manifestu obiektu BLOB do zestawu dynamicznego, użyj <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A?displayProperty=nameWithType> metody w celu dodania zasobu połączonego.  
  
 Ponadto pojedynczy zasób Win32 można dołączyć do zestawu przy użyciu <xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType> metody lub <xref:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType> metody. Ten zasób jest niewidoczny w manifeście zestawu.  
  
   
  
## Examples  
 Poniższy przykład generuje i zapisuje zestawu dynamicznego o nazwie `EmittedManifestResourceAssembly.exe`, który zawiera osadzony niezarządzany zasób. Ten przykład tworzy zestaw, który składa się z jednego modułu i zostanie otwarty strumień pamięci, aby zawierała niezarządzany zasób. Następnie wywołuje kod <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> metodę, aby zdefiniować zasób.  
  
> [!NOTE]
>  Można użyć dowolnego rodzaju strumienia zasobu bazy danych; na przykład można odczytać niezarządzanych danych binarnych z pliku.  
  
 W przykładzie zdefiniowano typ w module dynamiczne z `Main` metody i generuje treści metody MSIL. Po treść `Main` zostało wygenerowane metody i typu została utworzona, w przykładzie kodu zapisuje 5 bajtów w strumieniu skojarzone z zasobu manifestu. Po zapisaniu zestaw zasobów jest dołączany do niego.  
  
 Po uruchomieniu przykładu, możesz uruchomić emitowany zestaw. Kod w zestawie emitowany `Main` metoda odczytuje osadzonego zasobu manifestu i drukuje wartości bajtów do konsoli. Możesz użyć [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Aby wyświetlić informacje w manifeście zestawu.  
  
 [!code-csharp[DefineManifestResource#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineManifestResource/cs/source.cs#1)]
 [!code-vb[DefineManifestResource#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineManifestResource/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="stream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest ciągiem o zerowej długości.</exception>
        <exception cref="T:System.InvalidOperationException">Zestaw dynamiczny, który zawiera bieżącego modułu jest przejściowy; oznacza to, że nazwa pliku nie została określona podczas <see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" /> została wywołana.</exception>
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)" />
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)" />
        <altmember cref="M:System.Resources.ResourceWriter.AddResource(System.String,System.String)" />
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)" />
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)" />
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje <see langword="PInvoke" /> metody.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefinePInvokeMethod (name, dllName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa <see langword="PInvoke" /> metody. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="dllName">Nazwa biblioteki DLL, w którym <see langword="PInvoke" /> metoda jest zdefiniowana.</param>
        <param name="attributes">Atrybuty metody.</param>
        <param name="callingConvention">Konwencja wywołania metody.</param>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <param name="nativeCallConv">Natywną Konwencję wywoływania.</param>
        <param name="nativeCharSet">Metoda macierzystym zestawem znaków.</param>
        <summary>Definiuje <see langword="PInvoke" /> metody za pomocą określonej nazwy, nazwa pliku DLL, w którym metoda jest określona, atrybuty metody, konwencja wywołania metody, zwracany typ metody, typy parametrów metody i <see langword="PInvoke" />flagi.</summary>
        <returns>Zdefiniowane <see langword="PInvoke" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre atrybuty importowania bibliotek DLL (zobacz opis System.Runtime.InteropServices.DllImportAttribute) nie można określić jako argumenty tej metody. Takie atrybuty powinien być ustawiony przez emitowanie atrybutu niestandardowego dla metody. Na przykład biblioteka DLL import — atrybut `PreserveSig` jest ustawiana przez emitowanie atrybutów niestandardowych.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `DefinePInvokeMethod` metodę w celu utworzenia <xref:System.Reflection.Emit.MethodBuilder> dla niezarządzanych metody zewnętrznej, `MessageBoxA`, w interfejsie API Win32. Przykład wyświetla okno komunikatu z **ponów** i **anulować** przyciski, a następnie wyświetla wartość zwrotną z elementu okno komunikatu.  
  
> [!IMPORTANT]
>  Aby uzyskać wartość zwracaną różna od zera, należy dodać <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> do implementacji metody flag, po utworzeniu <xref:System.Reflection.Emit.MethodBuilder>, za pomocą <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> i <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> metody.  
  
 [!code-cpp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CPP/modulebuilder_definepinvokemethod1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CS/modulebuilder_definepinvokemethod1.cs#1)]
 [!code-vb[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/VB/modulebuilder_definepinvokemethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Metoda nie jest statyczny lub jeśli typ zawierający jest interfejs.  
  
—lub— 
Metoda jest abstrakcyjna.  
  
—lub— 
Metoda poprzednio został zdefiniowany.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> lub <paramref name="dllName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ zawierający poprzednio utworzono za pomocą <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /></exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa <see langword="PInvoke" /> metody. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="dllName">Nazwa biblioteki DLL, w którym <see langword="PInvoke" /> metoda jest zdefiniowana.</param>
        <param name="entryName">Nazwa punktu wejścia w DLL.</param>
        <param name="attributes">Atrybuty metody.</param>
        <param name="callingConvention">Konwencja wywołania metody.</param>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <param name="nativeCallConv">Natywną Konwencję wywoływania.</param>
        <param name="nativeCharSet">Metoda macierzystym zestawem znaków.</param>
        <summary>Definiuje <see langword="PInvoke" /> metody za pomocą określonej nazwy, nazwa pliku DLL, w którym metoda jest określona, atrybuty metody, konwencja wywołania metody, zwracany typ metody, typy parametrów metody i <see langword="PInvoke" />flagi.</summary>
        <returns>Zdefiniowane <see langword="PInvoke" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre biblioteki DLL zaimportować atrybutów (zobacz opis <xref:System.Runtime.InteropServices.DllImportAttribute>) nie można określić jako argumenty tej metody. Takie atrybuty powinien być ustawiony przez emitowanie atrybutu niestandardowego dla metody. Na przykład biblioteka DLL import — atrybut `PreserveSig` jest ustawiana przez emitowanie atrybutów niestandardowych.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `DefinePInvokeMethod` metodę w celu utworzenia <xref:System.Reflection.Emit.MethodBuilder> dla niezarządzanych metody zewnętrznej, `MessageBoxA`, w interfejsie API Win32. Przykład wyświetla okno komunikatu z **ponów** i **anulować** przyciski, a następnie wyświetla wartość zwrotną z elementu okno komunikatu.  
  
> [!IMPORTANT]
>  Aby uzyskać wartość zwracaną różna od zera, należy dodać <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> do implementacji metody flag, po utworzeniu <xref:System.Reflection.Emit.MethodBuilder>, za pomocą <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> i <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> metody.  
  
 W tym przykładzie użyto innego przeciążenia <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A> metody, ale techniki jest taka sama.  
  
 [!code-cpp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CPP/modulebuilder_definepinvokemethod1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CS/modulebuilder_definepinvokemethod1.cs#1)]
 [!code-vb[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/VB/modulebuilder_definepinvokemethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Metoda nie jest statyczny lub jeśli typ zawierający jest interfejs lub metoda jest abstrakcyjna, jeśli metoda została wcześniej zdefiniowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> lub <paramref name="dllName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ zawierający poprzednio utworzono za pomocą <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje zarządzanych zasobów osadzonych, która ma być przechowywany w tym module.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineResource (name As String, description As String) As IResourceWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Resources::IResourceWriter ^ DefineResource(System::String ^ name, System::String ^ description);" />
      <MemberSignature Language="F#" Value="member this.DefineResource : string * string -&gt; System.Resources.IResourceWriter" Usage="moduleBuilder.DefineResource (name, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zasobu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="description">Opis zasobu.</param>
        <summary>Definiuje nazwany zarządzanych zasobów osadzonych, aby znajdować się w tym module.</summary>
        <returns>Edytor zasobów dla określonych zasobów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący nie mogą wywoływać `ResourceWriter.Generate()` i `ResourceWriter.Close()` metod, ponieważ te metody są wywoływane przez `ModuleBuilder.Save` po zestawu dynamicznego są zapisywane na dysku.  
  
 Ta metoda umożliwia Osadź zarządzany zasób. Aby osadzić blob zasobu manifestu, należy użyć <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> metody. Aby uzyskać podsumowanie osadzanie i łączenie zasobów zarządzanych i obiektów blob zasobu manifestu, zobacz <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> metody.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `DefineResource` można dodać zasobu zewnętrznego do bieżącego <xref:System.Reflection.Emit.ModuleBuilder>.  
  
 [!code-cpp[ModuleBuilder_DefineResource1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineResource1/CPP/modulebuilder_defineresource1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineResource1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineResource1/CS/modulebuilder_defineresource1.cs#1)]
 [!code-vb[ModuleBuilder_DefineResource1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineResource1/VB/modulebuilder_defineresource1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ma wartość null.</exception>
        <exception cref="T:System.InvalidOperationException">Ten moduł jest przejściowy.  
  
—lub— 
Zawierające zestaw nie jest stałe.</exception>
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      </Docs>
    </Member>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineResource (name As String, description As String, attribute As ResourceAttributes) As IResourceWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Resources::IResourceWriter ^ DefineResource(System::String ^ name, System::String ^ description, System::Reflection::ResourceAttributes attribute);" />
      <MemberSignature Language="F#" Value="member this.DefineResource : string * string * System.Reflection.ResourceAttributes -&gt; System.Resources.IResourceWriter" Usage="moduleBuilder.DefineResource (name, description, attribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa zasobu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="description">Opis zasobu.</param>
        <param name="attribute">Atrybuty zasobu.</param>
        <summary>Definiuje nazwany zarządzanych osadzonego zasobu za pomocą podane atrybuty, który ma być przechowywany w tym module.</summary>
        <returns>Edytor zasobów dla określonych zasobów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt wywołujący nie mogą wywoływać `ResourceWriter.Generate()` i `ResourceWriter.Close()` metod, ponieważ te metody są wywoływane przez `ModuleBuilder.Save` po zestawu dynamicznego są zapisywane na dysku.  
  
 Ta metoda umożliwia Osadź zarządzany zasób. Aby osadzić blob zasobu manifestu, należy użyć <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> metody. Aby uzyskać podsumowanie osadzanie i łączenie zasobów zarządzanych i obiektów blob zasobu manifestu, zobacz <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> metody.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie DefineResource można dodać zasobu zewnętrznego do bieżącego <xref:System.Reflection.Emit.ModuleBuilder>.  
  
 [!code-cpp[ModuleBuilder_DefineResource2#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineResource2/CPP/modulebuilder_defineresource2.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineResource2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineResource2/CS/modulebuilder_defineresource2.cs#1)]
 [!code-vb[ModuleBuilder_DefineResource2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineResource2/VB/modulebuilder_defineresource2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ma wartość null.</exception>
        <exception cref="T:System.InvalidOperationException">Ten moduł jest przejściowy.  
  
—lub— 
Zawierające zestaw nie jest stałe.</exception>
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konstruuje <see langword="TypeBuilder" />. Aby zdefiniować typ wartości, należy zdefiniować typ, który pochodzi od klasy <see cref="T:System.ValueType" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Pełna ścieżka tego typu, włącznie z przestrzenią nazw. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <summary>Konstruuje <see langword="TypeBuilder" /> prywatnej typu o określonej nazwie w tym module.</summary>
        <returns>Prywatny typ o określonej nazwie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ nazwy muszą być unikatowe w obrębie zestawu. Dwa typy o takiej samej nazwie może znajdować się w dwóch różnych modułach zestawu.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Reflection.Emit.TypeBuilder> w bieżącym przy użyciu modułu dynamicznego `CreateType`, kompilacji i zakończeniu typu i zapisuje zestawu.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Typ o podanej nazwie istnieje w zestawie nadrzędny tego modułu.  
  
—lub— 
Typ zagnieżdżony atrybuty są ustawione na typ, który nie jest zagnieżdżona.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Pełna ścieżka tego typu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attr">Atrybuty zdefiniowanego typu.</param>
        <summary>Konstruuje <see langword="TypeBuilder" /> podanej nazwy typu i atrybuty typu.</summary>
        <returns>A <see langword="TypeBuilder" /> utworzone przy użyciu wszystkich wymaganych atrybutów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ nazwy muszą być unikatowe w obrębie zestawu. Dwa typy o takiej samej nazwie może znajdować się w dwóch różnych modułach zestawu.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Reflection.Emit.TypeBuilder> w bieżącym przy użyciu modułu dynamicznego `CreateType`, kompilacji i zakończeniu typu i zapisuje zestawu.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Typ o podanej nazwie istnieje w zestawie nadrzędny tego modułu.  
  
—lub— 
Typ zagnieżdżony atrybuty są ustawione na typ, który nie jest zagnieżdżona.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Pełna ścieżka tego typu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attr">Atrybut, który ma zostać skojarzony z typem.</param>
        <param name="parent">Typ, który rozszerza zdefiniowanego typu.</param>
        <summary>Konstruuje <see langword="TypeBuilder" /> podanej nazwy typu, jego atrybuty oraz typ, który rozszerza zdefiniowanego typu.</summary>
        <returns>A <see langword="TypeBuilder" /> utworzone przy użyciu wszystkich wymaganych atrybutów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ nazwy muszą być unikatowe w obrębie zestawu. Dwa typy o takiej samej nazwie może znajdować się w dwóch różnych modułach zestawu.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Reflection.Emit.TypeBuilder> w bieżącym przy użyciu modułu dynamicznego `CreateType`, kompilacji i zakończeniu typu i zapisuje zestawu.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Typ o podanej nazwie istnieje w zestawie nadrzędny tego modułu.  
  
—lub— 
Typ zagnieżdżony atrybuty są ustawione na typ, który nie jest zagnieżdżona.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, int typesize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typesize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type, typesize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typesize);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, typesize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typesize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Pełna ścieżka tego typu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attr">Atrybuty zdefiniowanego typu.</param>
        <param name="parent">Typ, który rozszerza zdefiniowanego typu.</param>
        <param name="typesize">Całkowity rozmiar tego typu.</param>
        <summary>Konstruuje <see langword="TypeBuilder" /> danej nazwy typu, atrybuty, typ, który rozszerza zdefiniowanego typu i całkowity rozmiar tego typu.</summary>
        <returns>Element <see langword="TypeBuilder" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ nazwy muszą być unikatowe w obrębie zestawu. Ma dwa typy o takiej samej nazwie w dwóch różnych modułach zestawu jest zabronione.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Reflection.Emit.TypeBuilder> w bieżącym przy użyciu modułu dynamicznego `CreateType`, kompilacji i zakończeniu typu i zapisuje zestawu.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Typ o podanej nazwie istnieje w zestawie nadrzędny tego modułu.  
  
—lub— 
Typ zagnieżdżony atrybuty są ustawione na typ, który nie jest zagnieżdżona.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packsize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packsize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type, packsize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packsize);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, packsize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packsize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">Pełna ścieżka tego typu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attr">Atrybuty zdefiniowanego typu.</param>
        <param name="parent">Typ, który rozszerza zdefiniowanego typu.</param>
        <param name="packsize">Rozmiar pakowania tego typu.</param>
        <summary>Konstruuje <see langword="TypeBuilder" /> danej nazwy typu, atrybuty, typ, który rozszerza zdefiniowanego typu i rozmiarem pakowania tego typu.</summary>
        <returns>Element <see langword="TypeBuilder" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ nazwy muszą być unikatowe w obrębie zestawu. Dwa typy o takiej samej nazwie może znajdować się w dwóch różnych modułach zestawu.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Reflection.Emit.TypeBuilder> w bieżącym przy użyciu modułu dynamicznego `CreateType`, kompilacji i zakończeniu typu i zapisuje zestawu.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Typ o podanej nazwie istnieje w zestawie nadrzędny tego modułu.  
  
—lub— 
Typ zagnieżdżony atrybuty są ustawione na typ, który nie jest zagnieżdżona.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * Type[] -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, interfaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Pełna ścieżka tego typu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attr">Atrybuty, które ma zostać skojarzony z typem.</param>
        <param name="parent">Typ, który rozszerza zdefiniowanego typu.</param>
        <param name="interfaces">Lista interfejsów, które implementuje.</param>
        <summary>Konstruuje <see langword="TypeBuilder" /> danej nazwy typu, atrybuty, typ, który rozszerza zdefiniowanego typu i interfejsy, które implementuje zdefiniowanego typu.</summary>
        <returns>A <see langword="TypeBuilder" /> utworzone przy użyciu wszystkich wymaganych atrybutów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ nazwy muszą być unikatowe w obrębie zestawu. Dwa typy o takiej samej nazwie może znajdować się w dwóch różnych modułach zestawu.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Reflection.Emit.TypeBuilder> w bieżącym przy użyciu modułu dynamicznego `CreateType`, kompilacji i zakończeniu typu i zapisuje zestawu.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Typ o podanej nazwie istnieje w zestawie nadrzędny tego modułu.  
  
—lub— 
Typ zagnieżdżony atrybuty są ustawione na typ, który nie jest zagnieżdżona.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packingSize, int typesize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packingSize, int32 typesize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packingSize, int typesize);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, packingSize, typesize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packingSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typesize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Pełna ścieżka tego typu. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="attr">Atrybuty zdefiniowanego typu.</param>
        <param name="parent">Typ, który rozszerza zdefiniowanego typu.</param>
        <param name="packingSize">Rozmiar pakowania tego typu.</param>
        <param name="typesize">Całkowity rozmiar tego typu.</param>
        <summary>Konstruuje <see langword="TypeBuilder" /> danej nazwy typu, atrybuty, typ, który rozszerza zdefiniowanego typu, rozmiar pakowania zdefiniowanego typu i całkowity rozmiar zdefiniowanego typu.</summary>
        <returns>A <see langword="TypeBuilder" /> utworzone przy użyciu wszystkich wymaganych atrybutów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ nazwy muszą być unikatowe w obrębie zestawu. Dwa typy o takiej samej nazwie może znajdować się w dwóch różnych modułach zestawu.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Reflection.Emit.TypeBuilder> w bieżącym przy użyciu modułu dynamicznego `CreateType`, kompilacji i zakończeniu typu i zapisuje zestawu.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Typ o podanej nazwie istnieje w zestawie nadrzędny tego modułu.  
  
—lub— 
Typ zagnieżdżony atrybuty są ustawione na typ, który nie jest zagnieżdżona.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineUninitializedData : string * int * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="moduleBuilder.DefineUninitializedData (name, size, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa używana do odwoływania się do danych. <c>Nazwa</c> nie może zawierać osadzone wartości.</param>
        <param name="size">Rozmiar pola danych.</param>
        <param name="attributes">Atrybuty dla pola.</param>
        <summary>Definiuje pole niezainicjowanych danych sekcję .sdata przenośny plik wykonywalny (PE).</summary>
        <returns>Pole odwołania do wybranych danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldAttributes.Static> jest automatycznie uwzględniany we `attributes`.  
  
 Dane zdefiniowane przez tę metodę nie jest tworzony do momentu <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> metoda jest wywoływana.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="name" /> wynosi zero.  
  
—lub— 
 <paramref name="size" /> jest mniejsza niż lub równa zero, lub większa niż lub równą 0x003f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> został wcześniej wywołany.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineUnmanagedResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje niezarządzany zasób, w tym module. Duży obiekt binarny (BLOB) musi mieć w formacie odpowiednim dla zasobów Win32.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (byte[] resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(unsigned int8[] resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineUnmanagedResource (resource As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineUnmanagedResource(cli::array &lt;System::Byte&gt; ^ resource);" />
      <MemberSignature Language="F#" Value="member this.DefineUnmanagedResource : byte[] -&gt; unit" Usage="moduleBuilder.DefineUnmanagedResource resource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resource" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="resource">Nieprzezroczysty obiekt BLOB, który reprezentuje niezarządzany zasób</param>
        <summary>Definiuje niezarządzany zasób osadzony podane nieprzezroczyste binarne dużych obiektów (BLOB bajtów).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw może być skojarzony tylko jeden zasób niezarządzany. Oznacza to, że wywołanie `DefineVersionInfoResource` lub `DefineUnmanagedResource` po wywołaniu jednej z metod wywołano wcześniej zgłasza <xref:System.ArgumentException>. Wiele niezarządzanych zasobów muszą być połączony z narzędzia, takiego jak narzędzie Microsoft ResMerge (nie w zestawie plików wykonywalnych języka wspólnego).  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Niezarządzany zasób został już zdefiniowany w zestawie modułu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resource" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (string resourceFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(string resourceFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineUnmanagedResource (resourceFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineUnmanagedResource(System::String ^ resourceFileName);" />
      <MemberSignature Language="F#" Value="member this.DefineUnmanagedResource : string -&gt; unit" Usage="moduleBuilder.DefineUnmanagedResource resourceFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceFileName">Nazwa pliku zasobów niezarządzanych.</param>
        <summary>Definiuje zasób niezarządzany, biorąc pod uwagę nazwę pliku zasobów Win32.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw może być skojarzony tylko jeden zasób niezarządzany. Oznacza to, że wywołanie `DefineVersionInfoResource` lub `DefineUnmanagedResource` po wywołaniu jednej z metod wywołano wcześniej zgłasza <xref:System.ArgumentException>. Wiele niezarządzanych zasobów muszą być połączony z narzędzia, takiego jak narzędzie Microsoft ResMerge (nie w zestawie plików wykonywalnych języka wspólnego).  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Niezarządzany zasób został już zdefiniowany w zestawie modułu.  
  
—lub— 
 <paramref name="resourceFileName" /> ciąg pusty ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="resourceFileName" /> Nie można odnaleźć.  
  
—lub— 
 <paramref name="resourceFileName" /> jest katalogiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="moduleBuilder.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z tym wystąpieniem lub <see langword="null" />.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest taki sam jak określony obiekt.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> equals typ i wartość tego wystąpienia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public override string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullyQualifiedName : string" Usage="System.Reflection.Emit.ModuleBuilder.FullyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see langword="String" /> reprezentuje w pełni kwalifikowana nazwa i ścieżka do tego modułu.</summary>
        <value>Nazwa FQDN modułu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać nazwę bez ścieżki, należy użyć `Name`.  
  
> [!NOTE]
>  Wielkość liter nazwy modułu to platforma zależnych.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Uzyskuje dostęp do informacji w ścieżce. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetArrayMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetArrayMethod (Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetArrayMethod(class System.Type arrayClass, string methodName, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetArrayMethod (arrayClass As Type, methodName As String, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetArrayMethod(Type ^ arrayClass, System::String ^ methodName, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetArrayMethod : Type * string * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.MethodInfo" Usage="moduleBuilder.GetArrayMethod (arrayClass, methodName, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="arrayClass">Array — klasa.</param>
        <param name="methodName">Nazwa metody w klasie tablicy.</param>
        <param name="callingConvention">Konwencja wywołania metody.</param>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <summary>Zwraca metodę o nazwie w klasie tablicy.</summary>
        <returns>Metoda o nazwie dla klasy tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetArrayMethod` jest przydatne, gdy masz tablicę typu, którego definicja nie została zakończona i chcesz uzyskać dostęp do metody zdefiniowane w <xref:System.Array>. Na przykład możesz zdefiniować typ i aby zdefiniować metodę, która przyjmuje tablicę typu jako parametru. Aby uzyskać dostęp do elementów tablicy, należy wywołać metody <xref:System.Array> klasy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A> uzyskać <xref:System.Reflection.MethodInfo> odpowiadającej metody, która zwraca wartości tablicy.  
  
 [!code-cpp[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CPP/modulebuilder_getarraymethod.cpp#1)]
 [!code-csharp[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CS/modulebuilder_getarraymethod.cs#1)]
 [!code-vb[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/VB/modulebuilder_getarraymethod.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayClass" /> nie jest tablicą.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayClass" /> lub <paramref name="methodName" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetArrayMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetArrayMethodToken (Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetArrayMethodToken(class System.Type arrayClass, string methodName, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetArrayMethodToken (arrayClass As Type, methodName As String, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetArrayMethodToken(Type ^ arrayClass, System::String ^ methodName, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetArrayMethodToken : Type * string * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetArrayMethodToken (arrayClass, methodName, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="arrayClass">Obiekt tablicy.</param>
        <param name="methodName">Ciąg, który zawiera nazwę metody.</param>
        <param name="callingConvention">Konwencja wywołania metody.</param>
        <param name="returnType">Zwracany typ metody.</param>
        <param name="parameterTypes">Typy parametrów metody.</param>
        <summary>Zwraca token dla metody nazwanej klasy tablicy.</summary>
        <returns>Token o nazwie metody w klasie tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest podobna do <xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A>, chyba że zwraca ona token metody tablicy, zamiast sama metoda.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A> uzyskać <xref:System.Reflection.Emit.MethodToken> odpowiadającej metody, która zwraca wartości tablicy.  
  
 [!code-cpp[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CPP/modulebuilder_getarraymethod.cpp#2)]
 [!code-csharp[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CS/modulebuilder_getarraymethod.cs#2)]
 [!code-vb[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/VB/modulebuilder_getarraymethod.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayClass" /> nie jest tablicą.  
  
—lub— 
Długość <paramref name="methodName" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayClass" /> lub <paramref name="methodName" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructorToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca token używany do identyfikowania określonego konstruktora, w tym module.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructorToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetConstructorToken (System.Reflection.ConstructorInfo con);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetConstructorToken(class System.Reflection.ConstructorInfo con) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructorToken (con As ConstructorInfo) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetConstructorToken(System::Reflection::ConstructorInfo ^ con);" />
      <MemberSignature Language="F#" Value="member this.GetConstructorToken : System.Reflection.ConstructorInfo -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetConstructorToken con" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="con">Konstruktor, który można pobrać tokenu dla.</param>
        <summary>Zwraca token używany do identyfikowania określonego konstruktora, w tym module.</summary>
        <returns>Token używany do identyfikowania określonego konstruktora, w tym module.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetConstructorToken (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;Type&gt; optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetConstructorToken(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructorToken (constructor As ConstructorInfo, optionalParameterTypes As IEnumerable(Of Type)) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetConstructorToken(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetConstructorToken : System.Reflection.ConstructorInfo * seq&lt;Type&gt; -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetConstructorToken (constructor, optionalParameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">Konstruktor, który można pobrać tokenu dla.</param>
        <param name="optionalParameterTypes">Kolekcja typów do konstruktora następujące parametry opcjonalne.</param>
        <summary>Zwraca token używany do identyfikowania Konstruktor, który ma określone atrybuty i typy parametrów w ramach tego modułu.</summary>
        <returns>Token używany do identyfikowania określonego konstruktora, w tym module.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca atrybuty niestandardowe, które są stosowane do bieżącego <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="moduleBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Ten argument jest ignorowany w przypadku obiektów tego typu.</param>
        <summary>Zwraca wszystkie atrybuty niestandardowe, które zostały zastosowane do bieżącego <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
        <returns>Tablica zawierająca atrybutów niestandardowych; Tablica jest pusta, jeśli istnieją żadne atrybuty.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="moduleBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Typ podstawowy, z której pochodzi atrybutów.</param>
        <param name="inherit">Ten argument jest ignorowany w przypadku obiektów tego typu.</param>
        <summary>Zwraca wszystkie atrybuty niestandardowe, które zostały zastosowane do bieżącego <see cref="T:System.Reflection.Emit.ModuleBuilder" />, i który pochodzi od typu określonego atrybutu.</summary>
        <returns>Tablica zawierająca atrybutów niestandardowych, które są uzyskiwane na dowolnym poziomie z <paramref name="attributeType" />; tablica jest pusta, jeśli takie atrybuty nie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> nie jest <see cref="T:System.Type" /> obiekt dostarczony w czasie wykonywania. Na przykład <paramref name="attributeType" /> jest <see cref="T:System.Reflection.Emit.TypeBuilder" /> obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="moduleBuilder.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca informacje na temat atrybutów, które zostały zastosowane do bieżącego <see cref="T:System.Reflection.Emit.ModuleBuilder" />, wyrażona jako <see cref="T:System.Reflection.CustomAttributeData" /> obiektów.</summary>
        <returns>Z listy ogólnej <see cref="T:System.Reflection.CustomAttributeData" /> obiekty reprezentujące dane dotyczące atrybutów, które zostały zastosowane do bieżącego modułu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby sprawdzić kod w kontekstu reflection-only, w przypadkach, gdzie atrybutów niestandardowych, samodzielnie są zdefiniowane w kodzie, który jest ładowany do kontekstu reflection-only atrybutów niestandardowych. Metody, takie jak <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> i <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> nie można użyć w takich przypadkach, ponieważ mogą one tworzyć wystąpienia atrybutów. Nie można wykonać kod w kontekstu reflection-only. Aby uzyskać więcej informacji i przykład kodu, zobacz <xref:System.Reflection.CustomAttributeData> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="moduleBuilder.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa pola.</param>
        <param name="bindingAttr">Kombinacji <see langword="BindingFlags" /> bit flagi używane do kontrolowania wyszukiwania.</param>
        <summary>Zwraca poziom modułu zdefiniowane pole w regionie .sdata przenośny plik wykonywalny (PE), która ma określoną nazwę i atrybuty powiązania.</summary>
        <returns>Pola, które ma określoną nazwę i atrybuty powiązania lub <see langword="null" /> Jeśli pole nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy użytkownik emitowanie dynamicznych zestawów, pola w regionie .sdata plików przenośnych plików wykonywalnych (PE) są definiowane za pomocą <xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A> lub <xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A> metody.  
  
> [!IMPORTANT]
>  Poziom modułu pola nie mogą zostać pobrane do momentu po <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> metoda została wywołana dla modułu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="moduleBuilder.GetFields bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">Kombinacji <see langword="BindingFlags" /> bit flagi używane do kontrolowania wyszukiwania.</param>
        <summary>Zwraca wszystkie pola zdefiniowane w regionie .sdata plików przenośnych plików wykonywalnych (PE), które odpowiadają flagi określone powiązanie.</summary>
        <returns>Tablica polami, które odpowiadają na określone flagi; Tablica jest pusta, jeśli istnieje żadnych z tych pól.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy użytkownik emitowanie dynamicznych zestawów, pola w regionie .sdata plików przenośnych plików wykonywalnych (PE) są definiowane za pomocą <xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A> lub <xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A> metody.  
  
> [!IMPORTANT]
>  Poziom modułu pola nie mogą zostać pobrane do momentu po <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> metoda została wywołana dla modułu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> Parametr <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFieldToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldToken GetFieldToken (System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.FieldToken GetFieldToken(class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFieldToken (field As FieldInfo) As FieldToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldToken GetFieldToken(System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="member this.GetFieldToken : System.Reflection.FieldInfo -&gt; System.Reflection.Emit.FieldToken" Usage="moduleBuilder.GetFieldToken field" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="field">Pole, które można pobrać tokenu dla.</param>
        <summary>Zwraca token używany do identyfikowania określonego pola w ramach tego modułu.</summary>
        <returns>Token używany do identyfikowania określonego pola w ramach tego modułu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="field" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="moduleBuilder.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="moduleBuilder.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody.</param>
        <param name="bindingAttr">Kombinacji <see langword="BindingFlags" /> bit flagi używane do kontrolowania wyszukiwania.</param>
        <param name="binder">Obiekt, który implementuje <see langword="Binder" />, zawierający właściwości związane z tej metody.</param>
        <param name="callConvention">Konwencja wywołania metody.</param>
        <param name="types">Typy parametrów metody.</param>
        <param name="modifiers">Tablica Modyfikatory parametrów umożliwia powiązanie, Praca z sygnaturami parametru, w których typy zostały zmodyfikowane.</param>
        <summary>Zwraca metodę poziom modułu, która spełnia określone kryteria.</summary>
        <returns>Metody, która jest zdefiniowana na poziomie modułu i odpowiadającego określonym kryteriom; lub <see langword="null" /> jeśli taka metoda nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia wdrożenia dla wszystkich przeciążeń z dziedziczonego <xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType> metody. Użyj dziedziczonego <xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType> metodę, aby uzyskać metody, które zostały zadeklarowane na poziomie modułu. Poziom modułu metody są zdefiniowane w emitowany kod za pomocą <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A> metody.  
  
> [!IMPORTANT]
>  Metody na poziomie modułu nie mogą zostać pobrane do momentu po <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> metoda została wywołana dla modułu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />, <paramref name="types" /> jest <see langword="null" />, lub element <paramref name="types" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="moduleBuilder.GetMethods bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">Kombinacji <see langword="BindingFlags" /> bit flagi używane do kontrolowania wyszukiwania.</param>
        <summary>Zwraca wszystkie metody, które zostały zdefiniowane na poziomie modułu dla bieżącego <see cref="T:System.Reflection.Emit.ModuleBuilder" />, które spełniają określone powiązanie flag.</summary>
        <returns>Tablica zawierająca wszystkie metody poziom modułu, które odpowiadają <paramref name="bindingFlags" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom modułu metody są zdefiniowane w emitowany kod za pomocą <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A> metody.  
  
> [!IMPORTANT]
>  Metody na poziomie modułu nie mogą zostać pobrane do momentu po <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> metoda została wywołana dla modułu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca token używany do identyfikowania określonej metody w ramach tego modułu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetMethodToken (System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetMethodToken(class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethodToken (method As MethodInfo) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetMethodToken(System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="member this.GetMethodToken : System.Reflection.MethodInfo -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetMethodToken method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="method">Metoda można pobrać tokenu dla.</param>
        <summary>Zwraca token używany do identyfikowania określonej metody w ramach tego modułu.</summary>
        <returns>Token używany do identyfikowania określonej metody w ramach tego modułu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ deklarujący dla metody nie jest w tym module.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetMethodToken (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;Type&gt; optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetMethodToken(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethodToken (method As MethodInfo, optionalParameterTypes As IEnumerable(Of Type)) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetMethodToken(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetMethodToken : System.Reflection.MethodInfo * seq&lt;Type&gt; -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetMethodToken (method, optionalParameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="method">Metoda można pobrać tokenu dla.</param>
        <param name="optionalParameterTypes">Kolekcja typów parametrów opcjonalnych do metody.</param>
        <summary>Zwraca token używany do identyfikowania metodę, która ma określone atrybuty i typy parametrów w ramach tego modułu.</summary>
        <returns>Token używany do identyfikowania określonej metody w ramach tego modułu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Typ deklarujący dla metody nie jest w tym module.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public override void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub GetPEKind (ByRef peKind As PortableExecutableKinds, ByRef machine As ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void GetPEKind([Runtime::InteropServices::Out] System::Reflection::PortableExecutableKinds % peKind, [Runtime::InteropServices::Out] System::Reflection::ImageFileMachine % machine);" />
      <MemberSignature Language="F#" Value="override this.GetPEKind :  *  -&gt; unit" Usage="moduleBuilder.GetPEKind (peKind, machine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">Po powrocie z tej metody kombinacji <see cref="T:System.Reflection.PortableExecutableKinds" /> wartości wskazujący rodzaj kodu w module.</param>
        <param name="machine">Gdy ta metoda zwraca jeden z <see cref="T:System.Reflection.ImageFileMachine" /> wartości oznaczają platformy docelowej przez moduł.</param>
        <summary>Pobiera pary wartości, wskazując rodzaj kodu w module i platformy docelowej przez moduł.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla modułów dynamicznych `peKind` jest zawsze <xref:System.Reflection.PortableExecutableKinds.NotAPortableExecutableImage?displayProperty=nameWithType> i `machine` jest zawsze 0 (zero).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSignatureToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje podpis tokenu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSignatureToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.SignatureToken GetSignatureToken (System.Reflection.Emit.SignatureHelper sigHelper);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.SignatureToken GetSignatureToken(class System.Reflection.Emit.SignatureHelper sigHelper) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSignatureToken (sigHelper As SignatureHelper) As SignatureToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::SignatureToken GetSignatureToken(System::Reflection::Emit::SignatureHelper ^ sigHelper);" />
      <MemberSignature Language="F#" Value="member this.GetSignatureToken : System.Reflection.Emit.SignatureHelper -&gt; System.Reflection.Emit.SignatureToken" Usage="moduleBuilder.GetSignatureToken sigHelper" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.SignatureToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sigHelper" Type="System.Reflection.Emit.SignatureHelper" />
      </Parameters>
      <Docs>
        <param name="sigHelper">Podpis.</param>
        <summary>Definiuje token dla podpisu, który jest zdefiniowany przez określony <see cref="T:System.Reflection.Emit.SignatureHelper" />.</summary>
        <returns>Token do zdefiniowanych podpisu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda definiuje token metadanych dla podpisu opisanego przez `sigHelper`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sigHelper" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSignatureToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.SignatureToken GetSignatureToken (byte[] sigBytes, int sigLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.SignatureToken GetSignatureToken(unsigned int8[] sigBytes, int32 sigLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSignatureToken (sigBytes As Byte(), sigLength As Integer) As SignatureToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::SignatureToken GetSignatureToken(cli::array &lt;System::Byte&gt; ^ sigBytes, int sigLength);" />
      <MemberSignature Language="F#" Value="member this.GetSignatureToken : byte[] * int -&gt; System.Reflection.Emit.SignatureToken" Usage="moduleBuilder.GetSignatureToken (sigBytes, sigLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.SignatureToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sigBytes" Type="System.Byte[]" />
        <Parameter Name="sigLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sigBytes">Podpis duży obiekt binarny (BLOB).</param>
        <param name="sigLength">Długość podpis obiektu BLOB.</param>
        <summary>Definiuje token dla podpisie, który ma określony znak długości tablicy i podpis.</summary>
        <returns>Token dla określonego podpisu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sigBytes" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSignerCertificate () As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Cryptography::X509Certificates::X509Certificate ^ GetSignerCertificate();" />
      <MemberSignature Language="F#" Value="override this.GetSignerCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate" Usage="moduleBuilder.GetSignerCertificate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> obiektu odpowiadającego certyfikatu objęte podpisu Authenticode pliku zestawu, do której należy ten moduł. Jeśli zestaw nie został podpisany, Authenticode <see langword="null" /> jest zwracana.</summary>
        <returns>Certyfikat, lub <see langword="null" /> Jeśli zestaw, do której należy ten moduł nie został podpisany Authenticode.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStringConstant">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.StringToken GetStringConstant (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.StringToken GetStringConstant(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStringConstant (str As String) As StringToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::StringToken GetStringConstant(System::String ^ str);" />
      <MemberSignature Language="F#" Value="member this.GetStringConstant : string -&gt; System.Reflection.Emit.StringToken" Usage="moduleBuilder.GetStringConstant str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.StringToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg do dodania do puli stałej modułu.</param>
        <summary>Zwraca token podany ciąg w puli stałej modułu.</summary>
        <returns>Token ciągu w stałej puli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `str` został już zdefiniowany, istniejący token zostanie zwrócony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSymWriter">
      <MemberSignature Language="C#" Value="public System.Diagnostics.SymbolStore.ISymbolWriter GetSymWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.SymbolStore.ISymbolWriter GetSymWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSymWriter () As ISymbolWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::SymbolStore::ISymbolWriter ^ GetSymWriter();" />
      <MemberSignature Language="F#" Value="member this.GetSymWriter : unit -&gt; System.Diagnostics.SymbolStore.ISymbolWriter" Usage="moduleBuilder.GetSymWriter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł zapisujący symbol skojarzone z tym modułu dynamicznego.</summary>
        <returns>Edytor symboli, skojarzone z tym modułu dynamicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera nazwany typ zdefiniowany w module.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetType (className As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetType(System::String ^ className);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="moduleBuilder.GetType className" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">Nazwa <see cref="T:System.Type" /> można pobrać.</param>
        <summary>Pobiera nazwany typ zdefiniowany w module.</summary>
        <returns>Żądany typ, jeśli typ jest zdefiniowany w tym module; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy używać tej metody można wygenerować typy tablicowe, typów wskaźnika lub typów byref. Użyj <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>, i <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType> metody zamiast tego.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="className" /> zerową lub jest większy niż 1023.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Żądany <see cref="T:System.Type" /> jest niepublicznych, a obiekt wywołujący nie ma <see cref="T:System.Security.Permissions.ReflectionPermission" /> aby odzwierciedlić obiektów w niepublicznych spoza bieżącego zestawu.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException">Napotkano błąd podczas ładowania <see cref="T:System.Type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetType (className As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetType(System::String ^ className, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="moduleBuilder.GetType (className, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">Nazwa <see cref="T:System.Type" /> można pobrać.</param>
        <param name="ignoreCase">Jeśli <see langword="true" />, wyszukiwanie jest rozróżniana wielkość liter. Jeśli <see langword="false" />, w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <summary>Pobiera nazwany typ zdefiniowany w module, opcjonalnie ignoruje wielkość liter nazwy typu.</summary>
        <returns>Żądany typ, jeśli typ jest zdefiniowany w tym module; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy używać tej metody można wygenerować typy tablicowe, typów wskaźnika lub typów byref. Użyj <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>, i <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType> metody zamiast tego.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="className" /> zerową lub jest większy niż 1023.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Żądany <see cref="T:System.Type" /> jest niepublicznych, a obiekt wywołujący nie ma <see cref="T:System.Security.Permissions.ReflectionPermission" /> aby odzwierciedlić obiektów w niepublicznych spoza bieżącego zestawu.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetType (className As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetType(System::String ^ className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="moduleBuilder.GetType (className, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">Nazwa <see cref="T:System.Type" /> można pobrać.</param>
        <param name="throwOnError">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />.</param>
        <param name="ignoreCase">Jeśli <see langword="true" />, wyszukiwanie jest rozróżniana wielkość liter. Jeśli <see langword="false" />, w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <summary>Pobiera nazwany typ zdefiniowany w module, opcjonalnie ignoruje wielkość liter nazwy typu. Opcjonalnie zgłasza wyjątek, jeśli typ nie zostanie znaleziony.</summary>
        <returns>Określony typ, jeśli typ jest zadeklarowany w tym module; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `throwOnError` Parametr dotyczy tylko, co się stanie, gdy typ nie zostanie znaleziony. Nie ma wpływu na inne wyjątki, które mogą być generowane. W szczególności, jeśli typ zostanie znaleziony, ale nie może zostać załadowany <xref:System.TypeLoadException> mogą być generowane nawet wtedy, gdy `throwOnError` jest `false`.  
  
 Nie należy używać tej metody można wygenerować typy tablicowe, typów wskaźnika lub typów byref. Użyj <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>, i <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType> metody zamiast tego.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość <paramref name="className" /> zerową lub jest większy niż 1023.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Żądany <see cref="T:System.Type" /> jest niepublicznych, a obiekt wywołujący nie ma <see cref="T:System.Security.Permissions.ReflectionPermission" /> aby odzwierciedlić obiektów w niepublicznych spoza bieżącego zestawu.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> jest <see langword="true" /> i nie można odnaleźć określonego typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="override this.GetTypes : unit -&gt; Type[]" Usage="moduleBuilder.GetTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie klasy, które są zdefiniowane w tym module.</summary>
        <returns>Tablica, która zawiera typy zdefiniowane w module, który jest odzwierciedlana przez to wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReflectionTypeLoadException` jest wyjątek obciążenia klasy specjalnej. `ReflectionTypeLoadException.Types` Właściwość zawiera tablicę klas, które zostały zdefiniowane w module i załadowany. Ta tablica może zawierać wartości null. `ReflectionTypeLoadException.LoaderExceptions` Właściwość jest tablicą wyjątki, które reprezentują wyjątki, które były generowane przez moduł ładujący klasy. Luki w tablicy klasy linii z wyjątków.  
  
 Na przykład, jeśli inicjatorów klasy jednej z klas zgłasza wyjątek podczas jego ładowania, `TargetInvocationException` są przechowywane w odpowiedni element `LoaderExceptions` tablicy.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">Nie można załadować co najmniej jedną klasę w module.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca token typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken GetTypeToken (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.TypeToken GetTypeToken(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeToken (name As String) As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeToken GetTypeToken(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetTypeToken : string -&gt; System.Reflection.Emit.TypeToken" Usage="moduleBuilder.GetTypeToken name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa klasy, włącznie z przestrzenią nazw.</param>
        <summary>Zwraca token używany do identyfikowania typu o określonej nazwie.</summary>
        <returns>Token używany do identyfikowania typu o określonej nazwie w ramach tego modułu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przydatna w przypadku klientów z <xref:System.Reflection.Emit.MethodRental> klasy, którzy chcą się bezpośrednie modyfikowanie treści metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> ciąg pusty ("").  
  
—lub— 
 <paramref name="name" /> reprezentuje <see langword="ByRef" /> typu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
Typ określony przez <paramref name="name" /> nie został odnaleziony.</exception>
        <exception cref="T:System.InvalidOperationException">Jest to moduł nieprzejściowych, który odwołuje się do modułu przejściowego.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken GetTypeToken (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.TypeToken GetTypeToken(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeToken GetTypeToken(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.GetTypeToken : Type -&gt; System.Reflection.Emit.TypeToken" Usage="moduleBuilder.GetTypeToken type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Obiekt typu, który reprezentuje typ klasy.</param>
        <summary>Zwraca token używany do identyfikowania określonego typu, w tym module.</summary>
        <returns>Token używany do identyfikowania danego typu, w tym module.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tokeny są używane w instrukcjach języka intermediate language (MSIL) firmy Microsoft, aby zidentyfikować obiekty. Tokeny są względne wobec modułu, w którym się znajdują. Na przykład, wartość tokenu dla `String` może różnić się od moduł. Gdy `GetTypeToken` jest wywołana, dodawania odwołania do modułu. Odwołanie stają się częścią modułu; wiele wywołań z samym argumentem nie obowiązują dodatkowe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> jest <see langword="ByRef" /> typu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jest to moduł nieprzejściowych, który odwołuje się do modułu przejściowego.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="moduleBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Typ atrybutu niestandardowego do testowania.</param>
        <param name="inherit">Ten argument jest ignorowany w przypadku obiektów tego typu.</param>
        <summary>Zwraca wartość wskazującą, czy podanego typu atrybutu zostało zastosowane do tego modułu.</summary>
        <returns>
          <see langword="true" /> Jeśli co najmniej jedno z <paramref name="attributeType" /> zostały zastosowane do tego modułu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> nie jest <see cref="T:System.Type" /> obiekt dostarczony w czasie wykonywania. Na przykład <paramref name="attributeType" /> jest <see cref="T:System.Reflection.Emit.TypeBuilder" /> obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public override bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsResource" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsResource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsResource();" />
      <MemberSignature Language="F#" Value="override this.IsResource : unit -&gt; bool" Usage="moduleBuilder.IsResource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obiekt jest zasobem.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekt jest zasobem; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTransient">
      <MemberSignature Language="C#" Value="public bool IsTransient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsTransient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsTransient" />
      <MemberSignature Language="VB.NET" Value="Public Function IsTransient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsTransient();" />
      <MemberSignature Language="F#" Value="member this.IsTransient : unit -&gt; bool" Usage="moduleBuilder.IsTransient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy ten moduł dynamiczny jest przejściowy.</summary>
        <returns>
          <see langword="true" /> Jeśli ten moduł dynamiczny jest przejściowy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public override int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MDStreamVersion As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MDStreamVersion { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MDStreamVersion : int" Usage="System.Reflection.Emit.ModuleBuilder.MDStreamVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję strumienia metadanych.</summary>
        <value>Liczba całkowita 32-bitowy, reprezentująca wersję strumienia metadanych. Dwa bajty wyższego rzędu reprezentuje główny numer wersji i dwa bajty niskiego rzędu stanowią pomocniczy numer wersji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Aby uzyskać więcej informacji w nagłówku metadanych zobacz "Partycja II: metadane definicji i semantyka" w dokumentacji Common Language Infrastructure (CLI). Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie ECMA.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public override int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataToken : int" Usage="System.Reflection.Emit.ModuleBuilder.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera token, który identyfikuje bieżącego modułu dynamicznego w metadanych.</summary>
        <value>Token liczby całkowitej, który identyfikuje bieżącego modułu w metadanych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tokeny przy użyciu tej właściwości może być przekazywany do niezarządzanego interfejsu API odbicia. Aby uzyskać więcej informacji, zobacz [niezarządzanego interfejsu API odbicia](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).  
  
> [!NOTE]
>  Informacje o tokeny metadanych można znaleźć w dokumentacji Common Language Infrastructure (CLI), szczególnie "partycja II: metadane definicji i semantyka". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie ECMA.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public override Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ModuleVersionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid ModuleVersionId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.ModuleVersionId : Guid" Usage="System.Reflection.Emit.ModuleBuilder.ModuleVersionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator unikatowym (UUID), który może służyć do rozróżniania między dwoma wersjami modułu.</summary>
        <value>Element <see cref="T:System.Guid" /> można rozróżnić dwóch wersji modułu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W metadanych niezarządzanych, identyfikator GUID zawrócony przez <xref:System.Reflection.Module.ModuleVersionId%2A> właściwość nazywa się `mvid`i są przechowywane w stosie identyfikatora GUID.  
  
> [!NOTE]
>  Więcej informacji na temat metadanych można znaleźć w dokumentacji Common Language Infrastructure (CLI), szczególnie "partycja II: metadane definicji i semantyka". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie ECMA.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.ModuleBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ciąg, który wskazuje, że jest to moduł w pamięci.</summary>
        <value>Tekst, który wskazuje, że jest to moduł w pamięci.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można uzyskać nazwę modułu dynamicznego, dopóki moduł został zapisany i ponownie załadowany z dysku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveField (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ ResolveField(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveField : int * Type[] * Type[] -&gt; System.Reflection.FieldInfo" Usage="moduleBuilder.ResolveField (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Token metadanych, który identyfikuje pole w module.</param>
        <param name="genericTypeArguments">Tablica <see cref="T:System.Type" /> obiektów reprezentujących argumenty typu ogólnego typu, w którym token jest w zakresie lub <see langword="null" /> w przypadku tego typu nie jest ogólna.</param>
        <param name="genericMethodArguments">Tablica <see cref="T:System.Type" /> obiektów reprezentujących argumenty typu generycznego metody, w którym token jest w zakresie lub <see langword="null" /> w przypadku tej metody nie jest ogólna.</param>
        <summary>Zwraca pola zidentyfikowane przez token określonych metadanych, w kontekście zdefiniowane przez parametry określonego typu ogólnego.</summary>
        <returns>A <see cref="T:System.Reflection.FieldInfo" /> obiekt reprezentujący pola, które jest identyfikowane za pomocą tokenu określonych metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metody w typie gdzie `metadataToken` znajduje się w zakresie uzyskać tablicę argumentów typu ogólnego dla `genericTypeArguments`. Użyj <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> metody w metodzie gdzie `metadataToken` znajduje się w zakresie uzyskać tablicę argumentów typu ogólnego dla `genericTypeArguments`. Jest zawsze bezpieczne zapewnienie tych argumentów, nawet wtedy, gdy nie są wymagane.  
  
> [!NOTE]
>  Informacje o tokeny metadanych można znaleźć w dokumentacji Common Language Infrastructure (CLI), szczególnie "partycja II: metadane definicji i semantyka". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie ECMA.  
  
 Kod, który demonstruje rozpoznawania tokenów w kontekście ogólnego (czyli parametrów typu ogólnego dla typu ogólnego lub metody rodzajowej, w której jest osadzony token) dla <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> nie jest tokenem dla pola w zakresie bieżącego modułu.  
  
—lub— 
 <paramref name="metadataToken" /> identyfikuje pole, którego rodzic <see langword="TypeSpec" /> ma podpis z typem elementu <see langword="var" /> (typ parametru typu ogólnego) lub <see langword="mvar" /> (parametr typu metody ogólnej), a nie podano argumentów typu rodzajowego niezbędne dla jeden lub oba <paramref name="genericTypeArguments" /> i <paramref name="genericMethodArguments" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> nie jest prawidłowym tokenem w zakresie bieżącego modułu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveMember (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MemberInfo ^ ResolveMember(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveMember : int * Type[] * Type[] -&gt; System.Reflection.MemberInfo" Usage="moduleBuilder.ResolveMember (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Token metadanych, który identyfikuje typ lub element członkowski w module.</param>
        <param name="genericTypeArguments">Tablica <see cref="T:System.Type" /> obiektów reprezentujących argumenty typu ogólnego typu, w którym token jest w zakresie lub <see langword="null" /> w przypadku tego typu nie jest ogólna.</param>
        <param name="genericMethodArguments">Tablica <see cref="T:System.Type" /> obiektów reprezentujących argumenty typu generycznego metody, w którym token jest w zakresie lub <see langword="null" /> w przypadku tej metody nie jest ogólna.</param>
        <summary>Zwraca wartość typu lub elementu członkowskiego, identyfikowane za pomocą tokenu określonych metadanych, w kontekście zdefiniowane przez parametry określonego typu ogólnego.</summary>
        <returns>A <see cref="T:System.Reflection.MemberInfo" /> obiekt reprezentujący typ lub element członkowski, który jest identyfikowany przez token określonych metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metody w typie gdzie `metadataToken` znajduje się w zakresie uzyskać tablicę argumentów typu ogólnego dla `genericTypeArguments`. Użyj <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> metody w metodzie gdzie `metadataToken` znajduje się w zakresie uzyskać tablicę argumentów typu ogólnego dla `genericTypeArguments`. Jest zawsze bezpieczne zapewnienie tych argumentów, nawet wtedy, gdy nie są wymagane.  
  
> [!NOTE]
>  Informacje o tokeny metadanych można znaleźć w dokumentacji Common Language Infrastructure (CLI), szczególnie "partycja II: metadane definicji i semantyka". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie ECMA.  
  
 Kod, który demonstruje rozpoznawania tokenów w kontekście ogólnego (czyli parametrów typu ogólnego dla typu ogólnego lub metody rodzajowej, w której jest osadzony token) dla <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> nie jest tokenem dla typu lub członka w zakresie bieżącego modułu.  
  
—lub— 
 <paramref name="metadataToken" /> jest <see langword="MethodSpec" /> lub <see langword="TypeSpec" /> którego podpis zawiera typ elementu <see langword="var" /> (typ parametru typu ogólnego) lub <see langword="mvar" /> (parametr typu metody ogólnej), a nie podano argumentów typu rodzajowego niezbędne dla jednego lub obu z <paramref name="genericTypeArguments" /> i <paramref name="genericMethodArguments" />.  
  
—lub— 
 <paramref name="metadataToken" /> identyfikuje właściwość lub zdarzenie.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> nie jest prawidłowym tokenem w zakresie bieżącego modułu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveMethod (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodBase ^ ResolveMethod(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveMethod : int * Type[] * Type[] -&gt; System.Reflection.MethodBase" Usage="moduleBuilder.ResolveMethod (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Token metadanych, który identyfikuje metodę lub Konstruktor w module.</param>
        <param name="genericTypeArguments">Tablica <see cref="T:System.Type" /> obiektów reprezentujących argumenty typu ogólnego typu, w którym token jest w zakresie lub <see langword="null" /> w przypadku tego typu nie jest ogólna.</param>
        <param name="genericMethodArguments">Tablica <see cref="T:System.Type" /> obiektów reprezentujących argumenty typu generycznego metody, w którym token jest w zakresie lub <see langword="null" /> w przypadku tej metody nie jest ogólna.</param>
        <summary>Zwraca metodę lub Konstruktor identyfikowane za pomocą tokenu określonych metadanych, w kontekście zdefiniowane przez parametry określonego typu ogólnego.</summary>
        <returns>A <see cref="T:System.Reflection.MethodBase" /> obiekt reprezentujący metodę, która jest identyfikowane za pomocą tokenu określonych metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metody w typie gdzie `metadataToken` znajduje się w zakresie uzyskać tablicę argumentów typu ogólnego dla `genericTypeArguments`. Użyj <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> metody w metodzie gdzie `metadataToken` znajduje się w zakresie uzyskać tablicę argumentów typu ogólnego dla `genericMethodArguments`. Jest zawsze bezpieczne zapewnienie tych argumentów, nawet wtedy, gdy nie są wymagane.  
  
> [!NOTE]
>  Informacje o tokeny metadanych można znaleźć w dokumentacji Common Language Infrastructure (CLI), szczególnie "partycja II: metadane definicji i semantyka". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie ECMA.  
  
 Kod, który demonstruje rozpoznawania tokenów w kontekście ogólnego (czyli parametrów typu ogólnego dla typu ogólnego lub metody rodzajowej, w której jest osadzony token) dla <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> nie jest tokenem dla metody lub konstruktora w zakresie bieżącego modułu.  
  
—lub— 
 <paramref name="metadataToken" /> jest <see langword="MethodSpec" /> którego podpis zawiera typ elementu <see langword="var" /> (typ parametru typu ogólnego) lub <see langword="mvar" /> (parametr typu metody ogólnej), a nie podano argumentów typu rodzajowego niezbędne dla jednego lub obu <paramref name="genericTypeArguments" /> i <paramref name="genericMethodArguments" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> nie jest prawidłowym tokenem w zakresie bieżącego modułu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public override byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveSignature (metadataToken As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ ResolveSignature(int metadataToken);" />
      <MemberSignature Language="F#" Value="override this.ResolveSignature : int -&gt; byte[]" Usage="moduleBuilder.ResolveSignature metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Token metadanych, który identyfikuje podpisu w module.</param>
        <summary>Zwraca obiekt blob podpisu identyfikowane za pomocą tokenu metadanych.</summary>
        <returns>Tablica bajtów reprezentujących podpis obiektu blob.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Informacje o tokeny metadanych i podpisy można znaleźć w dokumentacji Common Language Infrastructure (CLI), szczególnie "partycja II: metadane definicji i semantyka". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie ECMA.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> nie jest prawidłowym <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, podpis lub <see langword="FieldDef" /> tokenu w zakresie bieżącego modułu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> nie jest prawidłowym tokenem w zakresie bieżącego modułu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public override string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveString (metadataToken As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ResolveString(int metadataToken);" />
      <MemberSignature Language="F#" Value="override this.ResolveString : int -&gt; string" Usage="moduleBuilder.ResolveString metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Token metadanych, który identyfikuje ciąg w stercie będącej ciągiem tekstowym modułu.</param>
        <summary>Zwraca ciąg identyfikowane za pomocą tokenu określonych metadanych.</summary>
        <returns>Element <see cref="T:System.String" /> zawierający wartość ciągu w stercie będącej ciągiem tekstowym metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Informacje o tokeny metadanych można znaleźć w dokumentacji Common Language Infrastructure (CLI), szczególnie "partycja II: metadane definicji i semantyka". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie ECMA.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> nie jest tokenem ciągu w zakresie bieżącego modułu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> nie jest prawidłowym tokenem w zakresie bieżącego modułu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public override Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveType (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ ResolveType(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveType : int * Type[] * Type[] -&gt; Type" Usage="moduleBuilder.ResolveType (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">Token metadanych, który identyfikuje typ w module.</param>
        <param name="genericTypeArguments">Tablica <see cref="T:System.Type" /> obiektów reprezentujących argumenty typu ogólnego typu, w którym token jest w zakresie lub <see langword="null" /> w przypadku tego typu nie jest ogólna.</param>
        <param name="genericMethodArguments">Tablica <see cref="T:System.Type" /> obiektów reprezentujących argumenty typu generycznego metody, w którym token jest w zakresie lub <see langword="null" /> w przypadku tej metody nie jest ogólna.</param>
        <summary>Zwraca typ identyfikowane za pomocą tokenu określonych metadanych, w kontekście zdefiniowane przez parametry określonego typu ogólnego.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt reprezentujący typ, który jest identyfikowany przez token określonych metadanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metody w typie gdzie `metadataToken` znajduje się w zakresie uzyskać tablicę argumentów typu ogólnego dla `genericTypeArguments`. Użyj <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> metody w metodzie gdzie `metadataToken` znajduje się w zakresie uzyskać tablicę argumentów typu ogólnego dla `genericTypeArguments`. Jest zawsze bezpieczne zapewnienie tych argumentów, nawet wtedy, gdy nie są wymagane.  
  
> [!NOTE]
>  Informacje o tokeny metadanych można znaleźć w dokumentacji Common Language Infrastructure (CLI), szczególnie "partycja II: metadane definicji i semantyka". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie ECMA.  
  
 Kod, który demonstruje rozpoznawania tokenów w kontekście ogólnego (czyli parametrów typu ogólnego dla typu ogólnego lub metody rodzajowej, w której jest osadzony token) dla <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> nie jest tokenem dla typu w zakresie bieżącego modułu.  
  
—lub— 
 <paramref name="metadataToken" /> jest <see langword="TypeSpec" /> którego podpis zawiera typ elementu <see langword="var" /> (typ parametru typu ogólnego) lub <see langword="mvar" /> (parametr typu metody ogólnej), a nie podano argumentów typu rodzajowego niezbędne dla jednego lub obu <paramref name="genericTypeArguments" /> i <paramref name="genericMethodArguments" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> nie jest prawidłowym tokenem w zakresie bieżącego modułu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public override string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.ScopeName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ScopeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ScopeName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScopeName : string" Usage="System.Reflection.Emit.ModuleBuilder.ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg, który reprezentuje nazwę modułu dynamicznego.</summary>
        <value>Nazwa modułu dynamicznego.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stosuje atrybut niestandardowy do tego modułu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="moduleBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">Wystąpienie klasy pomocnika, która określa atrybut niestandardowy do zastosowania.</param>
        <summary>Stosuje atrybut niestandardowy do tego modułu za pomocą konstruktora niestandardowego atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="moduleBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">Konstruktor atrybutu niestandardowego.</param>
        <param name="binaryAttribute">Bajt reprezentujący atrybut obiektu BLOB.</param>
        <summary>Stosuje atrybut niestandardowy tego modułu przy użyciu określonego binarne dużych obiektów (BLOB, ten atrybut reprezentuje).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat formatowania `binaryAttribute`, zobacz dokumentację Common Language Infrastructure (CLI), szczególnie "partycja II: metadane definicji i semantyka". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie Ecma International w sieci Web.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> lub <paramref name="binaryAttribute" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.SetSymCustomAttribute : string * byte[] -&gt; unit" Usage="moduleBuilder.SetSymCustomAttribute (name, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa atrybutu niestandardowego</param>
        <param name="data">Nieprzezroczysty binarne dużych obiektów (BLOB) bajtów reprezentujący wartość atrybutu niestandardowego.</param>
        <summary>Ta metoda nie działa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie działa.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetUserEntryPoint">
      <MemberSignature Language="C#" Value="public void SetUserEntryPoint (System.Reflection.MethodInfo entryPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetUserEntryPoint(class System.Reflection.MethodInfo entryPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetUserEntryPoint (entryPoint As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetUserEntryPoint(System::Reflection::MethodInfo ^ entryPoint);" />
      <MemberSignature Language="F#" Value="member this.SetUserEntryPoint : System.Reflection.MethodInfo -&gt; unit" Usage="moduleBuilder.SetUserEntryPoint entryPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryPoint" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="entryPoint">Punkt wejścia użytkownika.</param>
        <summary>Ustawia punkt wejścia użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kompilator może wygenerować wycinka uruchomienia przed wywołaniem użytkownika głównego. Wycinka uruchomienia będzie punktu wejścia. Podczas gdy głównego użytkownika będą punktu wejścia użytkownika tak, aby debuger nie będzie wkroczyć do kompilatora punktu wejścia.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryPoint" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ta metoda jest wywoływana w module dynamiczne, który nie jest modułem debugowania.  
  
—lub— 
 <paramref name="entryPoint" /> nie znajduje się w tym module dynamiczne.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _ModuleBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_ModuleBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz: Biblioteka MSDN.  
  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Reflection.Emit.ModuleBuilder> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._ModuleBuilder> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Metoda jest wywoływana z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejsu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _ModuleBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_ModuleBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz: Biblioteka MSDN.  
  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Reflection.Emit.ModuleBuilder> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._ModuleBuilder> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Metoda jest wywoływana z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejsu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _ModuleBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_ModuleBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Lokalizację, która odbiera liczba typów informacji dostarczanych przez obiekt.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz: Biblioteka MSDN.  
  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Reflection.Emit.ModuleBuilder> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._ModuleBuilder> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Metoda jest wywoływana z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejsu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _ModuleBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_ModuleBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identyfikator elementu członkowskiego.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz: Biblioteka MSDN.  
  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Reflection.Emit.ModuleBuilder> wystąpienia jest rzutowany na <xref:System.Runtime.InteropServices._ModuleBuilder> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Metoda jest wywoływana z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejsu.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
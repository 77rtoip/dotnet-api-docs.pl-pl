<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2d2648e46890987df7b96cd4787aa5d57de2433b" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34285356" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje i reprezentuje dynamiczne metodę, która może być skompilowany, wykonywane i odrzucone. Odrzuconych dostępnych metod wyrzucanie elementów bezużytecznych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Reflection.Emit.DynamicMethod> klasy do generowania i wykonania metody w czasie wykonywania, bez konieczności generowania dynamicznego zestawu i typu dynamicznego zawiera metody. Kod wykonywalny utworzone za pomocą kompilatora just-in-time (JIT) jest odzyskana po <xref:System.Reflection.Emit.DynamicMethod> obiektu jest odzyskana. Metody dynamiczne są najbardziej wydajny sposób, aby wygenerować i wykonaj niewielkich ilości kodu.  
  
 Anonimowo hostowane metody dynamiczne lub może być logicznie powiązanych z modułem lub typem.  
  
-   Jeśli znajduje się anonimowo metody dynamicznej, znajduje się w zestawie dostarczane przez system, a w związku z tym jest odizolowana od innego kodu. Domyślnie go nie ma dostępu do dowolnych danych niepubliczne. Hostowanej anonimowo metody dynamicznej można ograniczyć możliwość pominąć kontroli widoczność kompilatora JIT, jeśli zostały przyznane <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagi. Poziom zaufania zestawu, którego niepubliczne elementy członkowskie są dostępne dla metody dynamicznej musi być równa lub podzbiór, poziom zaufania stos wywołań, który emitowane metody dynamicznej. Aby uzyskać więcej informacji na temat hostowanej anonimowo metody dynamicznej, zobacz [wskazówki: emitowanie kodu w scenariuszach zaufania częściowego](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md).  
  
-   Jeśli metody dynamicznej jest skojarzony z modułu, który określisz, metody dynamicznej jest skutecznie globalny tego modułu. Będzie miał dostęp do wszystkich typów w module i wszystkie `internal` (`Friend` w języku Visual Basic) elementy członkowskie typów. Możesz skojarzyć dynamicznym metodę o module, niezależnie od tego, czy utworzony moduł, pod warunkiem, że popyt na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> flagi można spełnić przez stos wywołań, który zawiera kod. Jeśli <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flaga jest uwzględniona w przyznanie, pominąć kontroli widoczność kompilatora JIT i uzyskać dostęp do danych prywatnych wszystkie typy zadeklarowany w module lub w innym module w dowolnym zestawie metody dynamicznej.  
  
    > [!NOTE]
    >  Po określeniu modułu, z którym jest skojarzona metoda dynamiczne tego modułu nie może być w zestawie dostarczane przez system, który jest używany do hostowania anonimowy.  
  
-   Jeśli metody dynamicznej jest skojarzona z typem, który określisz, ma dostęp do wszystkich elementów członkowskich tego typu, niezależnie od poziomu dostępu. Ponadto można pominięte kontroli widoczność JIT. Daje dynamiczne metody dostępu do danych z innych typów zadeklarowany w tym samym module lub inny moduł, w dowolnym zestawie. Metody dynamiczne można skojarzyć z dowolnego typu, ale musi otrzymać kod <xref:System.Security.Permissions.ReflectionPermission> zarówno <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> i <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> flagi.  
  
 W poniższej tabeli przedstawiono typy i elementy członkowskie są dostępne do hostowanej anonimowo metody dynamicznej, z lub bez kontroli widoczność JIT, w zależności od tego, czy <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> otrzymuje flagi.  
  
||Bez <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|Z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|Bez pomijania sprawdzania widoczność JIT|Publiczne elementy członkowskie typy publiczne w dowolnym zestawie.|Publiczne elementy członkowskie typy publiczne w dowolnym zestawie.|  
|Pomijanie JIT widoczność sprawdza, z ograniczeniami|Publiczne elementy członkowskie typy publiczne w dowolnym zestawie.|Wszystkie elementy członkowskie wszystkich typów, tylko w zestawy, których poziomy zaufania jest równa lub mniejsza niż poziom zaufania zestawu emitowane metody dynamicznej.|  
  
> [!NOTE]
>  Przed [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], emitowanie kodu wymagane <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. To uprawnienie jest domyślnie włączone w FullTrust i LocalIntranet nazwane zestawy uprawnień, ale nie w uprawnień internetowych. W związku z tym w starszych wersjach [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] biblioteki mogą być używane z Internetu uprawnienia tylko wtedy, gdy ma ona <xref:System.Security.SecurityCriticalAttribute> atrybutu i wykonuje również <xref:System.Security.PermissionSet.Assert%2A> dla <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>. Takie biblioteki wymagają przeglądu zabezpieczeń zachować ostrożność, ponieważ błędy kodowania może skutkować luk w zabezpieczeniach. [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] Umożliwia kod, aby emitować w scenariuszach częściowo zaufanych bez wystawiania wszystkie żądania kontroli zabezpieczeń, ponieważ generowanie kodu nie jest z założenia uprzywilejowanych operacji. Oznacza to, że wygenerowany kod nie ma więcej uprawnień niż zestaw, który emituje go. Dzięki temu biblioteki, w których Emituj kod jest przezroczysta pod względem zabezpieczeń i eliminuje potrzebę do potwierdzenia <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, który upraszcza zapisywanie bezpiecznego biblioteki. Aby użyć tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 W poniższej tabeli przedstawiono typy i elementy członkowskie są dostępne do dynamicznego metody, która jest skojarzona z modułu lub typu w module.  
  
||Skojarzone z modułu|Skojarzone z typem|  
|-|-|-|  
|Bez pomijania sprawdzania widoczność JIT|Publicznych oraz wewnętrznych elementów członkowskich typu publiczne, wewnętrzne i prywatne w module.<br /><br /> Publiczne elementy członkowskie typy publiczne w dowolnym zestawie.|Wszystkie elementy członkowskie skojarzonego typu. Publicznych oraz wewnętrznych elementów członkowskich innych typów w module.<br /><br /> Publiczne elementy członkowskie typy publiczne w dowolnym zestawie.|  
|Pomijanie sprawdzania widoczność JIT|Wszystkie elementy członkowskie wszystkie typy w dowolnym zestawu.|Wszystkie elementy członkowskie wszystkie typy w dowolnym zestawu.|  
  
 Dynamiczne metody, która jest skojarzona z modułem uprawnieniami tego modułu. Dynamiczne metody, która jest skojarzona z typem uprawnieniami zawierającego tego typu modułu.  
  
 Metody dynamiczne i ich parametry nie muszą mieć nazwy, ale można określić nazwy pomocnych w debugowaniu. Atrybuty niestandardowe nie są obsługiwane w przypadku dynamicznych metod lub ich parametrów.  
  
 Metody dynamiczne są `static` metod (`Shared` metod w języku Visual Basic), luźniejsze reguły dla delegata powiązanie wprowadzone w systemie [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] umożliwia dynamiczne metoda może być powiązane z obiektu tak, aby pełnił jak metody wystąpienia po wywołuje się przy użyciu tego wystąpienia obiektu delegowanego. Przykład przedstawiający to jest dostępne w celu <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> przeciążenie metody.  
  
> [!NOTE]
>  W [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], metod dynamicznych nie obsługują informacji o symbolach, która jest, nazwy zmiennych lokalnych i mapowanie numer wiersza. To ograniczenie może zostać usunięta w przyszłych wersjach. Można użyć <xref:System.Reflection.Emit.AssemblyBuilder> podczas tworzenia, aby uprościć debugowania wygenerowany język pośredni firmy Microsoft (MSIL), a następnie przejdź do metod dynamicznych podczas wdrażania końcowego, ponieważ <xref:System.Reflection.Emit.ILGenerator> wywołania są takie same, w obu przypadkach.  
  
## <a name="verification"></a>Weryfikacja  
 Poniższa lista zawiera podsumowanie warunków, w jakich metod dynamicznych może zawierać kod niemożliwy do zweryfikowania. (Na przykład nie jest dynamiczna metoda jeśli jego <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> ma ustawioną właściwość `false`.)  
  
-   Dynamiczne metody, która jest skojarzona z zestawem krytyczny dla zabezpieczeń jest także krytyczny dla zabezpieczeń i można pominąć weryfikacji. Na przykład zestawu bez atrybutów zabezpieczeń, który jest uruchamiany jako aplikacja na komputerze jest traktowany jako krytyczny dla zabezpieczeń w czasie wykonywania. Jeśli metoda dynamiczne są skojarzone z zestawu, metody dynamicznej może zawierać kod niemożliwy do zweryfikowania.  
  
-   Jeśli dynamiczny metodę, która zawiera kod, którego nie można zweryfikować jest skojarzony z zestawu, który ma przezroczystość poziomu 1, przy użyciu kompilatora just in time (JIT) injects żądania zabezpieczeń. Żądanie zakończy się powodzeniem, tylko wtedy, gdy metody dynamicznej jest wykonywana przez całkowicie zaufanego kodu. Zobacz [kod o przezroczystym poziomie bezpieczeństwa, poziom 1](~/docs/framework/misc/security-transparent-code-level-1.md).  
  
-   Jeśli dynamiczny metodę, która zawiera kod, którego nie można zweryfikować jest skojarzony z zestawu, który ma przezroczystość poziomu 2 (takie jak mscorlib.dll), zgłasza wyjątek (wstrzyknięte przez kompilator JIT) zamiast ją na żądanie zabezpieczeń. Zobacz [kod o przezroczystym poziomie bezpieczeństwa, poziom 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
-   Hostowanej anonimowo metody dynamicznej, zawierający niemożliwy do sprawdzenia kod zawsze zgłasza wyjątek. Można nigdy nie pominąć weryfikacji, nawet jeśli jest tworzony i wykonywane przez całkowicie zaufanego kodu.  
  
 Wyjątek zgłaszany, dla którego nie można zweryfikować kodu różni się w zależności od sposobu wywołaniu metody dynamicznej. Jeśli wywołanie metody dynamicznej przy użyciu delegata zwrócony z <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metody <xref:System.Security.VerificationException> jest generowany. Jeśli wywołanie metody dynamicznej za pomocą <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody <xref:System.Reflection.TargetInvocationException> jest zgłaszany z wewnętrznego <xref:System.Security.VerificationException>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy dynamiczne metodę, która przyjmuje dwa parametry. Przykład emituje treści proste funkcja, która wyświetla pierwszy parametr do konsoli, a w przykładzie użyto drugi parametr jako wartość zwracaną przez metodę. Przykład kończy metody tworzenia delegata wywołuje delegata o innych parametrach, a na koniec wywołuje przy użyciu metody dynamicznej <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody.  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy metodę dynamicznego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. To może być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa typ zwracany metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów Określanie typów parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <summary>Inicjuje hostowanej anonimowo metody dynamicznej określający nazwę metody, typ zwracany i typy parametrów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamiczne metodę, która jest tworzona przez ten konstruktor jest skojarzony z anonimowego zestawu zamiast istniejącego typu lub modułu. Anonimowe zestaw istnieje wyłącznie w celu świadczenia środowisko piaskownicy dla metod dynamicznych, oznacza to, odizolowane od innego kodu. To środowisko umożliwia bezpieczne dla metody dynamicznej wysyłanego i wykonywane przez kod częściowo zaufany.  
  
 Ten konstruktor Określa, że just in time (JIT) widoczność sprawdza zostaną wymuszone dla języka pośredniego firmy Microsoft (MSIL) metody dynamicznej. Oznacza to, że kod w metodzie dynamiczne ma dostęp do metod publicznych klasy klas publicznych. Jeśli metoda próbuje uzyskać dostęp do typów lub elementów członkowskich, które są są zgłaszane wyjątki `private`, `protected`, lub `internal` (`Friend` w języku Visual Basic). Aby utworzyć dynamiczne metodę, która ma ograniczone możliwości, aby pominąć sprawdzanie widoczność JIT, użyj <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> konstruktora.  
  
 Gdy jest tworzony hostowanej anonimowo metody dynamicznej, stos wywołań emisji zestawu jest dołączony. Po wywołaniu metody uprawnienia emisji zestawu są używane zamiast uprawnień rzeczywistego obiektu wywołującego. W związku z tym metody dynamicznej nie można wykonać na wyższym poziomie uprawnień niż zestaw wysyłanego, nawet jeśli jest przekazywany do i wykonywane przez zestaw, który ma wyższy poziom zaufania.  
  
 Ten konstruktor określa atrybuty metody <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>i Konwencja wywoływania <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Ten konstruktor został wprowadzony w [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. To może być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa typ zwracany metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów Określanie typów parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="restrictedSkipVisibility">
          <see langword="true" /> Aby pominąć JIT widoczność kontroli typy i składniki używane przez MSIL metody dynamicznej z tego ograniczenia: poziom zaufania zestawów, które zawierają te typy i składniki musi być równa lub mniejsza niż poziom zaufania stos wywołań, który emituje dynami Metoda c; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje hostowanej anonimowo metody dynamicznej, określić nazwę metody, zwracany typ typy parametrów i czy just in time (JIT) widoczność kontroli ma być pomijana dla typy i składniki używane przez język pośredni firmy Microsoft (MSIL) z metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamiczne metodę, która jest tworzona przez ten konstruktor jest skojarzony z anonimowego zestawu zamiast istniejącego typu lub modułu. Anonimowe zestaw istnieje wyłącznie w celu świadczenia środowisko piaskownicy dla metod dynamicznych, oznacza to, odizolowane od innego kodu. To środowisko umożliwia bezpieczne dla metody dynamicznej wysyłanego i wykonywane przez kod częściowo zaufany.  
  
 Hostowanej anonimowo metody dynamicznej bez automatycznego dostępu do żadnych typów lub elementów członkowskich, które są `private`, `protected`, lub `internal` (`Friend` w języku Visual Basic). To różni się od metod dynamicznych, skojarzonych z istniejącego typu lub moduł, które nie mają dostępu do ukrytych elementów członkowskich w ich skojarzonego zakresu.  
  
 Określ `true` dla `restrictedSkipVisibility` Jeśli dynamiczne metodę musi mieć dostęp do typów albo elementów członkowskich, które są `private`, `protected`, lub `internal`. Dzięki temu metody dynamicznej ograniczony dostęp do tych elementów członkowskich. Oznacza to, że członkowie jest możliwy tylko wtedy, gdy są spełnione następujące warunki:  
  
-   Elementy członkowskie docelowy należą do zestawu, który ma poziom zaufania równa lub niższa niż stos wywołań, który emituje metody dynamicznej.  
  
-   Stos wywołań, który emituje metody dynamicznej otrzymuje <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagi. Jest to wartość true, zawsze wtedy, gdy kod jest wykonywane przy pełnym zaufaniu. Częściowo zaufany kod jest wartość true tylko wtedy, gdy host powoduje przyznanie uprawnień.  
  
    > [!IMPORTANT]
    >  Jeśli nie udzielono uprawnienia zgłoszony wyjątek zabezpieczeń podczas <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> jest wywoływana lub po wywołaniu metody dynamicznej nie gdy ten konstruktor jest wywoływana. Do emisji dynamicznego metody są wymagane żadne specjalne uprawnienia.  
  
 Na przykład dynamiczne metodę, która zostanie utworzona z `restrictedSkipVisibility` ustawioną `true` mają dostęp do prywatnego elementu członkowskiego wszystkie zestawu w stosie wywołań, gdy stos wywołań udzielono dostępu do elementu członkowskiego ograniczone. Jeśli metody dynamicznej jest tworzony z częściowo zaufanego kodu w stosie wywołań, nie ma dostępu do prywatnego elementu członkowskiego typu w [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] zestawu, ponieważ takie zestawy są w pełni zaufany.  
  
 Jeśli `restrictedSkipVisibility` jest `false`, widoczność JIT sprawdza są wymuszane. Kod w metodzie dynamiczna ma dostęp do publicznego metod publicznych klasy i są zgłaszane wyjątki, jeśli próbuje uzyskać dostęp do typów albo elementów członkowskich, które są `private`, `protected`, lub `internal`.  
  
 Gdy jest tworzony hostowanej anonimowo metody dynamicznej, stos wywołań emisji zestawu jest dołączony. Po wywołaniu metody uprawnienia emisji stosu wywołań są używane zamiast uprawnień rzeczywistego obiektu wywołującego. W związku z tym metody dynamicznej nie można wykonać na wyższym poziomie uprawnień niż zestaw wysyłanego, nawet jeśli jest przekazywany do i wykonywane przez zestaw, który ma wyższy poziom zaufania.  
  
 Ten konstruktor określa atrybuty metody <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>i Konwencja wywoływania <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Ten konstruktor został wprowadzony w [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. To może być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa typ zwracany metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów Określanie typów parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="m">A <see cref="T:System.Reflection.Module" /> reprezentujący modułu, z którym ma być logicznie powiązanych metody dynamicznej.</param>
        <summary>Tworzy dynamiczne metodę, która jest globalna do modułu, określając nazwę metody, typ zwracany, typy parametrów i modułu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor określa atrybuty metody <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, konwencji wywoływania <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>i nie powoduje pominięcia just in time (JIT) widoczność kontroli.  
  
 Dynamiczne metody utworzone za pomocą tego konstruktora ma dostęp do publicznego i `internal` (`Friend` w języku Visual Basic) elementy członkowskie wszystkich typów, które są zawarte w module `m`.  
  
> [!NOTE]
>  W celu zapewnienia zgodności z poprzednimi wersjami wymaga tego konstruktora <xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> Flaga, jeśli są następujące warunki true: `m` jest modułem inne niż wywoływania modułu i popytu na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flagi nie powiodło się. Jeśli żądanie dla <xref:System.Security.Permissions.SecurityPermission> zakończy się powodzeniem, ta operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy z zabezpieczeniami w odbicia Emituj](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy dynamiczne metodę, która przyjmuje dwa parametry. Przykład emituje treści proste funkcja, która wyświetla pierwszy parametr do konsoli, a w przykładzie użyto drugi parametr jako wartość zwracaną przez metodę. Przykład kończy metody tworzenia delegata wywołuje delegata o innych parametrach, a na koniec wywołuje przy użyciu metody dynamicznej <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> metody.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.  - lub - <paramref name="m" /> jest moduł, który zawiera anonimowy hosting dla metod dynamicznych.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="m" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metody dynamicznej z modułu innej niż moduł wywołujący. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. To może być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa typ zwracany metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów Określanie typów parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="owner">A <see cref="T:System.Type" /> z metody dynamicznej jest logicznie powiązanych. Metody dynamicznej ma dostęp do wszystkich elementów członkowskich tego typu.</param>
        <summary>Tworzy dynamiczne metodę, określając nazwę metody, zwracany typ typy parametrów i typ, z którym jest logicznie powiązanych metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody dynamicznej utworzone za pomocą tego konstruktora ma dostęp do wszystkich elementów członkowskich typu `owner`i na publiczne i `internal` (`Friend` w języku Visual Basic) elementy członkowskie wszystkich typów w module, który zawiera `owner`.  
  
 Ten konstruktor określa atrybuty metody <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, konwencji wywoływania <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>i nie powoduje pominięcia just in time (JIT) widoczność kontroli.  
  
> [!NOTE]
>  W celu zapewnienia zgodności z poprzednimi wersjami wymaga tego konstruktora <xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> Flaga, jeśli są następujące warunki true: `owner` znajduje się w module niż wywoływania modułu i popytu na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flaga nie powiodło się. Jeśli żądanie dla <xref:System.Security.Permissions.SecurityPermission> zakończy się powodzeniem, ta operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy z zabezpieczeniami w odbicia Emituj](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Reflection.Emit.DynamicMethod> logicznie skojarzonego z typem. To skojarzenie udostępnia ona prywatne elementy członkowskie tego typu.  
  
 Przykładowy kod definiuje klasę o nazwie `Example` z polem prywatnej o nazwie klasy `DerivedFromxample` która pochodzi z klasy pierwszego typu delegata o nazwie `UseLikeStatic` zwracającą <xref:System.Int32> i ma następujące parametry typu `Example` i <xref:System.Int32>oraz typ delegata o nazwie `UseLikeInstance` zwracającą <xref:System.Int32> i ma jeden parametr typu <xref:System.Int32>.  
  
 Przykład kodu tworzy następnie <xref:System.Reflection.Emit.DynamicMethod> zmienia się pole prywatne wystąpienia `Example` i zwraca poprzednią wartość.  
  
> [!NOTE]
>  Ogólnie rzecz biorąc zmiana pola wewnętrzne klas nie jest dobrym obiektowo praktyk kodowania.  
  
 Przykład kodu tworzy wystąpienie `Example` , a następnie tworzy dwa obiekty delegowane. Pierwsza to typu `UseLikeStatic`, który ma te same parametry jako metody dynamicznej. Drugą jest wartość typu `UseLikeInstance`, który nie ma pierwszy parametr (typu `Example`). Ten delegat jest tworzony przy użyciu <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> przeciążenie metody; drugi parametr przeciążenie tej metody jest wystąpieniem `Example`, w tym przypadku wystąpienie właśnie utworzony, który jest powiązany z nowo utworzonego obiektu delegowanego. Przy każdym wywołaniu tego delegata metody dynamicznej działania w przypadku powiązane wystąpienie `Example`.  
  
> [!NOTE]
>  To jest przykład swobodna reguł dla delegata powiązanie wprowadzone w systemie [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], wraz z przeciążeń nowe <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> metody. Aby uzyskać więcej informacji, zobacz <xref:System.Delegate> klasy.  
  
 `UseLikeStatic` Delegata zostanie wywołany, przekazując wystąpienie elementu `Example` który jest powiązany `UseLikeInstance` delegowanie. Następnie przy użyciu `UseLikeInstance` delegata zostanie wywołany, tak aby oba obiekty delegowane działać na tym samym wystąpieniu programu `Example`. Zmiany w wartości wewnętrznego pola są wyświetlane po każdym wywołaniu. Na koniec `UseLikeInstance` delegata jest powiązany z wystąpieniem `DerivedFromxample`, i są powtarzane wywołania delegata.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.  - lub - <paramref name="owner" /> interfejsu, tablicy, otwartym typem ogólnym lub parametr typu ogólnego lub metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="owner" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> jest <see langword="null" />, lub jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metody dynamicznej z typu w module niż wywoływania modułu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. To może być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa typ zwracany metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów Określanie typów parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="m">A <see cref="T:System.Reflection.Module" /> reprezentujący modułu, z którym ma być logicznie powiązanych metody dynamicznej.</param>
        <param name="skipVisibility">
          <see langword="true" /> Aby pominąć JIT widoczność kontroli typy i składniki używane przez MSIL metody dynamicznej.</param>
        <summary>Tworzy dynamiczny metody globalne do modułu, określając nazwę metody zwracanie typu, typów parametrów, modułu oraz czy sprawdza just in time (JIT) widoczność ma być pomijana dla typy i składniki używane przez język pośredni firmy Microsoft (MSIL) dynamiczne metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor określa atrybuty metody <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>i konwencji wywoływania <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
 Metody dynamiczne utworzone za pomocą tego konstruktora ma dostęp do publicznego i `internal` (`Friend` w języku Visual Basic) elementy członkowskie wszystkich typów w module zawartych w niej `m`. Pomijanie JIT kontroli widoczność kompilatora umożliwia dynamiczne metody dostępu prywatnego i chronionych elementów członkowskich wszystkich innych typów również do. Jest to przydatne, na przykład podczas pisania kodu do serializacji obiektów.  
  
> [!NOTE]
>  W celu zapewnienia zgodności z poprzednimi wersjami wymaga tego konstruktora <xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> Flaga, jeśli są następujące warunki true: `m` jest modułem inne niż wywoływania modułu i popytu na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flagi nie powiodło się. Jeśli żądanie dla <xref:System.Security.Permissions.SecurityPermission> zakończy się powodzeniem, ta operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy z zabezpieczeniami w odbicia Emituj](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.  - lub - <paramref name="m" /> jest moduł, który zawiera anonimowy hosting dla metod dynamicznych.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="m" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metody dynamicznej z modułu innej niż moduł wywołujący. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. To może być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa typ zwracany metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów Określanie typów parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="owner">A <see cref="T:System.Type" /> z metody dynamicznej jest logicznie powiązanych. Metody dynamicznej ma dostęp do wszystkich elementów członkowskich tego typu.</param>
        <param name="skipVisibility">
          <see langword="true" /> Aby pominąć JIT widoczność kontroli typy i składniki używane przez MSIL metody dynamicznej; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy metodę dynamicznego, określając nazwę metody, typ zwracany, typów parametrów, typ z metody dynamicznej jest logicznie powiązanych oraz czy just in time (JIT) widoczność kontroli ma być pomijana dla typów i członków dostęp do programu Microsoft język pośredni (MSIL) metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody dynamicznej utworzone za pomocą tego konstruktora ma dostęp do wszystkich elementów członkowskich typu `owner`i na publiczne i `internal` (`Friend` w języku Visual Basic) elementy członkowskie wszystkich typów w module, który zawiera `owner`. Pomijanie JIT kontroli widoczność kompilatora umożliwia dynamiczne metody dostępu prywatnego i chronionych elementów członkowskich wszystkich innych typów również do. Jest to przydatne, na przykład podczas pisania kodu do serializacji obiektów.  
  
 Ten konstruktor określa atrybuty metody <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>i konwencji wywoływania <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  W celu zapewnienia zgodności z poprzednimi wersjami wymaga tego konstruktora <xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> Flaga, jeśli są następujące warunki true: `owner` znajduje się w module niż wywoływania modułu i popytu na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flaga nie powiodło się. Jeśli żądanie dla <xref:System.Security.Permissions.SecurityPermission> zakończy się powodzeniem, ta operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy z zabezpieczeniami w odbicia Emituj](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.  - lub - <paramref name="owner" /> interfejsu, tablicy, otwartym typem ogólnym lub parametr typu ogólnego lub metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="owner" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> jest <see langword="null" />, lub jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metody dynamicznej z typu w module niż wywoływania modułu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. To może być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="attributes">Bitowe połączenie <see cref="T:System.Reflection.MethodAttributes" /> wartości, które określają atrybuty metody dynamicznej. Kombinacja tylko dozwolone jest <see cref="F:System.Reflection.MethodAttributes.Public" /> i <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Konwencja wywoływania metody dynamicznej. Musi być <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa typ zwracany metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów Określanie typów parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="m">To be added.</param>
        <param name="skipVisibility">
          <see langword="true" /> Aby pominąć JIT widoczność kontroli typy i składniki używane przez MSIL metody dynamicznej; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy dynamiczne metodę, która jest globalna do modułu, określając nazwę metody, atrybuty wywoływanie Konwencji, zwróci typu, typów parametrów, moduł i czy sprawdza just in time (JIT) widoczność ma być pomijana dla typów i członków z niego Microsoft język pośredni (MSIL) metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamiczne metody utworzone za pomocą tego konstruktora ma dostęp do publicznego i `internal` (`Friend` w języku Visual Basic) elementy członkowskie wszystkich typów publicznych oraz wewnętrznych zawarte w module `m`.  
  
 Pomijanie JIT kontroli widoczność kompilatora umożliwia dynamiczne metody dostępu prywatnego i chronionych elementów członkowskich innych typów w module i wszystkie inne zestawy również do. Jest to przydatne, na przykład podczas pisania kodu do serializacji obiektów.  
  
> [!NOTE]
>  W celu zapewnienia zgodności z poprzednimi wersjami wymaga tego konstruktora <xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> Flaga, jeśli są następujące warunki true: `m` jest modułem inne niż wywoływania modułu i popytu na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flagi nie powiodło się. Jeśli żądanie dla <xref:System.Security.Permissions.SecurityPermission> zakończy się powodzeniem, ta operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy z zabezpieczeniami w odbicia Emituj](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.  - lub - <paramref name="m" /> jest moduł, który zawiera anonimowy hosting dla metod dynamicznych.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="m" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> inne niż jest kombinacją flag <see cref="F:System.Reflection.MethodAttributes.Public" /> i <see cref="F:System.Reflection.MethodAttributes.Static" />.  - lub - <paramref name="callingConvention" /> nie jest <see cref="F:System.Reflection.CallingConventions.Standard" />.  - lub - <paramref name="returnType" /> to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metody dynamicznej z modułu innej niż moduł wywołujący. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. To może być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="attributes">Bitowe połączenie <see cref="T:System.Reflection.MethodAttributes" /> wartości, które określają atrybuty metody dynamicznej. Kombinacja tylko dozwolone jest <see cref="F:System.Reflection.MethodAttributes.Public" /> i <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Konwencja wywoływania metody dynamicznej. Musi być <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa typ zwracany metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów Określanie typów parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="owner">A <see cref="T:System.Type" /> z metody dynamicznej jest logicznie powiązanych. Metody dynamicznej ma dostęp do wszystkich elementów członkowskich tego typu.</param>
        <param name="skipVisibility">
          <see langword="true" /> Aby pominąć JIT widoczność kontroli typy i składniki używane przez MSIL metody dynamicznej; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy metodę dynamicznego, określając nazwę metody, atrybuty, wywoływanie Konwencji, typ zwracany, typów parametrów, typ z metody dynamicznej jest logicznie powiązanych oraz czy just in time (JIT) widoczność kontroli ma być pomijana w przypadku typów i elementy członkowskie z niego Microsoft język pośredni (MSIL) metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamiczne metody jest globalny moduł, który zawiera typ `owner`. Ma dostęp do wszystkich elementów członkowskich typu `owner`.  
  
 Metody dynamicznej utworzone za pomocą tego konstruktora ma dostęp do wszystkich elementów członkowskich typu `owner`i na publiczne i `internal` (`Friend` w języku Visual Basic) elementy członkowskie wszystkich typów, które są zawarte w module, który zawiera `owner`. Pomijanie JIT kontroli widoczność kompilatora umożliwia dynamiczne metody dostępu prywatnego i chronionych elementów członkowskich wszystkich innych typów również do. Jest to przydatne, na przykład podczas pisania kodu do serializacji obiektów.  
  
> [!NOTE]
>  W celu zapewnienia zgodności z poprzednimi wersjami wymaga tego konstruktora <xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> Flaga, jeśli są następujące warunki true: `owner` znajduje się w module niż wywoływania modułu i popytu na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flaga nie powiodło się. Jeśli żądanie dla <xref:System.Security.Permissions.SecurityPermission> zakończy się powodzeniem, ta operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy z zabezpieczeniami w odbicia Emituj](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.  - lub - <paramref name="owner" /> interfejsu, tablicy, otwartym typem ogólnym lub parametr typu ogólnego lub metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="owner" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> inne niż jest kombinacją flag <see cref="F:System.Reflection.MethodAttributes.Public" /> i <see cref="F:System.Reflection.MethodAttributes.Static" />.  - lub - <paramref name="callingConvention" /> nie jest <see cref="F:System.Reflection.CallingConventions.Standard" />.  - lub - <paramref name="returnType" /> to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metody dynamicznej z typu w module niż wywoływania modułu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty określone podczas tworzenia metody dynamicznej.</summary>
        <value>Bitowe połączenie <see cref="T:System.Reflection.MethodAttributes" /> wartości reprezentujących atrybuty dla metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie atrybuty metody dla metody dynamiczne są zawsze <xref:System.Reflection.MethodAttributes.Public> i <xref:System.Reflection.MethodAttributes.Static>.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia atrybuty metody dynamicznej metody. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Konwencja wywoływania określona podczas tworzenia metody dynamicznej.</summary>
        <value>Jeden z <see cref="T:System.Reflection.CallingConventions" /> wartości, które wskazuje konwencja wywołania metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwencja wywoływania metody dynamicznej jest obecnie zawsze <xref:System.Reflection.CallingConventions.Standard>.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia konwencja wywołania metody dynamicznej. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy metody dynamicznej i tworzy delegata, który może służyć do jego wykonania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata, którego sygnatura zgodny z metody dynamicznej.</param>
        <summary>Kończy metody dynamicznej i tworzy delegata, który może służyć do jego wykonania.</summary>
        <returns>Delegat określonego typu, który może służyć do wykonania metody dynamicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metody lub <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> ukończeniu metody metody dynamicznej. Wszelkie dodatkowe próbować zmieniać metody dynamicznej, takiej jak zmodyfikowanie definicji parametrów lub emitowanie więcej język pośredni firmy Microsoft (MSIL) jest ignorowana. nie wyjątek.  
  
 W celu utworzenia treści metody dynamicznej metody, jeśli masz własne generator MSIL, wywołać <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> metodę, aby uzyskać <xref:System.Reflection.Emit.DynamicILInfo> obiektu. Jeśli nie masz własne generator MSIL, wywołanie <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> metodę, aby uzyskać <xref:System.Reflection.Emit.ILGenerator> obiektu, który może służyć do generowania treści metody.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy dynamiczne metodę, która przyjmuje dwa parametry. Przykład emituje treści proste funkcja, która wyświetla pierwszy parametr do konsoli, a w przykładzie użyto drugi parametr jako wartość zwracaną przez metodę. Przykład kończy metody tworzenia delegata wywołuje delegata o innych parametrach, a na koniec wywołuje przy użyciu metody dynamicznej <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dynamiczne metody ma nie treści metody.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> ma nieprawidłową liczbę parametrów ani typów nieprawidłowy parametr.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata, którego sygnatura zgodny z metody dynamicznej minus pierwszym parametrem.</param>
        <param name="target">Obiekt delegat jest powiązany. Musi być tego samego typu jako pierwszego parametru metody dynamicznej.</param>
        <summary>Kończy metody dynamicznej i tworzy delegata, który może służyć do wykonywania, określający typ delegata oraz delegat jest powiązany z obiektu.</summary>
        <returns>Delegat określonego typu, który może służyć do wykonania metody dynamicznej o wskazanym obiekcie docelowym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody tworzy delegata powiązany z określonego obiektu. Takie delegata jest nazywany zamknięte przez jego pierwszym argumentem. Mimo że metoda jest statyczna, działa tak, jakby była metodą wystąpienia; wystąpienie jest `target`.  
  
 Przeciążenie tej metody wymaga `target` być tego samego typu jako pierwszego parametru metody dynamicznej lub przypisane do tego typu (na przykład klasy pochodnej).  Podpis `delegateType` ma wszystkie parametry metody dynamicznej oprócz pierwszego. Na przykład, jeśli dynamiczna metoda ma parametry <xref:System.String>, <xref:System.Int32>, i <xref:System.Byte>, następnie `delegateType` ma następujące parametry <xref:System.Int32> i <xref:System.Byte>; `target` jest typu <xref:System.String>.  
  
 Wywoływanie <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metody lub <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> ukończeniu metody metody dynamicznej. Wszelkie dodatkowe próbować zmieniać metody dynamicznej, takiej jak zmodyfikowanie definicji parametrów lub emitowanie więcej język pośredni firmy Microsoft (MSIL) jest ignorowana. nie wyjątek.  
  
 W celu utworzenia treści metody dynamicznej metody, jeśli masz własne generator MSIL, wywołać <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> metodę, aby uzyskać <xref:System.Reflection.Emit.DynamicILInfo> obiektu. Jeśli nie masz własne generator MSIL, wywołanie <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> metodę, aby uzyskać <xref:System.Reflection.Emit.ILGenerator> obiektu, który może służyć do generowania treści metody.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy delegata, który wiąże <xref:System.Reflection.Emit.DynamicMethod> do wystąpienia typu, dzięki czemu metoda działa na tym samym wystąpieniu zawsze jest wywoływana.  
  
 Przykładowy kod definiuje klasę o nazwie `Example` z polem prywatnej o nazwie klasy `DerivedFromxample` która pochodzi z klasy pierwszego typu delegata o nazwie `UseLikeStatic` zwracającą <xref:System.Int32> i ma następujące parametry typu `Example` i <xref:System.Int32>oraz typ delegata o nazwie `UseLikeInstance` zwracającą <xref:System.Int32> i ma jeden parametr typu <xref:System.Int32>.  
  
 Przykład kodu tworzy następnie <xref:System.Reflection.Emit.DynamicMethod> zmienia się pole prywatne wystąpienia `Example` i zwraca poprzednią wartość.  
  
> [!NOTE]
>  Ogólnie rzecz biorąc zmiana pola wewnętrzne klas nie jest dobrym obiektowo praktyk kodowania.  
  
 Przykład kodu tworzy wystąpienie `Example` , a następnie tworzy dwa obiekty delegowane. Pierwsza to typu `UseLikeStatic`, który ma te same parametry jako metody dynamicznej. Drugą jest wartość typu `UseLikeInstance`, który nie ma pierwszy parametr (typu `Example`). Ten delegat jest tworzony przy użyciu <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> przeciążenie metody; drugi parametr przeciążenie tej metody jest wystąpieniem `Example`, w tym przypadku wystąpienie właśnie utworzony, który jest powiązany z nowo utworzonego obiektu delegowanego. Przy każdym wywołaniu tego delegata metody dynamicznej działania w przypadku powiązane wystąpienie `Example`.  
  
> [!NOTE]
>  To jest przykład swobodna reguł dla delegata powiązanie wprowadzone w systemie [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], wraz z przeciążeń nowe <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> metody. Aby uzyskać więcej informacji, zobacz <xref:System.Delegate> klasy.  
  
 `UseLikeStatic` Delegata zostanie wywołany, przekazując wystąpienie elementu `Example` który jest powiązany `UseLikeInstance` delegowanie. Następnie przy użyciu `UseLikeInstance` delegata zostanie wywołany, tak aby oba obiekty delegowane działać na tym samym wystąpieniu programu `Example`. Zmiany w wartości wewnętrznego pola są wyświetlane po każdym wywołaniu. Na koniec `UseLikeInstance` delegata jest powiązany z wystąpieniem `DerivedFromxample`, i są powtarzane wywołania delegata.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dynamiczne metody ma nie treści metody.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> nie jest ten sam typ jako pierwszego parametru metody dynamicznej, a nie można przypisać do tego typu.  - lub - <paramref name="delegateType" /> ma nieprawidłową liczbę parametrów ani typów nieprawidłowy parametr.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, który deklaruje metody, która jest zawsze <see langword="null" /> dla metod dynamicznych.</summary>
        <value>Zawsze <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca `null` dla metod dynamicznych. Nawet jeśli metody dynamiczne są logicznie skojarzony z typem, nie jest deklarowana przez typ.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia typ deklarujący metody dynamicznej. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja parametru na liście parametrów. Parametry są indeksowane, począwszy od pierwszego parametru numer 1.</param>
        <param name="attributes">Bitowe połączenie <see cref="T:System.Reflection.ParameterAttributes" /> wartości, które określają atrybuty parametru.</param>
        <param name="parameterName">Nazwa parametru. Nazwa może być ciągiem o zerowej długości.</param>
        <summary>Określa parametr metody dynamicznej.</summary>
        <returns>Zawsze zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `position` ma wartość 0, <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> metody odwołuje się do wartości zwracanej. Ustawianie informacji o parametrach nie ma wpływu na wartość zwracaną.  
  
 Jeśli dynamiczna metoda została już ukończona, wywołując <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> lub <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> — metoda nie ma wpływu. Nie wyjątek.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób definiowania informacji o parametrach dla metody dynamicznej. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Metoda nie ma parametrów.  - lub - <paramref name="position" /> jest mniejszy niż 0.  - lub - <paramref name="position" /> jest większa niż liczba parametrów metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca Podstawowa implementacja metody.</summary>
        <returns>Podstawowa implementacja metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zawsze zwraca bieżącą `DynamicMethod` obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca atrybuty niestandardowe zastosowane do metody.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <see langword="true" /> Aby przeszukać łańcuch dziedziczenia metody w celu znalezienia atrybutów niestandardowych; <see langword="false" /> do sprawdzania bieżącej metody.</param>
        <summary>Zwraca wszystkie atrybuty niestandardowe zdefiniowane dla metody.</summary>
        <returns>Tablica obiektów reprezentująca atrybuty niestandardowe metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla metody dynamiczne określanie `true` dla `inherit` nie obowiązuje, ponieważ metoda nie jest zadeklarowana w typie.  
  
> [!NOTE]
>  Atrybuty niestandardowe nie są obecnie obsługiwane w metodach dynamicznych. Zwrócony jedyny atrybut <xref:System.Runtime.CompilerServices.MethodImplAttribute>; można uzyskać metody flagi implementacji łatwiej przy użyciu <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">A <see cref="T:System.Type" /> reprezentujący typ atrybutu niestandardowego do zwrócenia.</param>
        <param name="inherit">
          <see langword="true" /> Aby przeszukać łańcuch dziedziczenia metody w celu znalezienia atrybutów niestandardowych; <see langword="false" /> do sprawdzania bieżącej metody.</param>
        <summary>Zwraca atrybuty niestandardowe określonego typu, które zostały zastosowane do metody.</summary>
        <returns>Tablica obiektów reprezentująca atrybuty metody, które są typu <paramref name="attributeType" /> lub pochodzić od typu <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla metody dynamiczne określanie `true` dla `inherit` nie obowiązuje, ponieważ metoda nie jest zadeklarowana w typie.  
  
> [!NOTE]
>  Atrybuty niestandardowe nie są obecnie obsługiwane w metodach dynamicznych. Zwrócony jedyny atrybut <xref:System.Runtime.CompilerServices.MethodImplAttribute>; można uzyskać metody flagi implementacji łatwiej przy użyciu <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu, który może służyć do generowania tokenów metadanych, zakresy i strumieni język pośredni (MSIL) firmy Microsoft treści metody.</summary>
        <returns>A <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu, który może służyć do generowania tokenów metadanych, zakresy i strumieni MSIL treści metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicILInfo> Podano klasy do obsługi generowania kodu niezarządzanego.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wykonywania kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca generator MSIL, który może służyć do wysyłania treści metody dynamicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca generator języka pośredniego (MSIL) firmy Microsoft dla metody domyślny rozmiar strumienia MSIL 64 bajtów.</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.ILGenerator" /> Obiektu dla metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po ukończeniu metody dynamicznej, wywołując <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> lub <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody, dalsze próby dodać MSIL jest ignorowana. Nie wyjątek.  
  
> [!NOTE]
>  Ma ograniczeń dotyczących zweryfikowanie kodu w metod dynamicznych, nawet w niektórych scenariuszach pełnego zaufania. Sekcja "Weryfikacja" w uwagi dla <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy dynamiczne metodę, która przyjmuje dwa parametry. Przykład emituje treści proste funkcja, która wyświetla pierwszy parametr do konsoli, a w przykładzie użyto drugi parametr jako wartość zwracaną przez metodę. Przykład kończy metody tworzenia delegata wywołuje delegata o innych parametrach, a na koniec wywołuje przy użyciu metody dynamicznej <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">Rozmiar strumienia MSIL, w bajtach.</param>
        <summary>Zwraca generator języka pośredniego (MSIL) firmy Microsoft dla metody z określonym rozmiarem strumienia MSIL.</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.ILGenerator" /> Obiektu w przypadku metody z określonym rozmiarem strumienia MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po ukończeniu metody dynamicznej, wywołując <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> lub <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody, dalsze próby dodać MSIL jest ignorowana. Nie wyjątek.  
  
> [!NOTE]
>  Ma ograniczeń dotyczących zweryfikowanie kodu w metod dynamicznych, nawet w niektórych scenariuszach pełnego zaufania. Sekcja "Weryfikacja" w uwagi dla <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje przeciążenie tej metody. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca flagi implementacji metody.</summary>
        <returns>Bitowe połączenie <see cref="T:System.Reflection.MethodImplAttributes" /> wartości reprezentujących flagi implementacji metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie atrybuty implementacji metody dla metody dynamiczne są zawsze <xref:System.Reflection.MethodImplAttributes.IL> i <xref:System.Reflection.MethodImplAttributes.NoInlining>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca parametry metody dynamicznej.</summary>
        <returns>Tablica <see cref="T:System.Reflection.ParameterInfo" /> obiektów, które reprezentują parametry metody dynamicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.ParameterInfo> Obiektów zwrócona przez tę metodę są wyłącznie w celach informacyjnych. Użyj <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> metodę, aby ustawić lub zmienić właściwości parametrów.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia parametry metody dynamicznej. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zmiennych lokalnych w metodzie są inicjowane przez zero.</summary>
        <value>
          <see langword="true" /> w przypadku zmiennych lokalnych w metodzie zero zainicjowana; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest ustawiona na `true`, emitowany język pośredni firmy Microsoft (MSIL) obejmuje inicjowanie zmiennych lokalnych. Jeśli wartość jest ustawiona na `false`, zmienne lokalne nie jest zainicjowany i nie jest wygenerowanego kodu.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> właściwości metody dynamicznej. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">Ten parametr jest ignorowany dla metod dynamicznych, ponieważ są one statycznych. Określ <see langword="null" />.</param>
        <param name="invokeAttr">Bitowe połączenie <see cref="T:System.Reflection.BindingFlags" /> wartości.</param>
        <param name="binder">A <see cref="T:System.Reflection.Binder" /> obiektu, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przez odbicie. Jeśli <c>integratora</c> jest <see langword="null" />, używany jest domyślny integrator. Aby uzyskać więcej informacji, zobacz <see cref="T:System.Reflection.Binder" />.</param>
        <param name="parameters">Lista argumentów. To jest tablica argumentów, których liczba, kolejność i typ jako parametry metody do wywołania. Jeśli nie ma żadnych parametrów ten parametr powinien być <see langword="null" />.</param>
        <param name="culture">Wystąpienie <see cref="T:System.Globalization.CultureInfo" /> używane do sterowania koercja typów. Jeśli jest to <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku. Na przykład, te informacje są potrzebne, aby poprawnie przekonwertować <see cref="T:System.String" /> reprezentujący 1000 do <see cref="T:System.Double" /> wartości, ponieważ 1000 jest inaczej reprezentowany przez innych kultur.</param>
        <summary>Wywołuje metodę dynamicznego przy użyciu określonych parametrów, zgodnie z ograniczeniami określony obiekt wiążący z informacjami o określonej kultury.</summary>
        <returns>A <see cref="T:System.Object" /> zawierający wartość zwracaną wywoływanej metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oprócz wymienionych wyjątki kod wywołujący powinna być przygotowana do catch wszelkie wyjątki zgłaszane przez metody dynamicznej.  
  
 Wykonywanie metody dynamicznej z delegatem, utworzone przez <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metoda jest bardziej efektywne niż wykonywania za pomocą <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody.  
  
 Wywoływanie <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody lub <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> ukończeniu metody metody dynamicznej. Wszelkie dodatkowe próbować zmieniać metody dynamicznej, takiej jak zmodyfikowanie definicji parametrów lub emitowanie więcej język pośredni firmy Microsoft (MSIL) jest ignorowana. nie wyjątek.  
  
 Wszystkie metody dynamiczne są statyczne, więc `obj` parametr zawsze jest ignorowany. Aby traktować dynamiczne — metoda, tak jakby był on metody wystąpienia, należy użyć <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> przeciążenia, które przyjmuje wystąpienia obiektu.  
  
 Jeśli dynamiczna metoda nie ma parametrów, wartość `parameters` powinien być `null`. W przeciwnym razie liczbę, typ i kolejność elementów w tablicy parametrów powinny być identyczne z liczbę, typ i kolejność parametrów metody dynamicznej.  
  
> [!NOTE]
>  Przeciążenie tej metody jest wywoływana przez <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> odziedziczone przeciążenie metody <xref:System.Reflection.MethodBase> klasy, więc poprzedniego uwagi dotyczą zarówno przeciążenia.  
  
 Ta metoda nie wymaga uprawnień bezpośrednio, ale wywołanie metody dynamicznej może spowodować żądania kontroli zabezpieczeń, w zależności od metody. Na przykład żądania nie są wykonywane dla hostowanej anonimowo metody dynamiczne, które zostały utworzone z `restrictedSkipVisibility` ustawiono parametr `false`. Z drugiej strony, jeśli tworzysz metodę o `restrictedSkipVisibility` ustawioną `true` go wymaga dostępu do ukrytych członkiem zestawu docelowego, metoda spowoduje, że żądanie uprawnienia zestaw docelowy plus <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flagi.  
  
> [!NOTE]
>  Przed [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda wymagane <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> flagi.  
  
   
  
## Examples  
 Poniższy przykładowy kod wywołuje metodę dynamicznej z powiązaniem dokładne, przy użyciu kultury angielski. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="F:System.Reflection.CallingConventions.VarArgs" /> Konwencji wywoływania nie jest obsługiwana.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">Liczba elementów w <paramref name="parameters" /> jest niezgodna z liczbą parametrów metody dynamicznej.</exception>
        <exception cref="T:System.ArgumentException">Wpisz jeden lub więcej elementów <paramref name="parameters" /> nie jest zgodny z typem odpowiadającego mu parametru metody dynamicznej.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Metody dynamicznej jest skojarzony z modułem anonimowo nie jest obsługiwany i został skonstruowany przy <paramref name="skipVisibility" /> ustawioną <see langword="false" />, ale metody dynamicznej uzyskuje dostęp do elementów członkowskich, które nie są <see langword="public" /> lub <see langword="internal" /> (<see langword="Friend" /> w języku Visual Basic).  - lub - znajduje się anonimowo metody dynamicznej i został skonstruowany przy <paramref name="skipVisibility" /> ustawioną <see langword="false" />, ale uzyskuje dostęp do elementów członkowskich, które nie są <see langword="public" />.  - lub - niemożliwy do sprawdzenia kod zawiera metody dynamicznej. Sekcja "Weryfikacja" w uwagi dla <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">A <see cref="T:System.Type" /> reprezentujący typ atrybutu niestandardowego do wyszukania.</param>
        <param name="inherit">
          <see langword="true" /> Aby przeszukać łańcuch dziedziczenia metody w celu znalezienia atrybutów niestandardowych; <see langword="false" /> do sprawdzania bieżącej metody.</param>
        <summary>Wskazuje, czy jest zdefiniowany typ określonego atrybutu niestandardowego.</summary>
        <returns>
          <see langword="true" /> Jeśli zdefiniowano typ określonego atrybutu niestandardowego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla metody dynamiczne określanie `true` dla `inherit` nie ma wpływu. Metody dynamiczne mieć nie łańcuch dziedziczenia.  
  
> [!NOTE]
>  Atrybuty niestandardowe nie są obecnie obsługiwane w metodach dynamicznych.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżącej metody dynamicznej jest krytyczny dla zabezpieczeń lub bezpieczny krytyczny dla zabezpieczeń i w związku z tym mogą wykonywać operacje krytyczne.</summary>
        <value>
          <see langword="true" /> w przypadku bieżącej metody dynamicznej krytyczny dla zabezpieczeń lub bezpieczny krytyczny dla zabezpieczeń; <see langword="false" /> Jeśli jest niewidoczne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości metody dynamicznej określone przez środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
 Przezroczystość metody dynamicznej zależy od moduł, który jest skojarzony z. Jeśli metody dynamicznej jest skojarzony z typem, a nie modułu, przezroczystość zależy od moduł, który zawiera typ. Metody dynamiczne nie ma adnotacji zabezpieczeń, są przypisane domyślną przezroczystość skojarzone modułu.  
  
-   Hostowanej anonimowo metody dynamicznej są zawsze przezroczysty, ponieważ moduł dostarczane przez system, który je zawiera jest niewidoczny.  
  
-   W poniższej tabeli opisano przezroczystość dynamiczne metodę, która jest skojarzona z zestawem zaufanych (to znaczy zestawu z silną nazwą zainstalowanego w pamięci podręcznej GAC).  
  
    |Adnotacja zestawu|Przezroczystość poziomu 1|Przezroczystość poziomu 2|  
    |-------------------------|--------------------------|--------------------------|  
    |W pełni przezroczyste|Przezroczyste|Przezroczyste|  
    |Pełni krytyczne|Krytyczny|Krytyczny|  
    |Mieszane przezroczystości|Przezroczyste|Przezroczyste|  
    |Security-agnostic|Bezpieczne krytyczne|Krytyczny|  
  
     Na przykład jeśli skojarzona z typem, który znajduje się w pliku mscorlib.dll, który ma poziom 2 przezroczystość mieszanych, dynamiczne — metoda metody dynamicznej jest niewidoczny i nie można wykonać kodu krytycznego. Informacji o poziomach przejrzystości, zobacz [kod o przezroczystym poziomie bezpieczeństwa, poziom 1](~/docs/framework/misc/security-transparent-code-level-1.md) i [kod o przezroczystym poziomie bezpieczeństwa, poziom 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Kojarzenie metody dynamicznej z modułu w zestawie zaufanego poziomu 1, który jest zabezpieczeń niezwiązane z żadnym, takich jak System.dll, nie zezwala na podniesienie poziomu zaufania. Jeśli zestaw grant kod, który wywołuje metody dynamicznej nie obejmuje zestaw grant System.dll (to znaczy pełnego zaufania) <xref:System.Security.SecurityException> jest generowany, gdy wywoływana jest metoda dynamicznych.  
  
-   Przezroczystość dynamiczne metodę, która jest skojarzona z częściowo zaufanym zestawie zależy od tego, jak zestaw jest ładowany. Jeśli zestaw jest ładowany z częściowa relacja zaufania (na przykład w domenie aplikacji piaskownicy), środowisko uruchomieniowe ignoruje adnotacje zabezpieczeń zestawu. Zestaw i jego typów i członków, włączając metod dynamicznych, są traktowane jako przezroczysty. Środowisko uruchomieniowe zwraca uwagę adnotacje zabezpieczeń tylko wtedy, gdy zestaw częściowego zaufania jest załadowany z pełnym zaufaniem (na przykład do domyślnej domeny aplikacji klasycznej aplikacji). W takim przypadku środowiska uruchomieniowego przypisuje metody dynamicznej domyślną przezroczystość dla metod zgodnie z zestawu adnotacji.  
  
 Aby uzyskać więcej informacji na temat odbicia Emituj i przejrzystości, zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dynamiczne metody nie ma treści metody.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżąca metoda dynamicznych to bezpieczny krytyczny dla zabezpieczeń na bieżącym poziomie zaufania; oznacza to, czy go mogą wykonywać operacje krytyczne i można uzyskać, sprawdzając kod przezroczysty.</summary>
        <value>
          <see langword="true" /> Jeśli metoda dynamiczna jest bezpieczny krytyczny dla zabezpieczeń na bieżącym poziomie zaufania; <see langword="false" /> przypadku zabezpieczeń krytyczny ani przezroczysty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości metody dynamicznej określone przez środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
 Przezroczystość metody dynamicznej zależy od moduł, który jest skojarzony z. Jeśli metody dynamicznej jest skojarzony z typem, a nie modułu, przezroczystość zależy od moduł, który zawiera typ. Metody dynamiczne nie ma adnotacji zabezpieczeń, są przypisane domyślną przezroczystość skojarzone modułu.  
  
-   Hostowanej anonimowo metody dynamicznej są zawsze przezroczysty, ponieważ moduł dostarczane przez system, który je zawiera jest niewidoczny.  
  
-   W poniższej tabeli opisano przezroczystość dynamiczne metodę, która jest skojarzona z zestawem zaufanych (to znaczy zestawu z silną nazwą zainstalowanego w pamięci podręcznej GAC).  
  
    |Adnotacja zestawu|Przezroczystość poziomu 1|Przezroczystość poziomu 2|  
    |-------------------------|--------------------------|--------------------------|  
    |W pełni przezroczyste|Przezroczyste|Przezroczyste|  
    |Pełni krytyczne|Krytyczny|Krytyczny|  
    |Mieszane przezroczystości|Przezroczyste|Przezroczyste|  
    |Security-agnostic|Bezpieczne krytyczne|Krytyczny|  
  
     Na przykład jeśli skojarzona z typem, który znajduje się w pliku mscorlib.dll, który ma poziom 2 przezroczystość mieszanych, dynamiczne — metoda metody dynamicznej jest niewidoczny i nie można wykonać kodu krytycznego. Informacji o poziomach przejrzystości, zobacz [kod o przezroczystym poziomie bezpieczeństwa, poziom 1](~/docs/framework/misc/security-transparent-code-level-1.md) i [kod o przezroczystym poziomie bezpieczeństwa, poziom 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Kojarzenie metody dynamicznej z modułu w zestawie zaufanego poziomu 1, który jest zabezpieczeń niezwiązane z żadnym, takich jak System.dll, nie zezwala na podniesienie poziomu zaufania. Jeśli zestaw grant kod, który wywołuje metody dynamicznej nie obejmuje zestaw grant System.dll (to znaczy pełnego zaufania) <xref:System.Security.SecurityException> jest generowany, gdy wywoływana jest metoda dynamicznych.  
  
-   Przezroczystość dynamiczne metodę, która jest skojarzona z częściowo zaufanym zestawie zależy od tego, jak zestaw jest ładowany. Jeśli zestaw jest ładowany z częściowa relacja zaufania (na przykład w domenie aplikacji piaskownicy), środowisko uruchomieniowe ignoruje adnotacje zabezpieczeń zestawu. Zestaw i jego typów i członków, włączając metod dynamicznych, są traktowane jako przezroczysty. Środowisko uruchomieniowe zwraca uwagę adnotacje zabezpieczeń tylko wtedy, gdy zestaw częściowego zaufania jest załadowany z pełnym zaufaniem (na przykład do domyślnej domeny aplikacji klasycznej aplikacji). W takim przypadku środowiska uruchomieniowego przypisuje metody dynamicznej domyślną przezroczystość dla metod zgodnie z zestawu adnotacji.  
  
 Aby uzyskać więcej informacji na temat odbicia Emituj i przejrzystości, zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dynamiczne metody nie ma treści metody.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżącej metody dynamicznej jest niewidoczny na bieżącym poziomie zaufania i dlatego nie można wykonać operacji krytyczne.</summary>
        <value>
          <see langword="true" /> w przypadku metody dynamicznej przezroczystym poziomie bezpieczeństwa na bieżącym poziomie zaufania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości metody dynamicznej określone przez środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
 Przezroczystość metody dynamicznej zależy od moduł, który jest skojarzony z. Jeśli metody dynamicznej jest skojarzony z typem, a nie modułu, przezroczystość zależy od moduł, który zawiera typ. Metody dynamiczne nie ma adnotacji zabezpieczeń, są przypisane domyślną przezroczystość skojarzone modułu.  
  
-   Hostowanej anonimowo metody dynamicznej są zawsze przezroczysty, ponieważ moduł dostarczane przez system, który je zawiera jest niewidoczny.  
  
-   W poniższej tabeli opisano przezroczystość dynamiczne metodę, która jest skojarzona z zestawem zaufanych (to znaczy zestawu z silną nazwą zainstalowanego w pamięci podręcznej GAC).  
  
    |Adnotacja zestawu|Przezroczystość poziomu 1|Przezroczystość poziomu 2|  
    |-------------------------|--------------------------|--------------------------|  
    |W pełni przezroczyste|Przezroczyste|Przezroczyste|  
    |Pełni krytyczne|Krytyczny|Krytyczny|  
    |Mieszane przezroczystości|Przezroczyste|Przezroczyste|  
    |Security-agnostic|Bezpieczne krytyczne|Krytyczny|  
  
     Na przykład jeśli skojarzona z typem, który znajduje się w pliku mscorlib.dll, który ma poziom 2 przezroczystość mieszanych, dynamiczne — metoda metody dynamicznej jest niewidoczny i nie można wykonać kodu krytycznego. Informacji o poziomach przejrzystości, zobacz [kod o przezroczystym poziomie bezpieczeństwa, poziom 1](~/docs/framework/misc/security-transparent-code-level-1.md) i [kod o przezroczystym poziomie bezpieczeństwa, poziom 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Kojarzenie metody dynamicznej z modułu w zestawie zaufanego poziomu 1, który jest zabezpieczeń niezwiązane z żadnym, takich jak System.dll, nie zezwala na podniesienie poziomu zaufania. Jeśli zestaw grant kod, który wywołuje metody dynamicznej nie obejmuje zestaw grant System.dll (to znaczy pełnego zaufania) <xref:System.Security.SecurityException> jest generowany, gdy wywoływana jest metoda dynamicznych.  
  
-   Przezroczystość dynamiczne metodę, która jest skojarzona z częściowo zaufanym zestawie zależy od tego, jak zestaw jest ładowany. Jeśli zestaw jest ładowany z częściowa relacja zaufania (na przykład w domenie aplikacji piaskownicy), środowisko uruchomieniowe ignoruje adnotacje zabezpieczeń zestawu. Zestaw i jego typów i członków, włączając metod dynamicznych, są traktowane jako przezroczysty. Środowisko uruchomieniowe zwraca uwagę adnotacje zabezpieczeń tylko wtedy, gdy zestaw częściowego zaufania jest załadowany z pełnym zaufaniem (na przykład do domyślnej domeny aplikacji klasycznej aplikacji). W takim przypadku środowiska uruchomieniowego przypisuje metody dynamicznej domyślną przezroczystość dla metod zgodnie z zestawu adnotacji.  
  
 Aby uzyskać więcej informacji na temat odbicia Emituj i przejrzystości, zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dynamiczne metody nie ma treści metody.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Nie jest obsługiwane dla metod dynamicznych.</summary>
        <value>Nie jest obsługiwane dla metod dynamicznych.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Niedozwolone dla metod dynamicznych.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł, z którym jest logicznie powiązanych metody dynamicznej.</summary>
        <value>
          <see cref="T:System.Reflection.Module" /> z bieżącej metody dynamicznej jest skojarzony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli moduł został określony podczas tworzenia metody dynamicznej, ta właściwość zwraca tego modułu. Jeśli typ został określony jako właściciela podczas tworzenia metody dynamicznej, ta właściwość zwraca moduł, który zawiera tego typu.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład <xref:System.Reflection.Emit.DynamicMethod.Module%2A> właściwości metody dynamicznej. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę metody dynamicznej.</summary>
        <value>Prosta nazwa metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nie jest konieczne nazwy metod dynamicznych.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla nazwę metody dynamicznej. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera użytej w odbicia do uzyskania metody klasy.</summary>
        <value>Zawsze <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca `null` dla metod dynamicznych.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia odbite typu metody dynamicznej. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera parametr zwrotnego metody dynamicznej.</summary>
        <value>Zawsze <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca `null` dla metod dynamicznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ zwracanej wartości dla metody dynamicznej.</summary>
        <value>A <see cref="T:System.Type" /> reprezentujący typ zwracanej wartości bieżącej metody; <see cref="T:System.Void" /> Jeśli metoda nie ma zwracanego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `null` został określony dla typu zwracanych danych podczas tworzenia metody dynamicznej, ta właściwość zwraca <xref:System.Void?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia zwracany typ metody dynamicznej. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty niestandardowe zwracany typ metody dynamicznej.</summary>
        <value>
          <see cref="T:System.Reflection.ICustomAttributeProvider" /> Reprezentujący atrybuty niestandardowe zwracanego typu dla metody dynamicznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybuty niestandardowe nie są obsługiwane dla zwracanego typu metody dynamicznej, więc zwrócił tablicę atrybutów niestandardowych <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A> metody zawsze jest pusta.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób wyświetlania atrybutów niestandardowych zwracany typ metody dynamicznej. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca podpis metody reprezentowany jako ciąg.</summary>
        <returns>Ciąg reprezentujący podpis metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sygnatura obejmuje tylko typy i nazwę metody ewentualne. Nazwy parametrów nie są uwzględniane.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład <xref:System.Reflection.Emit.DynamicMethod.ToString%2A> metody metody dynamicznej. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
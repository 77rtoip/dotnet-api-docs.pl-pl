<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata><Meta Name="ms.openlocfilehash" Value="13b1d9daf4a4d7aae5b5478565ec2459bbd08759" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69070983" /></Metadata><TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje i reprezentuje metodę dynamiczną, którą można kompilować, wykonać i odrzucić. Metody odrzucane są dostępne do wyrzucania elementów bezużytecznych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Reflection.Emit.DynamicMethod> klasy do generowania i wykonywania metody w czasie wykonywania bez konieczności generowania dynamicznego zestawu i typu dynamicznego, aby zawierał metodę. Kod wykonywalny utworzony przez kompilator just-in-Time (JIT) jest odzyskiwany w momencie <xref:System.Reflection.Emit.DynamicMethod> odzyskiwania obiektu. Metody dynamiczne to najbardziej wydajny sposób generowania i wykonywania małych ilości kodu.  
  
 Metoda dynamiczna może być anonimowo hostowana lub może być logicznie skojarzona z modułem lub typem.  
  
-   Jeśli metoda dynamiczna jest anonimowo hostowana, znajduje się w zestawie dostarczonym przez system i dlatego jest odizolowana od innego kodu. Domyślnie nie ma dostępu do żadnych danych niepublicznych. Anonimowo obsługiwana metoda dynamiczna może mieć ograniczoną zdolność do pomijania sprawdzania widoczności kompilatora JIT, jeśli został on udzielony <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> z flagą. Poziom zaufania zestawu, którego niepubliczne składowe są dostępne przez metodę dynamiczną, musi być równy lub podzestawem poziomu zaufania stosu wywołań, który emituje metodę dynamiczną. Aby uzyskać więcej informacji na temat anonimowo obsługiwanych metod dynamicznych [, zobacz Przewodnik: Emitowanie kodu w scenariuszach](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)częściowej relacji zaufania.  
  
-   Jeśli metoda dynamiczna jest skojarzona z określonym modułem, metoda dynamiczna jest efektywnie globalnie dla tego modułu. Może uzyskać dostęp do wszystkich typów w module i wszystkich `internal` elementów`Friend` członkowskich (w Visual Basic). Można skojarzyć metodę dynamiczną z dowolnym modułem, niezależnie od tego, czy utworzono moduł, pod warunkiem, że żądanie <xref:System.Security.Permissions.ReflectionPermission> dla <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> z flagą może być spełnione przez stos wywołań, który zawiera kod. <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Jeśli flaga jest uwzględniona w przystawce, metoda dynamiczna może pominąć sprawdzanie widoczności kompilatora JIT i uzyskać dostęp do prywatnych danych wszystkich typów zadeklarowanych w module lub w dowolnym innym module w dowolnym zestawie.  
  
    > [!NOTE]
    >  Po określeniu modułu, z którym skojarzona jest metoda dynamiczna, ten moduł nie może znajdować się w zestawie dostarczonym przez system, który jest używany do anonimowego hostingu.  
  
-   Jeśli metoda dynamiczna jest skojarzona z określonym typem, ma dostęp do wszystkich elementów członkowskich tego typu, niezależnie od poziomu dostępu. Ponadto sprawdzanie widoczności JIT można pominąć. Dzięki temu metoda dynamiczna uzyskuje dostęp do prywatnych danych innych typów zadeklarowanych w tym samym module lub w dowolnym innym module w dowolnym zestawie. Można skojarzyć metodę dynamiczną z dowolnym typem, ale kod musi być przyznany <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> zarówno flagom, jak <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> i.  
  
 W poniższej tabeli przedstawiono, które typy i elementy członkowskie są dostępne dla anonimowo hostowanej metody dynamicznej z i bez kontroli widoczności JIT, w zależności od <xref:System.Security.Permissions.ReflectionPermission> tego <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> , czy flaga jest przyznana.  
  
||Konieczności<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|Się<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|Bez pomijania sprawdzania widoczności JIT|Publiczne składowe typów publicznych w dowolnym zestawie.|Publiczne składowe typów publicznych w dowolnym zestawie.|  
|Pomijanie sprawdzania widoczności JIT, z ograniczeniami|Publiczne składowe typów publicznych w dowolnym zestawie.|Wszystkie elementy członkowskie wszystkich typów, tylko w zestawach, których poziomy zaufania są równe lub mniejsze niż poziom zaufania zestawu, który emituje metodę dynamiczną.|  
  
> [!NOTE]
>  Przed, emitujący kod wymagany <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagą. [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] To uprawnienie jest uwzględniane domyślnie w zestawach uprawnień o nazwie FullTrust i LocalIntranet, ale nie w zestawie uprawnień internetowych. W związku z tym, we wcześniejszych [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] wersjach biblioteki można używać tylko z uprawnieniami internetowymi, jeśli <xref:System.Security.SecurityCriticalAttribute> ma ona <xref:System.Security.PermissionSet.Assert%2A> atrybut i wykonuje także dla <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>. Takie biblioteki wymagają starannej oceny zabezpieczeń, ponieważ błędy kodowania mogą spowodować powstanie luk w zabezpieczeniach. [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] Zezwala na emitowanie kodu w scenariuszach częściowej relacji zaufania bez wydawania żadnych wymagań dotyczących zabezpieczeń, ponieważ generowanie kodu nie jest z założenia uprzywilejowanej operacji. Oznacza to, że wygenerowany kod nie ma więcej uprawnień niż zestaw, który emituje go. Pozwala to na używanie bibliotek, które emitują kod jako przezroczysty i eliminuje konieczność potwierdzenia <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, co upraszcza zadanie pisania bezpiecznej biblioteki. Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 W poniższej tabeli przedstawiono, które typy i elementy członkowskie są dostępne dla metody dynamicznej skojarzonej z modułem lub z typem w module.  
  
||Skojarzone z modułem|Skojarzone z typem|  
|-|-|-|  
|Bez pomijania sprawdzania widoczności JIT|Publiczne i wewnętrzne składowe publicznych, wewnętrznych i prywatnych typów w module.<br /><br /> Publiczne składowe typów publicznych w dowolnym zestawie.|Wszystkie elementy członkowskie skojarzonego typu. Publiczne i wewnętrzne elementy członkowskie wszystkich innych typów w module.<br /><br /> Publiczne składowe typów publicznych w dowolnym zestawie.|  
|Pomijanie sprawdzania widoczności JIT|Wszystkie elementy członkowskie wszystkich typów w dowolnym zestawie.|Wszystkie elementy członkowskie wszystkich typów w dowolnym zestawie.|  
  
 Metoda dynamiczna, która jest skojarzona z modułem, ma uprawnienia tego modułu. Metoda dynamiczna, która jest skojarzona z typem, ma uprawnienia do modułu zawierającego ten typ.  
  
 Metody dynamiczne i ich parametry nie muszą być nazwane, ale można określić nazwy, które mają być pomocne w debugowaniu. Atrybuty niestandardowe nie są obsługiwane w metodach dynamicznych ani ich parametrach.  
  
 Chociaż metody dynamiczne są `static` metodami`Shared` (metodami w Visual Basic), reguły swobodne dla powiązania [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] delegata wprowadzone w metodzie Zezwalaj, aby można było powiązać metodę dynamiczną z obiektem, tak że działa jak metoda wystąpienia, gdy wywoływana przy użyciu tego wystąpienia delegata. Przykład pokazujący, że jest to przewidziane dla <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> przeciążenia metody.  
  
> [!NOTE]
>  [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]W metodach dynamicznych nie obsługują informacji o symbolach, takich jak nazwy zmiennych lokalnych i mapowanie numerów wierszy. To ograniczenie może zostać usunięte w przyszłej wersji. Podczas programowania można <xref:System.Reflection.Emit.AssemblyBuilder> użyć programu, aby uprościć debugowanie wygenerowanego języka pośredniego firmy Microsoft (MSIL), a następnie przełączyć się na metody <xref:System.Reflection.Emit.ILGenerator> dynamiczne podczas końcowego wdrażania, ponieważ wywołania są takie same w obu przypadkach.  
  
## <a name="verification"></a>Weryfikacja  
 Poniższa lista zawiera podsumowanie warunków, w których metody dynamiczne mogą zawierać kod niemożliwy do zweryfikowania. (Na przykład metoda dynamiczna jest niemożliwy do sprawdzenia, jeśli <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> jej właściwość jest ustawiona `false`na.)  
  
-   Metoda dynamiczna, która jest skojarzona z zestawem o znaczeniu krytycznym, ma również krytyczne znaczenie dla zabezpieczeń i może pominąć weryfikację. Na przykład zestaw bez atrybutów zabezpieczeń, który jest uruchamiany jako aplikacja klasyczna, jest traktowany jako krytyczny dla zabezpieczeń przez środowisko uruchomieniowe. W przypadku kojarzenia metody dynamicznej z zestawem metoda dynamiczna może zawierać kod niemożliwy do zweryfikowania.  
  
-   Jeśli metoda dynamiczna, która zawiera kod niemożliwy do zweryfikowania, jest skojarzona z zestawem z przezroczystością poziomu 1, kompilator just-in-Time (JIT) wprowadza żądanie zabezpieczeń. Żądanie powiedzie się tylko wtedy, gdy metoda dynamiczna jest wykonywana przez w pełni zaufany kod. Zobacz [kod przezroczysty zabezpieczeń, poziom 1](~/docs/framework/misc/security-transparent-code-level-1.md).  
  
-   Jeśli metoda dynamiczna, która zawiera kod niemożliwy do zweryfikowania, jest skojarzona z zestawem, który ma przezroczystość poziomu 2 (na przykład mscorlib. dll), zgłasza wyjątek (wprowadzony przez kompilator JIT), zamiast korzystać z żądania zabezpieczeń. Zobacz [kod przezroczysty zabezpieczeń, poziom 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
-   Anonimowo obsługiwana metoda dynamiczna, która zawiera kod niemożliwy do zweryfikowania zawsze zgłasza wyjątek. Może nigdy nie pominąć weryfikacji, nawet jeśli jest tworzona i wykonywana przez w pełni zaufany kod.  
  
 Wyjątek, który jest generowany dla kodu niemożliwego do sprawdzenia, różni się w zależności od sposobu wywołania metody dynamicznej. Jeśli wywołasz metodę dynamiczną przy użyciu delegata zwróconego z <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metody <xref:System.Security.VerificationException> , jest zgłaszany. W przypadku wywołania metody dynamicznej przy użyciu <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody element <xref:System.Reflection.TargetInvocationException> jest generowany z wewnętrznym <xref:System.Security.VerificationException>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy metodę dynamiczną, która przyjmuje dwa parametry. Przykład emituje prostą treść funkcji, która drukuje pierwszy parametr do konsoli, a w przykładzie używa drugiego parametru jako wartości zwracanej metody. Przykład uzupełnia metodę przez utworzenie delegata, wywołuje delegata z różnymi parametrami i wreszcie wywołuje metodę dynamiczną przy użyciu <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody.  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Przewodnik: Emitowanie kodu w scenariuszach częściowo zaufanych</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy metodę dynamiczną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciąg o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">Obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu. <see cref="T:System.Type" /></param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów określająca typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <summary>Inicjuje anonimowo hostowaną metodę dynamiczną, określając nazwę metody, typ zwracany i typy parametrów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dynamiczna tworzona przez ten konstruktor jest skojarzona z zestawem anonimowym, a nie istniejącym typem lub modułem. Zestaw anonimowy istnieje tylko w celu zapewnienia środowiska piaskownicy dla metod dynamicznych, czyli do izolowania ich od innego kodu. To środowisko umożliwia bezpieczne emitowanie i wykonywanie metody dynamicznej przy użyciu częściowo zaufanego kodu.  
  
 Ten konstruktor określa, że sprawdzanie widoczności just-in-Time (JIT) będzie wymuszane dla języka pośredniego firmy Microsoft (MSIL) metody dynamicznej. Oznacza to, że kod w metodzie dynamicznej ma dostęp do publicznych metod klas publicznych. Wyjątki są generowane, jeśli metoda próbuje uzyskać dostęp do typów lub elementów `private`członkowskich `protected`, które są`Friend` , lub `internal` (w Visual Basic). Aby utworzyć metodę dynamiczną, która ma ograniczoną możliwość pomijania sprawdzania widoczności JIT, użyj <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> konstruktora.  
  
 Gdy tworzona jest anonimowo obsługiwana metoda dynamiczna, zostanie dołączony stos wywołań zestawu emitującego. Gdy wywoływana jest metoda, uprawnienia do emitowanego zestawu są używane zamiast uprawnień rzeczywistego obiektu wywołującego. W ten sposób metoda dynamiczna nie może zostać wykonana na wyższym poziomie uprawnień niż zestaw, który emituje go, nawet jeśli jest przenoszona do i wykonywany przez zestaw o wyższym poziomie zaufania.  
  
 Ten konstruktor określa atrybuty <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> metody i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>i Konwencję <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>wywoływania.  
  
> [!NOTE]
>  Ten konstruktor został wprowadzony w [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub. <see cref="T:System.Void" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" />jest typem, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />wartość.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Przewodnik: Emitowanie kodu w scenariuszach częściowo zaufanych</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciąg o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">Obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu. <see cref="T:System.Type" /></param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów określająca typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="restrictedSkipVisibility"><see langword="true" />Aby pominąć sprawdzanie widoczności JIT dla typów i elementów członkowskich, do których uzyskuje dostęp MSIL metoda dynamiczna, z tym ograniczeniem: poziom zaufania zestawów, które zawierają te typy i elementy członkowskie, muszą być równe lub mniejsze niż poziom zaufania stosu wywołań, który emituje dynamiczne c — Metoda; w przeciwnym razie. <see langword="false" /></param>
        <summary>Inicjuje anonimowo hostowaną metodę dynamiczną, określając nazwę metody, zwracany typ, typy parametrów i czy testy widoczności just-in-Time (JIT) powinny zostać pominięte dla typów i elementów członkowskich, do których uzyskuje się dostęp za pomocą języka pośredniego firmy Microsoft (MSIL) Metoda dynamiczna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dynamiczna tworzona przez ten konstruktor jest skojarzona z zestawem anonimowym, a nie istniejącym typem lub modułem. Zestaw anonimowy istnieje tylko w celu zapewnienia środowiska piaskownicy dla metod dynamicznych, czyli do izolowania ich od innego kodu. To środowisko umożliwia bezpieczne emitowanie i wykonywanie metody dynamicznej przy użyciu częściowo zaufanego kodu.  
  
 Anonimowo hostowane metody dynamiczne nie mają automatycznego dostępu do żadnych typów lub elementów członkowskich, `private`które `protected`są, `internal` lub`Friend` (w Visual Basic). Różni się to od metod dynamicznych, które są skojarzone z istniejącym typem lub modułem, który ma dostęp do ukrytych elementów członkowskich w ich skojarzonym zakresie.  
  
 `true` `private` `protected` `internal`Określ, czymetodadynamicznamauzyskiwaćdostępdotypówlubczłonków,któresą,lub.`restrictedSkipVisibility` Zapewnia to metodzie dynamicznej ograniczony dostęp do tych elementów członkowskich. Oznacza to, że członkowie mogą uzyskać dostęp tylko w przypadku spełnienia następujących warunków:  
  
-   Elementy docelowe należą do zestawu, który ma poziom zaufania równy lub niższy niż stos wywołań, który emituje metodę dynamiczną.  
  
-   Stos wywołań, który emituje metodę dynamiczną, jest <xref:System.Security.Permissions.ReflectionPermission> przyznawany <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> z flagą. Jest to zawsze prawdziwe, gdy kod jest wykonywany z pełnym zaufaniem. W przypadku częściowo zaufanego kodu ma to wartość true tylko wtedy, gdy host jawnie przyznaje uprawnienia.  
  
    > [!IMPORTANT]
    >  Jeśli uprawnienie nie zostało przyznane, wyjątek zabezpieczeń jest zgłaszany, gdy <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> jest wywoływana lub gdy wywoływana jest metoda dynamiczna, nie gdy ten konstruktor jest wywoływany. Do emisji metody dynamicznej nie są wymagane żadne specjalne uprawnienia.  
  
 Na przykład metoda dynamiczna, która jest tworzona przy `restrictedSkipVisibility` użyciu zestawu `true` do, ma dostęp do prywatnego elementu członkowskiego dowolnego zestawu w stosie wywołań, jeśli przydzielono dostęp do elementu członkowskiego w ramach stosu wywołań. Jeśli metoda dynamiczna jest tworzona przy użyciu częściowo zaufanego kodu w stosie wywołań, nie może uzyskać dostępu do prywatnej składowej typu [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] w zestawie, ponieważ takie zestawy są w pełni zaufane.  
  
 Jeśli `restrictedSkipVisibility` jest`false`, sprawdzanie widoczności JIT jest wymuszane. Kod w metodzie dynamicznej ma dostęp do publicznych metod klas publicznych, a wyjątki są generowane, jeśli próbuje uzyskać dostęp do typów lub członków, które `private`są `protected`, lub `internal`.  
  
 Gdy tworzona jest anonimowo obsługiwana metoda dynamiczna, zostanie dołączony stos wywołań zestawu emitującego. Gdy metoda jest wywoływana, są używane uprawnienia wysyłanego stosu wywołań zamiast uprawnień rzeczywistego obiektu wywołującego. W ten sposób metoda dynamiczna nie może zostać wykonana na wyższym poziomie uprawnień niż zestaw, który emituje go, nawet jeśli jest przenoszona do i wykonywany przez zestaw o wyższym poziomie zaufania.  
  
 Ten konstruktor określa atrybuty <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> metody i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>i Konwencję <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>wywoływania.  
  
> [!NOTE]
>  Ten konstruktor został wprowadzony w [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub. <see cref="T:System.Void" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" />jest typem, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />wartość.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Przewodnik: Emitowanie kodu w scenariuszach częściowo zaufanych</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciąg o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">Obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu. <see cref="T:System.Type" /></param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów określająca typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="m"><see cref="T:System.Reflection.Module" /> Reprezentujący moduł, z którym metoda dynamiczna ma być logicznie skojarzona.</param>
        <summary>Tworzy metodę dynamiczną, która jest globalnym względem modułu, określając nazwę metody, typ zwracany, typy parametrów i moduł.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor określa atrybuty <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> metody i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, Konwencję <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>wywoływania i nie pomija sprawdzania widoczności just-in-Time (JIT).  
  
 Metoda dynamiczna utworzona za pomocą tego konstruktora ma dostęp do publicznych `internal` i`Friend` (w Visual Basic) elementów członkowskich wszystkich typów zawartych w module `m`.  
  
> [!NOTE]
>  W celu <xref:System.Security.Permissions.SecurityPermission> zapewnienia zgodności <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> z poprzednimi wersjami Konstruktor wymaga flagi z flagą, jeśli spełnione `m` są następujące warunki: jest modułem innym niż <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> moduł wywołujący, <xref:System.Security.Permissions.ReflectionPermission> a zapotrzebowanie dla z flagą nie powiodło się. Jeśli żądanie <xref:System.Security.Permissions.SecurityPermission> zakończy się pomyślnie, operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , ten element członkowski nie jest już wymagany z flagą. [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] (Zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)). Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy metodę dynamiczną, która przyjmuje dwa parametry. Przykład emituje prostą treść funkcji, która drukuje pierwszy parametr do konsoli, a w przykładzie używa drugiego parametru jako wartości zwracanej metody. Przykład uzupełnia metodę przez utworzenie delegata, wywołuje delegata z różnymi parametrami i wreszcie wywołuje metodę dynamiczną przy użyciu <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> metody.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub. <see cref="T:System.Void" />  
  
—lub— 
 <paramref name="m" />jest modułem, który zapewnia anonimowe hosting dla metod dynamicznych.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="m" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" />jest typem, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />wartość.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metodę dynamiczną z modułem innym niż moduł wywołujący. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciąg o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">Obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu. <see cref="T:System.Type" /></param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów określająca typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="owner">A <see cref="T:System.Type" /> , z którym metoda dynamiczna jest skojarzona logicznie. Metoda dynamiczna ma dostęp do wszystkich elementów członkowskich typu.</param>
        <summary>Tworzy metodę dynamiczną, określając nazwę metody, zwracany typ, typy parametrów i typ, z którym metoda dynamiczna jest skojarzona logicznie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dynamiczna utworzona za pomocą tego konstruktora ma dostęp do wszystkich elementów członkowskich typu `owner`oraz do publicznych i `internal` (`Friend` w Visual Basic) elementów członkowskich wszystkich innych typów w module, który zawiera `owner`.  
  
 Ten konstruktor określa atrybuty <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> metody i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, Konwencję <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>wywoływania i nie pomija sprawdzania widoczności just-in-Time (JIT).  
  
> [!NOTE]
>  W celu <xref:System.Security.Permissions.SecurityPermission> zapewnienia zgodności <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> z poprzednimi wersjami ten Konstruktor wymaga flagi, jeśli oba warunki są `owner` spełnione: jest w module innym niż <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> moduł wywołujący, a żądanie dla <xref:System.Security.Permissions.ReflectionPermission> z Flaga zakończyła się niepowodzeniem. Jeśli żądanie <xref:System.Security.Permissions.SecurityPermission> zakończy się pomyślnie, operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , ten element członkowski nie jest już wymagany z flagą. [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] (Zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)). Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy obiekt <xref:System.Reflection.Emit.DynamicMethod> , który jest logicznie skojarzony z typem. To skojarzenie zapewnia dostęp do prywatnych elementów członkowskich tego typu.  
  
 Przykładowy kod definiuje klasę o nazwie `Example` z polem prywatnym, klasy o nazwie `DerivedFromExample` pochodzącej od pierwszej klasy, typ delegata o nazwie `UseLikeStatic` , który zwraca <xref:System.Int32> i ma parametry typu `Example` i <xref:System.Int32>i typ delegata o nazwie `UseLikeInstance` , który <xref:System.Int32> zwraca i ma jeden parametr typu <xref:System.Int32>.  
  
 Następnie przykładowy kod tworzy <xref:System.Reflection.Emit.DynamicMethod> , który zmienia pole prywatne `Example` wystąpienia i zwraca poprzednią wartość.  
  
> [!NOTE]
>  Ogólnie rzecz biorąc, zmiana wewnętrznych pól klas nie jest dobrym sposobem programowania zorientowanego obiektowo.  
  
 Przykładowy kod tworzy wystąpienie `Example` , a następnie tworzy dwa Delegaty. Pierwszy jest typu `UseLikeStatic`, który ma te same parametry co metoda dynamiczna. Sekunda jest typu `UseLikeInstance`, który nie ma pierwszego parametru (typu `Example`). Ten delegat jest tworzony przy użyciu <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> przeciążenia metody; drugi parametr tego przeciążenia metody jest `Example`wystąpieniem, w tym przypadku wystąpienia właśnie utworzone, które jest powiązane z nowo utworzonym delegatem. Za każdym razem, gdy obiekt delegowany jest wywoływany, metoda dynamiczna `Example`działa w wystąpieniu związanym.  
  
> [!NOTE]
>  Jest to przykład reguł swobodnych dla powiązania delegata wprowadzonych w, [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]a także nowych przeciążeń <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> metody. Aby uzyskać więcej informacji, zobacz <xref:System.Delegate> Klasa.  
  
 Obiekt delegowany jest wywoływany, przekazując w `Example` wystąpieniu, `UseLikeInstance` które jest powiązane z delegatem. `UseLikeStatic` Następnie obiekt delegowany jest wywoływany, aby oba Delegaty działały w tym `Example`samym wystąpieniu. `UseLikeInstance` Zmiany wartości pola wewnętrznego są wyświetlane po każdym wywołaniu. Na `UseLikeInstance` koniec delegat jest powiązany z `DerivedFromExample`wystąpieniem, a wywołania delegatów są powtarzane.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub. <see cref="T:System.Void" />  
  
—lub— 
 <paramref name="owner" />jest interfejsem, tablicą, otwartym typem ogólnym lub parametrem typu ogólnego typu lub metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="owner" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" />is <see langword="null" />lub jest typem, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metodę dynamiczną z typem w module innym niż moduł wywołujący. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciąg o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">Obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu. <see cref="T:System.Type" /></param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów określająca typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="m"><see cref="T:System.Reflection.Module" /> Reprezentujący moduł, z którym metoda dynamiczna ma być logicznie skojarzona.</param>
        <param name="skipVisibility"><see langword="true" />Aby pominąć sprawdzanie widoczności JIT dla typów i elementów członkowskich, do których można uzyskać dostęp za pomocą MSIL metody dynamicznej.</param>
        <summary>Tworzy metodę dynamiczną Global dla modułu, określając nazwę metody, zwracany typ, typy parametrów, moduł i czy testy widoczności just-in-Time (JIT) powinny zostać pominięte dla typów i członków, do których uzyskuje dostęp za pomocą języka pośredniego firmy Microsoft (MSIL). metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor określa atrybuty <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> metody i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>i Konwencję <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>wywoływania.  
  
 Metoda dynamiczna utworzona za pomocą tego konstruktora ma dostęp do publicznych `internal` i`Friend` (w Visual Basic) elementów członkowskich wszystkich typów w zawartym `m`module. Pomijanie sprawdzania widoczności kompilatora JIT umożliwia dynamiczną metodę dostępu do prywatnych i chronionych elementów członkowskich wszystkich innych typów. Jest to przydatne, na przykład podczas pisania kodu do serializacji obiektów.  
  
> [!NOTE]
>  W celu <xref:System.Security.Permissions.SecurityPermission> zapewnienia zgodności <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> z poprzednimi wersjami Konstruktor wymaga flagi z flagą, jeśli spełnione `m` są następujące warunki: jest modułem innym niż <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> moduł wywołujący, <xref:System.Security.Permissions.ReflectionPermission> a zapotrzebowanie dla z flagą nie powiodło się. Jeśli żądanie <xref:System.Security.Permissions.SecurityPermission> zakończy się pomyślnie, operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , ten element członkowski nie jest już wymagany z flagą. [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] (Zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)). Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub. <see cref="T:System.Void" />  
  
—lub— 
 <paramref name="m" />jest modułem, który zapewnia anonimowe hosting dla metod dynamicznych.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="m" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" />jest typem, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />wartość.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metodę dynamiczną z modułem innym niż moduł wywołujący. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciąg o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">Obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu. <see cref="T:System.Type" /></param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów określająca typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="owner">A <see cref="T:System.Type" /> , z którym metoda dynamiczna jest skojarzona logicznie. Metoda dynamiczna ma dostęp do wszystkich elementów członkowskich typu.</param>
        <param name="skipVisibility"><see langword="true" />Aby pominąć sprawdzanie widoczności JIT dla typów i elementów członkowskich, do których można uzyskać dostęp za pomocą MSIL metody dynamicznej; w przeciwnym razie. <see langword="false" /></param>
        <summary>Tworzy metodę dynamiczną, określając nazwę metody, zwracany typ, typy parametrów, typ, z którym metoda dynamiczna jest skojarzona logicznie, i czy testy widoczności just-in-Time (JIT) powinny zostać pominięte dla typów i członków, do których uzyskuje dostęp firma Microsoft język pośredni (MSIL) metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dynamiczna utworzona za pomocą tego konstruktora ma dostęp do wszystkich elementów członkowskich typu `owner`oraz do publicznych i `internal` (`Friend` w Visual Basic) elementów członkowskich wszystkich innych typów w module, który zawiera `owner`. Pomijanie sprawdzania widoczności kompilatora JIT umożliwia dynamiczną metodę dostępu do prywatnych i chronionych elementów członkowskich wszystkich innych typów. Jest to przydatne, na przykład podczas pisania kodu do serializacji obiektów.  
  
 Ten konstruktor określa atrybuty <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> metody i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>i Konwencję <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>wywoływania.  
  
> [!NOTE]
>  W celu <xref:System.Security.Permissions.SecurityPermission> zapewnienia zgodności <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> z poprzednimi wersjami ten Konstruktor wymaga flagi, jeśli oba warunki są `owner` spełnione: jest w module innym niż <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> moduł wywołujący, a żądanie dla <xref:System.Security.Permissions.ReflectionPermission> z Flaga zakończyła się niepowodzeniem. Jeśli żądanie <xref:System.Security.Permissions.SecurityPermission> zakończy się pomyślnie, operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , ten element członkowski nie jest już wymagany z flagą. [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] (Zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)). Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub. <see cref="T:System.Void" />  
  
—lub— 
 <paramref name="owner" />jest interfejsem, tablicą, otwartym typem ogólnym lub parametrem typu ogólnego typu lub metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="owner" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" />is <see langword="null" />lub jest typem, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metodę dynamiczną z typem w module innym niż moduł wywołujący. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciąg o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="attributes">Bitowa kombinacja <see cref="T:System.Reflection.MethodAttributes" /> wartości, która określa atrybuty metody dynamicznej. Jedyna dozwolona kombinacja to <see cref="F:System.Reflection.MethodAttributes.Public" /> i <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Konwencja wywoływania dla metody dynamicznej. Musi być <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">Obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu. <see cref="T:System.Type" /></param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów określająca typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="m"><see cref="T:System.Reflection.Module" /> Reprezentujący moduł, z którym metoda dynamiczna ma być logicznie skojarzona.</param>
        <param name="skipVisibility"><see langword="true" />Aby pominąć sprawdzanie widoczności JIT dla typów i elementów członkowskich, do których można uzyskać dostęp za pomocą MSIL metody dynamicznej; w przeciwnym razie. <see langword="false" /></param>
        <summary>Tworzy metodę dynamiczną Global dla modułu, określając nazwę metody, atrybuty, konwencję wywoływania, zwracany typ, typy parametrów, moduł i czy testy widoczności just-in-Time (JIT) powinny zostać pominięte dla typów i członków, do których uzyskuje dostęp Język pośredni Microsoft (MSIL) metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dynamiczna utworzona za pomocą tego konstruktora ma dostęp do publicznych `internal` i`Friend` (w Visual Basic) członków wszystkich typów publicznych i wewnętrznych zawartych w module `m`.  
  
 Pomijanie sprawdzania widoczności kompilatora JIT pozwala metodzie dynamicznej uzyskiwać dostęp do prywatnych i chronionych elementów członkowskich wszystkich innych typów w module i we wszystkich innych zestawach. Jest to przydatne, na przykład podczas pisania kodu do serializacji obiektów.  
  
> [!NOTE]
>  W celu <xref:System.Security.Permissions.SecurityPermission> zapewnienia zgodności <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> z poprzednimi wersjami Konstruktor wymaga flagi z flagą, jeśli spełnione `m` są następujące warunki: jest modułem innym niż <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> moduł wywołujący, <xref:System.Security.Permissions.ReflectionPermission> a zapotrzebowanie dla z flagą nie powiodło się. Jeśli żądanie <xref:System.Security.Permissions.SecurityPermission> zakończy się pomyślnie, operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , ten element członkowski nie jest już wymagany z flagą. [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] (Zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)). Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub. <see cref="T:System.Void" />  
  
—lub— 
 <paramref name="m" />jest modułem, który zapewnia anonimowe hosting dla metod dynamicznych.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="m" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" />jest kombinacją flag innych niż <see cref="F:System.Reflection.MethodAttributes.Public" /> i. <see cref="F:System.Reflection.MethodAttributes.Static" />  
  
—lub— 
 <paramref name="callingConvention" />nie <see cref="F:System.Reflection.CallingConventions.Standard" />jest.  
  
—lub— 
 <paramref name="returnType" />jest typem, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />wartość.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metodę dynamiczną z modułem innym niż moduł wywołujący. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciąg o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="attributes">Bitowa kombinacja <see cref="T:System.Reflection.MethodAttributes" /> wartości, która określa atrybuty metody dynamicznej. Jedyna dozwolona kombinacja to <see cref="F:System.Reflection.MethodAttributes.Public" /> i <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Konwencja wywoływania dla metody dynamicznej. Musi być <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">Obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu. <see cref="T:System.Type" /></param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiektów określająca typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="owner">A <see cref="T:System.Type" /> , z którym metoda dynamiczna jest skojarzona logicznie. Metoda dynamiczna ma dostęp do wszystkich elementów członkowskich typu.</param>
        <param name="skipVisibility"><see langword="true" />Aby pominąć sprawdzanie widoczności JIT dla typów i elementów członkowskich, do których można uzyskać dostęp za pomocą MSIL metody dynamicznej; w przeciwnym razie. <see langword="false" /></param>
        <summary>Tworzy metodę dynamiczną, określając nazwę metody, atrybuty, konwencję wywoływania, zwracany typ, typy parametrów, typ, z którym metoda dynamiczna jest skojarzona logicznie i czy testy widoczności just-in-Time (JIT) powinny być pomijane dla typów i elementy członkowskie z dostępem do języka pośredniego firmy Microsoft (MSIL) metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dynamiczna jest globalna dla modułu, który zawiera typ `owner`. Ma dostęp do wszystkich elementów członkowskich typu `owner`.  
  
 Metoda dynamiczna utworzona za pomocą tego konstruktora ma dostęp do wszystkich elementów członkowskich typu `owner`oraz do publicznych i `internal` (`Friend` w Visual Basic) członków wszystkich typów zawartych w module, który zawiera `owner`. Pomijanie sprawdzania widoczności kompilatora JIT umożliwia dynamiczną metodę dostępu do prywatnych i chronionych elementów członkowskich wszystkich innych typów. Jest to przydatne, na przykład podczas pisania kodu do serializacji obiektów.  
  
> [!NOTE]
>  W celu <xref:System.Security.Permissions.SecurityPermission> zapewnienia zgodności <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> z poprzednimi wersjami ten Konstruktor wymaga flagi, jeśli oba warunki są `owner` spełnione: jest w module innym niż <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> moduł wywołujący, a żądanie dla <xref:System.Security.Permissions.ReflectionPermission> z Flaga zakończyła się niepowodzeniem. Jeśli żądanie <xref:System.Security.Permissions.SecurityPermission> zakończy się pomyślnie, operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , ten element członkowski nie jest już wymagany z flagą. [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] (Zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)). Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub. <see cref="T:System.Void" />  
  
—lub— 
 <paramref name="owner" />jest interfejsem, tablicą, otwartym typem ogólnym lub parametrem typu ogólnego typu lub metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="owner" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" />jest kombinacją flag innych niż <see cref="F:System.Reflection.MethodAttributes.Public" /> i. <see cref="F:System.Reflection.MethodAttributes.Static" />  
  
—lub— 
 <paramref name="callingConvention" />nie <see cref="F:System.Reflection.CallingConventions.Standard" />jest.  
  
—lub— 
 <paramref name="returnType" />jest typem, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />wartość.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metodę dynamiczną z typem w module innym niż moduł wywołujący. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty określone podczas tworzenia metody dynamicznej.</summary>
        <value>Bitowa kombinacja <see cref="T:System.Reflection.MethodAttributes" /> wartości reprezentujących atrybuty dla metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie atrybuty metody dla metody dynamicznej są zawsze <xref:System.Reflection.MethodAttributes.Public> i. <xref:System.Reflection.MethodAttributes.Static>  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla atrybuty metody metody dynamicznej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera konwencję wywoływania określoną podczas tworzenia metody dynamicznej.</summary>
        <value>Jedna z <see cref="T:System.Reflection.CallingConventions" /> wartości, która wskazuje konwencję wywoływania metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie konwencja wywoływania dla metody dynamicznej jest zawsze <xref:System.Reflection.CallingConventions.Standard>.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla konwencję wywoływania metody dynamicznej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kończy metodę dynamiczną i tworzy delegata, który może służyć do jego wykonywania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata, którego sygnatura pasuje do metody dynamicznej.</param>
        <summary>Kończy metodę dynamiczną i tworzy delegata, który może służyć do jego wykonywania.</summary>
        <returns>Delegat określonego typu, który może służyć do wykonywania metody dynamicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> Wywołanie metody<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> lub metody uzupełnia metodę dynamiczną. Wszelkie dalsze próby zmiany metody dynamicznej, takie jak modyfikowanie definicji parametrów lub emitowanie większej wersji języka pośredniego firmy Microsoft (MSIL), są ignorowane; nie zgłoszono żadnego wyjątku.  
  
 Aby utworzyć treść metody dla metody dynamicznej w przypadku posiadania własnego generatora MSIL, wywołaj metodę, <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> aby <xref:System.Reflection.Emit.DynamicILInfo> uzyskać obiekt. Jeśli nie masz własnego generatora MSIL, wywołaj <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> metodę, aby <xref:System.Reflection.Emit.ILGenerator> uzyskać obiekt, którego można użyć do wygenerowania treści metody.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy metodę dynamiczną, która przyjmuje dwa parametry. Przykład emituje prostą treść funkcji, która drukuje pierwszy parametr do konsoli, a w przykładzie używa drugiego parametru jako wartości zwracanej metody. Przykład uzupełnia metodę przez utworzenie delegata, wywołuje delegata z różnymi parametrami i wreszcie wywołuje metodę dynamiczną przy użyciu <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda dynamiczna nie ma treści metody.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" />ma nieprawidłową liczbę parametrów lub nieprawidłowe typy parametrów.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata, którego sygnatura pasuje do metody dynamicznej, minus pierwszy parametr.</param>
        <param name="target">Obiekt, z którym jest powiązany delegat. Musi być tego samego typu co pierwszy parametr metody dynamicznej.</param>
        <summary>Kończy metodę dynamiczną i tworzy delegata, który może służyć do jego wykonywania, określając typ delegata i obiekt, z którym jest powiązany delegat.</summary>
        <returns>Delegat określonego typu, który może służyć do wykonywania metody dynamicznej z określonym obiektem docelowym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie metody tworzy delegata powiązanego z określonym obiektem. Delegat ten jest określany jako zamknięty w pierwszym argumencie. Chociaż metoda jest statyczna, działa tak, jakby była metodą wystąpienia; wystąpienie jest `target`.  
  
 To Przeciążenie metody musi `target` być tego samego typu co pierwszy parametr metody dynamicznej lub do przypisania do tego typu (na przykład klasy pochodnej).  Sygnatura `delegateType` zawiera wszystkie parametry metody dynamicznej z wyjątkiem pierwszej. Na przykład <xref:System.String>Jeśli metoda dynamiczna ma parametry, <xref:System.Int32>, i <xref:System.Byte>, `delegateType` zawiera parametry <xref:System.Int32> i <xref:System.Byte>; `target` jest typu <xref:System.String>.  
  
 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> Wywołanie metody<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> lub metody uzupełnia metodę dynamiczną. Wszelkie dalsze próby zmiany metody dynamicznej, takie jak modyfikowanie definicji parametrów lub emitowanie większej wersji języka pośredniego firmy Microsoft (MSIL), są ignorowane; nie zgłoszono żadnego wyjątku.  
  
 Aby utworzyć treść metody dla metody dynamicznej w przypadku posiadania własnego generatora MSIL, wywołaj metodę, <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> aby <xref:System.Reflection.Emit.DynamicILInfo> uzyskać obiekt. Jeśli nie masz własnego generatora MSIL, wywołaj <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> metodę, aby <xref:System.Reflection.Emit.ILGenerator> uzyskać obiekt, którego można użyć do wygenerowania treści metody.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy delegata, który wiąże <xref:System.Reflection.Emit.DynamicMethod> z wystąpieniem typu, tak aby metoda działała na tym samym wystąpieniu przy każdym wywołaniu.  
  
 Przykładowy kod definiuje klasę o nazwie `Example` z polem prywatnym, klasy o nazwie `DerivedFromExample` pochodzącej od pierwszej klasy, typ delegata o nazwie `UseLikeStatic` , który zwraca <xref:System.Int32> i ma parametry typu `Example` i <xref:System.Int32>i typ delegata o nazwie `UseLikeInstance` , który <xref:System.Int32> zwraca i ma jeden parametr typu <xref:System.Int32>.  
  
 Następnie przykładowy kod tworzy <xref:System.Reflection.Emit.DynamicMethod> , który zmienia pole prywatne `Example` wystąpienia i zwraca poprzednią wartość.  
  
> [!NOTE]
>  Ogólnie rzecz biorąc, zmiana wewnętrznych pól klas nie jest dobrym sposobem programowania zorientowanego obiektowo.  
  
 Przykładowy kod tworzy wystąpienie `Example` , a następnie tworzy dwa Delegaty. Pierwszy jest typu `UseLikeStatic`, który ma te same parametry co metoda dynamiczna. Sekunda jest typu `UseLikeInstance`, który nie ma pierwszego parametru (typu `Example`). Ten delegat jest tworzony przy użyciu <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> przeciążenia metody; drugi parametr tego przeciążenia metody jest `Example`wystąpieniem, w tym przypadku wystąpienia właśnie utworzone, które jest powiązane z nowo utworzonym delegatem. Za każdym razem, gdy obiekt delegowany jest wywoływany, metoda dynamiczna `Example`działa w wystąpieniu związanym.  
  
> [!NOTE]
>  Jest to przykład reguł swobodnych dla powiązania delegata wprowadzonych w, [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]a także nowych przeciążeń <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> metody. Aby uzyskać więcej informacji, zobacz <xref:System.Delegate> Klasa.  
  
 Obiekt delegowany jest wywoływany, przekazując w `Example` wystąpieniu, `UseLikeInstance` które jest powiązane z delegatem. `UseLikeStatic` Następnie obiekt delegowany jest wywoływany, aby oba Delegaty działały w tym `Example`samym wystąpieniu. `UseLikeInstance` Zmiany wartości pola wewnętrznego są wyświetlane po każdym wywołaniu. Na `UseLikeInstance` koniec delegat jest powiązany z `DerivedFromExample`wystąpieniem, a wywołania delegatów są powtarzane.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda dynamiczna nie ma treści metody.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" />nie jest tym samym typem co pierwszy parametr metody dynamicznej i nie można go przypisać do tego typu.  
  
—lub— 
 <paramref name="delegateType" />ma nieprawidłową liczbę parametrów lub nieprawidłowe typy parametrów.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, który deklaruje metodę, która jest zawsze <see langword="null" /> dla metod dynamicznych.</summary>
        <value>Zawsze <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca `null` dla metod dynamicznych. Nawet wtedy, gdy metoda dynamiczna jest logicznie skojarzona z typem, nie jest deklarowana przez typ.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla typ deklarujący metody dynamicznej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameterName" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja parametru na liście parametrów. Parametry są indeksowane Zaczynając od liczby 1 pierwszego parametru.</param>
        <param name="attributes">Bitowa kombinacja <see cref="T:System.Reflection.ParameterAttributes" /> wartości, która określa atrybuty parametru.</param>
        <param name="parameterName">Nazwa parametru. Nazwa może być ciągiem o zerowej długości.</param>
        <summary>Definiuje parametr metody dynamicznej.</summary>
        <returns>Zawsze zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `position` jest równa 0 <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> , Metoda odwołuje się do wartości zwracanej. Ustawianie informacji o parametrach nie ma wpływu na wartość zwracaną.  
  
 Jeśli metoda dynamiczna została już ukończona, przez wywołanie <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metody lub <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> Metoda nie ma żadnego wpływu. Nie zgłoszono żadnego wyjątku.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zdefiniować informacje o parametrach dla metody dynamicznej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Metoda nie ma parametrów.  
  
—lub— 
 <paramref name="position" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="position" />jest większa niż liczba parametrów metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca podstawową implementację metody.</summary>
        <returns>Podstawowa implementacja metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zawsze zwraca bieżący `DynamicMethod` obiekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca atrybuty niestandardowe zastosowane do metody.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inherit"><see langword="true" />Aby wyszukać łańcuch dziedziczenia metody w celu znalezienia atrybutów niestandardowych; <see langword="false" /> aby sprawdzić tylko bieżącą metodę.</param>
        <summary>Zwraca wszystkie atrybuty niestandardowe zdefiniowane dla metody.</summary>
        <returns>Tablica obiektów reprezentująca wszystkie atrybuty niestandardowe metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla metod dynamicznych, określanie `true` dla `inherit` nie ma wpływu, ponieważ metoda nie jest zadeklarowana w typie.  
  
> [!NOTE]
>  Atrybuty niestandardowe nie są obecnie obsługiwane w metodach dynamicznych. Jedynym zwracanym atrybutem <xref:System.Runtime.CompilerServices.MethodImplAttribute>jest; można łatwo uzyskać flagi implementacji metody <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> za pomocą metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><see cref="T:System.Type" /> Reprezentujący typ atrybutu niestandardowego do zwrócenia.</param>
        <param name="inherit"><see langword="true" />Aby wyszukać łańcuch dziedziczenia metody w celu znalezienia atrybutów niestandardowych; <see langword="false" /> aby sprawdzić tylko bieżącą metodę.</param>
        <summary>Zwraca atrybuty niestandardowe określonego typu, które zostały zastosowane do metody.</summary>
        <returns>Tablica obiektów reprezentująca atrybuty metody typu <paramref name="attributeType" /> lub pochodne od typu. <paramref name="attributeType" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla metod dynamicznych, określanie `true` dla `inherit` nie ma wpływu, ponieważ metoda nie jest zadeklarowana w typie.  
  
> [!NOTE]
>  Atrybuty niestandardowe nie są obecnie obsługiwane w metodach dynamicznych. Jedynym zwracanym atrybutem <xref:System.Runtime.CompilerServices.MethodImplAttribute>jest; można łatwo uzyskać flagi implementacji metody <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> za pomocą metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Reflection.Emit.DynamicILInfo" /> Zwraca obiekt, którego można użyć do wygenerowania treści metody z tokenów metadanych, zakresów i strumieni języka pośredniego firmy Microsoft (MSIL).</summary>
        <returns><see cref="T:System.Reflection.Emit.DynamicILInfo" /> Obiekt, którego można użyć do wygenerowania treści metody z tokenów metadanych, zakresów i strumieni MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicILInfo> Klasa jest dostarczana do obsługi generowania kodu niezarządzanego.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wykonać kod niezarządzany. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca generator MSIL, który może być używany do emitowania treści metody dynamicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca generator języka pośredniego firmy Microsoft (MSIL) dla metody z domyślnym rozmiarem strumienia MSIL wynoszącym 64 bajtów.</summary>
        <returns><see cref="T:System.Reflection.Emit.ILGenerator" /> Obiekt dla metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po ukończeniu metody dynamicznej przez wywołanie <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metody lub <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> jakakolwiek kolejna próba dodania MSIL jest ignorowana. Nie zgłoszono żadnego wyjątku.  
  
> [!NOTE]
>  Istnieją ograniczenia dotyczące niemożliwego do zweryfikowania kodu w metodach dynamicznych, nawet w niektórych scenariuszach z pełnym zaufaniem. Zobacz sekcję "weryfikacja" w artykule uwagi dla <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy metodę dynamiczną, która przyjmuje dwa parametry. Przykład emituje prostą treść funkcji, która drukuje pierwszy parametr do konsoli, a w przykładzie używa drugiego parametru jako wartości zwracanej metody. Przykład uzupełnia metodę przez utworzenie delegata, wywołuje delegata z różnymi parametrami i wreszcie wywołuje metodę dynamiczną przy użyciu <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">Rozmiar strumienia MSIL w bajtach.</param>
        <summary>Zwraca generator języka pośredniego firmy Microsoft (MSIL) dla metody z określonym rozmiarem strumienia MSIL.</summary>
        <returns><see cref="T:System.Reflection.Emit.ILGenerator" /> Obiekt dla metody z określonym rozmiarem strumienia MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po ukończeniu metody dynamicznej przez wywołanie <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metody lub <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> jakakolwiek kolejna próba dodania MSIL jest ignorowana. Nie zgłoszono żadnego wyjątku.  
  
> [!NOTE]
>  Istnieją ograniczenia dotyczące niemożliwego do zweryfikowania kodu w metodach dynamicznych, nawet w niektórych scenariuszach z pełnym zaufaniem. Zobacz sekcję "weryfikacja" w artykule uwagi dla <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje Przeciążenie metody. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca flagi implementacji dla metody.</summary>
        <returns>Bitowa kombinacja <see cref="T:System.Reflection.MethodImplAttributes" /> wartości reprezentujących flagi implementacji dla metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie atrybuty implementacji metody dla metod dynamicznych są zawsze <xref:System.Reflection.MethodImplAttributes.IL> i. <xref:System.Reflection.MethodImplAttributes.NoInlining>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca parametry metody dynamicznej.</summary>
        <returns>Tablica <see cref="T:System.Reflection.ParameterInfo" /> obiektów, która reprezentuje parametry metody dynamicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.ParameterInfo> Obiekty zwracane przez tę metodę są wyłącznie do celów informacyjnych. Użyj metody <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> , aby ustawić lub zmienić charakterystyki parametrów.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla parametry metody dynamicznej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zmienne lokalne w metodzie są inicjowane od zera.</summary>
        <value><see langword="true" />Jeśli zmienne lokalne w metodzie są inicjowane od zera; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest ustawiona na `true`, emitowane języka pośredniego firmy Microsoft (MSIL) obejmuje inicjalizację zmiennych lokalnych. Jeśli jest ustawiona na `false`, zmienne lokalne nie są inicjowane, a wygenerowany kod jest niemożliwy do zweryfikowania.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> Właściwość metody dynamicznej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">Ten parametr jest ignorowany dla metod dynamicznych, ponieważ są statyczne. Określ <see langword="null" />.</param>
        <param name="invokeAttr">Bitowa kombinacja <see cref="T:System.Reflection.BindingFlags" /> wartości.</param>
        <param name="binder">Obiekt, który umożliwia powiązanie, przekształcenie typów argumentów, wywoływanie elementów członkowskich oraz <see cref="T:System.Reflection.MemberInfo" /> pobieranie obiektów poprzez odbicie. <see cref="T:System.Reflection.Binder" /> Jeśli <paramref name="binder" /> jest<see langword="null" />, używany jest domyślny spinacz. Aby uzyskać więcej informacji, <see cref="T:System.Reflection.Binder" />Zobacz.</param>
        <param name="parameters">Lista argumentów. Jest to tablica argumentów o tej samej liczbie, kolejności i typie co parametry metody do wywołania. Jeśli nie ma żadnych parametrów, ten parametr powinien <see langword="null" />być.</param>
        <param name="culture">Wystąpienie <see cref="T:System.Globalization.CultureInfo" /> używane do zarządzania przymusem typów. Jeśli tak <see langword="null" /> <see cref="T:System.Globalization.CultureInfo" /> , jest używany dla bieżącego wątku. Na przykład te informacje są konieczne do prawidłowej konwersji a <see cref="T:System.String" /> , która reprezentuje 1000 <see cref="T:System.Double" /> do wartości, ponieważ 1000 jest reprezentowane inaczej przez różne kultury.</param>
        <summary>Wywołuje metodę dynamiczną przy użyciu określonych parametrów w ramach ograniczeń określonego spinacza z określonymi informacjami o kulturze.</summary>
        <returns>A <see cref="T:System.Object" /> zawierająca wartość zwracaną wywołanej metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oprócz wymienionych wyjątków, kod wywołujący powinien zostać przygotowany do przechwytywania wszelkich wyjątków zgłoszonych przez metodę dynamiczną.  
  
 Wykonywanie metody dynamicznej z delegatem utworzonym przez <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metodę jest wydajniejsze niż wykonywanie <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> przy użyciu metody.  
  
 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> Wywołanie metody<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> lub metody uzupełnia metodę dynamiczną. Wszelkie dalsze próby zmiany metody dynamicznej, takie jak modyfikowanie definicji parametrów lub emitowanie większej wersji języka pośredniego firmy Microsoft (MSIL), są ignorowane; nie zgłoszono żadnego wyjątku.  
  
 Wszystkie metody dynamiczne są statyczne, więc `obj` parametr jest zawsze ignorowany. Aby traktować metodę dynamiczną tak, jakby była metodą wystąpienia, należy użyć <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> przeciążenia, które przyjmuje wystąpienie obiektu.  
  
 Jeśli metoda dynamiczna nie ma parametrów, wartość `parameters` powinna być. `null` W przeciwnym razie liczba, typ i kolejność elementów w tablicy parametrów powinna być taka sama jak liczba, typ i kolejność parametrów metody dynamicznej.  
  
> [!NOTE]
>  To Przeciążenie metody jest wywoływane przez <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> Przeciążenie metody dziedziczone <xref:System.Reflection.MethodBase> z klasy, więc powyższe uwagi dotyczą obu przeciążeń.  
  
 Ta metoda nie wymaga bezpośredniego uprawnienia, ale wywołanie metody dynamicznej może skutkować zapotrzebowań na zabezpieczenia w zależności od metody. Na przykład nie są wykonywane żadne żądania dla anonimowo obsługiwanych metod dynamicznych, które są tworzone z `restrictedSkipVisibility` parametrem ustawionym na `false`. Z drugiej strony, jeśli `restrictedSkipVisibility` utworzysz metodę z ustawionym na `true` tak, aby mógł uzyskać dostęp do ukrytego elementu członkowskiego zestawu docelowego, metoda spowoduje żądanie uprawnień zestawu <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> docelowego Plus <xref:System.Security.Permissions.ReflectionPermission> z flagą.  
  
> [!NOTE]
>  Przed, ta metoda jest wymagana <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> flagą. [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]  
  
   
  
## Examples  
 Poniższy przykład kodu wywołuje metodę dynamiczną z dokładnym wiązaniem przy użyciu kultury US-English. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Konwencja <see cref="F:System.Reflection.CallingConventions.VarArgs" /> wywoływania nie jest obsługiwana.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">Liczba elementów w <paramref name="parameters" /> jest niezgodna z liczbą parametrów w metodzie dynamicznej.</exception>
        <exception cref="T:System.ArgumentException">Typ co najmniej jednego elementu <paramref name="parameters" /> nie jest zgodny z typem odpowiedniego parametru metody dynamicznej.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Metoda dynamiczna jest skojarzona z modułem, nie jest hostowana anonimowo i została skonstruowana przy <see langword="false" />użyciu <paramref name="skipVisibility" /> wartości ustawionej na, ale metoda dynamiczna uzyskuje <see langword="internal" /> dostęp do elementów członkowskich, które nie <see langword="public" /> są lub (<see langword="Friend" /> w Visual Basic).  
  
—lub— 
Metoda dynamiczna jest anonimowo hostowana i została zbudowana <paramref name="skipVisibility" /> z ustawioną na <see langword="false" />, ale uzyskuje dostęp do elementów <see langword="public" />Członkowskich, które nie są.  
  
—lub— 
Metoda dynamiczna zawiera kod niemożliwy do zweryfikowania. Zobacz sekcję "weryfikacja" w artykule uwagi dla <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><see cref="T:System.Type" /> Reprezentujący typ atrybutu niestandardowego do wyszukania.</param>
        <param name="inherit"><see langword="true" />Aby wyszukać łańcuch dziedziczenia metody w celu znalezienia atrybutów niestandardowych; <see langword="false" /> aby sprawdzić tylko bieżącą metodę.</param>
        <summary>Wskazuje, czy określony typ atrybutu niestandardowego jest zdefiniowany.</summary>
        <returns><see langword="true" />Jeśli określony typ atrybutu niestandardowego jest zdefiniowany; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla metod dynamicznych, określanie `true` dla `inherit` nie ma żadnego wpływu. Metody dynamiczne nie mają łańcucha dziedziczenia.  
  
> [!NOTE]
>  Atrybuty niestandardowe nie są obecnie obsługiwane w metodach dynamicznych.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżąca metoda dynamiczna ma krytyczne znaczenie dla zabezpieczeń lub zabezpieczenia-krytycznie, i w związku z tym może wykonywać krytyczne operacje.</summary>
        <value><see langword="true" />Jeśli bieżąca metoda dynamiczna jest krytyczna dla zabezpieczeń lub bezpieczna-krytyczna; <see langword="false" /> jeśli jest przezroczysty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A> i<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> raportują poziom przezroczystości metody dynamicznej zgodnie z definicją w środowisku uruchomieniowym języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacji zabezpieczeń zestawu i jego typów, sprawdzanie bieżącego poziomu zaufania i próba duplikowania reguł środowiska uruchomieniowego.  
  
 Przezroczystość metody dynamicznej zależy od modułu, z którym jest skojarzony. Jeśli metoda dynamiczna jest skojarzona z typem, a nie modułem, jego przezroczystość zależy od modułu, który zawiera typ. Metody dynamiczne nie mają adnotacji zabezpieczeń, dlatego są przypisywane domyślne ustawienia przezroczystości dla skojarzonego modułu.  
  
-   Anonimowo hostowane metody dynamiczne są zawsze niewidoczne, ponieważ moduł udostępniany przez system jest przezroczysty.  
  
-   Przezroczystość metody dynamicznej, która jest skojarzona z zaufanym zestawem (czyli zestaw o silnej nazwie, który jest zainstalowany w globalnej pamięci podręcznej zestawów), jest opisany w poniższej tabeli.  
  
    |Adnotacja zestawu|Przezroczystość poziomu 1|Przezroczystość poziomu 2|  
    |-------------------------|--------------------------|--------------------------|  
    |W pełni przezroczyste|Przezroczyste|Przezroczyste|  
    |W pełni krytyczne|Krytyczny|Krytyczny|  
    |Przezroczystość mieszana|Przezroczyste|Przezroczyste|  
    |Security-agnostic|Bezpieczny-krytyczny|Krytyczny|  
  
     Na przykład, jeśli skojarzesz metodę dynamiczną z typem, który znajduje się w bibliotece Mscorlib. dll, która ma poziom 2 przezroczystość, metoda dynamiczna jest przezroczysta i nie można wykonać kodu krytycznego. Aby uzyskać informacje na temat poziomów przezroczystości, zobacz [kod przezroczysty pod względem zabezpieczeń, poziom 1](~/docs/framework/misc/security-transparent-code-level-1.md) i [kod przezroczysty pod względem zabezpieczeń, poziom 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Kojarzenie metody dynamicznej z modułem w zestawie zaufanych poziomów 1, który jest niezależny od zabezpieczeń, takich jak system. dll, nie zezwala na podniesienie zaufania. Jeśli zestaw przyznany kod, który wywołuje metodę dynamiczną, nie zawiera zestawu przydzielenia system. dll (czyli pełnego zaufania), jest generowany, <xref:System.Security.SecurityException> gdy wywoływana jest metoda dynamiczna.  
  
-   Przezroczystość metody dynamicznej, która jest skojarzona z częściowo zaufanym zestawem, zależy od sposobu ładowania zestawu. Jeśli zestaw jest ładowany z częściowym zaufaniem (na przykład do domeny aplikacji w trybie piaskownicy), środowisko uruchomieniowe ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy i elementy członkowskie, w tym metody dynamiczne, są traktowane jako przezroczyste. Środowisko uruchomieniowe płaci zwrócić uwagę na adnotacje zabezpieczeń tylko wtedy, gdy zestaw częściowego zaufania jest ładowany z pełnym zaufaniem (na przykład do domyślnej domeny aplikacji klasycznej). W takim przypadku środowisko uruchomieniowe przypisuje metodę dynamiczną domyślną przezroczystość dla metod zgodnie z adnotacjami zestawu.  
  
 Aby uzyskać więcej informacji na temat emisji odbicia i przezroczystości, zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Aby uzyskać informacje na temat przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda dynamiczna nie ma treści metody.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Zagadnienia dotyczące zabezpieczeń dla odbicia</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Zmiany zabezpieczeń w .NET Framework w wersji 4,0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Kod przezroczysty pod względem zabezpieczeń, poziom 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Kod o przezroczystym poziomie bezpieczeństwa, poziom 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżąca metoda dynamiczna jest w bezpiecznym stanie krytycznym na bieżącym poziomie zaufania; oznacza to, czy może wykonywać krytyczne operacje i można uzyskać do nich dostęp za pomocą przezroczystego kodu.</summary>
        <value><see langword="true" />Jeśli metoda dynamiczna jest bezpieczna — zabezpieczenia krytyczne na bieżącym poziomie zaufania; <see langword="false" /> jeśli jest to zabezpieczenia krytyczne lub przezroczyste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A> i<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> raportują poziom przezroczystości metody dynamicznej zgodnie z definicją w środowisku uruchomieniowym języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacji zabezpieczeń zestawu i jego typów, sprawdzanie bieżącego poziomu zaufania i próba duplikowania reguł środowiska uruchomieniowego.  
  
 Przezroczystość metody dynamicznej zależy od modułu, z którym jest skojarzony. Jeśli metoda dynamiczna jest skojarzona z typem, a nie modułem, jego przezroczystość zależy od modułu, który zawiera typ. Metody dynamiczne nie mają adnotacji zabezpieczeń, dlatego są przypisywane domyślne ustawienia przezroczystości dla skojarzonego modułu.  
  
-   Anonimowo hostowane metody dynamiczne są zawsze niewidoczne, ponieważ moduł udostępniany przez system jest przezroczysty.  
  
-   Przezroczystość metody dynamicznej, która jest skojarzona z zaufanym zestawem (czyli zestaw o silnej nazwie, który jest zainstalowany w globalnej pamięci podręcznej zestawów), jest opisany w poniższej tabeli.  
  
    |Adnotacja zestawu|Przezroczystość poziomu 1|Przezroczystość poziomu 2|  
    |-------------------------|--------------------------|--------------------------|  
    |W pełni przezroczyste|Przezroczyste|Przezroczyste|  
    |W pełni krytyczne|Krytyczny|Krytyczny|  
    |Przezroczystość mieszana|Przezroczyste|Przezroczyste|  
    |Security-agnostic|Bezpieczny-krytyczny|Krytyczny|  
  
     Na przykład, jeśli skojarzesz metodę dynamiczną z typem, który znajduje się w bibliotece Mscorlib. dll, która ma poziom 2 przezroczystość, metoda dynamiczna jest przezroczysta i nie można wykonać kodu krytycznego. Aby uzyskać informacje na temat poziomów przezroczystości, zobacz [kod przezroczysty pod względem zabezpieczeń, poziom 1](~/docs/framework/misc/security-transparent-code-level-1.md) i [kod przezroczysty pod względem zabezpieczeń, poziom 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Kojarzenie metody dynamicznej z modułem w zestawie zaufanych poziomów 1, który jest niezależny od zabezpieczeń, takich jak system. dll, nie zezwala na podniesienie zaufania. Jeśli zestaw przyznany kod, który wywołuje metodę dynamiczną, nie zawiera zestawu przydzielenia system. dll (czyli pełnego zaufania), jest generowany, <xref:System.Security.SecurityException> gdy wywoływana jest metoda dynamiczna.  
  
-   Przezroczystość metody dynamicznej, która jest skojarzona z częściowo zaufanym zestawem, zależy od sposobu ładowania zestawu. Jeśli zestaw jest ładowany z częściowym zaufaniem (na przykład do domeny aplikacji w trybie piaskownicy), środowisko uruchomieniowe ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy i elementy członkowskie, w tym metody dynamiczne, są traktowane jako przezroczyste. Środowisko uruchomieniowe płaci zwrócić uwagę na adnotacje zabezpieczeń tylko wtedy, gdy zestaw częściowego zaufania jest ładowany z pełnym zaufaniem (na przykład do domyślnej domeny aplikacji klasycznej). W takim przypadku środowisko uruchomieniowe przypisuje metodę dynamiczną domyślną przezroczystość dla metod zgodnie z adnotacjami zestawu.  
  
 Aby uzyskać więcej informacji na temat emisji odbicia i przezroczystości, zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Aby uzyskać informacje na temat przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda dynamiczna nie ma treści metody.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Zagadnienia dotyczące zabezpieczeń dla odbicia</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Zmiany zabezpieczeń w .NET Framework w wersji 4,0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Kod przezroczysty pod względem zabezpieczeń, poziom 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Kod o przezroczystym poziomie bezpieczeństwa, poziom 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżąca metoda dynamiczna jest przezroczysta na bieżącym poziomie zaufania, w związku z czym nie można wykonać operacji krytycznych.</summary>
        <value><see langword="true" />Jeśli metoda dynamiczna jest przezroczysta pod względem zabezpieczeń na bieżącym poziomie zaufania; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A> i<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> raportują poziom przezroczystości metody dynamicznej zgodnie z definicją w środowisku uruchomieniowym języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacji zabezpieczeń zestawu i jego typów, sprawdzanie bieżącego poziomu zaufania i próba duplikowania reguł środowiska uruchomieniowego.  
  
 Przezroczystość metody dynamicznej zależy od modułu, z którym jest skojarzony. Jeśli metoda dynamiczna jest skojarzona z typem, a nie modułem, jego przezroczystość zależy od modułu, który zawiera typ. Metody dynamiczne nie mają adnotacji zabezpieczeń, dlatego są przypisywane domyślne ustawienia przezroczystości dla skojarzonego modułu.  
  
-   Anonimowo hostowane metody dynamiczne są zawsze niewidoczne, ponieważ moduł udostępniany przez system jest przezroczysty.  
  
-   Przezroczystość metody dynamicznej, która jest skojarzona z zaufanym zestawem (czyli zestaw o silnej nazwie, który jest zainstalowany w globalnej pamięci podręcznej zestawów), jest opisany w poniższej tabeli.  
  
    |Adnotacja zestawu|Przezroczystość poziomu 1|Przezroczystość poziomu 2|  
    |-------------------------|--------------------------|--------------------------|  
    |W pełni przezroczyste|Przezroczyste|Przezroczyste|  
    |W pełni krytyczne|Krytyczny|Krytyczny|  
    |Przezroczystość mieszana|Przezroczyste|Przezroczyste|  
    |Security-agnostic|Bezpieczny-krytyczny|Krytyczny|  
  
     Na przykład, jeśli skojarzesz metodę dynamiczną z typem, który znajduje się w bibliotece Mscorlib. dll, która ma poziom 2 przezroczystość, metoda dynamiczna jest przezroczysta i nie można wykonać kodu krytycznego. Aby uzyskać informacje na temat poziomów przezroczystości, zobacz [kod przezroczysty pod względem zabezpieczeń, poziom 1](~/docs/framework/misc/security-transparent-code-level-1.md) i [kod przezroczysty pod względem zabezpieczeń, poziom 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Kojarzenie metody dynamicznej z modułem w zestawie zaufanych poziomów 1, który jest niezależny od zabezpieczeń, takich jak system. dll, nie zezwala na podniesienie zaufania. Jeśli zestaw przyznany kod, który wywołuje metodę dynamiczną, nie zawiera zestawu przydzielenia system. dll (czyli pełnego zaufania), jest generowany, <xref:System.Security.SecurityException> gdy wywoływana jest metoda dynamiczna.  
  
-   Przezroczystość metody dynamicznej, która jest skojarzona z częściowo zaufanym zestawem, zależy od sposobu ładowania zestawu. Jeśli zestaw jest ładowany z częściowym zaufaniem (na przykład do domeny aplikacji w trybie piaskownicy), środowisko uruchomieniowe ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy i elementy członkowskie, w tym metody dynamiczne, są traktowane jako przezroczyste. Środowisko uruchomieniowe płaci zwrócić uwagę na adnotacje zabezpieczeń tylko wtedy, gdy zestaw częściowego zaufania jest ładowany z pełnym zaufaniem (na przykład do domyślnej domeny aplikacji klasycznej). W takim przypadku środowisko uruchomieniowe przypisuje metodę dynamiczną domyślną przezroczystość dla metod zgodnie z adnotacjami zestawu.  
  
 Aby uzyskać więcej informacji na temat emisji odbicia i przezroczystości, zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Aby uzyskać informacje na temat przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda dynamiczna nie ma treści metody.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Zagadnienia dotyczące zabezpieczeń dla odbicia</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Zmiany zabezpieczeń w .NET Framework w wersji 4,0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Kod przezroczysty pod względem zabezpieczeń, poziom 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Kod o przezroczystym poziomie bezpieczeństwa, poziom 2</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Nieobsługiwane w metodach dynamicznych.</summary>
        <value>Nieobsługiwane w metodach dynamicznych.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Niedozwolone dla metod dynamicznych.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł, z którym metoda dynamiczna jest skojarzona logicznie.</summary>
        <value><see cref="T:System.Reflection.Module" /> Z którym jest skojarzona bieżąca metoda dynamiczna.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli moduł został określony podczas tworzenia metody dynamicznej, ta właściwość zwraca ten moduł. Jeśli typ został określony jako właściciel podczas tworzenia metody dynamicznej, ta właściwość zwraca moduł, który zawiera ten typ.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla <xref:System.Reflection.Emit.DynamicMethod.Module%2A> Właściwość metody dynamicznej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę metody dynamicznej.</summary>
        <value>Prosta nazwa metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nazwy metod dynamicznych nie są konieczne.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla nazwę metody dynamicznej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klasę, która została użyta w odbiciu w celu uzyskania metody.</summary>
        <value>Zawsze <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca `null` dla metod dynamicznych.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla typ odbicia metody dynamicznej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera parametr Return metody dynamicznej.</summary>
        <value>Zawsze <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca `null` dla metod dynamicznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ wartości zwracanej dla metody dynamicznej.</summary>
        <value><see cref="T:System.Type" /> Reprezentujący typ wartości zwracanej przez bieżącą metodę; <see cref="T:System.Void" /> Jeśli metoda nie ma zwracanego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `null` została określona dla typu zwracanego podczas tworzenia metody dynamicznej, ta właściwość zwraca <xref:System.Void?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla zwracany typ metody dynamicznej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty niestandardowe typu zwracanego dla metody dynamicznej.</summary>
        <value><see cref="T:System.Reflection.ICustomAttributeProvider" /> Reprezentujący atrybuty niestandardowe zwracanego typu dla metody dynamicznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybuty niestandardowe nie są obsługiwane w zwracanym typie metody dynamicznej, dlatego tablica atrybutów niestandardowych zwracanych przez <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A> metodę jest zawsze pusta.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak wyświetlić niestandardowe atrybuty typu zwracanego metody dynamicznej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca sygnaturę metody reprezentowanej jako ciąg.</summary>
        <returns>Ciąg reprezentujący sygnaturę metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sygnatura zawiera tylko typy i nazwę metody, jeśli istnieje. Nazwy parametrów nie są uwzględniane.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla <xref:System.Reflection.Emit.DynamicMethod.ToString%2A> metodę metody dynamicznej. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

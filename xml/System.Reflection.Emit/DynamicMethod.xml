<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata><Meta Name="ms.openlocfilehash" Value="250bfb72c231153f30ed56f6c0b50068bd66f828" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58462024" /></Metadata><TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje i reprezentuje metodę dynamiczną, która zostanie skompilowany, wykonywane i odrzucone. Odrzucono metody są dostępne do wyrzucania elementów bezużytecznych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Reflection.Emit.DynamicMethod> klasy do generowania i wykonać metodę w czasie wykonywania, bez konieczności Generowanie zestawu dynamicznego i typu dynamicznego, które zawierają metody. Kod wykonywalny utworzony przez kompilator just-in-time (JIT) są odzyskiwane podczas <xref:System.Reflection.Emit.DynamicMethod> obiektu są odzyskiwane. Metody dynamiczne są najbardziej efektywny sposób, aby wygenerować i wykonać niewielką ilość kodu.  
  
 Anonimowo hostowane metody dynamiczne, lub może być logicznie powiązanych z modułu lub typu.  
  
-   Jeśli anonimowo jest obsługiwana metoda dynamiczna, znajduje się w zestawie dostarczane przez system i dlatego jest odizolowane od innego kodu. Domyślnie go nie ma dostępu do żadnych danych bez publicznego. Anonimowo obsługiwana metoda dynamiczna może ograniczone zdolności do pominięcia widoczności kompilator JIT, jeśli ma udzielonego <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagi. Poziom zaufania zestawu, którego niepubliczne składowe są dostępne przez metodę dynamiczną, musi być równy lub być podzbiorem wartości, stos wywołań, który emitowane metody dynamicznej poziom zaufania. Aby uzyskać więcej informacji na temat anonimowo obsługiwane metody dynamiczne, zobacz [instruktażu: Emitowanie kodu w scenariuszach częściowej relacji zaufania](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md).  
  
-   Jeśli metoda dynamiczna jest skojarzony z modułem, który określisz, metoda dynamiczna jest skutecznie globalne do tego modułu. Będzie miał dostęp do wszystkich typów w module i wszystkie `internal` (`Friend` w języku Visual Basic) elementy członkowskie typu. Możesz skojarzyć dynamiczny metody z każdego modułu, niezależnie od tego, czy utworzony moduł, pod warunkiem, że popyt na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> flagi mogą być spełnione przez stos wywołań, który zawiera kod. Jeśli <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flagi są objęte Przydziel, pominąć kontrole widoczność kompilator JIT i dostęp do prywatnych danych wszystkich typów zadeklarowane w module lub w inny moduł, w dowolnym zestawie metodę dynamiczną.  
  
    > [!NOTE]
    >  Po określeniu modułu, z którym jest skojarzona metoda dynamiczna, ten moduł nie może być w zestawie dostarczane przez system, który jest używany do hostowania anonimowe.  
  
-   Jeśli metoda dynamiczna jest skojarzony z typem, który określisz, ma dostęp do wszystkich elementów członkowskich tego typu, niezależnie od tego poziomu dostępu. Ponadto możesz pominąć kontrole widoczność JIT. Daje to dynamicznej metody dostępu do prywatnych danych innych typów zadeklarowane w tym samym module lub w inny moduł, w dowolnym zestawie. Możesz skojarzyć metodę dynamiczną z dowolnego typu, ale Twój kod musi mieć przyznane <xref:System.Security.Permissions.ReflectionPermission> zarówno <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> i <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> flag.  
  
 W poniższej tabeli przedstawiono typy i elementy członkowskie są dostępne anonimowo obsługiwane metody dynamiczne, z lub bez kontroli widoczności JIT, w zależności od tego, czy <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> otrzymuje flagi.  
  
||Bez <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|za pomocą <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|Bez pominięcia testów widoczności JIT|Publiczne elementy członkowskie typów publicznych w każdym zestawie.|Publiczne elementy członkowskie typów publicznych w każdym zestawie.|  
|Pomijanie JIT sprawdzenie widoczność, bez ograniczeń|Publiczne elementy członkowskie typów publicznych w każdym zestawie.|Wszyscy członkowie wszystkich typów, tylko w zestawach, w których poziomy zaufania są równe lub mniejsze niż poziom zaufania zestawu, który jest emitowane metody dynamicznej.|  
  
> [!NOTE]
>  Przed [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], wymagany kod emisji <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. To uprawnienie jest zawarte domyślnie w FullTrust i LocalIntranet nazwane zestawy uprawnień, ale nie uprawnień internetowych zbioru. Dlatego we wcześniejszych wersjach programu [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] biblioteki mogą być używane z Internetu uprawnień, tylko wtedy, gdy ma ona <xref:System.Security.SecurityCriticalAttribute> atrybutu i wykonuje również <xref:System.Security.PermissionSet.Assert%2A> dla <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>. Takie biblioteki wymagają weryfikacji zabezpieczeń zachowania ostrożność, ponieważ kodowanie błędów może spowodować luki w zabezpieczeniach. [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] Pozwala kod był emitowany w scenariuszach częściowej relacji zaufania, bez wydawania żadnych wymogów bezpieczeństwa, ponieważ generowanie kodu nie jest z natury uprzywilejowaną operacją. Oznacza to, że wygenerowany kod nie ma więcej uprawnień niż zestaw, który emituje go. Dzięki temu biblioteki, które emitują kod, aby być przezroczyste dla zabezpieczeń i usuwa potrzebę zapewnienia <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, która upraszcza proces bezpieczna biblioteka. Aby użyć tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 W poniższej tabeli przedstawiono typy i elementy członkowskie są dostępne dla metodę dynamiczną, która jest skojarzona z modułu lub typu w module.  
  
||Skojarzone z modułem|Skojarzone z typem|  
|-|-|-|  
|Bez pominięcia testów widoczności JIT|Public i internal składowych typu publiczne, wewnętrzne i prywatne w module.<br /><br /> Publiczne elementy członkowskie typów publicznych w każdym zestawie.|Wszyscy członkowie skojarzonego typu. Publicznych i wewnętrznych członków innych typów w module.<br /><br /> Publiczne elementy członkowskie typów publicznych w każdym zestawie.|  
|Pomijanie kontrole widoczność JIT|Wszyscy członkowie wszystkich typów w każdym zestawie.|Wszyscy członkowie wszystkich typów w każdym zestawie.|  
  
 Metoda dynamiczna, która jest skojarzona z modułem uprawnieniami tego modułu. Metoda dynamiczna, która jest skojarzona z typem uprawnieniami moduł zawierający tego typu.  
  
 Dynamicznych metod i ich parametrów nie muszą mieć nazwy, ale można określić nazwy, aby pomóc w debugowaniu. Atrybutów niestandardowych, które nie są obsługiwane w przypadku dynamicznych metod lub ich parametrów.  
  
 Mimo że metody dynamiczne są `static` metody (`Shared` metod w języku Visual Basic), luźniejsze reguły dla powiązaniach delegatów wprowadzona w [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] dającą metodę dynamiczną, która ma być powiązana z obiektem, zachowuje się jak metoda wystąpienia podczas wywołuje się za pomocą tego wystąpienia delegata. Przykład demonstrujący, to jest przewidziane <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> przeciążenie metody.  
  
> [!NOTE]
>  W [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], nie obsługują metod dynamicznych, informacji o symbolach, który jest, nazwy zmiennych lokalnych i mapowanie numer wiersza. To ograniczenie może zostać usunięta w przyszłych wersjach. Możesz użyć <xref:System.Reflection.Emit.AssemblyBuilder> podczas programowania do upraszczaj debugowanie wygenerowanego języka Microsoft intermediate language (MSIL), a następnie przełączyć się do metody dynamiczne podczas wdrażania końcowego, ponieważ <xref:System.Reflection.Emit.ILGenerator> wywołania są takie same w obu przypadkach.  
  
## <a name="verification"></a>Weryfikacja  
 Poniższa lista zawiera podsumowanie warunków, w jakich metody dynamiczne mogą zawierać nieweryfikowalny kod. (Na przykład nie jest metoda dynamiczna jeśli jego <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> właściwość jest ustawiona na `false`.)  
  
-   Metoda dynamiczna, która jest skojarzona z zestawem zabezpieczenia krytyczny jest również zabezpieczenia krytyczny i można pominąć weryfikację. Na przykład zestaw bez atrybuty zabezpieczeń, która działa jako aplikacja jest traktowany jako krytyczne dla bezpieczeństwa w czasie wykonywania. Jeśli możesz skojarzyć metodę dynamiczną z zestawem, metoda dynamiczna może zawierać zweryfikowanie kodu.  
  
-   Jeśli metoda dynamiczna, która zawiera nieweryfikowalny kod jest skojarzony z zestawu, który ma poziom 1 przejrzystości, kompilator just-in-time (JIT) wprowadza żądania zabezpieczeń. Żądanie zakończy się powodzeniem, tylko wtedy, gdy metoda dynamiczna jest wykonywana przez całkowicie zaufanego kodu. Zobacz [kod o przezroczystym poziomie bezpieczeństwa, poziom 1](~/docs/framework/misc/security-transparent-code-level-1.md).  
  
-   Jeśli metoda dynamiczna, która zawiera nieweryfikowalny kod jest skojarzony z zestawu, który ma poziom 2 przezroczystości (mscorlib.dll), zgłasza wyjątek (wprowadzonym przez kompilator JIT) zamiast wywołania żądania zabezpieczeń. Zobacz [kod o przezroczystym poziomie bezpieczeństwa, poziom 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
-   Anonimowo obsługiwana metoda dynamiczna, która zawiera nieweryfikowalny kod zawsze zgłasza wyjątek. Można nigdy nie pominąć weryfikację, nawet jeśli jest tworzona i wykonywane przez całkowicie zaufanego kodu.  
  
 Wyjątek, który jest generowany dla nieweryfikowalny kod zmienia się zależnie od sposobu, w których zostanie wywołana metoda dynamiczna. Jeśli wywołujesz metodę dynamiczną za pomocą delegata zwróciło <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metody <xref:System.Security.VerificationException> zgłaszany. Jeśli wywołujesz metodę dynamiczną za pomocą <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody <xref:System.Reflection.TargetInvocationException> jest generowany przy użyciu wewnętrznego <xref:System.Security.VerificationException>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy metodę dynamiczną, która przyjmuje dwa parametry. Przykład emituje treści prostej funkcji, który wyświetla pierwszy parametr do konsoli, a w przykładzie użyto drugi parametr jako wartość zwracaną metody. Przykład stanowi zakończenie metody dotyczy tworzenia delegata, wywołuje delegata z innymi parametrami i na koniec wywołuje metodę dynamiczną, przy użyciu <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody.  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Przewodnik: Emitowanie kodu w scenariuszach częściowej relacji zaufania</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy metodę dynamiczną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiekty, określając typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <summary>Inicjuje anonimowo obsługiwana metoda dynamiczna, określając nazwę metody, typ zwracany i typy parametrów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dynamiczna, która jest tworzona przez ten konstruktor jest skojarzony z anonimowych zestawu, zamiast istniejącego typu lub modułu. Anonimowy zestaw istnieje tylko w celu udostępnienia w środowisku piaskownicy dla metody dynamiczne, to znaczy, odizolowane od innego kodu. Środowisko to sprawia, że bezpieczne dynamicznej metody, która ma być emitowane i wykonywane przez częściowo zaufany kod.  
  
 Ten konstruktor Określa, czy just-in-time (JIT) sprawdzenie widoczność zostaną wymuszone dla języka Microsoft intermediate language (MSIL) metody dynamicznej. Oznacza to, że kod w metodzie dynamiczna ma dostęp do metod publicznych klas publicznych. Są zgłaszane wyjątki, jeśli metoda próbuje uzyskać dostęp do typów lub elementów członkowskich, które są `private`, `protected`, lub `internal` (`Friend` w języku Visual Basic). Aby utworzyć metodę dynamiczną, która ma ograniczone możliwości pominięcia testów widoczności JIT, należy użyć <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> konstruktora.  
  
 Gdy jest konstruowany anonimowo obsługiwana metoda dynamiczna, stos wywołań, emitującymi zgromadzenie jest dołączony. Gdy metoda jest wywoływana, uprawnieniami emitującymi zgromadzenie są używane zamiast uprawnień obiektu wywołującego rzeczywiste. Dlatego metoda dynamiczna nie można wykonać na wyższym poziomie uprawnień niż zestaw, do którego została wyemitowana, nawet jeśli jest przekazywany do i wykonywane przez zestaw, który ma wyższego poziomu zaufania.  
  
 Ten konstruktor określa atrybuty metody <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>i konwencji wywoływania <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Ten konstruktor została wprowadzona w systemie [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Przewodnik: Emitowanie kodu w scenariuszach częściowej relacji zaufania</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiekty, określając typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="restrictedSkipVisibility"><see langword="true" /> Aby pominąć JIT widoczność kontroli typów i elementów członkowskich uzyskiwał dostęp do MSIL metody dynamiczne, z tym ograniczeniem: poziom zaufania zestawów, które zawierają te typy i elementy członkowskie muszą być równe lub mniejsze niż poziom zaufania stosu wywołań, który emituje dynamiczne Metoda c; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje anonimowo obsługiwana metoda dynamiczna, określając nazwę metody, zwracany typ, typy parametrów i tego, czy ma być pomijana just-in-time (JIT) widoczności dla typów i elementów członkowskich uzyskują języka Microsoft intermediate language (MSIL) z Metoda dynamiczna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dynamiczna, która jest tworzona przez ten konstruktor jest skojarzony z anonimowych zestawu, zamiast istniejącego typu lub modułu. Anonimowy zestaw istnieje tylko w celu udostępnienia w środowisku piaskownicy dla metody dynamiczne, to znaczy, odizolowane od innego kodu. Środowisko to sprawia, że bezpieczne dynamicznej metody, która ma być emitowane i wykonywane przez częściowo zaufany kod.  
  
 Anonimowo obsługiwane metody dynamiczne bez automatycznego dostępu do żadnych typów ani elementów członkowskich, które są `private`, `protected`, lub `internal` (`Friend` w języku Visual Basic). To różni się od metod dynamicznych, które są skojarzone z istniejącego typu lub modułu, które nie mają dostępu do ukrytych członków w ich skojarzone zakresie.  
  
 Określ `true` dla `restrictedSkipVisibility` Jeśli metoda dynamiczna ma dostęp do typów lub elementów członkowskich, które są `private`, `protected`, lub `internal`. Daje to dostęp metodę dynamiczną, ograniczone do tych członków. Oznacza to elementów członkowskich jest możliwy tylko wtedy, gdy są spełnione następujące warunki:  
  
-   Członków docelowych należy do zestawu, który ma poziom zaufania, równa lub mniejsza niż stos wywołań, który emituje metodę dynamiczną.  
  
-   Stos wywołań, który emituje metodę dynamiczną otrzymuje <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagi. Jest to wartość true, zawsze wtedy, gdy kod jest wykonywany z pełnym zaufaniem. Dla częściowo zaufanego kodu jest wartość true tylko wtedy, gdy host powoduje przyznanie uprawnień.  
  
    > [!IMPORTANT]
    >  Jeśli nie przyznano uprawnienia, wyjątek zabezpieczeń jest generowany, gdy <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> nosi nazwę lub gdy zostanie wywołana metoda dynamiczna, nie gdy ten konstruktor jest wywoływana. Żadne specjalne ustawienia nie są wymagane do emitowania metody dynamicznej.  
  
 Na przykład metodę dynamiczną, która jest tworzona przy użyciu `restrictedSkipVisibility` równa `true` można uzyskać dostęp do od prywatnej składowej każdy zespół w stosie wywołań gdy stos wywołań udzielono ograniczonego dostępu elementu członkowskiego. Jeśli metoda dynamiczna jest tworzona przy użyciu częściowo zaufany kod w stosie wywołań, nie można uzyskać dostępu od prywatnej składowej typu w [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] zestawu, ponieważ takie zestawy są w pełni zaufane.  
  
 Jeśli `restrictedSkipVisibility` jest `false`, sprawdzenie widoczność JIT są wymuszane. Kod w metodzie dynamiczna ma dostęp do metod publicznych klas publicznych oraz zgłaszania wyjątków, jeśli próbuje uzyskać dostęp do typów lub elementów członkowskich, które są `private`, `protected`, lub `internal`.  
  
 Gdy jest konstruowany anonimowo obsługiwana metoda dynamiczna, stos wywołań, emitującymi zgromadzenie jest dołączony. Po wywołaniu metody uprawnienia emitowanie stosu wywołań są używane zamiast uprawnień rzeczywistego obiektu wywołującego. Dlatego metoda dynamiczna nie można wykonać na wyższym poziomie uprawnień niż zestaw, do którego została wyemitowana, nawet jeśli jest przekazywany do i wykonywane przez zestaw, który ma wyższego poziomu zaufania.  
  
 Ten konstruktor określa atrybuty metody <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>i konwencji wywoływania <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Ten konstruktor została wprowadzona w systemie [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Przewodnik: Emitowanie kodu w scenariuszach częściowej relacji zaufania</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiekty, określając typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="m">A <see cref="T:System.Reflection.Module" /> reprezentujący modułu, z którym ma być logicznie powiązanych metodę dynamiczną.</param>
        <summary>Tworzy metodę dynamiczną, która jest globalna do modułu, określając nazwę metody, zwracany typ, typy parametrów i moduł.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor określa atrybuty metody <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, Konwencja wywoływania <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>i nie powoduje pominięcia testów widoczności usługi just-in-time (JIT).  
  
 Metoda dynamiczna utworzonych za pomocą tego konstruktora ma dostęp do publicznego i `internal` (`Friend` w języku Visual Basic) elementy członkowskie wszystkich typów, które są zawarte w module `m`.  
  
> [!NOTE]
>  W celu zapewnienia zgodności z poprzednimi wersjami zażąda tego konstruktora <xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flagę, jeśli są oba następujące warunki true: `m` jest modułem innych niż modułu wywołującego i popytu na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flagi nie powiodło się. Jeśli zapotrzebowanie na <xref:System.Security.Permissions.SecurityPermission> zakończy się powodzeniem, ta operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy metodę dynamiczną, która przyjmuje dwa parametry. Przykład emituje treści prostej funkcji, który wyświetla pierwszy parametr do konsoli, a w przykładzie użyto drugi parametr jako wartość zwracaną metody. Przykład stanowi zakończenie metody dotyczy tworzenia delegata, wywołuje delegata z innymi parametrami i na koniec wywołuje metodę dynamiczną, przy użyciu <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> metody.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.  
  
—lub— 
 <paramref name="m" /> jest to moduł, który zapewnia hosting anonimowo dla metod dynamicznych.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="m" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metodę dynamiczną z modułu innej niż moduł wywoływania. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiekty, określając typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="owner">A <see cref="T:System.Type" /> za pomocą którego metoda dynamiczna jest logicznie powiązanych. Metoda dynamiczna ma dostęp do wszystkich elementów członkowskich tego typu.</param>
        <summary>Tworzy metodę dynamiczną, określając nazwę metody, zwracany typ, typy parametrów i typ za pomocą którego metoda dynamiczna jest logicznie powiązanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dynamiczna utworzonych za pomocą tego konstruktora ma dostęp do wszystkich elementów członkowskich typu `owner`i na publiczne i `internal` (`Friend` w języku Visual Basic) innych typów w module, który zawiera `owner`.  
  
 Ten konstruktor określa atrybuty metody <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, Konwencja wywoływania <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>i nie powoduje pominięcia testów widoczności usługi just-in-time (JIT).  
  
> [!NOTE]
>  W celu zapewnienia zgodności z poprzednimi wersjami zażąda tego konstruktora <xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flagę, jeśli są oba następujące warunki true: `owner` jest w module innych niż modułu wywołującego i popytu na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flaga nie powiodło się. Jeśli zapotrzebowanie na <xref:System.Security.Permissions.SecurityPermission> zakończy się powodzeniem, ta operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Reflection.Emit.DynamicMethod> logicznie skojarzony z typem. To skojarzenie udostępnia ona prywatnych elementów członkowskich tego typu.  
  
 Przykładowy kod definiuje klasę o nazwie `Example` za pomocą pola prywatnego, klasę o nazwie `DerivedFromxample` pochodząca z pierwszej klasy, typ delegata, o nazwie `UseLikeStatic` zwracającego <xref:System.Int32> i ma następujące parametry typu `Example` i <xref:System.Int32>, a typ delegata, o nazwie `UseLikeInstance` zwracającego <xref:System.Int32> i ma jeden parametr typu <xref:System.Int32>.  
  
 Następnie kod przykładowy tworzy <xref:System.Reflection.Emit.DynamicMethod> zmienia się pole private wystąpienia `Example` i zwraca poprzednią wartość.  
  
> [!NOTE]
>  Ogólnie rzecz biorąc zmiana wewnętrznego pól klasy nie jest dobry obiektowe rozwiązaniem kodowania.  
  
 Przykładowy kod tworzy wystąpienie `Example` , a następnie tworzy dwa delegaty. Pierwszy jest typu `UseLikeStatic`, który ma te same parametry jako metodę dynamiczną. Drugą jest wartość typu `UseLikeInstance`, który nie ma pierwszy parametr (typu `Example`). Ten delegat jest tworzony przy użyciu <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> przeciążenie metody; drugi parametr przeciążenia tej metody jest wystąpieniem `Example`, w tym przypadku wystąpienie został właśnie utworzony, który jest powiązany z nowo utworzonego obiektu delegowanego. Zawsze, gdy ten obiekt delegowany jest wywoływany, metodę dynamiczną działa na komputerze z wystąpieniem powiązanej `Example`.  
  
> [!NOTE]
>  To przykład swobodna reguł powiązaniach delegatów wprowadzona w [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], wraz z nowe przeciążenia <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> metody. Aby uzyskać więcej informacji, zobacz <xref:System.Delegate> klasy.  
  
 `UseLikeStatic` Obiekt delegowany jest wywoływany, przekazując wystąpienie elementu `Example` , jest powiązany z `UseLikeInstance` delegować. A następnie `UseLikeInstance` obiekt delegowany jest wywoływany tak, aby obie delegatów działa na tym samym wystąpieniu programu `Example`. Zmiany w wartościach wewnętrzne pola są wyświetlane po każdym wywołaniu. Na koniec `UseLikeInstance` delegata jest powiązany do wystąpienia `DerivedFromxample`, rok i wywołuje delegata.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.  
  
—lub— 
 <paramref name="owner" /> to interfejs, tablica, to otwarty typ ogólny lub parametr typu ogólnego lub metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="owner" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> jest <see langword="null" />, lub jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metodę dynamiczną z typem w module niż modułu wywołującego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiekty, określając typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="m">A <see cref="T:System.Reflection.Module" /> reprezentujący modułu, z którym ma być logicznie powiązanych metodę dynamiczną.</param>
        <param name="skipVisibility"><see langword="true" /> Aby pominąć JIT widoczność kontroli typów i elementów członkowskich uzyskiwał dostęp do MSIL metody dynamicznej.</param>
        <summary>Tworzy dynamiczny metodę, która jest globalne do modułu, określając nazwę metody zwracają typ, typy parametrów, moduł i czy widoczności just-in-time (JIT) — sprawdza, czy ma być pomijana dla typów i elementów członkowskich uzyskiwał dostęp do języka Microsoft intermediate language (MSIL) metody dynamiczne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor określa atrybuty metody <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>i konwencji wywoływania <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
 Metoda dynamiczna utworzonych za pomocą tego konstruktora ma dostęp do publicznego i `internal` (`Friend` w języku Visual Basic) elementy członkowskie wszystkich typów w module zawarte `m`. Pomijanie JIT kompilatora widoczności umożliwia metodę dynamiczną dostęp do prywatnych i chronionych elementów członkowskich wszystkie pozostałe typy także. Jest to przydatne, na przykład podczas pisania kodu do wykonywania serializacji obiektów.  
  
> [!NOTE]
>  W celu zapewnienia zgodności z poprzednimi wersjami zażąda tego konstruktora <xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flagę, jeśli są oba następujące warunki true: `m` jest modułem innych niż modułu wywołującego i popytu na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flagi nie powiodło się. Jeśli zapotrzebowanie na <xref:System.Security.Permissions.SecurityPermission> zakończy się powodzeniem, ta operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.  
  
—lub— 
 <paramref name="m" /> jest to moduł, który zapewnia hosting anonimowo dla metod dynamicznych.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="m" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metodę dynamiczną z modułu innej niż moduł wywoływania. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiekty, określając typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="owner">A <see cref="T:System.Type" /> za pomocą którego metoda dynamiczna jest logicznie powiązanych. Metoda dynamiczna ma dostęp do wszystkich elementów członkowskich tego typu.</param>
        <param name="skipVisibility"><see langword="true" /> Aby pominąć JIT widoczność kontroli typów i elementów członkowskich uzyskiwał dostęp do MSIL metody dynamicznej; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy metodę dynamiczną, określając nazwę metody, zwracany typ, typy parametrów, typ za pomocą którego metoda dynamiczna jest logicznie powiązanych i tego, czy dla typów i elementów członkowskich uzyskiwał dostęp do firmy Microsoft, w którym ma być pomijana just-in-time (JIT) widoczności Intermediate language (MSIL) metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dynamiczna utworzonych za pomocą tego konstruktora ma dostęp do wszystkich elementów członkowskich typu `owner`i na publiczne i `internal` (`Friend` w języku Visual Basic) innych typów w module, który zawiera `owner`. Pomijanie JIT kompilatora widoczności umożliwia metodę dynamiczną dostęp do prywatnych i chronionych elementów członkowskich wszystkie pozostałe typy także. Jest to przydatne, na przykład podczas pisania kodu do wykonywania serializacji obiektów.  
  
 Ten konstruktor określa atrybuty metody <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> i <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>i konwencji wywoływania <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  W celu zapewnienia zgodności z poprzednimi wersjami zażąda tego konstruktora <xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flagę, jeśli są oba następujące warunki true: `owner` jest w module innych niż modułu wywołującego i popytu na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flaga nie powiodło się. Jeśli zapotrzebowanie na <xref:System.Security.Permissions.SecurityPermission> zakończy się powodzeniem, ta operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.  
  
—lub— 
 <paramref name="owner" /> to interfejs, tablica, to otwarty typ ogólny lub parametr typu ogólnego lub metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="owner" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> jest <see langword="null" />, lub jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metodę dynamiczną z typem w module niż modułu wywołującego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="attributes">Bitowa kombinacja <see cref="T:System.Reflection.MethodAttributes" /> wartości, które określa atrybuty metody dynamicznej. Dozwolona tylko kombinacji <see cref="F:System.Reflection.MethodAttributes.Public" /> i <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Konwencja wywoływania metody dynamicznej. Musi być <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiekty, określając typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="m">A <see cref="T:System.Reflection.Module" /> reprezentujący modułu, z którym ma być logicznie powiązanych metodę dynamiczną.</param>
        <param name="skipVisibility"><see langword="true" /> Aby pominąć JIT widoczność kontroli typów i elementów członkowskich uzyskiwał dostęp do MSIL metody dynamicznej; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy metodę dynamiczną, która jest globalna do modułu, określający nazwę metody, atrybuty, Konwencja wywoływania, zwraca typ, typy parametrów, moduł i czy widoczności just-in-time (JIT) — sprawdza, czy ma być pomijana dla typów i elementów członkowskich uzyskiwał dostęp do Języka Microsoft intermediate language (MSIL) metody dynamicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dynamiczna utworzonych za pomocą tego konstruktora ma dostęp do publicznego i `internal` (`Friend` w języku Visual Basic) elementy członkowskie wszystkich typów publicznych i wewnętrznych zawarte w module `m`.  
  
 Pomijanie JIT kompilatora widoczności umożliwia metoda dynamiczna na dostęp do prywatnych i chronionych członków innych typów w module i wszystkich innych zestawów także. Jest to przydatne, na przykład podczas pisania kodu do wykonywania serializacji obiektów.  
  
> [!NOTE]
>  W celu zapewnienia zgodności z poprzednimi wersjami zażąda tego konstruktora <xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flagę, jeśli są oba następujące warunki true: `m` jest modułem innych niż modułu wywołującego i popytu na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flagi nie powiodło się. Jeśli zapotrzebowanie na <xref:System.Security.Permissions.SecurityPermission> zakończy się powodzeniem, ta operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.  
  
—lub— 
 <paramref name="m" /> jest to moduł, który zapewnia hosting anonimowo dla metod dynamicznych.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="m" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> inne niż to kombinacja flag <see cref="F:System.Reflection.MethodAttributes.Public" /> i <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
—lub— 
 <paramref name="callingConvention" /> nie jest <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
—lub— 
 <paramref name="returnType" /> jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metodę dynamiczną z modułu innej niż moduł wywoływania. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa metody dynamicznej. Może to być ciągiem o zerowej długości, ale nie może być <see langword="null" />.</param>
        <param name="attributes">Bitowa kombinacja <see cref="T:System.Reflection.MethodAttributes" /> wartości, które określa atrybuty metody dynamicznej. Dozwolona tylko kombinacji <see cref="F:System.Reflection.MethodAttributes.Public" /> i <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Konwencja wywoływania metody dynamicznej. Musi być <see cref="F:System.Reflection.CallingConventions.Standard" />.</param>
        <param name="returnType">A <see cref="T:System.Type" /> obiekt, który określa zwracany typ metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma zwracanego typu.</param>
        <param name="parameterTypes">Tablica <see cref="T:System.Type" /> obiekty, określając typy parametrów metody dynamicznej lub <see langword="null" /> Jeśli metoda nie ma parametrów.</param>
        <param name="owner">A <see cref="T:System.Type" /> za pomocą którego metoda dynamiczna jest logicznie powiązanych. Metoda dynamiczna ma dostęp do wszystkich elementów członkowskich tego typu.</param>
        <param name="skipVisibility"><see langword="true" /> Aby pominąć JIT widoczność kontroli typów i elementów członkowskich uzyskiwał dostęp do MSIL metody dynamicznej; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy metodę dynamiczną, określając nazwę metody, atrybuty, wywołanie Konwencji, zwracany typ, typy parametrów typu za pomocą którego metoda dynamiczna jest logicznie powiązanych i tego, czy dla typów, w którym ma być pomijana just-in-time (JIT) widoczności i dostęp do języka Microsoft intermediate language (MSIL) metody dynamiczne elementy członkowskie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dynamiczna jest globalne moduł, który zawiera typ `owner`. Ma dostęp do wszystkich elementów członkowskich typu `owner`.  
  
 Metoda dynamiczna utworzonych za pomocą tego konstruktora ma dostęp do wszystkich elementów członkowskich typu `owner`i publicznego i `internal` (`Friend` w języku Visual Basic) elementy członkowskie wszystkich typów, które są zawarte w module, który zawiera `owner`. Pomijanie JIT kompilatora widoczności umożliwia metodę dynamiczną dostęp do prywatnych i chronionych elementów członkowskich wszystkie pozostałe typy także. Jest to przydatne, na przykład podczas pisania kodu do wykonywania serializacji obiektów.  
  
> [!NOTE]
>  W celu zapewnienia zgodności z poprzednimi wersjami zażąda tego konstruktora <xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flagę, jeśli są oba następujące warunki true: `owner` jest w module innych niż modułu wywołującego i popytu na <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flaga nie powiodło się. Jeśli zapotrzebowanie na <xref:System.Security.Permissions.SecurityPermission> zakończy się powodzeniem, ta operacja jest dozwolona.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ten element członkowski nie wymaga już <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flagi. (Zobacz [problemy związane z zabezpieczeniami, w odbiciu emisji](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Element <paramref name="parameterTypes" /> jest <see langword="null" /> lub <see cref="T:System.Void" />.  
  
—lub— 
 <paramref name="owner" /> to interfejs, tablica, to otwarty typ ogólny lub parametr typu ogólnego lub metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="owner" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> inne niż to kombinacja flag <see cref="F:System.Reflection.MethodAttributes.Public" /> i <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
—lub— 
 <paramref name="callingConvention" /> nie jest <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
—lub— 
 <paramref name="returnType" /> jest to typ, dla którego <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby skojarzyć metodę dynamiczną z typem w module niż modułu wywołującego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />.</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty określone podczas tworzenia metody dynamicznej.</summary>
        <value>Bitowa kombinacja <see cref="T:System.Reflection.MethodAttributes" /> wartości reprezentujących atrybuty dla metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie atrybuty metody dla metody dynamiczne są zawsze <xref:System.Reflection.MethodAttributes.Public> i <xref:System.Reflection.MethodAttributes.Static>.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla atrybuty metody dynamicznej metody. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera konwencja wywołania określona podczas tworzenia metody dynamicznej.</summary>
        <value>Jedną z <see cref="T:System.Reflection.CallingConventions" /> wartości wskazujących konwencja wywołania metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie jest konwencja wywołania metody dynamicznej zawsze <xref:System.Reflection.CallingConventions.Standard>.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla konwencja wywołania metody dynamicznej. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje metodę dynamiczną i tworzy delegata, który może służyć do wykonywania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ obiektu delegowanego, którego podpis jest zgodny z typem metody dynamicznej.</param>
        <summary>Wykonuje metodę dynamiczną i tworzy delegata, który może służyć do wykonywania.</summary>
        <returns>Delegat określonego typu, który może służyć do wykonywania metody dynamicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metody lub <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metoda wykonuje metodę dynamiczną. Dowolne dalsze próby zmienić metodę dynamiczną, takie jak modyfikowanie definicji parametrów lub emitowania więcej języka Microsoft intermediate language (MSIL), są ignorowane; jest zgłaszany żaden wyjątek.  
  
 Aby utworzyć treści metody dynamicznej metody, gdy masz własnego generator MSIL, wywołaj <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> metodę, aby uzyskać <xref:System.Reflection.Emit.DynamicILInfo> obiektu. Jeśli nie masz własnego generator MSIL, wywołaj <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> metodę, aby uzyskać <xref:System.Reflection.Emit.ILGenerator> obiektu, który może służyć do generowania treści metody.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy metodę dynamiczną, która przyjmuje dwa parametry. Przykład emituje treści prostej funkcji, który wyświetla pierwszy parametr do konsoli, a w przykładzie użyto drugi parametr jako wartość zwracaną metody. Przykład stanowi zakończenie metody dotyczy tworzenia delegata, wywołuje delegata z innymi parametrami i na koniec wywołuje metodę dynamiczną, przy użyciu <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda dynamiczna ma bez treści metody.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" /> ma nieprawidłową liczbę typów niewłaściwego parametru lub parametrów.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ obiektu delegowanego, którego podpis jest zgodny z typem metodę dynamiczną, minus pierwszy parametr.</param>
        <param name="target">Obiekt delegowany jest powiązany. Musi być tego samego typu jako pierwszy parametr metody dynamicznej.</param>
        <summary>Wykonuje metodę dynamiczną i tworzy delegata, który może służyć do wykonania, określając typ delegata i obiektu, który delegata jest powiązany z.</summary>
        <returns>Delegat określonego typu, który może służyć do wykonywania metodę dynamiczną z wskazanym obiekcie docelowym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego przeciążenia metody tworzy delegata, powiązany z określonego obiektu. Taki obiekt delegowany jest zamknięte w ciągu pierwszego argumentu. Mimo że metoda jest statyczna, działa tak, jakby był metodą instancji; wystąpienie jest `target`.  
  
 Wymaga tego przeciążenia metody `target` być tego samego typu jako pierwszy parametr metody dynamiczne lub przypisane do tego typu (na przykład klasy pochodnej).  Podpis `delegateType` ma wszystkie parametry dynamiczne metody oprócz pierwszego. Na przykład, jeśli metoda dynamiczna ma następujące parametry <xref:System.String>, <xref:System.Int32>, i <xref:System.Byte>, następnie `delegateType` ma następujące parametry <xref:System.Int32> i <xref:System.Byte>; `target` typu <xref:System.String>.  
  
 Wywoływanie <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metody lub <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metoda wykonuje metodę dynamiczną. Dowolne dalsze próby zmienić metodę dynamiczną, takie jak modyfikowanie definicji parametrów lub emitowania więcej języka Microsoft intermediate language (MSIL), są ignorowane; jest zgłaszany żaden wyjątek.  
  
 Aby utworzyć treści metody dynamicznej metody, gdy masz własnego generator MSIL, wywołaj <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> metodę, aby uzyskać <xref:System.Reflection.Emit.DynamicILInfo> obiektu. Jeśli nie masz własnego generator MSIL, wywołaj <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> metodę, aby uzyskać <xref:System.Reflection.Emit.ILGenerator> obiektu, który może służyć do generowania treści metody.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy delegata, która jest powiązywana <xref:System.Reflection.Emit.DynamicMethod> do wystąpienia typu, tak aby metoda działa na tym samym wystąpieniu każdorazowo jest wywoływana.  
  
 Przykładowy kod definiuje klasę o nazwie `Example` za pomocą pola prywatnego, klasę o nazwie `DerivedFromxample` pochodząca z pierwszej klasy, typ delegata, o nazwie `UseLikeStatic` zwracającego <xref:System.Int32> i ma następujące parametry typu `Example` i <xref:System.Int32>, a typ delegata, o nazwie `UseLikeInstance` zwracającego <xref:System.Int32> i ma jeden parametr typu <xref:System.Int32>.  
  
 Następnie kod przykładowy tworzy <xref:System.Reflection.Emit.DynamicMethod> zmienia się pole private wystąpienia `Example` i zwraca poprzednią wartość.  
  
> [!NOTE]
>  Ogólnie rzecz biorąc zmiana wewnętrznego pól klasy nie jest dobry obiektowe rozwiązaniem kodowania.  
  
 Przykładowy kod tworzy wystąpienie `Example` , a następnie tworzy dwa delegaty. Pierwszy jest typu `UseLikeStatic`, który ma te same parametry jako metodę dynamiczną. Drugą jest wartość typu `UseLikeInstance`, który nie ma pierwszy parametr (typu `Example`). Ten delegat jest tworzony przy użyciu <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> przeciążenie metody; drugi parametr przeciążenia tej metody jest wystąpieniem `Example`, w tym przypadku wystąpienie został właśnie utworzony, który jest powiązany z nowo utworzonego obiektu delegowanego. Zawsze, gdy ten obiekt delegowany jest wywoływany, metodę dynamiczną działa na komputerze z wystąpieniem powiązanej `Example`.  
  
> [!NOTE]
>  To przykład swobodna reguł powiązaniach delegatów wprowadzona w [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], wraz z nowe przeciążenia <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> metody. Aby uzyskać więcej informacji, zobacz <xref:System.Delegate> klasy.  
  
 `UseLikeStatic` Obiekt delegowany jest wywoływany, przekazując wystąpienie elementu `Example` , jest powiązany z `UseLikeInstance` delegować. A następnie `UseLikeInstance` obiekt delegowany jest wywoływany tak, aby obie delegatów działa na tym samym wystąpieniu programu `Example`. Zmiany w wartościach wewnętrzne pola są wyświetlane po każdym wywołaniu. Na koniec `UseLikeInstance` delegata jest powiązany do wystąpienia `DerivedFromxample`, rok i wywołuje delegata.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda dynamiczna ma bez treści metody.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> nie jest ten sam typ jako pierwszy parametr metody dynamicznej, a nie jest możliwy do przypisania do tego typu.  
  
—lub— 
 <paramref name="delegateType" /> ma nieprawidłową liczbę typów niewłaściwego parametru lub parametrów.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, który deklaruje metodę, która jest zawsze <see langword="null" /> dla metod dynamicznych.</summary>
        <value>Zawsze <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość ta zwraca zawsze `null` dla metod dynamicznych. Nawet wtedy, gdy metoda dynamiczna jest logicznie skojarzone z typem, nie jest deklarowana przez typ.  
  
   
  
## Examples  
 Poniższy przykład kodu przedstawia metodę dynamiczną typ deklarujący. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="parameterName" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja parametru na liście parametrów. Parametry są indeksowane począwszy od numeru 1 jako pierwszy parametr.</param>
        <param name="attributes">Bitowa kombinacja <see cref="T:System.Reflection.ParameterAttributes" /> wartości, które określa atrybuty parametru.</param>
        <param name="parameterName">Nazwa parametru. Nazwa może być ciągiem o zerowej długości.</param>
        <summary>Określa parametr metody dynamicznej.</summary>
        <returns>Zawsze zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `position` ma wartość 0, <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> metoda odwołuje się do wartości zwracanej. Ustawianie informacji o parametrach nie ma wpływu na wartość zwracaną.  
  
 Jeśli metoda dynamiczna zostało już zakończone, wywołując <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> lub <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> metoda nie ma wpływu. Jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje jak zdefiniować informacje o parametrach metody dynamicznej. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Metoda nie ma parametrów.  
  
—lub— 
 <paramref name="position" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="position" /> jest większa niż liczba parametrów metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca implementację podstawową metody.</summary>
        <returns>Podstawowa implementacja metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zawsze zwraca bieżącą `DynamicMethod` obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca atrybuty niestandardowe zastosowane do metody.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inherit"><see langword="true" /> Aby przeszukać łańcuch dziedziczenia metody w celu znalezienia atrybutów niestandardowych; <see langword="false" /> do sprawdzania bieżącej metody.</param>
        <summary>Zwraca atrybuty niestandardowe zdefiniowane dla metody.</summary>
        <returns>Tablica obiektów reprezentujących atrybuty niestandardowe metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla metody dynamiczne, określając `true` dla `inherit` nie ma wpływu, ponieważ metoda nie jest zadeklarowana w typie.  
  
> [!NOTE]
>  Atrybutów niestandardowych, które nie są obecnie obsługiwane dla metod dynamicznych. Zwrócony to jedyny atrybut <xref:System.Runtime.CompilerServices.MethodImplAttribute>; zawiera metody flagi implementacji łatwiej przy użyciu <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="attributeType">A <see cref="T:System.Type" /> reprezentujący typ atrybutów niestandardowych do zwrócenia.</param>
        <param name="inherit"><see langword="true" /> Aby przeszukać łańcuch dziedziczenia metody w celu znalezienia atrybutów niestandardowych; <see langword="false" /> do sprawdzania bieżącej metody.</param>
        <summary>Zwraca atrybuty niestandardowe określonego typu, które zostały zastosowane do metody.</summary>
        <returns>Tablica obiektów reprezentująca atrybuty metody, które są typu <paramref name="attributeType" /> lub pochodzić od typu <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla metody dynamiczne, określając `true` dla `inherit` nie ma wpływu, ponieważ metoda nie jest zadeklarowana w typie.  
  
> [!NOTE]
>  Atrybutów niestandardowych, które nie są obecnie obsługiwane dla metod dynamicznych. Zwrócony to jedyny atrybut <xref:System.Runtime.CompilerServices.MethodImplAttribute>; zawiera metody flagi implementacji łatwiej przy użyciu <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu, który może służyć do generowania treści metody z tokeny metadanych, zakresy i strumieni intermediate language (MSIL) firmy Microsoft.</summary>
        <returns>Element <see cref="T:System.Reflection.Emit.DynamicILInfo" /> obiektu, który może służyć do generowania treści metody z tokeny metadanych, zakresy i strumieni MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicILInfo> Klasy jest dostarczany do obsługi generowania kodu niezarządzanego.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wykonywania kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca generator MSIL, który może służyć do wysyłania treści metody dynamicznej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca generator języka intermediate language (MSIL) firmy Microsoft dla danej metody domyślny rozmiar strumienia MSIL 64 bajtów.</summary>
        <returns><see cref="T:System.Reflection.Emit.ILGenerator" /> Obiektu dla metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu metodę dynamiczną, wywołując <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> lub <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody, dowolny dalsze próby dodania MSIL jest ignorowana. Jest zgłaszany żaden wyjątek.  
  
> [!NOTE]
>  Ma ograniczeń dotyczących nieweryfikowalny kod w metody dynamiczne, nawet w niektórych scenariuszach pełnego zaufania. Sekcja "Weryfikacja" w uwagi dla <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy metodę dynamiczną, która przyjmuje dwa parametry. Przykład emituje treści prostej funkcji, który wyświetla pierwszy parametr do konsoli, a w przykładzie użyto drugi parametr jako wartość zwracaną metody. Przykład stanowi zakończenie metody dotyczy tworzenia delegata, wywołuje delegata z innymi parametrami i na koniec wywołuje metodę dynamiczną, przy użyciu <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">Rozmiar strumienia MSIL, w bajtach.</param>
        <summary>Zwraca generator języka intermediate language (MSIL) firmy Microsoft dla metody z określonym rozmiarem strumienia MSIL.</summary>
        <returns><see cref="T:System.Reflection.Emit.ILGenerator" /> Obiektu dla metody, z określonym rozmiarem strumienia MSIL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu metodę dynamiczną, wywołując <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> lub <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody, dowolny dalsze próby dodania MSIL jest ignorowana. Jest zgłaszany żaden wyjątek.  
  
> [!NOTE]
>  Ma ograniczeń dotyczących nieweryfikowalny kod w metody dynamiczne, nawet w niektórych scenariuszach pełnego zaufania. Sekcja "Weryfikacja" w uwagi dla <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje tego przeciążenia metody. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Instrukcje: Definiowanie i wykonywanie metod dynamicznych</related>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość flagi implementacji metody.</summary>
        <returns>Bitowa kombinacja <see cref="T:System.Reflection.MethodImplAttributes" /> wartości flagi implementacji metody reprezentująca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie atrybuty implementacji metody dla metod dynamicznych są zawsze <xref:System.Reflection.MethodImplAttributes.IL> i <xref:System.Reflection.MethodImplAttributes.NoInlining>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca parametry metody dynamicznej.</summary>
        <returns>Tablica <see cref="T:System.Reflection.ParameterInfo" /> obiektami, które reprezentują parametry metody dynamicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.ParameterInfo> Obiektów zwróconych przez tę metodę są wyłącznie w celach informacyjnych. Użyj <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> metodę, aby ustawić lub zmienić właściwości parametrów.  
  
   
  
## Examples  
 Poniższy przykład kodu przedstawia parametry metody dynamicznej. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zmiennych lokalnych w metodzie są inicjowane od zera.</summary>
        <value><see langword="true" /> w przypadku zmiennych lokalnych w metodzie inicjowany z wartością zerową; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest ustawiona `true`, emitowany języka Microsoft intermediate language (MSIL) zawiera inicjowanie zmiennych lokalnych. Jeśli jest równa `false`, zmienne lokalne nie jest zainicjowany i nie jest wygenerowany kod.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> właściwość metodę dynamiczną. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Ten parametr jest ignorowany dla metody dynamiczne, ponieważ są to statyczne. Określ <see langword="null" />.</param>
        <param name="invokeAttr">Bitowa kombinacja <see cref="T:System.Reflection.BindingFlags" /> wartości.</param>
        <param name="binder">A <see cref="T:System.Reflection.Binder" /> typów obiektu, który umożliwia wiązanie, wymuszanie argumentów, wywoływania członków i pobieranie <see cref="T:System.Reflection.MemberInfo" /> obiektów przy użyciu odbicia. Jeśli <paramref name="binder" /> jest <see langword="null" />, jest używany domyślny integrator. Aby uzyskać więcej informacji, zobacz <see cref="T:System.Reflection.Binder" />.</param>
        <param name="parameters">Listy argumentów. Jest to tablica argumentów za pomocą tego samego liczbę, kolejność i typ jako parametry metody do wywołania. Jeśli nie ma żadnych parametrów tego parametru powinna być <see langword="null" />.</param>
        <param name="culture">Wystąpienie <see cref="T:System.Globalization.CultureInfo" /> używane do sterowania wymuszanie typów. Jeśli jest to <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana. Na przykład, te informacje są potrzebne do przekonwertowania poprawnie <see cref="T:System.String" /> reprezentujący 1000- <see cref="T:System.Double" /> wartości, ponieważ 1000 jest reprezentowana w inny sposób przez różnych kultur.</param>
        <summary>Wywołuje metodę dynamiczną, przy użyciu określonych parametrów, w ramach ograniczeń określony obiekt wiążący z informacjami o określonej kultury.</summary>
        <returns>Element <see cref="T:System.Object" /> zawierający wartość zwracaną wywoływanej metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oprócz wymienionych wyjątki kod wywołujący powinna być przygotowana do przechwytywać wyjątki zgłaszane przez metodę dynamiczną.  
  
 Wykonywanie metody dynamiczne z delegatem, utworzone przez <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metody jest bardziej wydajne niż wykonywanie ją za pomocą <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody.  
  
 Wywoływanie <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> metody lub <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> metoda wykonuje metodę dynamiczną. Dowolne dalsze próby zmienić metodę dynamiczną, takie jak modyfikowanie definicji parametrów lub emitowania więcej języka Microsoft intermediate language (MSIL), są ignorowane; jest zgłaszany żaden wyjątek.  
  
 Wszystkie metody dynamiczne są statyczne, więc `obj` parametr zawsze jest ignorowany. Aby traktować metodę dynamiczną, tak jakby był metodą instancji, należy użyć <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> przeciążenia przyjmującego wystąpienia obiektu.  
  
 Jeśli metoda dynamiczna nie ma parametrów, wartość `parameters` powinien być `null`. W przeciwnym razie liczbę, typ i kolejność elementów w tablicy parametrów powinna być taka sama jak liczba, typ i kolejność parametrów metody dynamicznej.  
  
> [!NOTE]
>  Tego przeciążenia metody jest wywoływana przez <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> przeciążenie metody dziedziczone z <xref:System.Reflection.MethodBase> klasy, więc poprzedniego uwagi dotyczą oba przeciążenia.  
  
 Ta metoda nie wymagać uprawnień bezpośrednio, ale wywołania metody dynamicznej może spowodować wymogów bezpieczeństwa, w zależności od metody. Na przykład, nie wymagania wprowadzono anonimowo obsługiwane metody dynamiczne, które zostały utworzone z `restrictedSkipVisibility` parametr `false`. Z drugiej strony, jeśli tworzysz metodę z `restrictedSkipVisibility` równa `true` więc może uzyskać dostęp ukrytego elementu członkowskiego zestawu docelowego, metoda spowoduje, że żądanie uprawnienia oraz zestaw docelowy <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flagi.  
  
> [!NOTE]
>  Przed [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda wymagane <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> flagi.  
  
   
  
## Examples  
 Poniższy kod wywołuje metodę dynamiczną z powiązaniem dokładnie, przy użyciu kultury angielski (US). Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="F:System.Reflection.CallingConventions.VarArgs" /> Konwencji wywoływania nie jest obsługiwana.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">Liczba elementów w <paramref name="parameters" /> jest niezgodna z liczbą parametrów metody dynamicznej.</exception>
        <exception cref="T:System.ArgumentException">Wpisz jeden lub więcej elementów <paramref name="parameters" /> nie jest zgodny z typem odpowiedniego parametru metody dynamicznej.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Metoda dynamiczna jest skojarzony z modułem, nie jest hostowana anonimowo i został skonstruowany przy użyciu <paramref name="skipVisibility" /> równa <see langword="false" />, ale metoda dynamiczna uzyskuje dostęp do elementów członkowskich, które nie są <see langword="public" /> lub <see langword="internal" /> (<see langword="Friend" /> w języku Visual Basic).  
  
—lub— 
Metoda dynamiczna znajduje się anonimowo i został skonstruowany przy użyciu <paramref name="skipVisibility" /> równa <see langword="false" />, ale uzyskuje dostęp do elementów członkowskich, które nie są <see langword="public" />.  
  
—lub— 
Dynamiczna metoda zawiera nieweryfikowalny kod. Sekcja "Weryfikacja" w uwagi dla <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="attributeType">A <see cref="T:System.Type" /> reprezentujący typ atrybutu niestandardowego, aby wyszukać.</param>
        <param name="inherit"><see langword="true" /> Aby przeszukać łańcuch dziedziczenia metody w celu znalezienia atrybutów niestandardowych; <see langword="false" /> do sprawdzania bieżącej metody.</param>
        <summary>Wskazuje, czy zdefiniowano typ określonego atrybutu niestandardowego.</summary>
        <returns><see langword="true" /> Jeśli nie zdefiniowano typu określonego atrybutu niestandardowego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla metody dynamiczne, określając `true` dla `inherit` nie ma wpływu. Metody dynamiczne mają nie łańcuch dziedziczenia.  
  
> [!NOTE]
>  Atrybutów niestandardowych, które nie są obecnie obsługiwane dla metod dynamicznych.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżąca metoda dynamiczna jest krytyczne dla bezpieczeństwa lub zabezpieczenia bezpieczny krytyczny i w związku z tym można wykonywać krytyczne operacje.</summary>
        <value><see langword="true" /> Jeśli bieżąca metoda dynamiczna jest krytyczne dla bezpieczeństwa lub zabezpieczenia bezpieczny krytyczny; <see langword="false" /> , gdy jest za przezroczysty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości metodę dynamiczną, zgodnie z ustaleniami środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania bieżącego poziomu zaufania i próby zduplikowania reguł w środowisku uruchomieniowym.  
  
 Przezroczystość metodę dynamiczną, zależy od moduł, który jest skojarzony. Jeśli metoda dynamiczna jest skojarzony z typem, a nie modułu, jego przezroczystość zależy od moduł, który zawiera typu. Metody dynamiczne ma adnotacje zabezpieczeń, więc są przypisane przezroczystość domyślne skojarzonego modułu.  
  
-   Anonimowo obsługiwane metody dynamiczne są zawsze przezroczyste, ponieważ moduł dostarczane przez system, który je zawiera jest przezroczysty.  
  
-   W poniższej tabeli opisano przezroczystość metodę dynamiczną, która jest skojarzona z zaufanym zestawie (czyli zestawu z silną nazwą zainstalowaną w globalnej pamięci podręcznej).  
  
    |Adnotacja zestawu|Poziom 1 przejrzystości|Poziom 2 przezroczystości|  
    |-------------------------|--------------------------|--------------------------|  
    |W pełni przezroczyste|Przezroczyste|Przezroczyste|  
    |W pełni krytyczne|Krytyczny|Krytyczny|  
    |Mieszane przezroczystości|Przezroczyste|Przezroczyste|  
    |Security-agnostic|Safe-critical|Krytyczny|  
  
     Na przykład jeśli metoda dynamiczna jest skojarzona z typem, który znajduje się w mscorlib.dll, który ma poziom 2 przezroczystości mieszany, metoda dynamiczna jest niewidoczna i nie można wykonać kod krytyczny. Aby uzyskać informacji na temat poziomów przezroczystości, zobacz [kod o przezroczystym poziomie bezpieczeństwa, poziom 1](~/docs/framework/misc/security-transparent-code-level-1.md) i [kod o przezroczystym poziomie bezpieczeństwa, poziom 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Kojarzenie metodę dynamiczną za pomocą modułu w zestawie zaufanego poziomu 1, który jest zabezpieczeń, niezależnie od takich jak System.dll, nie zezwala na podniesienie poziomu zaufania. Jeśli zestaw uprawnień kodu, który wywołuje metodę dynamiczną nie obejmuje zestaw uprawnień System.dll (czyli pełne zaufanie) <xref:System.Security.SecurityException> jest generowany, gdy wywoływana jest metoda dynamiczna.  
  
-   Przezroczystość metodę dynamiczną, która jest skojarzona z częściowo zaufanym zestawem zależy od tego, jak zestaw jest ładowany. Jeśli zestaw jest ładowany z częściowej relacji zaufania (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i jego typów i członków, łącznie z metody dynamiczne są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń, tylko wtedy, gdy zestaw częściowego zaufania jest ładowany z pełnym zaufaniem (na przykład do domyślnej domeny aplikacji klasycznych aplikacji). W takim przypadku środowiska uruchomieniowego przypisuje metodę dynamiczną, domyślną przezroczystość dla metod, zgodnie z adnotacje zestawu.  
  
 Aby uzyskać więcej informacji na temat odbicia emisji i przejrzystości, zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Aby uzyskać informacje o przezroczystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda dynamiczna nie ma treści metody.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Zagadnienia dotyczące zabezpieczeń dla odbicia</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Zmiany zabezpieczeń w programie .NET Framework w wersji 4.0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Kod o przezroczystym poziomie bezpieczeństwa, poziom 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Kod o przezroczystym poziomie bezpieczeństwa, poziom 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżąca metoda dynamiczna to zabezpieczenia bezpieczny krytyczny bieżącym poziomie zaufania. oznacza to, czy go może wykonywać krytyczne operacje i może zostać oceniony przez kod przezroczysty.</summary>
        <value><see langword="true" /> Jeśli metoda dynamiczna jest zabezpieczenia bezpieczny krytyczny bieżącym poziomie zaufania. <see langword="false" /> przypadku krytyczne dla bezpieczeństwa lub przezroczyste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości metodę dynamiczną, zgodnie z ustaleniami środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania bieżącego poziomu zaufania i próby zduplikowania reguł w środowisku uruchomieniowym.  
  
 Przezroczystość metodę dynamiczną, zależy od moduł, który jest skojarzony. Jeśli metoda dynamiczna jest skojarzony z typem, a nie modułu, jego przezroczystość zależy od moduł, który zawiera typu. Metody dynamiczne ma adnotacje zabezpieczeń, więc są przypisane przezroczystość domyślne skojarzonego modułu.  
  
-   Anonimowo obsługiwane metody dynamiczne są zawsze przezroczyste, ponieważ moduł dostarczane przez system, który je zawiera jest przezroczysty.  
  
-   W poniższej tabeli opisano przezroczystość metodę dynamiczną, która jest skojarzona z zaufanym zestawie (czyli zestawu z silną nazwą zainstalowaną w globalnej pamięci podręcznej).  
  
    |Adnotacja zestawu|Poziom 1 przejrzystości|Poziom 2 przezroczystości|  
    |-------------------------|--------------------------|--------------------------|  
    |W pełni przezroczyste|Przezroczyste|Przezroczyste|  
    |W pełni krytyczne|Krytyczny|Krytyczny|  
    |Mieszane przezroczystości|Przezroczyste|Przezroczyste|  
    |Security-agnostic|Safe-critical|Krytyczny|  
  
     Na przykład jeśli metoda dynamiczna jest skojarzona z typem, który znajduje się w mscorlib.dll, który ma poziom 2 przezroczystości mieszany, metoda dynamiczna jest niewidoczna i nie można wykonać kod krytyczny. Aby uzyskać informacji na temat poziomów przezroczystości, zobacz [kod o przezroczystym poziomie bezpieczeństwa, poziom 1](~/docs/framework/misc/security-transparent-code-level-1.md) i [kod o przezroczystym poziomie bezpieczeństwa, poziom 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Kojarzenie metodę dynamiczną za pomocą modułu w zestawie zaufanego poziomu 1, który jest zabezpieczeń, niezależnie od takich jak System.dll, nie zezwala na podniesienie poziomu zaufania. Jeśli zestaw uprawnień kodu, który wywołuje metodę dynamiczną nie obejmuje zestaw uprawnień System.dll (czyli pełne zaufanie) <xref:System.Security.SecurityException> jest generowany, gdy wywoływana jest metoda dynamiczna.  
  
-   Przezroczystość metodę dynamiczną, która jest skojarzona z częściowo zaufanym zestawem zależy od tego, jak zestaw jest ładowany. Jeśli zestaw jest ładowany z częściowej relacji zaufania (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i jego typów i członków, łącznie z metody dynamiczne są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń, tylko wtedy, gdy zestaw częściowego zaufania jest ładowany z pełnym zaufaniem (na przykład do domyślnej domeny aplikacji klasycznych aplikacji). W takim przypadku środowiska uruchomieniowego przypisuje metodę dynamiczną, domyślną przezroczystość dla metod, zgodnie z adnotacje zestawu.  
  
 Aby uzyskać więcej informacji na temat odbicia emisji i przejrzystości, zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Aby uzyskać informacje o przezroczystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda dynamiczna nie ma treści metody.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Zagadnienia dotyczące zabezpieczeń dla odbicia</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Zmiany zabezpieczeń w programie .NET Framework w wersji 4.0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Kod o przezroczystym poziomie bezpieczeństwa, poziom 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Kod o przezroczystym poziomie bezpieczeństwa, poziom 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżąca metoda dynamiczna jest niewidoczne na bieżącym poziomie zaufania, a w związku z tym nie można wykonać operacji krytycznych.</summary>
        <value><see langword="true" /> Jeśli metoda dynamiczna jest przezroczyste dla zabezpieczeń na bieżącym poziomie zaufania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, I <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości metodę dynamiczną, zgodnie z ustaleniami środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania bieżącego poziomu zaufania i próby zduplikowania reguł w środowisku uruchomieniowym.  
  
 Przezroczystość metodę dynamiczną, zależy od moduł, który jest skojarzony. Jeśli metoda dynamiczna jest skojarzony z typem, a nie modułu, jego przezroczystość zależy od moduł, który zawiera typu. Metody dynamiczne ma adnotacje zabezpieczeń, więc są przypisane przezroczystość domyślne skojarzonego modułu.  
  
-   Anonimowo obsługiwane metody dynamiczne są zawsze przezroczyste, ponieważ moduł dostarczane przez system, który je zawiera jest przezroczysty.  
  
-   W poniższej tabeli opisano przezroczystość metodę dynamiczną, która jest skojarzona z zaufanym zestawie (czyli zestawu z silną nazwą zainstalowaną w globalnej pamięci podręcznej).  
  
    |Adnotacja zestawu|Poziom 1 przejrzystości|Poziom 2 przezroczystości|  
    |-------------------------|--------------------------|--------------------------|  
    |W pełni przezroczyste|Przezroczyste|Przezroczyste|  
    |W pełni krytyczne|Krytyczny|Krytyczny|  
    |Mieszane przezroczystości|Przezroczyste|Przezroczyste|  
    |Security-agnostic|Safe-critical|Krytyczny|  
  
     Na przykład jeśli metoda dynamiczna jest skojarzona z typem, który znajduje się w mscorlib.dll, który ma poziom 2 przezroczystości mieszany, metoda dynamiczna jest niewidoczna i nie można wykonać kod krytyczny. Aby uzyskać informacji na temat poziomów przezroczystości, zobacz [kod o przezroczystym poziomie bezpieczeństwa, poziom 1](~/docs/framework/misc/security-transparent-code-level-1.md) i [kod o przezroczystym poziomie bezpieczeństwa, poziom 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Kojarzenie metodę dynamiczną za pomocą modułu w zestawie zaufanego poziomu 1, który jest zabezpieczeń, niezależnie od takich jak System.dll, nie zezwala na podniesienie poziomu zaufania. Jeśli zestaw uprawnień kodu, który wywołuje metodę dynamiczną nie obejmuje zestaw uprawnień System.dll (czyli pełne zaufanie) <xref:System.Security.SecurityException> jest generowany, gdy wywoływana jest metoda dynamiczna.  
  
-   Przezroczystość metodę dynamiczną, która jest skojarzona z częściowo zaufanym zestawem zależy od tego, jak zestaw jest ładowany. Jeśli zestaw jest ładowany z częściowej relacji zaufania (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i jego typów i członków, łącznie z metody dynamiczne są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń, tylko wtedy, gdy zestaw częściowego zaufania jest ładowany z pełnym zaufaniem (na przykład do domyślnej domeny aplikacji klasycznych aplikacji). W takim przypadku środowiska uruchomieniowego przypisuje metodę dynamiczną, domyślną przezroczystość dla metod, zgodnie z adnotacje zestawu.  
  
 Aby uzyskać więcej informacji na temat odbicia emisji i przejrzystości, zobacz [problemy z zabezpieczeniami w emisji odbicia](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Aby uzyskać informacje o przezroczystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Metoda dynamiczna nie ma treści metody.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Problemy związane z zabezpieczeniami w emisji odbicia</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Zagadnienia dotyczące zabezpieczeń dla odbicia</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Zmiany zabezpieczeń w programie .NET Framework w wersji 4.0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Kod o przezroczystym poziomie bezpieczeństwa, poziom 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Kod o przezroczystym poziomie bezpieczeństwa, poziom 2</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Nie jest obsługiwane dla metod dynamicznych.</summary>
        <value>Nie jest obsługiwane dla metod dynamicznych.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Niedozwolone dla metod dynamicznych.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł za pomocą którego metoda dynamiczna jest logicznie powiązanych.</summary>
        <value><see cref="T:System.Reflection.Module" /> z bieżącej metody dynamiczne jest skojarzony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli moduł został określony podczas tworzenia metodę dynamiczną, ta właściwość zwraca ten moduł. Jeśli typ został określony jako właściciela podczas tworzenia metodę dynamiczną, ta właściwość zwraca modułu, który zawiera tego typu.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład <xref:System.Reflection.Emit.DynamicMethod.Module%2A> właściwość metodę dynamiczną. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę metody dynamicznej.</summary>
        <value>Prosta nazwa metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nie jest niezbędne do nazw metod dynamicznych.  
  
   
  
## Examples  
 Poniższy przykład kodu przedstawia nazwę metody dynamicznej. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klasę, który został użyty w odbiciu do uzyskania metody.</summary>
        <value>Zawsze <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość ta zwraca zawsze `null` dla metod dynamicznych.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla typ odbitych metodę dynamiczną. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera parametru zwracanego metody dynamicznej.</summary>
        <value>Zawsze <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość ta zwraca zawsze `null` dla metod dynamicznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ zwracanej wartości dla metody dynamicznej.</summary>
        <value>A <see cref="T:System.Type" /> reprezentujący typ zwracanej wartości bieżącej metody; <see cref="T:System.Void" /> Jeśli metoda nie ma zwracanego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `null` został określony dla zwracanego typu podczas tworzenia metodę dynamiczną, właściwość ta zwraca <xref:System.Void?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla typ zwracany metody dynamicznej. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty niestandardowe zwracany typ metody dynamicznej.</summary>
        <value><see cref="T:System.Reflection.ICustomAttributeProvider" /> Reprezentujący atrybuty niestandardowe zwracany typ metody dynamicznej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybutów niestandardowych, które nie są obsługiwane w zwracanym typie metodę dynamiczną, więc tablicę atrybutów niestandardowych, które są zwracane przez <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A> metody jest zawsze puste.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób wyświetlania atrybutów niestandardowych, zwracany typ metody dynamicznej. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca podpis metody, reprezentowane jako ciąg.</summary>
        <returns>Ciąg reprezentujący podpis metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podpis zawiera tylko typy i nazwę metody, jeśli istnieje. Nazwy parametrów nie są uwzględniane.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład <xref:System.Reflection.Emit.DynamicMethod.ToString%2A> metoda metodę dynamiczną. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Reflection.Emit.DynamicMethod> klasy.  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="PackagePart" FullName="System.IO.Packaging.PackagePart">
  <Metadata><Meta Name="ms.openlocfilehash" Value="600c1b9eae0184b24425b237d4ac104af4523cbf" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69244730" /></Metadata><TypeSignature Language="C#" Value="public abstract class PackagePart" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PackagePart extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.PackagePart" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PackagePart" />
  <TypeSignature Language="C++ CLI" Value="public ref class PackagePart abstract" />
  <TypeSignature Language="F#" Value="type PackagePart = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia klasę bazową dla części przechowywanych w <see cref="T:System.IO.Packaging.Package" />.  Ta klasa jest abstrakcyjna.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.IO.Packaging.PackagePart> składa się z trzech podstawowych elementów:  
  
|Access|Opis|  
|------------|-----------------|  
|<xref:System.IO.Packaging.PackagePart.Uri%2A>|[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Część.|  
|<xref:System.IO.Packaging.PackagePart.ContentType%2A>|[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Typ strumienia zawartości.|  
|<xref:System.IO.Packaging.PackagePart.GetStream%2A>|Strumień danych zawartości części.|  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja otwartych Konwencji pakietów</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Packaging.PackagePart" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Pakowanie URI w WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)  
  
 [Specyfikacja otwartych Konwencji pakietów](https://go.microsoft.com/fwlink/?LinkID=71255)  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="package">Element nadrzędny <see cref="T:System.IO.Packaging.Package" /> części.</param>
        <param name="partUri">Części względem nadrzędnego <see cref="T:System.IO.Packaging.Package" /> elementu głównego. [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Packaging.PackagePart" /> klasy z określonym elementem nadrzędnym <see cref="P:System.IO.Packaging.PackagePart.Package" /> i częścią [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri`musi być <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] poprawnie sformułowana zgodnie ze specyfikacją *ogólnej składni Uniform Resource Identifier* [RFC 3986](https://tools.ietf.org/html/rfc3986) (URI) i specyfikacji [Open pakowanie Konwencji](https://go.microsoft.com/fwlink/?LinkID=71255) .  
  
 Użyj tego konstruktora, gdy <xref:System.IO.Packaging.PackagePart.ContentType%2A> część części nie jest bezpośrednio znana i zostanie ustawiona później, gdy <xref:System.IO.Packaging.Package.CreatePart%2A> zostanie wywołana.  
  
 Domyślnie <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> Właściwość części jest inicjowana do <xref:System.IO.Packaging.CompressionOption.NotCompressed>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="package" />lub <paramref name="partUri" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja otwartych Konwencji pakietów</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri, contentType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="package">Element nadrzędny <see cref="T:System.IO.Packaging.Package" /> części.</param>
        <param name="partUri">Części względem nadrzędnego <see cref="T:System.IO.Packaging.Package" /> elementu głównego. [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]</param>
        <param name="contentType">Typ [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] zawartości strumienia danych części.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Packaging.PackagePart" /> klasy z określonym elementem nadrzędnym <see cref="P:System.IO.Packaging.PackagePart.Package" />, częściowym [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]i [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typem zawartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri`musi być <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] poprawnie sformułowana zgodnie ze specyfikacją *ogólnej składni Uniform Resource Identifier* [RFC 3986](https://tools.ietf.org/html/rfc3986) (URI) i specyfikacji [Open pakowanie Konwencji](https://go.microsoft.com/fwlink/?LinkID=71255) .  
  
 Domyślnie <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> Właściwość części jest inicjowana do <xref:System.IO.Packaging.CompressionOption.NotCompressed>.  
  
 `contentType`musi być [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typem utworzonym zgodnie z protokołem HTTP [2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol-https*, sekcja 3,7.  W poniższej tabeli przedstawiono przykład typów zawartości [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] używanych w [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentach.  
  
|Opis|Typ zawartości|  
|-----------------|------------------|  
|Font|application/vnd.ms-opentype|  
|Profil ICC|application/vnd.ms-color.iccprofile|  
|Obraz JPEG|image/jpeg|  
|Czcionka zasłonięta|application/vnd.ms-package.obfuscated-opentype|  
|Obraz PNG|image/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|Obraz TIFF|obraz/TIFF|  
|Obraz zdjęć Windows Media|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="package" />lub <paramref name="partUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />jest nieprawidłowy <see cref="T:System.IO.Packaging.PackagePart" />. [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja otwartych Konwencji pakietów</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri, contentType, compressionOption)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="package">Element nadrzędny <see cref="T:System.IO.Packaging.Package" /> części.</param>
        <param name="partUri">Części względem nadrzędnego <see cref="T:System.IO.Packaging.Package" /> elementu głównego. [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]</param>
        <param name="contentType">Typ [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] zawartości strumienia danych części.</param>
        <param name="compressionOption">Opcja kompresji strumienia danych części.</param>
        <summary>Inicjuje nowe <see cref="T:System.IO.Packaging.PackagePart" /> wystąpienie klasy z określonym elementem nadrzędnym [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] <see cref="P:System.IO.Packaging.PackagePart.Package" />, częścią, [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typem zawartości i <see cref="T:System.IO.Packaging.CompressionOption" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri`musi być <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] poprawnie sformułowana zgodnie ze specyfikacją *ogólnej składni Uniform Resource Identifier* [RFC 3986](https://tools.ietf.org/html/rfc3986) (URI) i specyfikacji [Open pakowanie Konwencji](https://go.microsoft.com/fwlink/?LinkID=71255) .  
  
 `contentType`musi być [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typem utworzonym zgodnie z protokołem HTTP [2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol-https*, sekcja 3,7.  W poniższej tabeli przedstawiono przykład typów zawartości [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] używanych w [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentach.  
  
|Opis|Typ zawartości|  
|-----------------|------------------|  
|Font|application/vnd.ms-opentype|  
|Profil ICC|application/vnd.ms-color.iccprofile|  
|Obraz JPEG|image/jpeg|  
|Czcionka zasłonięta|application/vnd.ms-package.obfuscated-opentype|  
|Obraz PNG|image/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|Obraz TIFF|obraz/TIFF|  
|Obraz zdjęć Windows Media|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="package" />lub <paramref name="partUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />jest nieprawidłowy <see cref="T:System.IO.Packaging.PackagePart" />. [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="compressionOption" /> Wartość jest nieprawidłowa.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja otwartych Konwencji pakietów</related>
      </Docs>
    </Member>
    <Member MemberName="CompressionOption">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.CompressionOption CompressionOption { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Packaging.CompressionOption CompressionOption" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.CompressionOption" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompressionOption As CompressionOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::CompressionOption CompressionOption { System::IO::Packaging::CompressionOption get(); };" />
      <MemberSignature Language="F#" Value="member this.CompressionOption : System.IO.Packaging.CompressionOption" Usage="System.IO.Packaging.PackagePart.CompressionOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.CompressionOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera opcję kompresji strumienia zawartości części.</summary>
        <value>Opcja kompresji strumienia zawartości części.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A>to właściwość tylko do odczytu, do której można uzyskać dostęp tylko wtedy, <xref:System.IO.Packaging.Package> gdy element nadrzędny jest otwarty.  
  
 Właściwość jest automatycznie ustawiana <xref:System.IO.Packaging.PackagePart.%23ctor%2A> przez konstruktora. <xref:System.IO.Packaging.PackagePart.CompressionOption%2A>  Po ustawieniu przez konstruktora <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> nie można zmienić.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" /></exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string" Usage="System.IO.Packaging.PackagePart.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Pobiera typ strumienia zawartości.</summary>
        <value>[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Typ strumienia danych zawartości części.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A>to właściwość tylko do odczytu, do której można uzyskać dostęp tylko wtedy, <xref:System.IO.Packaging.Package> gdy element nadrzędny jest otwarty.  
  
 Właściwość jest automatycznie ustawiana <xref:System.IO.Packaging.PackagePart.%23ctor%2A> przez konstruktora. <xref:System.IO.Packaging.PackagePart.ContentType%2A>  Po ustawieniu przez konstruktora <xref:System.IO.Packaging.PackagePart.ContentType%2A> nie można zmienić.  
  
 Właściwość jest typu, [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] który został utworzony zgodnie z *protokołem HTTP 2616 Hypertext Transfer Protocol-* https, sekcja 3,7. [](https://www.w3.org/Protocols/rfc2616/rfc2616.html) <xref:System.IO.Packaging.PackagePart.ContentType%2A>  W poniższej tabeli przedstawiono przykład typów zawartości [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] używanych w [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentach.  
  
|Opis|Typ zawartości|  
|-----------------|------------------|  
|Font|application/vnd.ms-opentype|  
|Profil ICC|application/vnd.ms-color.iccprofile|  
|Obraz JPEG|image/jpeg|  
|Czcionka zasłonięta|application/vnd.ms-package.obfuscated-opentype|  
|Obraz PNG|image/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|Obraz TIFF|obraz/TIFF|  
|Obraz zdjęć Windows Media|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" />  
  
—lub— 
Ciąg zwracany przez metodę klasy <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" /> pochodnej jest pusty.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja otwartych Konwencji pakietów</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy relację poziomu części między tym <see cref="T:System.IO.Packaging.PackagePart" /> elementem docelowym <see cref="T:System.IO.Packaging.PackagePart" /> lub zasobem zewnętrznym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziomu części definiuje skojarzenie między tą częścią i częścią docelową lub zasobem.  Relacja poziomu części może być jedną z dwóch form.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> a elementem docelowym <xref:System.IO.Packaging.PackagePart> wewnątrz <xref:System.IO.Packaging.Package>.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> a zasobem docelowym poza pakietem.  
  
 W relacji częściowej część źródłowa jest uznawana za "Owner" relacji.  Po usunięciu części źródłowej zostaną również usunięte wszystkie relacje należące do części.  Proces tworzenia lub usuwania relacji nie pozwala fizycznie zmieniać części docelowej ani zasobu w jakikolwiek sposób.  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> Metoda nie zmienia fizycznie części źródłowej lub docelowej części lub zasobu w jakikolwiek sposób.  
  
 Obiekt docelowy relacji nie może być inną relacją.  
  
 Aby uzyskać więcej informacji na temat relacji pakietów, zobacz sekcję 1,3 specyfikacji *Open Package Conventions (OPC)* , która <https://go.microsoft.com/fwlink/?LinkID=71255>jest dostępna do pobrania na stronie.  
  
 Więcej informacji o dokumentach XPS można znaleźć w artykule *Open XML Paper Specification (XPS)* dostępnym do <https://go.microsoft.com/fwlink/?LinkID=67000>pobrania.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja otwartych Konwencji pakietów</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części docelowej.</param>
        <param name="targetMode">Jedna z wartości wyliczenia. Na przykład, <see cref="F:System.IO.Packaging.TargetMode.Internal" /> jeśli część docelowa znajduje się <see cref="T:System.IO.Packaging.Package" />wewnątrz lub <see cref="F:System.IO.Packaging.TargetMode.External" /> <see cref="T:System.IO.Packaging.Package" />Jeśli obiekt docelowy jest zasobem poza.</param>
        <param name="relationshipType">Rola relacji.</param>
        <summary>Tworzy relację poziomu części między tym <see cref="T:System.IO.Packaging.PackagePart" /> elementem docelowym <see cref="T:System.IO.Packaging.PackagePart" /> lub zasobem zewnętrznym.</summary>
        <returns>Relacja poziomu części między tym <see cref="T:System.IO.Packaging.PackagePart" /> elementem docelowym <see cref="T:System.IO.Packaging.PackagePart" /> lub zasobem zewnętrznym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziomu części definiuje skojarzenie między tą częścią i częścią docelową lub zasobem.  Relacja poziomu części może być jedną z dwóch form.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> a elementem docelowym <xref:System.IO.Packaging.PackagePart> wewnątrz <xref:System.IO.Packaging.Package>.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> a zasobem docelowym poza pakietem.  
  
 W relacji częściowej część źródłowa jest uznawana za "Owner" relacji.  Po usunięciu części źródłowej zostaną również usunięte wszystkie relacje należące do części.  Proces tworzenia lub usuwania relacji nie pozwala fizycznie zmieniać części docelowej ani zasobu w jakikolwiek sposób.  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> Metoda nie zmienia fizycznie części źródłowej lub docelowej części lub zasobu w jakikolwiek sposób.  
  
 Obiekt docelowy relacji nie może być inną relacją.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` musi być względnym identyfikatorem URI, który jest sformułowany zgodnie ze specyfikacją ogólnej składni Uniform Resource Identifier [RFC 3986](https://tools.ietf.org/html/rfc3986) *(URI)* .  Wewnętrzny względny identyfikator URI może być ścieżką bezwzględną rozpoczynającą się od ukośnika ("/"), taką jak "/page1.XAML" lub "/images/picture4.jpg" lub ścieżką względną, taką jak ".. /imagespicture1.jpg ", który jest rozpoznawany względem katalogu głównego pakietu ("/") jako podstawowy identyfikator URI.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.External>, `targetUri` może być bezwzględny lub względny identyfikator URI utworzony zgodnie ze specyfikacją ogólnej składni Uniform Resource Identifier [RFC 3986](https://tools.ietf.org/html/rfc3986) *(URI)* . `"https://www.microsoft.com/page2.xml"`to przykład bezwzględnego identyfikatora URI, który odwołuje się do zewnętrznego zasobu docelowego "Page2. xml".  "images/picture1. jpg" to przykładowy względny identyfikator URI, który odwołuje się również do zewnętrznego zasobu docelowego "1. jpg", ale który jest rozpoznawany względem identyfikatora URI samego pakietu.  
  
 `relationshipType`musi być [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] sformułowany zgodnie ze specyfikacją *ogólnej składni Uniform Resource Identifier* [RFC 3986](https://tools.ietf.org/html/rfc3986) (URI).  Różne typy pakietów mogą definiować różne typy relacji częściowej.  W poniższej tabeli przedstawiono identyfikatory URI na poziomie `relationshipType` części zdefiniowane dla dokumentów, które są zgodne ze *specyfikacją Open XML Paper Specification (XPS)*.  
  
|Relacja poziomu części dokumentu XPS|Identyfikator URI typu relacji|  
|-------------------------------------------|---------------------------|  
|Definicje podpisów cyfrowych|[http://schemas.microsoft.com/xps/2005/06/signature-definitions](https://schemas.microsoft.com/xps/2005/06/signature-definitions)|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|Wymagany zasób|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|Czcionka z ograniczeniami|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|Części StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 Aby uzyskać więcej informacji na temat relacji pakietów, zobacz sekcję 1,3 specyfikacji *Open Package Conventions (OPC)* , która <https://go.microsoft.com/fwlink/?LinkID=71255>jest dostępna do pobrania na stronie.  
  
 Więcej informacji o dokumentach XPS można znaleźć w artykule *Open XML Paper Specification (XPS)* dostępnym do [http://go.microsoft.com/fwlink/?LinkID=67000](https://go.microsoft.com/fwlink/?LinkID=67000)pobrania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" />lub <paramref name="relationshipType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Parametr nie jest prawidłową <see cref="T:System.IO.Packaging.TargetMode" /> wartością wyliczenia. <paramref name="targetMode" /></exception>
        <exception cref="T:System.ArgumentException">Część identyfikowana przez <paramref name="targetUri" /> jest relacją (obiekt docelowy relacji nie może być inną relacją).  
  
—lub— 
 <paramref name="targetMode" />jest określony jako <see cref="F:System.IO.Packaging.TargetMode.Internal" /> , <paramref name="targetUri" /> ale jest bezwzględny zewnętrzny [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu (nie można dodać nowej relacji).</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja otwartych Konwencji pakietów</related>
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części docelowej.</param>
        <param name="targetMode">Jedna z wartości wyliczenia. Na przykład, <see cref="F:System.IO.Packaging.TargetMode.Internal" /> jeśli część docelowa znajduje się <see cref="T:System.IO.Packaging.Package" />wewnątrz lub <see cref="F:System.IO.Packaging.TargetMode.External" /> <see cref="T:System.IO.Packaging.Package" />Jeśli obiekt docelowy jest zasobem poza.</param>
        <param name="relationshipType">Rola relacji.</param>
        <param name="id">Unikatowy identyfikator relacji.</param>
        <summary>Tworzy relację poziomu części między tym <see cref="T:System.IO.Packaging.PackagePart" /> elementem docelowym <see cref="T:System.IO.Packaging.PackagePart" /> lub zasobem zewnętrznym.</summary>
        <returns>Relacja poziomu części między tym <see cref="T:System.IO.Packaging.PackagePart" /> elementem docelowym <see cref="T:System.IO.Packaging.PackagePart" /> lub zasobem zewnętrznym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziomu części definiuje skojarzenie między tą częścią i częścią docelową lub zasobem.  Relacja poziomu części może być jedną z dwóch form.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> a elementem docelowym <xref:System.IO.Packaging.PackagePart> wewnątrz <xref:System.IO.Packaging.Package>.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> a zasobem docelowym poza pakietem.  
  
 W relacji częściowej część źródłowa jest uznawana za "Owner" relacji.  Po usunięciu części źródłowej zostaną również usunięte wszystkie relacje należące do części.  Proces tworzenia lub usuwania relacji nie pozwala fizycznie zmieniać części docelowej ani zasobu w jakikolwiek sposób.  
  
 `id`musi być prawidłowym identyfikatorem XML.  Typ to XSD: ID i musi być zgodny z konwencjami nazewnictwa określonymi *w schemacie XML schematu część 2: `id`*  Specyfikacja typów danych (zobacz [https://www.w3.org/TR/xmlschema-2/#ID](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> Metoda nie zmienia fizycznie części źródłowej lub docelowej części lub zasobu w jakikolwiek sposób.  
  
 Obiekt docelowy relacji nie może być inną relacją.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` musi być względnym identyfikatorem URI, który jest sformułowany zgodnie ze specyfikacją ogólnej składni Uniform Resource Identifier [RFC 3986](https://tools.ietf.org/html/rfc3986) *(URI)* .  Wewnętrzny względny identyfikator URI może być ścieżką bezwzględną rozpoczynającą się od ukośnika ("/"), taką jak "/page1.XAML" lub "/images/picture4.jpg" lub ścieżką względną, taką jak ".. /imagespicture1.jpg ", który jest rozpoznawany względem katalogu głównego pakietu ("/") jako podstawowy identyfikator URI.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.External>, `targetUri` może być bezwzględny lub względny identyfikator URI utworzony zgodnie ze specyfikacją ogólnej składni Uniform Resource Identifier [RFC 3986](https://tools.ietf.org/html/rfc3986) *(URI)* .  "https://www.microsoft.com/page2.xml" to przykład bezwzględnego identyfikatora URI, który odwołuje się do zewnętrznego zasobu docelowego "Page2. xml".  "images/picture1. jpg" to przykładowy względny identyfikator URI, który odwołuje się również do zewnętrznego zasobu docelowego "1. jpg", ale który jest rozpoznawany względem identyfikatora URI samego pakietu.  
  
 `relationshipType`musi być [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] sformułowany zgodnie ze specyfikacją *ogólnej składni Uniform Resource Identifier* [RFC 3986](https://tools.ietf.org/html/rfc3986) (URI).  Różne typy pakietów mogą definiować różne typy relacji częściowej.  W poniższej tabeli przedstawiono identyfikatory URI na poziomie `relationshipType` części zdefiniowane dla dokumentów, które są zgodne ze *specyfikacją Open XML Paper Specification (XPS)*.  
  
|Relacja poziomu części dokumentu XPS|Identyfikator URI typu relacji|  
|-------------------------------------------|---------------------------|  
|Definicje podpisów cyfrowych|http://schemas.microsoft.com/xps/2005/06/signature-definitions|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|Wymagany zasób|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|Czcionka z ograniczeniami|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|Części StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 Aby uzyskać więcej informacji na temat relacji pakietów, zobacz sekcję 1,3 specyfikacji *Open Package Conventions (OPC)* , która <https://go.microsoft.com/fwlink/?LinkID=71255>jest dostępna do pobrania na stronie.  
  
 Więcej informacji o dokumentach XPS można znaleźć w artykule *Open XML Paper Specification (XPS)* dostępnym do [http://go.microsoft.com/fwlink/?LinkID=67000](https://go.microsoft.com/fwlink/?LinkID=67000)pobrania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" />lub <paramref name="relationshipType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Parametr nie jest prawidłową <see cref="T:System.IO.Packaging.TargetMode" /> wartością wyliczenia. <paramref name="targetMode" /></exception>
        <exception cref="T:System.ArgumentException">Część identyfikowana przez <paramref name="targetUri" /> jest relacją (obiekt docelowy relacji nie może być inną relacją).  
  
—lub— 
 <paramref name="targetMode" />jest określony jako <see cref="F:System.IO.Packaging.TargetMode.Internal" /> , <paramref name="targetUri" /> ale jest bezwzględny zewnętrzny [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu (nie można dodać nowej relacji).</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />nie jest prawidłowym identyfikatorem XML.  
  
—lub— 
Część z określonym <paramref name="id" /> już istnieje.</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja otwartych Konwencji pakietów</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="packagePart.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Relacja do usunięcia.</param>
        <summary>Usuwa określony poziom <see cref="T:System.IO.Packaging.PackageRelationship" />części.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id`musi być prawidłowym identyfikatorem XML.  Typ to XSD: ID i musi być zgodny z konwencjami nazewnictwa określonymi *w schemacie XML schematu część 2: `id`*  Specyfikacja typów danych (zobacz [https://www.w3.org/TR/xmlschema-2/#ID](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Jeśli określony `id` element nie jest zgodny z <xref:System.IO.Packaging.PackageRelationship.Id%2A> żadną z relacji należących do tej części, żadna relacja nie zostanie usunięta i nie zostanie zgłoszony żaden wyjątek.  
  
 Innym niż usuwanie określonej relacji, <xref:System.IO.Packaging.PackagePart.DeleteRelationship%2A> Metoda nie zmienia fizycznie tej części ani części docelowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu (nie można usunąć relacji).</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />nie jest prawidłowym identyfikatorem XML.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetContentTypeCore">
      <MemberSignature Language="C#" Value="protected virtual string GetContentTypeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetContentTypeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetContentTypeCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetContentTypeCore () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetContentTypeCore();" />
      <MemberSignature Language="F#" Value="abstract member GetContentTypeCore : unit -&gt; string&#xA;override this.GetContentTypeCore : unit -&gt; string" Usage="packagePart.GetContentTypeCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typ zawartości części.</summary>
        <returns>[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Typ zawartości części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A>jest wirtualną metodą <xref:System.IO.Packaging.PackagePart> abstrakcyjnej klasy bazowej. Zaimplementuj tę metodę tylko w typach pochodnych, w których nie można podać wartości dla typu zawartości w czasie konstruowania lub jeśli Obliczanie wartości typu zawartości jest operacją nieuproszczoną lub kosztowną. Zwracana wartość musi być prawidłowym [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typem zawartości.  
  
 Klasy pochodne mogą wywołać <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A> , aby <xref:System.IO.Packaging.PackagePart.ContentType%2A> zainicjować właściwość klasy pochodnej do wartości domyślnej.  Po ustawieniu <xref:System.IO.Packaging.PackagePart.ContentType%2A> właściwości nie można jej zmienić.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Klasa pochodna nie zapewnia implementacji przesłaniania wymaganej dla <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Relacja do zwrócenia.</param>
        <summary>Zwraca relację, która ma określoną <see cref="P:System.IO.Packaging.PackageRelationship.Id" />wartość.</summary>
        <returns>Relacja zgodna z określoną <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id`musi być prawidłowym identyfikatorem XML.  Typ to XSD: ID i musi być zgodny z konwencjami nazewnictwa określonymi *w schemacie XML schematu część 2: `id`*  Specyfikacja typów danych (zobacz [https://www.w3.org/TR/xmlschema-2/#ID](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Możesz użyć metody, <xref:System.IO.Packaging.PackagePart.RelationshipExists%2A> aby określić, czy relacja z określonym <xref:System.IO.Packaging.PackageRelationship.Id%2A> elementem należy do tej części.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />nie jest prawidłowym identyfikatorem XML.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="relationshipType" />jest pustym ciągiem.</exception>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" />  
  
—lub— 
Relacja z określoną <paramref name="id" /> nie istnieje w pakiecie.</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji o relacji).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="packagePart.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję wszystkich relacji należących do tej części.</summary>
        <returns>Kolekcja wszystkich relacji należących do części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwracana kolekcja nigdy nie `null`jest, jednak Kolekcja może zawierać zerowe elementy, jeśli część nie definiuje żadnych relacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" /></exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji o relacji).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="packagePart.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType"><see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> Relacje do zlokalizowania i zwrócenia w kolekcji.</param>
        <summary>Zwraca kolekcję relacji pasujących do określonego <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />.</summary>
        <returns>Kolekcja relacji, które pasują do określonego <paramref name="relationshipType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwracana kolekcja nigdy nie `null`jest, jednak Kolekcja może zawierać zerowe elementy, jeśli żadne relacje nie odpowiadają określonemu `relationshipType` dla części.  
  
 Wszystkie spacje wiodące i końcowe w `relationshipType` ciągu są automatycznie obcinane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relationshipType" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="relationshipType" />jest pustym ciągiem.</exception>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" /></exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji o relacji).</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja otwartych Konwencji pakietów</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca strumień danych zawartości części.</summary>
        <block subset="none" type="usage"><para>
            <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" />wewnętrznie wywołuje metodę pochodną <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> w rzeczywistości otwarte i zwracają strumień danych części na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.  
  
Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> używana jest implementacja podklasy klasy abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> .  W operacji <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> domyślnej wewnętrznie wywołania <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasy do otwierania i zwracania strumienia danych części z pliku zip.</para></block>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream();" />
      <MemberSignature Language="F#" Value="member this.GetStream : unit -&gt; System.IO.Stream" Usage="packagePart.GetStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca strumień danych zawartości części.</summary>
        <returns>Strumień danych zawartości części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia otwarcie strumienia zawartości z <xref:System.IO.FileMode> <xref:System.IO.FileMode.OpenOrCreate> uprawnieniami i <xref:System.IO.FileAccess> , które są takie same jak nadrzędne <xref:System.IO.Packaging.Package>.  
  
 Metoda przeciążenia <xref:System.IO.Packaging.PackagePart.GetStream%2A> umożliwia ustawienie określonego <xref:System.IO.FileMode>elementu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" /></exception>
        <exception cref="T:System.IO.IOException">Obiekt Stream zwrócony przez <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metodę klasy pochodnej to. <see langword="null" /></exception>
        <block subset="none" type="usage"><para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream" />wewnętrznie wywołuje metodę pochodną <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> w rzeczywistości otwarte i zwracają strumień danych części na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.  
  
Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> używana jest implementacja podklasy klasy abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> .  W operacji <see cref="M:System.IO.Packaging.PackagePart.GetStream" /> domyślnej wewnętrznie wywołania <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasy do otwierania i zwracania strumienia danych części z pliku zip.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="member this.GetStream : System.IO.FileMode -&gt; System.IO.Stream" Usage="packagePart.GetStream mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">Tryb we/wy, w którym ma zostać otwarty strumień zawartości.</param>
        <summary>Zwraca strumień zawartości otwarty w określonym we/wy <see cref="T:System.IO.FileMode" />.</summary>
        <returns>Strumień zawartości części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uprawnienia zwróconego strumienia zawartości są takie same jak uprawnienia elementu nadrzędnego <xref:System.IO.Packaging.Package>. <xref:System.IO.FileAccess>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Parametr nie jest prawidłową <see cref="T:System.IO.FileMode" /> wartością wyliczenia. <paramref name="mode" /></exception>
        <exception cref="T:System.IO.IOException"><paramref name="mode" /> Parametr nie jest zgodny ze strumieniem pakietu i części.  
  
—lub— 
Obiekt Stream zwrócony przez <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metodę klasy pochodnej to. <see langword="null" /></exception>
        <block subset="none" type="usage"><para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" />wewnętrznie wywołuje metodę pochodną <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> w rzeczywistości otwarte i zwracają strumień danych części na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.  
  
Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> używana jest implementacja podklasy klasy abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> .  W operacji <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" /> domyślnej wewnętrznie wywołania <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasy do otwierania i zwracania strumienia danych części z pliku zip.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.GetStream : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Stream" Usage="packagePart.GetStream (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">Tryb we/wy, w którym ma zostać otwarty strumień zawartości.</param>
        <param name="access">Uprawnienia dostępu do użycia podczas otwierania strumienia zawartości.</param>
        <summary>Zwraca strumień zawartości części otwarty z określonym <see cref="T:System.IO.FileMode" /> i. <see cref="T:System.IO.FileAccess" /></summary>
        <returns>Strumień zawartości części.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Parametr nie jest prawidłową <see cref="T:System.IO.FileMode" /> wartością wyliczenia. <paramref name="mode" />  
  
—lub— 
Parametr nie jest prawidłową <see cref="T:System.IO.FileAccess" /> wartością wyliczenia. <paramref name="access" /></exception>
        <exception cref="T:System.IO.IOException"><paramref name="mode" />lub <paramref name="access" /> nie jest zgodny ze strumieniem pakietu i części.  
  
—lub— 
Parametr jest określony, ponieważ <see cref="F:System.IO.FileAccess.Read" /> <paramref name="mode" /> parametr wymaga dostępu do zapisu. <paramref name="access" />  (<see cref="T:System.IO.FileMode" /> wartości<see cref="F:System.IO.FileMode.CreateNew" />, ,<see cref="F:System.IO.FileAccess.Write" /> i wymagaj lub<see cref="F:System.IO.FileAccess.ReadWrite" /> dostęp.) <see cref="F:System.IO.FileMode.Truncate" /> <see cref="F:System.IO.FileMode.Append" /> <see cref="F:System.IO.FileMode.Create" /> 
—lub— 
Obiekt Stream zwrócony przez <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metodę klasy pochodnej to. <see langword="null" /></exception>
        <block subset="none" type="usage"><para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" />wewnętrznie wywołuje metodę pochodną <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> w rzeczywistości otwarte i zwracają strumień danych części na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.  
  
Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> używana jest implementacja podklasy klasy abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> .  W operacji <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" /> domyślnej wewnętrznie wywołania <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasy do otwierania i zwracania strumienia danych części z pliku zip.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetStreamCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Stream GetStreamCore (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Stream GetStreamCore(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetStreamCore (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Stream ^ GetStreamCore(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="abstract member GetStreamCore : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Stream" Usage="packagePart.GetStreamCore (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">Tryb we/wy, w którym ma zostać otwarty strumień zawartości.</param>
        <param name="access">Uprawnienia dostępu do użycia podczas otwierania strumienia zawartości.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca strumień zawartości części otwarty z określonym <see cref="T:System.IO.FileMode" /> i. <see cref="T:System.IO.FileAccess" /></summary>
        <returns>Strumień danych zawartości części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje nie powinny być <xref:System.IO.Packaging.PackagePart.GetStreamCore%2A> wywoływane bezpośrednio, ale powinny być <xref:System.IO.Packaging.PackagePart.GetStream%2A>wywoływane.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Implementacja pochodna <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> nie powinna wprowadzać żadnych założeń dotyczących kolejności lub operacji wykonywanych <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> przez metodę, która go wywołuje.</para></block>
        <block subset="none" type="usage"><para>Metoda pochodna <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> jest wywoływana <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> przez metody, aby otworzyć i zwrócić strumień danych części na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.  
  
Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> używana jest implementacja podklasy klasy abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> .  W operacji <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> domyślnej wewnętrznie wywołania <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasy do otwierania i zwracania strumienia danych części z pliku zip.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Package">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.Package Package { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.Package Package" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Package" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Package As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::Package ^ Package { System::IO::Packaging::Package ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Package : System.IO.Packaging.Package" Usage="System.IO.Packaging.PackagePart.Package" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element nadrzędny <see cref="T:System.IO.Packaging.Package" /> części.</summary>
        <value>Pakiet nadrzędny części.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Package%2A>to właściwość tylko do odczytu, do której można uzyskać dostęp tylko wtedy, <xref:System.IO.Packaging.Package> gdy element nadrzędny jest otwarty.  
  
 Właściwość jest automatycznie ustawiana <xref:System.IO.Packaging.PackagePart.%23ctor%2A> przez konstruktora. <xref:System.IO.Packaging.PackagePart.Package%2A>  Po ustawieniu przez konstruktora nie można zmienić elementu nadrzędnego <xref:System.IO.Packaging.PackagePart.Package%2A> części.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" /></exception>
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="packagePart.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Relacja, dla której ma zostać wyszukane.</param>
        <summary>Zwraca wartość wskazującą, czy ta część jest właścicielem relacji z określoną <see cref="P:System.IO.Packaging.PackageRelationship.Id" />.</summary>
        <returns><see langword="true" />Jeśli ta część jest właścicielem relacji z określonym <paramref name="id" />; w przeciwnym razie,. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id`musi być prawidłowym identyfikatorem XML.  Typ to XSD: ID i musi być zgodny z konwencjami nazewnictwa określonymi *w schemacie XML schematu część 2: `id`*  Specyfikacja typów danych (zobacz [https://www.w3.org/TR/xmlschema-2/#ID](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />nie jest prawidłowym identyfikatorem XML.</exception>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" /></exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji o relacji).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Uri">
      <MemberSignature Language="C#" Value="public Uri Uri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Uri" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Uri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Uri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Uri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Uri : Uri" Usage="System.IO.Packaging.PackagePart.Uri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Pobiera część.</summary>
        <value>Część [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] elementu względem katalogu głównego pakietu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Uri%2A>to właściwość tylko do odczytu, do której można uzyskać dostęp tylko wtedy, <xref:System.IO.Packaging.Package> gdy element nadrzędny jest otwarty.  
  
 Właściwość jest automatycznie ustawiana <xref:System.IO.Packaging.PackagePart.%23ctor%2A> przez konstruktora. <xref:System.IO.Packaging.PackagePart.Uri%2A>  Po ustawieniu przez konstruktora <xref:System.IO.Packaging.PackagePart.Uri%2A> części nie można zmienić.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany). <see cref="P:System.IO.Packaging.PackagePart.Package" /></exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ComparePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
  </Members>
</Type>

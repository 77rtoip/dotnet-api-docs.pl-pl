<Type Name="PackagePart" FullName="System.IO.Packaging.PackagePart">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ab3d87c5990d28ae57417dac333b5e127cd7f826" /><Meta Name="ms.sourcegitcommit" Value="10aa513a7461eb2abbf8d1e35d2a045d4e5a9be7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/09/2019" /><Meta Name="ms.locfileid" Value="67665410" /></Metadata><TypeSignature Language="C#" Value="public abstract class PackagePart" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PackagePart extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.PackagePart" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PackagePart" />
  <TypeSignature Language="C++ CLI" Value="public ref class PackagePart abstract" />
  <TypeSignature Language="F#" Value="type PackagePart = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia klasę bazową dla przechowywanych we właściwości części <see cref="T:System.IO.Packaging.Package" />.  Ta klasa jest abstrakcyjna.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.IO.Packaging.PackagePart> składa się z trzech podstawowych elementów:  
  
|Access|Opis|  
|------------|-----------------|  
|<xref:System.IO.Packaging.PackagePart.Uri%2A>|[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części.|  
|<xref:System.IO.Packaging.PackagePart.ContentType%2A>|[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Typ zawartości strumienia.|  
|<xref:System.IO.Packaging.PackagePart.GetStream%2A>|Strumień danych zawartości części.|  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja konwencje Otwórz pakowania</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Packaging.PackagePart" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Pakowanie URI w WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)  
  
 [Specyfikacja konwencje Otwórz pakowania](https://go.microsoft.com/fwlink/?LinkID=71255)  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="package">Element nadrzędny <see cref="T:System.IO.Packaging.Package" /> części.</param>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części względem nadrzędnego <see cref="T:System.IO.Packaging.Package" /> głównego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Packaging.PackagePart" /> klasy przy użyciu określonego elementu nadrzędnego <see cref="P:System.IO.Packaging.PackagePart.Package" /> i części [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` musi być prawidłowy <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] sformułowany, zgodnie z [ze standardem RFC 3986](https://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji i [Otwórz pakowania Konwencje](https://go.microsoft.com/fwlink/?LinkID=71255) specyfikacji.  
  
 Użyć tego konstruktora podczas <xref:System.IO.Packaging.PackagePart.ContentType%2A> części nie jest od razu znana i zostanie ustawiona później podczas <xref:System.IO.Packaging.Package.CreatePart%2A> jest wywoływana.  
  
 Domyślnie <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> właściwość part jest inicjowany do <xref:System.IO.Packaging.CompressionOption.NotCompressed>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="package" /> lub <paramref name="partUri" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja konwencje Otwórz pakowania</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri, contentType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="package">Element nadrzędny <see cref="T:System.IO.Packaging.Package" /> części.</param>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części względem nadrzędnego <see cref="T:System.IO.Packaging.Package" /> głównego.</param>
        <param name="contentType">[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Typ części strumienia danych zawartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Packaging.PackagePart" /> klasy przy użyciu określonego elementu nadrzędnego <see cref="P:System.IO.Packaging.PackagePart.Package" />częścią [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)], i [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typ zawartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` musi być prawidłowy <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] sformułowany, zgodnie z [ze standardem RFC 3986](https://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji i [Otwórz pakowania Konwencje](https://go.microsoft.com/fwlink/?LinkID=71255) specyfikacji.  
  
 Domyślnie <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> właściwość part jest inicjowany do <xref:System.IO.Packaging.CompressionOption.NotCompressed>.  
  
 `contentType` musi być [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typu sformułowany, zgodnie z [dokumencie RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *protokołu HTTP - HTTP*, 3.7 sekcji.  W poniższej tabeli przedstawiono przykład zawartości [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typów używanych w [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentów.  
  
|Opis|Typ zawartości|  
|-----------------|------------------|  
|Czcionka|application/vnd.ms-opentype|  
|Profil ICC|application/vnd.ms-color.iccprofile|  
|Obraz JPEG|image/jpeg|  
|Zaciemnionego czcionki|application/vnd.ms-package.obfuscated-opentype|  
|Obraz PNG|image/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|Obraz TIFF|image/tiff|  
|Obraz Windows Media zdjęcia|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="package" /> lub <paramref name="partUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> nie jest prawidłowym <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja konwencje Otwórz pakowania</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri, contentType, compressionOption)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="package">Element nadrzędny <see cref="T:System.IO.Packaging.Package" /> części.</param>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części względem nadrzędnego <see cref="T:System.IO.Packaging.Package" /> głównego.</param>
        <param name="contentType">[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Typ części strumienia danych zawartości.</param>
        <param name="compressionOption">Opcja kompresji części strumienia danych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Packaging.PackagePart" /> klasy przy użyciu określonego elementu nadrzędnego <see cref="P:System.IO.Packaging.PackagePart.Package" />częścią [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)], [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typ, zawartości i <see cref="T:System.IO.Packaging.CompressionOption" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` musi być prawidłowy <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] sformułowany, zgodnie z [ze standardem RFC 3986](https://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji i [Otwórz pakowania Konwencje](https://go.microsoft.com/fwlink/?LinkID=71255) specyfikacji.  
  
 `contentType` musi być [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typu sformułowany, zgodnie z [dokumencie RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *protokołu HTTP - HTTP*, 3.7 sekcji.  W poniższej tabeli przedstawiono przykład zawartości [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typów używanych w [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentów.  
  
|Opis|Typ zawartości|  
|-----------------|------------------|  
|Czcionka|application/vnd.ms-opentype|  
|Profil ICC|application/vnd.ms-color.iccprofile|  
|Obraz JPEG|image/jpeg|  
|Zaciemnionego czcionki|application/vnd.ms-package.obfuscated-opentype|  
|Obraz PNG|image/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|Obraz TIFF|image/tiff|  
|Obraz Windows Media zdjęcia|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="package" /> lub <paramref name="partUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> nie jest prawidłowym <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="compressionOption" /> Wartość jest nieprawidłowa.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja konwencje Otwórz pakowania</related>
      </Docs>
    </Member>
    <Member MemberName="CompressionOption">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.CompressionOption CompressionOption { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Packaging.CompressionOption CompressionOption" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.CompressionOption" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompressionOption As CompressionOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::CompressionOption CompressionOption { System::IO::Packaging::CompressionOption get(); };" />
      <MemberSignature Language="F#" Value="member this.CompressionOption : System.IO.Packaging.CompressionOption" Usage="System.IO.Packaging.PackagePart.CompressionOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.CompressionOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera opcję kompresji części strumienia zawartości.</summary>
        <value>Opcja kompresji części strumienia zawartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> jest właściwością tylko do odczytu, która jest możliwy tylko wtedy, gdy element nadrzędny <xref:System.IO.Packaging.Package> jest otwarty.  
  
 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> Właściwość jest automatycznie ustawiana przez <xref:System.IO.Packaging.PackagePart.%23ctor%2A> konstruktora.  Po ustawieniu przez konstruktora, <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> nie można jej zmienić.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string" Usage="System.IO.Packaging.PackagePart.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typ zawartości strumienia.</summary>
        <value>[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Typ strumienia danych zawartości dla części.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> jest właściwością tylko do odczytu, która jest możliwy tylko wtedy, gdy element nadrzędny <xref:System.IO.Packaging.Package> jest otwarty.  
  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> Właściwość jest automatycznie ustawiana przez <xref:System.IO.Packaging.PackagePart.%23ctor%2A> konstruktora.  Po ustawieniu przez konstruktora, <xref:System.IO.Packaging.PackagePart.ContentType%2A> nie można jej zmienić.  
  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> Właściwość [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typu sformułowany, zgodnie z [dokumencie RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *protokołu HTTP - HTTP*, 3.7 sekcji.  W poniższej tabeli przedstawiono przykład zawartości [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typów używanych w [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentów.  
  
|Opis|Typ zawartości|  
|-----------------|------------------|  
|Czcionka|application/vnd.ms-opentype|  
|Profil ICC|application/vnd.ms-color.iccprofile|  
|Obraz JPEG|image/jpeg|  
|Zaciemnionego czcionki|application/vnd.ms-package.obfuscated-opentype|  
|Obraz PNG|image/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|Obraz TIFF|image/tiff|  
|Obraz Windows Media zdjęcia|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).  
  
—lub— 
Ciąg zwracany w klasie pochodnej <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" /> metoda jest pusta.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja konwencje Otwórz pakowania</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy relację między tą część poziom <see cref="T:System.IO.Packaging.PackagePart" /> do określonego obiektu docelowego <see cref="T:System.IO.Packaging.PackagePart" /> lub zasobów zewnętrznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziom część definiuje skojarzenie między tej części i część docelowa lub zasobu.  Relacja część poziom może być jedną z dwóch form.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> do obiektu docelowego <xref:System.IO.Packaging.PackagePart> wewnątrz <xref:System.IO.Packaging.Package>.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> do zasobu docelowego poza pakietem.  
  
 W ramach relacji "owner" relacji jest uważany za część źródła.  Po usunięciu części źródła wszystkie relacje, które są własnością części również zostaną usunięte.  Proces tworzenia lub usuwania relacji nie zmienia fizycznie część docelowa lub zasobu w dowolny sposób.  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> Metoda nie fizycznie zmienia część źródła lub część docelowa lub zasobu w dowolny sposób.  
  
 Element docelowy relacji nie może być w innej relacji.  
  
 Aby uzyskać więcej informacji na temat relacji pakietu sekcji 1.3 *otwarte konwencje tworzenia pakietów (OPC)* specyfikacji pobrać <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 Aby dowiedzieć się więcej o XPS dokumenty zobacz *protokołu dynamicznej konfiguracji hosta (XPS, Open XML Paper Specification)* pobrać <https://go.microsoft.com/fwlink/?LinkID=67000>.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja konwencje Otwórz pakowania</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części docelowej.</param>
        <param name="targetMode">Jedna z wartości wyliczenia. Na przykład <see cref="F:System.IO.Packaging.TargetMode.Internal" /> Jeśli część docelowa znajduje się wewnątrz <see cref="T:System.IO.Packaging.Package" />; lub <see cref="F:System.IO.Packaging.TargetMode.External" /> Jeśli element docelowy zasób poza <see cref="T:System.IO.Packaging.Package" />.</param>
        <param name="relationshipType">Rola relacji.</param>
        <summary>Tworzy relację między tą część poziom <see cref="T:System.IO.Packaging.PackagePart" /> do określonego obiektu docelowego <see cref="T:System.IO.Packaging.PackagePart" /> lub zasobów zewnętrznych.</summary>
        <returns>Część poziom relacji między tą <see cref="T:System.IO.Packaging.PackagePart" /> do obiektu docelowego <see cref="T:System.IO.Packaging.PackagePart" /> lub zasobów zewnętrznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziom część definiuje skojarzenie między tej części i część docelowa lub zasobu.  Relacja część poziom może być jedną z dwóch form.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> do obiektu docelowego <xref:System.IO.Packaging.PackagePart> wewnątrz <xref:System.IO.Packaging.Package>.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> do zasobu docelowego poza pakietem.  
  
 W ramach relacji "owner" relacji jest uważany za część źródła.  Po usunięciu części źródła wszystkie relacje, które są własnością części również zostaną usunięte.  Proces tworzenia lub usuwania relacji nie zmienia fizycznie część docelowa lub zasobu w dowolny sposób.  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> Metoda nie fizycznie zmienia część źródła lub część docelowa lub zasobu w dowolny sposób.  
  
 Element docelowy relacji nie może być w innej relacji.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` musi być względnym identyfikatorem URI, który został utworzony przy użyciu [ze standardem RFC 3986](https://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* Specyfikacja.  Wewnętrzny względny identyfikator URI może być albo ścieżkę bezwzględną rozpoczyna się od ukośnika ("/") znaków takich jak "/ page1.xaml" lub "/ images/picture4.jpg", lub ścieżką względną, takie jak "... / imagespicture1.jpg "który jest rozpoznawany jako przed głównym pakietu ("/ ") jako podstawowy identyfikator URI.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.External>, `targetUri` może być albo bezwzględnym lub względnym identyfikatorem URI utworzony zgodnie z [ze standardem RFC 3986](https://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji. `"https://www.microsoft.com/page2.xml"` znajduje się przykład bezwzględny identyfikator URI, który odwołuje się do zasobu docelowego zewnętrznego "page2.xml".  "images/picture1.jpg" jest przykładem względny identyfikator URI, który odwołuje się zewnętrznego docelowego zasobu "1.jpg" ale która rozwiązuje względem identyfikatora URI pakietu.  
  
 `relationshipType` musi być [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] który został utworzony zgodnie z opisem w [ze standardem RFC 3986](https://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji.  Typy inny pakiet można zdefiniować typy różnych części poziom relacji.  W poniższej tabeli przedstawiono poziom część `relationshipType` identyfikatory URI są zdefiniowane dla dokumentów, które są zgodne z *protokołu dynamicznej konfiguracji hosta (XPS, Open XML Paper Specification)*.  
  
|Relacja części na poziomie dokumentu XPS|Identyfikator URI typu relacji|  
|-------------------------------------------|---------------------------|  
|Definicje podpis cyfrowy|[http://schemas.microsoft.com/xps/2005/06/signature-definitions](https://schemas.microsoft.com/xps/2005/06/signature-definitions)|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|Wymagany zasób|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|Ograniczone czcionki|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 Aby uzyskać więcej informacji na temat relacji pakietu sekcji 1.3 *otwarte konwencje tworzenia pakietów (OPC)* specyfikacji pobrać <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 Aby dowiedzieć się więcej o XPS dokumenty zobacz *protokołu dynamicznej konfiguracji hosta (XPS, Open XML Paper Specification)* pobrać [ http://go.microsoft.com/fwlink/?LinkID=67000 ](https://go.microsoft.com/fwlink/?LinkID=67000).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> lub <paramref name="relationshipType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetMode" /> Parametr nie jest prawidłowym <see cref="T:System.IO.Packaging.TargetMode" /> wartość wyliczenia.</exception>
        <exception cref="T:System.ArgumentException">Część identyfikowane przez <paramref name="targetUri" /> relacji (element docelowy relacji nie może być innej relacji).  
  
—lub— 
 <paramref name="targetMode" /> jest określony jako <see cref="F:System.IO.Packaging.TargetMode.Internal" /> , ale <paramref name="targetUri" /> jest bezwzględny zewnętrznym [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu (nie można dodać nowej relacji).</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja konwencje Otwórz pakowania</related>
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części docelowej.</param>
        <param name="targetMode">Jedna z wartości wyliczenia. Na przykład <see cref="F:System.IO.Packaging.TargetMode.Internal" /> Jeśli część docelowa znajduje się wewnątrz <see cref="T:System.IO.Packaging.Package" />; lub <see cref="F:System.IO.Packaging.TargetMode.External" /> Jeśli element docelowy zasób poza <see cref="T:System.IO.Packaging.Package" />.</param>
        <param name="relationshipType">Rola relacji.</param>
        <param name="id">Unikatowy identyfikator dla relacji.</param>
        <summary>Tworzy relację między tą część poziom <see cref="T:System.IO.Packaging.PackagePart" /> do określonego obiektu docelowego <see cref="T:System.IO.Packaging.PackagePart" /> lub zasobów zewnętrznych.</summary>
        <returns>Część poziom relacji między tą <see cref="T:System.IO.Packaging.PackagePart" /> do obiektu docelowego <see cref="T:System.IO.Packaging.PackagePart" /> lub zasobów zewnętrznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziom część definiuje skojarzenie między tej części i część docelowa lub zasobu.  Relacja część poziom może być jedną z dwóch form.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> do obiektu docelowego <xref:System.IO.Packaging.PackagePart> wewnątrz <xref:System.IO.Packaging.Package>.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> do zasobu docelowego poza pakietem.  
  
 W ramach relacji "owner" relacji jest uważany za część źródła.  Po usunięciu części źródła wszystkie relacje, które są własnością części również zostaną usunięte.  Proces tworzenia lub usuwania relacji nie zmienia fizycznie część docelowa lub zasobu w dowolny sposób.  
  
 `id` Musi być prawidłowym identyfikatorem XML.  `id` Typ jest xsd:ID i musi zgodne z konwencjami nazewnictwa, które zostały określone w *XML schematu część 2: Typy danych* specyfikacji (zobacz [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> Metoda nie fizycznie zmienia część źródła lub część docelowa lub zasobu w dowolny sposób.  
  
 Element docelowy relacji nie może być w innej relacji.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` musi być względnym identyfikatorem URI, który został utworzony przy użyciu [ze standardem RFC 3986](https://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* Specyfikacja.  Wewnętrzny względny identyfikator URI może być albo ścieżkę bezwzględną rozpoczyna się od ukośnika ("/") znaków takich jak "/ page1.xaml" lub "/ images/picture4.jpg", lub ścieżką względną, takie jak "... / imagespicture1.jpg "który jest rozpoznawany jako przed głównym pakietu ("/ ") jako podstawowy identyfikator URI.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.External>, `targetUri` może być albo bezwzględnym lub względnym identyfikatorem URI utworzony zgodnie z [ze standardem RFC 3986](https://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji.  "https://www.microsoft.com/page2.xml" znajduje się przykład bezwzględny identyfikator URI, który odwołuje się do zasobu docelowego zewnętrznego "page2.xml".  "images/picture1.jpg" jest przykładem względny identyfikator URI, który odwołuje się zewnętrznego docelowego zasobu "1.jpg" ale która rozwiązuje względem identyfikatora URI pakietu.  
  
 `relationshipType` musi być [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] który został utworzony zgodnie z opisem w [ze standardem RFC 3986](https://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji.  Typy inny pakiet można zdefiniować typy różnych części poziom relacji.  W poniższej tabeli przedstawiono poziom część `relationshipType` identyfikatory URI są zdefiniowane dla dokumentów, które są zgodne z *protokołu dynamicznej konfiguracji hosta (XPS, Open XML Paper Specification)*.  
  
|Relacja części na poziomie dokumentu XPS|Identyfikator URI typu relacji|  
|-------------------------------------------|---------------------------|  
|Definicje podpis cyfrowy|http://schemas.microsoft.com/xps/2005/06/signature-definitions|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|Wymagany zasób|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|Ograniczone czcionki|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 Aby uzyskać więcej informacji na temat relacji pakietu sekcji 1.3 *otwarte konwencje tworzenia pakietów (OPC)* specyfikacji pobrać <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 Aby dowiedzieć się więcej o XPS dokumenty zobacz *protokołu dynamicznej konfiguracji hosta (XPS, Open XML Paper Specification)* pobrać [ http://go.microsoft.com/fwlink/?LinkID=67000 ](https://go.microsoft.com/fwlink/?LinkID=67000).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> lub <paramref name="relationshipType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetMode" /> Parametr nie jest prawidłowym <see cref="T:System.IO.Packaging.TargetMode" /> wartość wyliczenia.</exception>
        <exception cref="T:System.ArgumentException">Część identyfikowane przez <paramref name="targetUri" /> relacji (element docelowy relacji nie może być innej relacji).  
  
—lub— 
 <paramref name="targetMode" /> jest określony jako <see cref="F:System.IO.Packaging.TargetMode.Internal" /> , ale <paramref name="targetUri" /> jest bezwzględny zewnętrznym [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu (nie można dodać nowej relacji).</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> nie jest prawidłowym identyfikatorem XML.  
  
—lub— 
Element z określonym <paramref name="id" /> już istnieje.</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja konwencje Otwórz pakowania</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="packagePart.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Relacji do usunięcia.</param>
        <summary>Usuwa określony poziom część <see cref="T:System.IO.Packaging.PackageRelationship" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Musi być prawidłowym identyfikatorem XML.  `id` Typ jest xsd:ID i musi zgodne z konwencjami nazewnictwa, które zostały określone w *XML schematu część 2: Typy danych* specyfikacji (zobacz [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Jeśli określony `id` nie odpowiada <xref:System.IO.Packaging.PackageRelationship.Id%2A> dla każdej relacji, które należą do tej części relacja nie zostanie usunięty, a następnie jest zgłaszany żaden wyjątek.  
  
 Inne niż usunięcie określonej relacji <xref:System.IO.Packaging.PackagePart.DeleteRelationship%2A> metoda nie fizycznie zmienia tę część lub część docelowa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu (nie można usunąć relacji).</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> nie jest prawidłowym identyfikatorem XML.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetContentTypeCore">
      <MemberSignature Language="C#" Value="protected virtual string GetContentTypeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetContentTypeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetContentTypeCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetContentTypeCore () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetContentTypeCore();" />
      <MemberSignature Language="F#" Value="abstract member GetContentTypeCore : unit -&gt; string&#xA;override this.GetContentTypeCore : unit -&gt; string" Usage="packagePart.GetContentTypeCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po przesłonięciu w klasie pochodnej zwraca [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typ zawartości części.</summary>
        <returns>[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Typ zawartości części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A> jest metoda wirtualna <xref:System.IO.Packaging.PackagePart> abstrakcyjna klasa bazowa. Zaimplementować tę metodę tylko w typach pochodnych, gdzie wartość dla typu zawartości nie można podać w czasie tworzenia, lub jeśli typ zawartości do obliczania wartości jest operacją proste lub kosztowne. Zwracana wartość musi być prawidłowym [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typ zawartości.  
  
 Klasy pochodne mogą wywołać <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A> zainicjować <xref:System.IO.Packaging.PackagePart.ContentType%2A> właściwości klasy pochodnej na wartość domyślną.  Po <xref:System.IO.Packaging.PackagePart.ContentType%2A> została ustawiona właściwość go nie można jej zmienić.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Klasa pochodna nie zapewnia wymaganych do implementacji zastąpienie <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Relacji do zwrócenia.</param>
        <summary>Zwraca relację, która ma określoną <see cref="P:System.IO.Packaging.PackageRelationship.Id" />.</summary>
        <returns>Relacja, który jest zgodny z określonym <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Musi być prawidłowym identyfikatorem XML.  `id` Typ jest xsd:ID i musi zgodne z konwencjami nazewnictwa, które zostały określone w *XML schematu część 2: Typy danych* specyfikacji (zobacz [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Możesz użyć <xref:System.IO.Packaging.PackagePart.RelationshipExists%2A> metodę, aby określić, czy relacja z określonym <xref:System.IO.Packaging.PackageRelationship.Id%2A> należące do tej części.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> nie jest prawidłowym identyfikatorem XML.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="relationshipType" /> jest ciągiem pustym.</exception>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).  
  
—lub— 
Relacja z określonym <paramref name="id" /> nie istnieje w pakiecie.</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji o relacji).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="packagePart.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję wszystkie relacje, które należą do tej części.</summary>
        <returns>Kolekcja wszystkie relacje, które są własnością części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nigdy nie jest zwrócona Kolekcja `null`; jednak Kolekcja może zawierać żadnego elementu, jeśli część nie definiuje żadnych relacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji o relacji).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="packagePart.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType"><see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> Relacji do lokalizowania i zwracać w kolekcji.</param>
        <summary>Zwraca kolekcję obiektów, które odpowiadają określonej relacji <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />.</summary>
        <returns>Kolekcja relacje, które odpowiadają określonej <paramref name="relationshipType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nigdy nie jest zwrócona Kolekcja `null`; jednak Kolekcja może zawierać żadnego elementu, jeśli relacje nie są zgodne z określonym `relationshipType` zdefiniowanego dla części.  
  
 Żadnych spacji wiodących albo końcowych w `relationshipType` ciągu są automatycznie usuwane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relationshipType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="relationshipType" /> jest ciągiem pustym.</exception>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji o relacji).</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja konwencje Otwórz pakowania</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca część strumienia danych zawartości.</summary>
        <block subset="none" type="usage"><para>
            <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> wywołuje wewnętrznie pochodnej <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metoda faktycznie otworzyć i zwrócić strumień danych część oparta na fizyczny format zaimplementowaniu w klasie pochodnej.  
  
Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> podklasy implementację abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> ma być dostarczana i używane przez klasy.  W operacji domyślne <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> wywołuje wewnętrznie <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> z <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasy, aby otworzyć i zwraca część strumienia danych z pliku ZIP.</para></block>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream();" />
      <MemberSignature Language="F#" Value="member this.GetStream : unit -&gt; System.IO.Stream" Usage="packagePart.GetStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca część strumienia danych zawartości.</summary>
        <returns>Strumień danych zawartości dla części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zostanie otwarty strumień zawartości za pomocą <xref:System.IO.FileMode> z <xref:System.IO.FileMode.OpenOrCreate> i <xref:System.IO.FileAccess> uprawnienia, które są takie same jak w elemencie nadrzędnym <xref:System.IO.Packaging.Package>.  
  
 Przeciążenie <xref:System.IO.Packaging.PackagePart.GetStream%2A> metoda umożliwia ustawienie określonej <xref:System.IO.FileMode>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Obiekt Strumień zwrócony przez <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metoda klasy pochodnej jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream" /> wywołuje wewnętrznie pochodnej <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metoda faktycznie otworzyć i zwrócić strumień danych część oparta na fizyczny format zaimplementowaniu w klasie pochodnej.  
  
Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> podklasy implementację abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> ma być dostarczana i używane przez klasy.  W operacji domyślne <see cref="M:System.IO.Packaging.PackagePart.GetStream" /> wywołuje wewnętrznie <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> z <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasy, aby otworzyć i zwraca część strumienia danych z pliku ZIP.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="member this.GetStream : System.IO.FileMode -&gt; System.IO.Stream" Usage="packagePart.GetStream mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">Tryb We/Wy, w którym można otworzyć strumienia zawartości.</param>
        <summary>Zwraca zawartość strumienia otwarty w określonej operacji We/Wy <see cref="T:System.IO.FileMode" />.</summary>
        <returns>Strumień zawartości części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileAccess> Uprawnienia zwrócony strumień zawartości są takie same, jak uprawnienia elementu nadrzędnego <xref:System.IO.Packaging.Package>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> Parametr nie jest prawidłowym <see cref="T:System.IO.FileMode" /> wartość wyliczenia.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mode" /> Parametr nie jest zgodny z pakietu i części strumienia.  
  
—lub— 
Obiekt Strumień zwrócony przez <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metoda klasy pochodnej jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" /> wywołuje wewnętrznie pochodnej <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metoda faktycznie otworzyć i zwrócić strumień danych część oparta na fizyczny format zaimplementowaniu w klasie pochodnej.  
  
Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> podklasy implementację abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> ma być dostarczana i używane przez klasy.  W operacji domyślne <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" /> wywołuje wewnętrznie <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> z <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasy, aby otworzyć i zwraca część strumienia danych z pliku ZIP.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.GetStream : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Stream" Usage="packagePart.GetStream (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">Tryb We/Wy, w którym można otworzyć strumienia zawartości.</param>
        <param name="access">Uprawnienia dostępu do użycia podczas otwierania strumienia zawartości.</param>
        <summary>Zwraca część strumienia zawartości otwarty z określonym <see cref="T:System.IO.FileMode" /> i <see cref="T:System.IO.FileAccess" />.</summary>
        <returns>Strumień zawartości części.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> Parametr nie jest prawidłowym <see cref="T:System.IO.FileMode" /> wartość wyliczenia.  
  
—lub— 
<paramref name="access" /> Parametr nie jest prawidłowym <see cref="T:System.IO.FileAccess" /> wartość wyliczenia.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mode" /> lub <paramref name="access" /> nie jest zgodny z pakietu i części strumienia.  
  
—lub— 
<paramref name="access" /> Parametr jest określony jako <see cref="F:System.IO.FileAccess.Read" /> ale <paramref name="mode" /> parametr wymaga dostępu do zapisu.  (<see cref="T:System.IO.FileMode" /> wartości <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, <see cref="F:System.IO.FileMode.Truncate" />, i <see cref="F:System.IO.FileMode.Append" /> wymagają <see cref="F:System.IO.FileAccess.Write" /> lub <see cref="F:System.IO.FileAccess.ReadWrite" /> dostępu.) 
—lub— 
Obiekt Strumień zwrócony przez <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metoda klasy pochodnej jest <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" /> wywołuje wewnętrznie pochodnej <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metoda faktycznie otworzyć i zwrócić strumień danych część oparta na fizyczny format zaimplementowaniu w klasie pochodnej.  
  
Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> podklasy implementację abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> ma być dostarczana i używane przez klasy.  W operacji domyślne <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" /> wywołuje wewnętrznie <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> z <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasy, aby otworzyć i zwraca część strumienia danych z pliku ZIP.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetStreamCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Stream GetStreamCore (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Stream GetStreamCore(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetStreamCore (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Stream ^ GetStreamCore(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="abstract member GetStreamCore : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Stream" Usage="packagePart.GetStreamCore (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">Tryb We/Wy, w którym można otworzyć strumienia zawartości.</param>
        <param name="access">Uprawnienia dostępu do użycia podczas otwierania strumienia zawartości.</param>
        <summary>Po przesłonięciu w klasie pochodnej zwraca strumień zawartości części otwarty z określonym <see cref="T:System.IO.FileMode" /> i <see cref="T:System.IO.FileAccess" />.</summary>
        <returns>Strumień danych zawartości części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje nie powinien wywoływać <xref:System.IO.Packaging.PackagePart.GetStreamCore%2A> bezpośrednio, ale zamiast tego należy wywołać <xref:System.IO.Packaging.PackagePart.GetStream%2A>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Pochodnej <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> implementacji należy wprowadzić nie założeń dotyczących kolejności lub operacji wykonywanych przez <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> metody, który ją wywołuje.</para></block>
        <block subset="none" type="usage"><para>Pochodnej <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metoda jest wywoływana przez <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> metody, aby otworzyć i zwrócić strumień danych część oparte na fizyczny format zaimplementowaniu w klasie pochodnej.  
  
Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> podklasy implementację abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> ma być dostarczana i używane przez klasy.  W operacji domyślne <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> wywołuje wewnętrznie <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> z <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasy, aby otworzyć i zwraca część strumienia danych z pliku ZIP.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Package">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.Package Package { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.Package Package" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Package" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Package As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::Package ^ Package { System::IO::Packaging::Package ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Package : System.IO.Packaging.Package" Usage="System.IO.Packaging.PackagePart.Package" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element nadrzędny <see cref="T:System.IO.Packaging.Package" /> części.</summary>
        <value>Pakiet nadrzędnej części.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Package%2A> jest właściwością tylko do odczytu, która jest możliwy tylko wtedy, gdy element nadrzędny <xref:System.IO.Packaging.Package> jest otwarty.  
  
 <xref:System.IO.Packaging.PackagePart.Package%2A> Właściwość jest automatycznie ustawiana przez <xref:System.IO.Packaging.PackagePart.%23ctor%2A> konstruktora.  Po ustawieniu przez konstruktora obiektu nadrzędnego <xref:System.IO.Packaging.PackagePart.Package%2A> dla części nie można jej zmienić.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="packagePart.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Relacji do wyszukania.</param>
        <summary>Zwraca wartość wskazującą, czy ta część jest właścicielem relacji z określonym <see cref="P:System.IO.Packaging.PackageRelationship.Id" />.</summary>
        <returns><see langword="true" /> Jeśli ta część jest właścicielem relację z danym <paramref name="id" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Musi być prawidłowym identyfikatorem XML.  `id` Typ jest xsd:ID i musi zgodne z konwencjami nazewnictwa, które zostały określone w *XML schematu część 2: Typy danych* specyfikacji (zobacz [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> nie jest prawidłowym identyfikatorem XML.</exception>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji o relacji).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Uri">
      <MemberSignature Language="C#" Value="public Uri Uri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Uri" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Uri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Uri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Uri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Uri : Uri" Usage="System.IO.Packaging.PackagePart.Uri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] części.</summary>
        <value>[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części względem katalogu głównego pakietu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Uri%2A> jest właściwością tylko do odczytu, która jest możliwy tylko wtedy, gdy element nadrzędny <xref:System.IO.Packaging.Package> jest otwarty.  
  
 <xref:System.IO.Packaging.PackagePart.Uri%2A> Właściwość jest automatycznie ustawiana przez <xref:System.IO.Packaging.PackagePart.%23ctor%2A> konstruktora.  Po ustawieniu przez konstruktora, <xref:System.IO.Packaging.PackagePart.Uri%2A> części nie można jej zmienić.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Część została usunięta.  
  
—lub— 
<see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ComparePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
  </Members>
</Type>
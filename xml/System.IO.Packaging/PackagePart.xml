<Type Name="PackagePart" FullName="System.IO.Packaging.PackagePart">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="154c70fa5276cdccac41f7e7f56b00b2e5fd1bb9" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33682762" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PackagePart" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PackagePart extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.PackagePart" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PackagePart" />
  <TypeSignature Language="C++ CLI" Value="public ref class PackagePart abstract" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia klasę podstawową dla części przechowywanego w <see cref="T:System.IO.Packaging.Package" />.  Ta klasa jest abstrakcyjna.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.IO.Packaging.PackagePart> składa się z trzech podstawowych elementów:  
  
|Access|Opis|  
|------------|-----------------|  
|<xref:System.IO.Packaging.PackagePart.Uri%2A>|[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części.|  
|<xref:System.IO.Packaging.PackagePart.ContentType%2A>|[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Typ zawartości strumienia.|  
|<xref:System.IO.Packaging.PackagePart.GetStream%2A>|Strumień danych zawartości części.|  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Packaging.PackagePart" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Pakowanie URI w WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)  
  
 [Otwarte konwencje specyfikacji pakietów](http://go.microsoft.com/fwlink/?LinkID=71255)  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="package">Element nadrzędny <see cref="T:System.IO.Packaging.Package" /> części.</param>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części względem nadrzędnego <see cref="T:System.IO.Packaging.Package" /> głównego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Packaging.PackagePart" /> klasy z określonego elementu nadrzędnego <see cref="P:System.IO.Packaging.PackagePart.Package" /> i [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` musi być prawidłowym <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] sformatowany zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji i [Otwórz pakowania Konwencje](http://go.microsoft.com/fwlink/?LinkID=71255) specyfikacji.  
  
 Użyj tego konstruktora podczas <xref:System.IO.Packaging.PackagePart.ContentType%2A> części nie jest od razu znana i zostanie ustawiona później podczas <xref:System.IO.Packaging.Package.CreatePart%2A> jest wywoływana.  
  
 Domyślnie <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> właściwość części jest inicjowana na <xref:System.IO.Packaging.CompressionOption.NotCompressed>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="package" /> lub <paramref name="partUri" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="package">Element nadrzędny <see cref="T:System.IO.Packaging.Package" /> części.</param>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części względem nadrzędnego <see cref="T:System.IO.Packaging.Package" /> głównego.</param>
        <param name="contentType">[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Typ strumienia danych części zawartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Packaging.PackagePart" /> klasy z określonego elementu nadrzędnego <see cref="P:System.IO.Packaging.PackagePart.Package" />, część [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)], i [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typ zawartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` musi być prawidłowym <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] sformatowany zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji i [Otwórz pakowania Konwencje](http://go.microsoft.com/fwlink/?LinkID=71255) specyfikacji.  
  
 Domyślnie <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> właściwość części jest inicjowana na <xref:System.IO.Packaging.CompressionOption.NotCompressed>.  
  
 `contentType` musi być [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typu sformatowany zgodnie z [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol - HTTP*, 3.7 sekcji.  W poniższej tabeli przedstawiono przykład zawartość [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typów używanych w [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentów.  
  
|Opis|Typ zawartości|  
|-----------------|------------------|  
|Czcionki|application/vnd.ms-opentype|  
|Profil ICC|application/vnd.ms-color.iccprofile|  
|Obraz JPEG|image/jpeg|  
|Zasłoniętych czcionek|application/vnd.ms-package.obfuscated-opentype|  
|Format PNG|image/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|Obrazu TIFF|obraz/tiff|  
|Obraz w formacie Windows Media Photo|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="package" /> lub <paramref name="partUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> nie jest prawidłową <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="package">Element nadrzędny <see cref="T:System.IO.Packaging.Package" /> części.</param>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części względem nadrzędnego <see cref="T:System.IO.Packaging.Package" /> głównego.</param>
        <param name="contentType">[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Typ części danych strumienia zawartości.</param>
        <param name="compressionOption">Opcję kompresji części strumienia danych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Packaging.PackagePart" /> klasy z określonego elementu nadrzędnego <see cref="P:System.IO.Packaging.PackagePart.Package" />, część [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)], [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typu zawartości i <see cref="T:System.IO.Packaging.CompressionOption" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` musi być prawidłowym <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] sformatowany zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji i [Otwórz pakowania Konwencje](http://go.microsoft.com/fwlink/?LinkID=71255) specyfikacji.  
  
 `contentType` musi być [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typu sformatowany zgodnie z [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol - HTTP*, 3.7 sekcji.  W poniższej tabeli przedstawiono przykład zawartość [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typów używanych w [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentów.  
  
|Opis|Typ zawartości|  
|-----------------|------------------|  
|Czcionki|application/vnd.ms-opentype|  
|Profil ICC|application/vnd.ms-color.iccprofile|  
|Obraz JPEG|image/jpeg|  
|Zasłoniętych czcionek|application/vnd.ms-package.obfuscated-opentype|  
|Format PNG|image/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|Obrazu TIFF|obraz/tiff|  
|Obraz w formacie Windows Media Photo|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="package" /> lub <paramref name="partUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> nie jest prawidłową <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="compressionOption" /> Wartość jest nieprawidłowa.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="CompressionOption">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.CompressionOption CompressionOption { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Packaging.CompressionOption CompressionOption" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.CompressionOption" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompressionOption As CompressionOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::CompressionOption CompressionOption { System::IO::Packaging::CompressionOption get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.CompressionOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera opcję kompresji części strumienia zawartości.</summary>
        <value>Opcję kompresji części strumienia zawartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> jest właściwością tylko do odczytu, która jest możliwy tylko wtedy, gdy element nadrzędny <xref:System.IO.Packaging.Package> jest otwarty.  
  
 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> Właściwość jest automatycznie ustawiana przez <xref:System.IO.Packaging.PackagePart.%23ctor%2A> konstruktora.  Po ustawieniu przez konstruktora, <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> nie można zmienić.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typ zawartości strumienia.</summary>
        <value>[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Typu strumienia danych zawartości dla części.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> jest właściwością tylko do odczytu, która jest możliwy tylko wtedy, gdy element nadrzędny <xref:System.IO.Packaging.Package> jest otwarty.  
  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> Właściwość jest automatycznie ustawiana przez <xref:System.IO.Packaging.PackagePart.%23ctor%2A> konstruktora.  Po ustawieniu przez konstruktora, <xref:System.IO.Packaging.PackagePart.ContentType%2A> nie można zmienić.  
  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> Właściwość jest [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typu sformatowany zgodnie z [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol - HTTP*, 3.7 sekcji.  W poniższej tabeli przedstawiono przykład zawartość [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typów używanych w [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentów.  
  
|Opis|Typ zawartości|  
|-----------------|------------------|  
|Czcionki|application/vnd.ms-opentype|  
|Profil ICC|application/vnd.ms-color.iccprofile|  
|Obraz JPEG|image/jpeg|  
|Zasłoniętych czcionek|application/vnd.ms-package.obfuscated-opentype|  
|Format PNG|image/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|Obrazu TIFF|obraz/tiff|  
|Obraz w formacie Windows Media Photo|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).  
  
 —lub—  
  
 Długość ciągu zwróconego przez klasy pochodnej <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" /> metody jest pusta.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy poziom części relację między to <see cref="T:System.IO.Packaging.PackagePart" /> do określonego obiektu docelowego <see cref="T:System.IO.Packaging.PackagePart" /> lub zewnętrznego zasobu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja części poziomie definiuje skojarzenie między tej części i części docelowej lub zasobu.  Poziom części relacji może być jedną z dwóch formach.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> do obiektu docelowego <xref:System.IO.Packaging.PackagePart> wewnątrz <xref:System.IO.Packaging.Package>.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> do zasobu docelowego poza pakietem.  
  
 W ramach relacji "właściciela" relacji jest traktowany jako część źródła.  Po usunięciu części źródła są także usuwane wszystkie relacje, które są własnością części.  Proces tworzenia lub usuwania relacji nie zmienia fizycznie części docelowej lub zasobu w dowolny sposób.  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> — Metoda nie fizycznie zmienić element źródłowy lub docelowy part lub zasobu w dowolny sposób.  
  
 Element docelowy relacji nie może być w innej relacji.  
  
 Aby uzyskać więcej informacji na temat relacji pakietu sekcji 1.3 *otwarte konwencje pakietów (OPC)* specyfikacji pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 Dla więcej informacji na temat XPS dokumentów zobacz *protokołu dynamicznej konfiguracji hosta (XPS, Open XML Paper Specification)* pobrać [ http://go.microsoft.com/fwlink/?LinkID=67000 ](http://go.microsoft.com/fwlink/?LinkID=67000).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części docelowej.</param>
        <param name="targetMode">Jedna z wartości wyliczenia. Na przykład <see cref="F:System.IO.Packaging.TargetMode.Internal" /> Jeśli element docelowy znajduje się wewnątrz <see cref="T:System.IO.Packaging.Package" />; lub <see cref="F:System.IO.Packaging.TargetMode.External" /> Jeśli elementem docelowym jest zasobem poza <see cref="T:System.IO.Packaging.Package" />.</param>
        <param name="relationshipType">Rola relacji.</param>
        <summary>Tworzy poziom części relację między to <see cref="T:System.IO.Packaging.PackagePart" /> do określonego obiektu docelowego <see cref="T:System.IO.Packaging.PackagePart" /> lub zewnętrznego zasobu.</summary>
        <returns>Poziom części relacji to <see cref="T:System.IO.Packaging.PackagePart" /> do obiektu docelowego <see cref="T:System.IO.Packaging.PackagePart" /> lub zewnętrznego zasobu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja części poziomie definiuje skojarzenie między tej części i części docelowej lub zasobu.  Poziom części relacji może być jedną z dwóch formach.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> do obiektu docelowego <xref:System.IO.Packaging.PackagePart> wewnątrz <xref:System.IO.Packaging.Package>.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> do zasobu docelowego poza pakietem.  
  
 W ramach relacji "właściciela" relacji jest traktowany jako część źródła.  Po usunięciu części źródła są także usuwane wszystkie relacje, które są własnością części.  Proces tworzenia lub usuwania relacji nie zmienia fizycznie części docelowej lub zasobu w dowolny sposób.  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> — Metoda nie fizycznie zmienić element źródłowy lub docelowy part lub zasobu w dowolny sposób.  
  
 Element docelowy relacji nie może być w innej relacji.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` musi być względnym identyfikatorem URI, który został utworzony przy użyciu [RFC 3986](http://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* Specyfikacja.  Wewnętrzny względnego identyfikatora URI może być albo ścieżkę bezwzględną, która rozpoczyna się od ukośnika ("/") znaków takich jak "/ page1.xaml" lub "/ images/picture4.jpg", lub ścieżką względną, takie jak "... / imagespicture1.jpg "rozwiązań przed katalog główny pakietu ("/ ") jako podstawowy identyfikator URI.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.External>, `targetUri` może być albo bezwzględnym lub względnym identyfikatorem URI utworzony zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji.  "http://www.microsoft.com/page2.xml" jest przykładem bezwzględny identyfikator URI, który odwołuje się do zasobu docelowego zewnętrzne "page2.xml".  Przykładem względnym identyfikatorem URI również odwołuje się do docelowego zewnętrznych zasobów "1.jpg" ale która rozwiązuje względem adresu URI pakietu jest "images/picture1.jpg".  
  
 `relationshipType` musi być [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] który został utworzony zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji.  Typy pakietów różnych można zdefiniować typy różnych części poziom relacji.  W poniższej tabeli przedstawiono część poziomie `relationshipType` identyfikatorów URI zdefiniowane dla dokumentów, które odpowiadają *protokołu dynamicznej konfiguracji hosta (XPS, Open XML Paper Specification)*.  
  
|Relacja poziom części dokumentu XPS|Identyfikator URI typu relacji|  
|-------------------------------------------|---------------------------|  
|Definicje podpis cyfrowy|[http://schemas.microsoft.com/xps/2005/06/signature-definitions](http://schemas.microsoft.com/xps/2005/06/signature-definitions)|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|Wymagany zasób|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|RESTRICTED Font|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 Aby uzyskać więcej informacji na temat relacji pakietu sekcji 1.3 *otwarte konwencje pakietów (OPC)* specyfikacji pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 Dla więcej informacji na temat XPS dokumentów zobacz *protokołu dynamicznej konfiguracji hosta (XPS, Open XML Paper Specification)* pobrać [ http://go.microsoft.com/fwlink/?LinkID=67000 ](http://go.microsoft.com/fwlink/?LinkID=67000).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> lub <paramref name="relationshipType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="targetMode" /> Parametru nie jest prawidłową <see cref="T:System.IO.Packaging.TargetMode" /> wartości wyliczenia.</exception>
        <exception cref="T:System.ArgumentException">Część identyfikowane przez <paramref name="targetUri" /> Relacja (element docelowy relacji nie może być innej relacji).  
  
 —lub—  
  
 <paramref name="targetMode" /> jest określony jako <see cref="F:System.IO.Packaging.TargetMode.Internal" /> , ale <paramref name="targetUri" /> jest bezwzględny zewnętrznym [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu (nie można dodać nowej relacji).</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części docelowej.</param>
        <param name="targetMode">Jedna z wartości wyliczenia. Na przykład <see cref="F:System.IO.Packaging.TargetMode.Internal" /> Jeśli element docelowy znajduje się wewnątrz <see cref="T:System.IO.Packaging.Package" />; lub <see cref="F:System.IO.Packaging.TargetMode.External" /> Jeśli elementem docelowym jest zasobem poza <see cref="T:System.IO.Packaging.Package" />.</param>
        <param name="relationshipType">Rola relacji.</param>
        <param name="id">Unikatowy identyfikator dla tej relacji.</param>
        <summary>Tworzy poziom części relację między to <see cref="T:System.IO.Packaging.PackagePart" /> do określonego obiektu docelowego <see cref="T:System.IO.Packaging.PackagePart" /> lub zewnętrznego zasobu.</summary>
        <returns>Poziom części relacji to <see cref="T:System.IO.Packaging.PackagePart" /> do obiektu docelowego <see cref="T:System.IO.Packaging.PackagePart" /> lub zewnętrznego zasobu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja części poziomie definiuje skojarzenie między tej części i części docelowej lub zasobu.  Poziom części relacji może być jedną z dwóch formach.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> do obiektu docelowego <xref:System.IO.Packaging.PackagePart> wewnątrz <xref:System.IO.Packaging.Package>.  
  
-   Między źródłem <xref:System.IO.Packaging.PackagePart> do zasobu docelowego poza pakietem.  
  
 W ramach relacji "właściciela" relacji jest traktowany jako część źródła.  Po usunięciu części źródła są także usuwane wszystkie relacje, które są własnością części.  Proces tworzenia lub usuwania relacji nie zmienia fizycznie części docelowej lub zasobu w dowolny sposób.  
  
 `id` Musi być prawidłowym identyfikatorem XML.  `id` Typu jest xsd:ID i wykonaj konwencje nazewnictwa określonych w *XML schematu część 2: typy danych* specyfikacji (zobacz [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> — Metoda nie fizycznie zmienić element źródłowy lub docelowy part lub zasobu w dowolny sposób.  
  
 Element docelowy relacji nie może być w innej relacji.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` musi być względnym identyfikatorem URI, który został utworzony przy użyciu [RFC 3986](http://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* Specyfikacja.  Wewnętrzny względnego identyfikatora URI może być albo ścieżkę bezwzględną, która rozpoczyna się od ukośnika ("/") znaków takich jak "/ page1.xaml" lub "/ images/picture4.jpg", lub ścieżką względną, takie jak "... / imagespicture1.jpg "rozwiązań przed katalog główny pakietu ("/ ") jako podstawowy identyfikator URI.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.External>, `targetUri` może być albo bezwzględnym lub względnym identyfikatorem URI utworzony zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji.  "http://www.microsoft.com/page2.xml" jest przykładem bezwzględny identyfikator URI, który odwołuje się do zasobu docelowego zewnętrzne "page2.xml".  Przykładem względnym identyfikatorem URI również odwołuje się do docelowego zewnętrznych zasobów "1.jpg" ale która rozwiązuje względem adresu URI pakietu jest "images/picture1.jpg".  
  
 `relationshipType` musi być [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] który został utworzony zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) *ogólna składnia identyfikatora URI (Uniform Resource)* specyfikacji.  Typy pakietów różnych można zdefiniować typy różnych części poziom relacji.  W poniższej tabeli przedstawiono część poziomie `relationshipType` identyfikatorów URI zdefiniowane dla dokumentów, które odpowiadają *protokołu dynamicznej konfiguracji hosta (XPS, Open XML Paper Specification)*.  
  
|Relacja poziom części dokumentu XPS|Identyfikator URI typu relacji|  
|-------------------------------------------|---------------------------|  
|Definicje podpis cyfrowy|http://schemas.microsoft.com/xps/2005/06/signature-definitions|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|Wymagany zasób|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|RESTRICTED Font|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 Aby uzyskać więcej informacji na temat relacji pakietu sekcji 1.3 *otwarte konwencje pakietów (OPC)* specyfikacji pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 Dla więcej informacji na temat XPS dokumentów zobacz *protokołu dynamicznej konfiguracji hosta (XPS, Open XML Paper Specification)* pobrać [ http://go.microsoft.com/fwlink/?LinkID=67000 ](http://go.microsoft.com/fwlink/?LinkID=67000).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> lub <paramref name="relationshipType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="targetMode" /> Parametru nie jest prawidłową <see cref="T:System.IO.Packaging.TargetMode" /> wartości wyliczenia.</exception>
        <exception cref="T:System.ArgumentException">Część identyfikowane przez <paramref name="targetUri" /> Relacja (element docelowy relacji nie może być innej relacji).  
  
 —lub—  
  
 <paramref name="targetMode" /> jest określony jako <see cref="F:System.IO.Packaging.TargetMode.Internal" /> , ale <paramref name="targetUri" /> jest bezwzględny zewnętrznym [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu (nie można dodać nowej relacji).</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> nie jest prawidłowym identyfikatorem XML.  
  
 —lub—  
  
 Element z określonym <paramref name="id" /> już istnieje.</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Relacji do usunięcia.</param>
        <summary>Usuwa określony poziom części <see cref="T:System.IO.Packaging.PackageRelationship" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Musi być prawidłowym identyfikatorem XML.  `id` Typu jest xsd:ID i wykonaj konwencje nazewnictwa określonych w *XML schematu część 2: typy danych* specyfikacji (zobacz [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Jeśli określony `id` niezgodny <xref:System.IO.Packaging.PackageRelationship.Id%2A> dla żadnej z relacji, które należą do tej części relacja nie zostanie usunięta i nie jest wyjątek.  
  
 Inne niż usunięcie określonej relacji <xref:System.IO.Packaging.PackagePart.DeleteRelationship%2A> — metoda nie fizycznie zmienia tej części lub element docelowy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu (nie można usunąć relacji).</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> nie jest prawidłowym identyfikatorem XML.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetContentTypeCore">
      <MemberSignature Language="C#" Value="protected virtual string GetContentTypeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetContentTypeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetContentTypeCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetContentTypeCore () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetContentTypeCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po przesłonięciu w klasie pochodnej zwraca [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typu zawartości części.</summary>
        <returns>[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] Typu zawartości części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A> jest metoda wirtualna <xref:System.IO.Packaging.PackagePart> abstrakcyjnej klasy podstawowej. Zaimplementuj tę metodę, tylko w typach pochodnych, której nie można podać wartość dla typu zawartości podczas konstruowania lub wpisz Obliczanie zawartości wartości jest to proste lub kosztowna operacja. Zwracana wartość musi być prawidłową [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] typ zawartości.  
  
 Klasy pochodne mogą wywoływać <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A> zainicjować <xref:System.IO.Packaging.PackagePart.ContentType%2A> właściwości klasy pochodnej na wartość domyślną.  Po <xref:System.IO.Packaging.PackagePart.ContentType%2A> właściwość została ustawiona go nie można zmienić.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Klasa pochodna nie dostarcza implementację przesłonięcia wymagane dla <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Relacji do zwrócenia.</param>
        <summary>Zwraca relacji, która ma określoną <see cref="P:System.IO.Packaging.PackageRelationship.Id" />.</summary>
        <returns>Relacji, która jest zgodna z określoną <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Musi być prawidłowym identyfikatorem XML.  `id` Typu jest xsd:ID i wykonaj konwencje nazewnictwa określonych w *XML schematu część 2: typy danych* specyfikacji (zobacz [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Można użyć <xref:System.IO.Packaging.PackagePart.RelationshipExists%2A> metodę, aby określić, czy relacja z określonym <xref:System.IO.Packaging.PackageRelationship.Id%2A> należących do tej części.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> nie jest prawidłowym identyfikatorem XML.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" /> jest pustym ciągiem.</exception>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).  
  
 —lub—  
  
 Relacja z określonym <paramref name="id" /> nie istnieje w pakiecie.</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji relacji).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję wszystkie relacje, które należą do tej części.</summary>
        <returns>Kolekcja wszystkie relacje, które należą do firmy przez część.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nigdy nie jest zwracana Kolekcja `null`; jednak kolekcji może zawierać żadnego elementu, jeśli element nie definiuje żadnych relacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji relacji).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">
          <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> Relacji do lokalizowania i zwracany w kolekcji.</param>
        <summary>Zwraca kolekcję relacje, które odpowiada określonym <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />.</summary>
        <returns>Kolekcja relacje, które pasują do określonego <paramref name="relationshipType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nigdy nie jest zwracana Kolekcja `null`; jednak kolekcji może zawierać żadnego elementu, jeśli brak relacji odpowiada określonym `relationshipType` zdefiniowanego dla części.  
  
 Wszelkie początkowe lub końcowe spacje w `relationshipType` ciągu są automatycznie usuwane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" /> jest pustym ciągiem.</exception>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji relacji).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca część strumienia danych zawartości.</summary>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> wewnętrznie wywołuje pochodnej <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metodę faktycznie otworzyć i zwraca część strumienia danych na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.  
  
 Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementacja podklasą klasy abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> klasa ma być dostarczana i używane.  W operacji domyślne <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> wewnętrznie wywołuje <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> z <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasę, aby otworzyć i zwracanie części strumienia danych z pliku ZIP.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca część strumienia danych zawartości.</summary>
        <returns>Strumień danych zawartości dla części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powoduje otwarcie strumień zawartości z <xref:System.IO.FileMode> z <xref:System.IO.FileMode.OpenOrCreate> i <xref:System.IO.FileAccess> uprawnienia, które są takie same, co element nadrzędny <xref:System.IO.Packaging.Package>.  
  
 Przeciążenie <xref:System.IO.Packaging.PackagePart.GetStream%2A> metody umożliwia ustawienie określonej <xref:System.IO.FileMode>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Obiekt Strumień zwrócony przez <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> jest metoda pochodna podklasy <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream" /> wewnętrznie wywołuje pochodnej <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metodę faktycznie otworzyć i zwraca część strumienia danych na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.  
  
 Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementacja podklasą klasy abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> klasa ma być dostarczana i używane.  W operacji domyślne <see cref="M:System.IO.Packaging.PackagePart.GetStream" /> wewnętrznie wywołuje <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> z <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasę, aby otworzyć i zwracanie części strumienia danych z pliku ZIP.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">Tryb operacji We/Wy, w której można otworzyć strumienia zawartości.</param>
        <summary>Zwraca strumień zawartości otwarty w określonym we/wy <see cref="T:System.IO.FileMode" />.</summary>
        <returns>Strumień zawartości części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileAccess> Uprawnienia zwrócony strumień zawartości są takie same, jak uprawnienia nadrzędnego <xref:System.IO.Packaging.Package>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> Parametru nie jest prawidłową <see cref="T:System.IO.FileMode" /> wartości wyliczenia.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mode" /> Parametr nie jest zgodny z pakietu i części strumienia.  
  
 —lub—  
  
 Obiekt Strumień zwrócony przez <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> jest metoda pochodna podklasy <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" /> wewnętrznie wywołuje pochodnej <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metodę faktycznie otworzyć i zwraca część strumienia danych na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.  
  
 Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementacja podklasą klasy abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> klasa ma być dostarczana i używane.  W operacji domyślne <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" /> wewnętrznie wywołuje <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> z <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasę, aby otworzyć i zwracanie części strumienia danych z pliku ZIP.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">Tryb operacji We/Wy, w której można otworzyć strumienia zawartości.</param>
        <param name="access">Uprawnienia dostępu do używania podczas otwierania strumienia zawartości.</param>
        <summary>Zwraca część strumień zawartości otwarty z określonym <see cref="T:System.IO.FileMode" /> i <see cref="T:System.IO.FileAccess" />.</summary>
        <returns>Strumień zawartości dla części.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> Parametru nie jest prawidłową <see cref="T:System.IO.FileMode" /> wartości wyliczenia.  
  
 —lub—  
  
 <paramref name="access" /> Parametru nie jest prawidłową <see cref="T:System.IO.FileAccess" /> wartości wyliczenia.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mode" /> lub <paramref name="access" /> nie jest zgodny z pakietu i części strumienia.  
  
 —lub—  
  
 <paramref name="access" /> Parametr jest określony jako <see cref="F:System.IO.FileAccess.Read" /> , ale <paramref name="mode" /> parametr wymaga dostępu do zapisu.  (<see cref="T:System.IO.FileMode" /> wartości <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, <see cref="F:System.IO.FileMode.Truncate" />, i <see cref="F:System.IO.FileMode.Append" /> wymagają <see cref="F:System.IO.FileAccess.Write" /> lub <see cref="F:System.IO.FileAccess.ReadWrite" /> dostępu.)  
  
 —lub—  
  
 Obiekt Strumień zwrócony przez <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> jest metoda pochodna podklasy <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" /> wewnętrznie wywołuje pochodnej <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metodę faktycznie otworzyć i zwraca część strumienia danych na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.  
  
 Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementacja podklasą klasy abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> klasa ma być dostarczana i używane.  W operacji domyślne <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" /> wewnętrznie wywołuje <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> z <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasę, aby otworzyć i zwracanie części strumienia danych z pliku ZIP.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetStreamCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Stream GetStreamCore (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Stream GetStreamCore(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetStreamCore (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Stream ^ GetStreamCore(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">Tryb operacji We/Wy, w której można otworzyć strumienia zawartości.</param>
        <param name="access">Uprawnienia dostępu do używania podczas otwierania strumienia zawartości.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej zwraca strumień zawartości części otwarty z określonym <see cref="T:System.IO.FileMode" /> i <see cref="T:System.IO.FileAccess" />.</summary>
        <returns>Strumień danych zawartości części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje nie powinny wywoływać <xref:System.IO.Packaging.PackagePart.GetStreamCore%2A> bezpośrednio, ale zamiast tego należy wywołać <xref:System.IO.Packaging.PackagePart.GetStream%2A>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Pochodne <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> wdrażania należy się upewnić, nie założenia dotyczące zamówienia lub operacje wykonywane przez <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> metodę, która wywołuje go.</para>
        </block>
        <block subset="none" type="usage">
          <para>Pochodne <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> metoda jest wywoływana przez <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> metody, aby otworzyć i zwrócić strumień danych części oparte na fizycznym formacie zaimplementowana w klasie pochodnej.  
  
 Domyślnie <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementacja podklasą klasy abstrakcyjnej <see cref="T:System.IO.Packaging.PackagePart" /> klasa ma być dostarczana i używane.  W operacji domyślne <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> wewnętrznie wywołuje <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> z <see cref="T:System.IO.Packaging.ZipPackagePart" /> klasę, aby otworzyć i zwracanie części strumienia danych z pliku ZIP.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Package">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.Package Package { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.Package Package" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Package" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Package As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::Package ^ Package { System::IO::Packaging::Package ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element nadrzędny <see cref="T:System.IO.Packaging.Package" /> części.</summary>
        <value>Pakiet nadrzędny części.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Package%2A> jest właściwością tylko do odczytu, która jest możliwy tylko wtedy, gdy element nadrzędny <xref:System.IO.Packaging.Package> jest otwarty.  
  
 <xref:System.IO.Packaging.PackagePart.Package%2A> Właściwość jest automatycznie ustawiana przez <xref:System.IO.Packaging.PackagePart.%23ctor%2A> konstruktora.  Po ustawieniu przez konstruktora nadrzędnego <xref:System.IO.Packaging.PackagePart.Package%2A> części można zmienić.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Relacji do sprawdzenia.</param>
        <summary>Zwraca wartość wskazującą, czy ta część jest właścicielem relacji z określonym <see cref="P:System.IO.Packaging.PackageRelationship.Id" />.</summary>
        <returns>
          <see langword="true" /> Jeśli ta część jest właścicielem relacji z określonym <paramref name="id" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Musi być prawidłowym identyfikatorem XML.  `id` Typu jest xsd:ID i wykonaj konwencje nazewnictwa określonych w *XML schematu część 2: typy danych* specyfikacji (zobacz [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> nie jest prawidłowym identyfikatorem XML.</exception>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji relacji).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Uri">
      <MemberSignature Language="C#" Value="public Uri Uri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Uri" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Uri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Uri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Uri { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] części.</summary>
        <value>[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części względem katalogu głównego pakietu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Uri%2A> jest właściwością tylko do odczytu, która jest możliwy tylko wtedy, gdy element nadrzędny <xref:System.IO.Packaging.Package> jest otwarty.  
  
 <xref:System.IO.Packaging.PackagePart.Uri%2A> Właściwość jest automatycznie ustawiana przez <xref:System.IO.Packaging.PackagePart.%23ctor%2A> konstruktora.  Po ustawieniu przez konstruktora, <xref:System.IO.Packaging.PackagePart.Uri%2A> części nie można zmienić.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element został usunięty.  
  
 —lub—  
  
 <see cref="P:System.IO.Packaging.PackagePart.Package" /> Nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ComparePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
  </Members>
</Type>
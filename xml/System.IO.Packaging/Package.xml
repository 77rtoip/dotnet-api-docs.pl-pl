<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata><Meta Name="ms.openlocfilehash" Value="db72d34b5a4c159399029932c6bc75949e8c9313" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69356450" /></Metadata><TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type Package = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje kontener, który może przechowywać wiele obiektów danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package>jest klasą abstrakcyjną, która może służyć do organizowania obiektów w pojedynczą jednostkę zdefiniowanego formatu fizycznego na potrzeby przenośności i wydajnego dostępu.  
  
 Plik ZIP jest podstawowym formatem fizycznym dla <xref:System.IO.Packaging.Package>.  Inne <xref:System.IO.Packaging.Package> implementacje mogą korzystać z innych formatów fizycznych, takich jak dokument XML, baza danych lub usługa sieci Web.  
  
 Podobnie jak w przypadku systemu plików, elementy zawarte <xref:System.IO.Packaging.Package> w a są przywoływane w hierarchicznej organizacji folderów i plików.  
  
 Chociaż <xref:System.IO.Packaging.Package> sama jest klasą abstrakcyjną <xref:System.IO.Packaging.ZipPackage> , Klasa pochodna jest <xref:System.IO.Packaging.Package.Open%2A> używana domyślnie przez metodę.  
  
 ("Część") jest klasą abstrakcyjną, która reprezentuje obiekt, który jest przechowywany <xref:System.IO.Packaging.Package>w. <xref:System.IO.Packaging.PackagePart>  
  
 ("Relacja") definiuje skojarzenie między źródłem <xref:System.IO.Packaging.Package> lub <xref:System.IO.Packaging.PackagePart> obiektem docelowym. <xref:System.IO.Packaging.PackageRelationship>  Może <xref:System.IO.Packaging.PackageRelationship> to być jeden z dwóch typów, z których każdy może być jedną z dwóch form:  
  
-   Relacja poziomu pakietu (utworzona przez <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> metodę) <xref:System.IO.Packaging.Package> odnosi się do:  
  
    -   Część docelowa pakietu.  
  
    -   Zasób docelowy poza pakietem.  
  
-   Relacja poziomu części (utworzona przez <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> metodę) wiąże źródło <xref:System.IO.Packaging.PackagePart> z:  
  
    -   Inna część docelowa pakietu.  
  
    -   Zasób docelowy poza pakietem.  
  
 <xref:System.IO.Packaging.Package> Źródło<xref:System.IO.Packaging.PackagePart> lub źródło relacji jest traktowane jako "właściciel" relacji.  Po usunięciu obiektu źródłowego zostaną również usunięte wszystkie relacje należące do obiektu źródłowego.  Proces tworzenia lub usuwania relacji nie powoduje fizycznej zmiany obiektów źródłowych ani docelowych w jakikolwiek sposób.  
  
 A <xref:System.IO.Packaging.PackageDigitalSignature> ("podpis cyfrowy") to skład części i relacji reprezentujący podpis cyfrowy zawarty <xref:System.IO.Packaging.Package>w.  Podpis cyfrowy identyfikuje nadawcę i sprawdza, czy podpisane części i relacje zawarte w <xref:System.IO.Packaging.Package> nie zostały zmodyfikowane.  
  
 Pakiety obsługują również cyfrowe Rights Management (DRM), które umożliwiają szyfrowanie elementów zawartości <xref:System.IO.Packaging.Package> w celu zaszyfrowania przy użyciu określonych praw dostępu przyznanych autoryzowanym użytkownikom.  
  
 W oparciu o <xref:System.IO.Packaging.Package> architekturę <xref:System.Windows.Xps.Packaging.XpsDocument> jest typem pakietu przeznaczonym do przechowywania dokumentów na podstawie [specyfikacji Open XML Paper Specification (XPS)](https://go.microsoft.com/fwlink/?LinkID=65761).  
  
 .NET Framework używa pakietów do przechowywania zawartości, zasobów i relacji dla stron i dokumentów przy użyciu standardowego pliku ZIP domyślnie. Podobnie jak w przypadku dowolnego pliku zip, aplikacja może używać <xref:System.IO.Packaging> klas do przechowywania i opcjonalnego ochrony dowolnego typu lub liczby plików danych w jednym kontenerze "wydajny dostęp".  
  
 Aby uzyskać więcej informacji, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono podstawowe kroki tworzenia programu <xref:System.IO.Packaging.Package>.  W tym przykładzie tworzony jest pakiet zawierający dokument wraz z obrazem graficznym, który jest wyświetlany jako część dokumentu.  (Podobnie jak w przypadku, w którym plik HTML ma \<tag IMG >, który odwołuje się do zewnętrznego pliku obrazu).  Pakiet <xref:System.IO.Packaging.PackageRelationship> zawiera również dwa elementy.  Pierwszy, "na poziomie pakietu", definiuje część dokumentu jako element główny pakietu.  Druga relacja "na poziomie części" definiuje skojarzenie między częścią dokumentu ("Źródło" relacji poziomu części) i używaniem części obrazu ("target" relacji poziomu części).  Pełny przykład można znaleźć w artykule [pisanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Specyfikacja Open pakowanie Conventions (OPC)</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=74494">Cyfrowe podpisywanie Konwencji Open pakowanie</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Packaging.Package" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package openFileAccess" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Uprawnienia we/wy pliku dla pakietu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Packaging.Package" /> klasy, która używa danego <see cref="T:System.IO.FileAccess" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A>jest chronionym konstruktorem <xref:System.IO.Packaging.Package> abstrakcyjnej klasy podstawowej. Gdy jest wywoływana w klasie pochodnej, <xref:System.IO.Packaging.Package.%23ctor%2A> Konstruktor inicjuje nowe wystąpienie klasy pochodnej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="openFileAccess" /> jest nieprawidłowa.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess * bool -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package (openFileAccess, streaming)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="streaming" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Uprawnienia we/wy pliku dla pakietu.</param>
        <param name="streaming"><see langword="true" />Aby otworzyć pakiet do przesyłania strumieniowego; w przeciwnym razie. <see langword="false" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.Packaging.Package" /> klasy, która używa danej <see cref="T:System.IO.FileAccess" /> opcji i przesyłania strumieniowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A>jest chronionym konstruktorem <xref:System.IO.Packaging.Package> abstrakcyjnej abstrakcyjnej klasy podstawowej. Gdy jest wywoływana w klasie pochodnej, <xref:System.IO.Packaging.Package.%23ctor%2A> Konstruktor inicjuje nowe wystąpienie klasy pochodnej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="openFileAccess" /> jest nieprawidłowa.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="package.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje i zamyka pakiet oraz wszystkie strumienie części podstawowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Close%2A> <xref:System.IO.Packaging.Package.Dispose%2A> Dla klasy i<xref:System.IO.Packaging.Package.Close%2A> wykonać<xref:System.IO.Packaging.Package.Dispose%2A> tę samą operację — nie ma powodu wywołania, jeśli wywołasz lub vice <xref:System.IO.Packaging.Package> versa.  
  
 <xref:System.IO.Packaging.Package.Close%2A>i <xref:System.IO.Packaging.Package.Dispose%2A> wewnętrznie wywołanie <xref:System.IO.Packaging.Package.Flush%2A>.  
  
> [!NOTE]
>  Instrukcja (inna `using` od dyrektywy Namespace) <xref:System.IO.Packaging.Package.Close%2A> jest zalecanym sposobem i <xref:System.IO.Packaging.Package.Dispose%2A> pakietem. `using`  [Pisanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160055) i [odczytywanie przykładu pakietu](https://go.microsoft.com/fwlink/?LinkID=160034) pokazuje, jak zamknąć i usunąć pakiet przy użyciu `using` instrukcji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową część pakietu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A>Inicjuje puste <xref:System.IO.Stream> dla nowej części.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Metoda może służyć do uzyskania odwołania do wystąpienia strumienia skojarzonego z częścią.  
  
 Aby uzyskać więcej informacji na temat części pakietu, zobacz sekcję 1,1 specyfikacji Open Package Conventions (OPC), która jest <https://go.microsoft.com/fwlink/?LinkID=71255>dostępna do pobrania na stronie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć nowe <xref:System.IO.Packaging.PackagePart> , a następnie przechowywać dane w części.  Pełny przykład można znaleźć w artykule [pisanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" />wewnętrznie wywołuje metodę klasy <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> pochodnej, aby faktycznie utworzyć część opartą na formacie fizycznym zaimplementowanym w klasie pochodnej.</para></block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Nowa część.</param>
        <param name="contentType">Typ zawartości strumienia danych.</param>
        <summary>Tworzy nową nieskompresowaną część o danym identyfikatorze URI i typie zawartości.</summary>
        <returns>Nowa część utworzona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A>Inicjuje puste <xref:System.IO.Stream> dla nowej części.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Metoda może służyć do uzyskania odwołania do wystąpienia strumienia skojarzonego z częścią.  
  
 Część <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> to .<xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>  
  
 Aby uzyskać dodatkowe informacje dotyczące części pakietu, zobacz sekcję 1,1 w specyfikacji Open Package Conventions (OPC) dostępną do <https://go.microsoft.com/fwlink/?LinkID=71255>pobrania na stronie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć nowe <xref:System.IO.Packaging.PackagePart> , a następnie przechowywać dane w części.  Pełny przykład można znaleźć w artykule [pisanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" />lub <paramref name="contentType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />jest nieprawidłowy <see cref="T:System.IO.Packaging.PackagePart" />. [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]</exception>
        <exception cref="T:System.InvalidOperationException">Część z określonym <paramref name="partUri" /> już istnieje w pakiecie.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu (nie można dodać nowej części).</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />wewnętrznie wywołuje <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> metodę klasy pochodnej, aby faktycznie utworzyć część opartą na formacie fizycznym zaimplementowanym w klasie pochodnej.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Nowa część.</param>
        <param name="contentType">Typ zawartości strumienia danych.</param>
        <param name="compressionOption">Opcja kompresji strumienia <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> danych lub <see cref="F:System.IO.Packaging.CompressionOption.Normal" /> kompresji.</param>
        <summary>Tworzy nową część z danym identyfikatorem URI, typem zawartości i opcją kompresji.</summary>
        <returns>Nowa część utworzona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla domyślnej <xref:System.IO.Packaging.ZipPackage> klasy <xref:System.IO.Packaging.Package.CreatePart%2A> pochodnej Metoda obsługuje `compressionOption` <xref:System.IO.Packaging.CompressionOption.Normal> tylko dwie wartości lub kompresję. <xref:System.IO.Packaging.CompressionOption.NotCompressed>  Inne <xref:System.IO.Packaging.CompressionOption> wartości<xref:System.IO.Packaging.CompressionOption.Fast>, lub używają<xref:System.IO.Packaging.CompressionOption.SuperFast> kompresji. <xref:System.IO.Packaging.CompressionOption.Maximum> <xref:System.IO.Packaging.CompressionOption.Normal>  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A>tworzy wartość pustą <xref:System.IO.Stream> dla nowej części.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Metoda może służyć do uzyskania odwołania do wystąpienia strumienia skojarzonego z częścią.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć nowe <xref:System.IO.Packaging.PackagePart> , a następnie przechowywać dane w części.  Pełny przykład można znaleźć w artykule [pisanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" />lub <paramref name="contentType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />jest nieprawidłowy <see cref="T:System.IO.Packaging.PackagePart" />. [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]</exception>
        <exception cref="T:System.InvalidOperationException">Część z określonym <paramref name="partUri" /> już istnieje w pakiecie.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="compressionOption" /> Wartość jest nieprawidłowa.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu (nie można dodać nowej części).</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />wewnętrznie wywołuje <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> metodę klasy pochodnej, aby faktycznie utworzyć część opartą na formacie fizycznym zaimplementowanym w klasie pochodnej.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="abstract member CreatePartCore : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePartCore (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Dla tworzonej części.</param>
        <param name="contentType">Typ zawartości strumienia danych.</param>
        <param name="compressionOption">Opcja kompresji strumienia danych.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, tworzy nową część w pakiecie.</summary>
        <returns>Część utworzona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda pochodna <xref:System.IO.Packaging.Package.CreatePartCore%2A> jest wywoływana <xref:System.IO.Packaging.Package.CreatePart%2A> przez metodę w celu utworzenia części na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.  
  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> używana jest implementacja klasy pochodnej klasy abstrakcyjnej <xref:System.IO.Packaging.Package> .  W operacji <xref:System.IO.Packaging.Package.CreatePart%2A> domyślnej wewnętrznie wywołania <xref:System.IO.Packaging.Package.CreatePartCore%2A> <xref:System.IO.Packaging.ZipPackage> klasy w celu utworzenia nowej części w pliku zip.  
  
 Dla domyślnej <xref:System.IO.Packaging.ZipPackage> klasy <xref:System.IO.Packaging.Package.CreatePartCore%2A> pochodnej Metoda obsługuje `compressionOption` <xref:System.IO.Packaging.CompressionOption.Normal> tylko dwie wartości lub kompresję. <xref:System.IO.Packaging.CompressionOption.NotCompressed>  Inne <xref:System.IO.Packaging.CompressionOption> wartości<xref:System.IO.Packaging.CompressionOption.Fast>, lub używają<xref:System.IO.Packaging.CompressionOption.SuperFast> kompresji. <xref:System.IO.Packaging.CompressionOption.Maximum> <xref:System.IO.Packaging.CompressionOption.Normal>  
  
 Aby uzyskać więcej informacji na temat modelu pakietu i części pakietu, zobacz rozdział 1 specyfikacji Open Package Conventions (OPC) dostępne do pobrania w <https://go.microsoft.com/fwlink/?LinkID=71255>witrynie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Implementacja pochodna <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> nie powinna wprowadzać żadnych założeń dotyczących kolejności lub operacji wykonywanych <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> przez metodę, która go wywołuje.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy relację poziomu pakietu z daną częścią.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziomu pakietu definiuje skojarzenie między pakietem i skojarzoną częścią docelową lub zasobem.  Relacja poziomu pakietu może być jedną z dwóch form.  
  
-   Między a <xref:System.IO.Packaging.Package> a elementem docelowym <xref:System.IO.Packaging.PackagePart> wewnątrz pakietu.  
  
-   Między a <xref:System.IO.Packaging.Package> a docelowym zasobem poza pakietem.  
  
 W oddzielnym pakiecie pakiet jest traktowany jako "właściciel" relacji.  Po usunięciu pakietu zostaną również usunięte wszystkie relacje należące do pakietu.  Proces tworzenia lub usuwania relacji nie pozwala fizycznie zmieniać części docelowej ani zasobu w jakikolwiek sposób.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
   
  
## Examples  
 Poniższy przykład ilustruje tworzenie <xref:System.IO.Packaging.PackageRelationship> <xref:System.IO.Packaging.Package> między a i części dokumentu głównego.  Pełny przykład można znaleźć w artykule [pisanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Części docelowej.</param>
        <param name="targetMode">Wskazuje, czy część docelowa <see cref="F:System.IO.Packaging.TargetMode.External" /> to <see cref="F:System.IO.Packaging.TargetMode.Internal" /> czy pakiet.</param>
        <param name="relationshipType">Identyfikator URI, który jednoznacznie definiuje rolę relacji.</param>
        <summary>Tworzy relację poziomu pakietu do części z danym identyfikatorem URI, trybem docelowym i typem relacji.</summary>
        <returns>Skojarzenie poziomu pakietu z określoną częścią.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziomu pakietu definiuje skojarzenie między pakietem i skojarzoną częścią docelową lub zasobem.  Relacja poziomu pakietu może być jedną z dwóch form.  
  
-   Między a <xref:System.IO.Packaging.Package> a elementem docelowym w pakiecie.  
  
-   Między a <xref:System.IO.Packaging.Package> a docelowym zasobem poza pakietem.  
  
 W oddzielnym pakiecie pakiet jest traktowany jako "właściciel" relacji.  Po usunięciu pakietu zostaną również usunięte wszystkie relacje należące do pakietu.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A>nie zmienia fizycznie części docelowej ani zasobu w jakikolwiek sposób.  
  
 Obiekt docelowy relacji nie może być inną relacją.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` musi być względnym identyfikatorem URI, który jest sformułowany zgodnie ze specyfikacją ogólnej składni Uniform Resource Identifier [RFC 3986](https://tools.ietf.org/html/rfc3986) (URI).  Wewnętrzny względny identyfikator URI może być ścieżką bezwzględną rozpoczynającą się od ukośnika ("/"), taką jak "/page1.XAML" lub "/images/picture4.jpg" lub ścieżką względną, taką jak ".. /imagespicture1.jpg ", który jest rozpoznawany względem katalogu głównego pakietu ("/") jako podstawowy identyfikator URI.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.External>, `targetUri` może być bezwzględny lub względny identyfikator URI utworzony zgodnie ze specyfikacją ogólnej składni Uniform Resource Identifier [RFC 3986](https://tools.ietf.org/html/rfc3986) (URI). `http://www.microsoft.com/page2.xml`to przykład bezwzględnego identyfikatora URI, który odwołuje się do zewnętrznego zasobu docelowego "Page2. xml".  "images/picture1. jpg" to przykładowy względny identyfikator URI, który odwołuje się również do zewnętrznego zasobu docelowego "1. jpg", ale który jest rozpoznawany względem identyfikatora URI samego pakietu.  
  
 `relationshipType`musi być [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] sformułowany zgodnie ze specyfikacją ogólnej składni Uniform Resource Identifier [RFC 3986](https://tools.ietf.org/html/rfc3986) (URI).  W poniższej tabeli przedstawiono identyfikatory URI na poziomie `relationshipType` pakietu zdefiniowane przez specyfikację Open Package Conventions (OPC).  
  
|Relacja poziomu pakietu|Identyfikator URI typu relacji|  
|---------------------------------|---------------------------|  
|Właściwości podstawowe|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Podpis cyfrowy|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Certyfikat podpisu cyfrowego|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Źródło podpisu cyfrowego|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Miniatura|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Aby uzyskać więcej informacji na temat pakietów i relacji między pakietami, zobacz sekcję 1,3 specyfikacji Open Package Conventions (OPC), <https://go.microsoft.com/fwlink/?LinkID=71255>która jest dostępna do pobrania na stronie.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.IO.Packaging.Package.CreateRelationship%2A> w celu <xref:System.IO.Packaging.PackageRelationship> utworzenia między <xref:System.IO.Packaging.Package> a i części dokumentu głównego.  Pełny przykład można znaleźć w artykule [pisanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" />lub <paramref name="relationshipType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="targetUri" /> Część to<paramref name="targetMode" /> , lub jest<paramref name="targetUri" /> bezwzględnym identyfikatorem URI. <see cref="F:System.IO.Packaging.TargetMode.Internal" /> <see cref="T:System.IO.Packaging.PackageRelationship" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="targetMode" /> jest nieprawidłowa.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu.</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Części docelowej.</param>
        <param name="targetMode">Wskazuje, czy część docelowa <see cref="F:System.IO.Packaging.TargetMode.External" /> to <see cref="F:System.IO.Packaging.TargetMode.Internal" /> czy pakiet.</param>
        <param name="relationshipType">Identyfikator URI, który jednoznacznie definiuje rolę relacji.</param>
        <param name="id">Unikatowy identyfikator XML.</param>
        <summary>Tworzy relację poziomu pakietu do części z danym identyfikatorem URI, trybem docelowym, typem relacji i [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</summary>
        <returns>Skojarzenie poziomu pakietu z określoną częścią.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziomu pakietu definiuje skojarzenie między pakietem i skojarzoną częścią docelową lub zasobem.  Relacja poziomu pakietu może być jedną z dwóch form.  
  
-   Między a <xref:System.IO.Packaging.Package> a elementem docelowym w pakiecie.  
  
-   Między a <xref:System.IO.Packaging.Package> a docelowym zasobem poza pakietem.  
  
 W oddzielnym pakiecie pakiet jest traktowany jako "właściciel" relacji.  Po usunięciu pakietu zostaną również usunięte wszystkie relacje należące do pakietu.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A>nie zmienia fizycznie części docelowej ani zasobu w jakikolwiek sposób.  
  
 Obiekt docelowy relacji nie może być inną relacją.  
  
 `id`musi być prawidłowym identyfikatorem XML.  `id` Typ to XSD: ID i musi być zgodny z konwencjami nazewnictwa określonymi w schemacie XML schematu część 2: Specyfikacja typów danych (zobacz [https://www.w3.org/TR/xmlschema-2/#ID](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Jeśli `id` jest określony jako `null` unikatowy identyfikator zostanie automatycznie wygenerowany.  `id` Określony przez pusty ciąg jest nieprawidłowy.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` musi być względnym identyfikatorem URI, który jest sformułowany zgodnie ze specyfikacją ogólnej składni Uniform Resource Identifier [RFC 3986](https://tools.ietf.org/html/rfc3986) (URI).  Wewnętrzny względny identyfikator URI może być ścieżką bezwzględną rozpoczynającą się od ukośnika ("/"), taką jak "/page1.XAML" lub "/images/picture4.jpg" lub ścieżką względną, taką jak ".. /imagespicture1.jpg ", który jest rozpoznawany względem katalogu głównego pakietu ("/") jako podstawowy identyfikator URI.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.External>, `targetUri` może być bezwzględny lub względny identyfikator URI utworzony zgodnie ze specyfikacją ogólnej składni Uniform Resource Identifier [RFC 3986](https://tools.ietf.org/html/rfc3986) (URI). `http://www.microsoft.com/page2.xml`to przykład bezwzględnego identyfikatora URI, który odwołuje się do zewnętrznego zasobu docelowego "Page2. xml".  "images/picture1. jpg" to przykładowy względny identyfikator URI, który odwołuje się również do zewnętrznego zasobu docelowego "1. jpg", ale który jest rozpoznawany względem identyfikatora URI samego pakietu.  
  
 `relationshipType`musi być identyfikatorem URI, który jest sformułowany zgodnie ze specyfikacją ogólnej składni Uniform Resource Identifier [RFC 3986](https://tools.ietf.org/html/rfc3986) (URI).  W poniższej tabeli przedstawiono identyfikatory URI na poziomie `relationshipType` pakietu zdefiniowane przez specyfikację Open Package Conventions (OPC).  
  
|Relacja poziomu pakietu|Identyfikator URI typu relacji|  
|---------------------------------|---------------------------|  
|Właściwości podstawowe|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Podpis cyfrowy|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Certyfikat podpisu cyfrowego|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Źródło podpisu cyfrowego|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Miniatura|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Aby uzyskać dodatkowe informacje na temat pakietów i relacji między pakietami, zobacz sekcję 1,3 specyfikacji Open Package Conventions (OPC), <https://go.microsoft.com/fwlink/?LinkID=71255>która jest dostępna do pobrania na stronie.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.IO.Packaging.Package.CreateRelationship%2A> w celu <xref:System.IO.Packaging.PackageRelationship> utworzenia między <xref:System.IO.Packaging.Package> a i części dokumentu głównego.  Pełny przykład można znaleźć w artykule [pisanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" />lub <paramref name="relationshipType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="targetUri" /> Część to<paramref name="targetMode" /> , lub jest<paramref name="targetUri" /> bezwzględnym identyfikatorem URI. <see cref="F:System.IO.Packaging.TargetMode.Internal" /> <see cref="T:System.IO.Packaging.PackageRelationship" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="targetMode" /> jest nieprawidłowa.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />nie jest prawidłowym identyfikatorem XML; lub część z określonym <paramref name="id" /> już wystąpieniem w pakiecie.</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.DeletePart : Uri -&gt; unit" Usage="package.DeletePart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Część do usunięcia.</param>
        <summary>Usuwa część z danym identyfikatorem URI z pakietu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri`musi być względnym identyfikatorem URI, który składa się ze ścieżki bezwzględnej, która rozpoczyna się od znaku ukośnika ("/").  Ścieżka bezwzględna jest określana względem katalogu głównego pakietu i jest tworzona zgodnie ze specyfikacją ogólnej składni Uniform Resource Identifier [RFC 3986](https://tools.ietf.org/html/rfc3986) (URI).  "/page1.XAML" i "/images/picture4.jpg" to przykłady prawidłowych identyfikatorów URI części.  
  
 Wyjątek nie jest zgłaszany, jeśli część z określoną `partUri` pozycją nie znajduje się w pakiecie.  (Można użyć metody, <xref:System.IO.Packaging.Package.PartExists%2A> aby określić, czy część z określonym `partUri` znajduje się w pakiecie).  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />jest nieprawidłowy <see cref="T:System.IO.Packaging.PackagePart" />. [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />wewnętrznie wywołuje <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> metodę klasy pochodnej w celu usunięcia części na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.</para></block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member DeletePartCore : Uri -&gt; unit" Usage="package.DeletePartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri"><see cref="P:System.IO.Packaging.PackagePart.Uri" /> Elementu<see cref="T:System.IO.Packaging.PackagePart" /> do usunięcia.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, usuwa część z danym identyfikatorem URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> używana jest implementacja klasy pochodnej klasy abstrakcyjnej <xref:System.IO.Packaging.Package> .  W operacji <xref:System.IO.Packaging.Package.DeletePart%2A> domyślnej wewnętrznie wywołania <xref:System.IO.Packaging.Package.DeletePartCore%2A> <xref:System.IO.Packaging.ZipPackage> klasy w celu wykonania rzeczywistej operacji usuwania na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.  
  
 Aby uzyskać więcej informacji na temat modelu pakietu i części pakietu, zobacz rozdział 1 specyfikacji Open Package Conventions (OPC) dostępne do pobrania w <https://go.microsoft.com/fwlink/?LinkID=71255>witrynie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Implementacja klasy <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> pochodnej jest wywoływana <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> przez metodę do określonej części na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.  
  
Implementacja pochodna <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> nie powinna wprowadzać żadnych założeń dotyczących kolejności lub operacji wykonywanych <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> przez metodę, która go wywołuje.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="package.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Elementu<see cref="T:System.IO.Packaging.PackageRelationship" /> do usunięcia.</param>
        <summary>Usuwa relację poziomu pakietu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziomu pakietu definiuje skojarzenie między pakietem i skojarzoną częścią docelową lub zasobem.  Relacja poziomu pakietu może być jedną z dwóch form.  
  
-   Między a <xref:System.IO.Packaging.Package> a elementem docelowym w pakiecie.  
  
-   Między a <xref:System.IO.Packaging.Package> a docelowym zasobem poza pakietem.  
  
 W oddzielnym pakiecie pakiet jest traktowany jako "właściciel" relacji.  Po usunięciu pakietu zostaną również usunięte wszystkie relacje należące do pakietu.  
  
 Wyjątek nie jest zgłaszany, jeśli relacja z `id` określoną pozycją nie znajduje się w pakiecie.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A>w żaden sposób nie zmieniamy fizycznie części docelowej.  
  
 Aby uzyskać więcej informacji na temat relacji pakietów, zobacz sekcję 1,3 specyfikacji Open Package Conventions (OPC), która jest <https://go.microsoft.com/fwlink/?LinkID=71255>dostępna do pobrania na stronie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />nie jest prawidłowym identyfikatorem XML.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="package.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Opróżnia i zapisuje zawartość wszystkich części i relacji, zamyka pakiet i zwalnia wszystkie zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby upewnić się, że wszystkie zmiany są poprawnie <xref:System.IO.Packaging.Package.Dispose%2A> zapisane, także kończy, opróżnia i zamyka wszystkie części i relacje, które są zawarte w pakiecie.  
  
 <xref:System.IO.Packaging.Package.Dispose%2A> <xref:System.IO.Packaging.Package.Close%2A>Dla klasyi<xref:System.IO.Packaging.Package.Close%2A> wykonać tę samą operację — nie ma powodów wywołania w przypadku wywołania lub odwrócenia. <xref:System.IO.Packaging.Package.Dispose%2A> <xref:System.IO.Packaging.Package>  
  
 <xref:System.IO.Packaging.Package.Close%2A>i <xref:System.IO.Packaging.Package.Dispose%2A> wewnętrznie wywołanie <xref:System.IO.Packaging.Package.Flush%2A>.  
  
 Klasy pochodne, które przydzielą i zarządzają zasobami nienależącymi do pamięci, powinny <xref:System.IO.Packaging.Package.Dispose%2A> zastąpić tę metodę, aby zwolnić zasoby, gdy jest wywoływana. Przesłonięcia klasy pochodnej powinna również <xref:System.IO.Packaging.Package.Flush%2A> być wywoływana i metodą klasy <xref:System.IO.Packaging.Package.Dispose%2A> bazowej, aby upewnić się, że zawsze jest wykonywane oczyszczanie klasy podstawowej.  
  
> [!NOTE]
>  Instrukcja (inna `using` od dyrektywy Namespace) <xref:System.IO.Packaging.Package.Close%2A> jest zalecanym sposobem i <xref:System.IO.Packaging.Package.Dispose%2A> pakietem. `using` [Pisanie przykładu pakietu](https://go.microsoft.com/fwlink/?LinkID=160055) pokazuje, jak zamknąć i usunąć pakiet przy użyciu `using` instrukcji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberSignature Language="F#" Value="member this.FileOpenAccess : System.IO.FileAccess" Usage="System.IO.Packaging.Package.FileOpenAccess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ustawienie dostępu do pliku dla pakietu.</summary>
        <value>Jedna z <see cref="T:System.IO.FileAccess" /> wartości: <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, lub <see cref="F:System.IO.FileAccess.ReadWrite" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FileOpenAccess%2A> Właściwość nie ma wartości domyślnej.  Ustawienie dostępu do pliku jest określone w <xref:System.IO.Packaging.Package.%23ctor%2A> wywołaniu konstruktora podczas tworzenia nowego pakietu lub <xref:System.IO.Packaging.Package.Open%2A> w wywołaniu, gdy otworzysz istniejący pakiet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="package.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje zawartość wszystkich części i relacji, które są zawarte w pakiecie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A>wewnętrznie wywołuje <xref:System.IO.Packaging.Package.FlushCore%2A> implementację klasy pochodnej w celu wykonania rzeczywistej operacji opróżniania określonej przez format.  <xref:System.IO.Packaging.Package.FlushCore%2A> Metoda klasy pochodnej jest odpowiedzialna za faktyczne zapisywanie części i zawartości relacji do określonej fizycznej implementacji klasy pochodnej.  
  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> używana jest pochodna implementacja abstrakcyjnej <xref:System.IO.Packaging.Package> klasy bazowej. W operacji domyślnej wewnętrznie wywołuje <xref:System.IO.Packaging.Package.Flush%2A> <xref:System.IO.Packaging.Package.FlushCore%2A> , aby zapisać części i relacje w pakiecie pliku zip.  
  
 <xref:System.IO.Packaging.Package.Flush%2A>jest wywoływana automatycznie przez <xref:System.IO.Packaging.Package.Close%2A> metody i. <xref:System.IO.Packaging.Package.Dispose%2A>  Gdy <xref:System.IO.Packaging.Package.Close%2A> <xref:System.IO.Packaging.Package.Flush%2A> lub <xref:System.IO.Packaging.Package.Dispose%2A> jest wywoływana, nie trzeba wywoływać oddzielnie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu i nie można go modyfikować.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.Flush" />wewnętrznie wywołuje <see cref="M:System.IO.Packaging.Package.FlushCore" /> metodę klasy pochodnej do rzeczywistego opróżniania części na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberSignature Language="F#" Value="abstract member FlushCore : unit -&gt; unit" Usage="package.FlushCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, zapisuje zawartość wszystkich części i relacji do magazynu klasy pochodnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A>jest wywoływany przez <xref:System.IO.Packaging.Package.Flush%2A> metodę w celu wykonania rzeczywistej operacji opróżniania na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Implementacja pochodna <see cref="M:System.IO.Packaging.Package.FlushCore" /> nie powinna wprowadzać żadnych założeń dotyczących kolejności lub operacji wykonywanych <see cref="M:System.IO.Packaging.Package.Flush" /> przez metodę, która go wywołuje.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.GetPart : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Część do zwrócenia.</param>
        <summary>Zwraca część o podanym identyfikatorze URI.</summary>
        <returns>Część z określonym <paramref name="partUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest <xref:System.InvalidOperationException> zgłaszany, jeśli część z określoną `partUri` nie istnieje.  
  
 Metoda może służyć do określenia, czy `partUri` odwołuje się do istniejącej części. <xref:System.IO.Packaging.Package.PartExists%2A>  
  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> używana jest pochodna implementacja abstrakcyjnej <xref:System.IO.Packaging.Package> klasy bazowej.  W operacji <xref:System.IO.Packaging.Package.GetPart%2A> domyślnej wewnętrznie wywołania <xref:System.IO.Packaging.Package.GetPartCore%2A> <xref:System.IO.Packaging.ZipPackage> klasy zwracają żądaną część z pliku zip.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak lokalizować, pobierać i odczytywać części, które są zawarte w pakiecie.  Aby uzyskać pełny przykład, zobacz [odczytywanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />jest nieprawidłowy <see cref="T:System.IO.Packaging.PackagePart" />. [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]</exception>
        <exception cref="T:System.InvalidOperationException">Część z określonym <paramref name="partUri" /> elementem nie znajduje się w pakiecie.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />wewnętrznie wywołuje metodę klasy <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> pochodnej w rzeczywistości opróżnia część na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member GetPartCore : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Część do pobrania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca część rozmieszczoną przez dany identyfikator URI.</summary>
        <returns>Żądana część; lub <see langword="null" />, jeśli część z określoną <paramref name="partUri" /> nie znajduje się w pakiecie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> używana jest pochodna implementacja klasy abstrakcyjnej <xref:System.IO.Packaging.Package> .  W operacji <xref:System.IO.Packaging.Package.GetPart%2A> domyślnej wewnętrznie wywołania <xref:System.IO.Packaging.Package.GetPartCore%2A> <xref:System.IO.Packaging.ZipPackage> klasy w celu pobrania części z pliku zip.  
  
 Aby uzyskać więcej informacji na temat modelu pakietu i części pakietu, zobacz rozdział 1 specyfikacji Open Package Conventions (OPC) dostępne do pobrania w <https://go.microsoft.com/fwlink/?LinkID=71255>witrynie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Implementacja klasy <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> pochodnej jest wywoływana <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> przez metodę w celu uzyskania dostępu i zwrócenia określonej części na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.  
  
Implementacja pochodna <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> nie powinna wprowadzać żadnych założeń dotyczących kolejności lub operacji wykonywanych <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> przez metodę, która go wywołuje.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberSignature Language="F#" Value="member this.GetParts : unit -&gt; System.IO.Packaging.PackagePartCollection" Usage="package.GetParts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję wszystkich części w pakiecie.</summary>
        <returns>Kolekcja wszystkich <see cref="T:System.IO.Packaging.PackagePart" /> elementów, które są zawarte w pakiecie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A>Zwraca kolekcję wszystkich części, które są zawarte w pakiecie, w tym <xref:System.IO.Packaging.PackageRelationship> części.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A>nigdy nie zwróci `null`wartości; jednak zwracana kolekcja będzie zawierać zerowe elementy, jeśli pakiet nie zawiera żadnych części.  
  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> używana jest pochodna implementacja abstrakcyjnej <xref:System.IO.Packaging.Package> klasy bazowej.  W operacji domyślnej program <xref:System.IO.Packaging.Package.GetParts%2A> <xref:System.IO.Packaging.Package.GetPartsCore%2A> wywołuje metodę <xref:System.IO.Packaging.ZipPackage> klasy w celu zwrócenia części z pliku zip.  
  
 Aby uzyskać więcej informacji na temat pakietów i części pakietu, zobacz sekcję 1,1 specyfikacji Open Package Conventions (OPC), która jest <https://go.microsoft.com/fwlink/?LinkID=71255>dostępna do pobrania na stronie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.IO.Packaging.Package.GetParts%2A> jak używać metody w celu uzyskania kolekcji części, które są zawarte <xref:System.IO.Packaging.Package>w.  Aby uzyskać kompletny kod źródłowy programu, zobacz [Tworzenie pakietu z przykładem podpisu cyfrowego](https://go.microsoft.com/fwlink/?LinkID=159966).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetParts" />wewnętrznie wywołuje metodę klasy <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> pochodnej w rzeczywistości opróżnia część na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberSignature Language="F#" Value="abstract member GetPartsCore : unit -&gt; System.IO.Packaging.PackagePart[]" Usage="package.GetPartsCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca tablicę wszystkich części w pakiecie.</summary>
        <returns>Tablica wszystkich części, które są zawarte w pakiecie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja klasy <xref:System.IO.Packaging.Package.GetPartsCore%2A> pochodnej jest wywoływana <xref:System.IO.Packaging.Package.GetParts%2A> przez metodę, aby uzyskać dostęp i zwrócić tablicę części na podstawie formatu fizycznego zaimplementowanego w klasie pochodnej.  
  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> używana jest pochodna implementacja klasy abstrakcyjnej <xref:System.IO.Packaging.Package> .  W operacji <xref:System.IO.Packaging.Package.GetParts%2A> domyślnej wewnętrznie wywołania <xref:System.IO.Packaging.Package.GetPartCore%2A> <xref:System.IO.Packaging.ZipPackage> klasy w celu pobrania części z pliku zip.  
  
 Aby uzyskać więcej informacji na temat modelu pakietu i części pakietu, zobacz rozdział 1 specyfikacji Open Package Conventions (OPC) dostępne do pobrania w <https://go.microsoft.com/fwlink/?LinkID=71255>witrynie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Implementacja pochodna <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> nie powinna wprowadzać żadnych założeń dotyczących kolejności lub operacji wykonywanych <see cref="M:System.IO.Packaging.Package.GetParts" /> przez metodę, która go wywołuje.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Relacja do zwrócenia.</param>
        <summary>Zwraca relację poziomu pakietu o danym identyfikatorze.</summary>
        <returns>Relacja poziomu pakietu z określoną <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id`musi być prawidłowym identyfikatorem XML. Typ ma wartość XSD: ID i musi następować zgodnie z konwencjami nazewnictwa określonymi [w sekcji 3.3.8 schematu XML. część 2: `id` Specyfikacja](https://www.w3.org/TR/xmlschema-2/#ID)typu danych.  
  
 Aby uzyskać dodatkowe informacje na temat pakietów i relacji między pakietami, zobacz sekcję 1,3 specyfikacji Open Package Conventions (OPC), <https://go.microsoft.com/fwlink/?LinkID=71255>która jest dostępna do pobrania na stronie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />nie jest prawidłowym identyfikatorem XML.</exception>
        <exception cref="T:System.InvalidOperationException">Relacja z określoną <paramref name="id" /> nie znajduje się w pakiecie.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję wszystkich relacji poziomu pakietu.</summary>
        <returns>Kolekcja wszystkich relacji poziomu pakietu, które są zawarte w pakiecie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A>nigdy nie zwróci `null`; jednak zwracana kolekcja może zawierać zero elementów, jeśli pakiet nie zawiera żadnych relacji na poziomie pakietu.  
  
 Relacja poziomu pakietu definiuje skojarzenie między pakietem i skojarzoną częścią docelową lub zasobem.  Relacja poziomu pakietu może być jedną z dwóch form.  
  
-   Między a <xref:System.IO.Packaging.Package> a elementem docelowym w pakiecie.  
  
-   Między a <xref:System.IO.Packaging.Package> a docelowym zasobem poza pakietem.  
  
 W oddzielnym pakiecie pakiet jest traktowany jako "właściciel" relacji.  Po usunięciu pakietu zostaną również usunięte wszystkie relacje należące do pakietu.  Proces tworzenia lub usuwania relacji nie pozwala fizycznie zmieniać części docelowej ani zasobu w jakikolwiek sposób.  
  
 Aby uzyskać dodatkowe informacje na temat pakietów i relacji między pakietami, zobacz sekcję 1,3 specyfikacji Open Package Conventions (OPC), <https://go.microsoft.com/fwlink/?LinkID=71255>która jest dostępna do pobrania na stronie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType"><see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> Aby dopasować i zwrócić do kolekcji.</param>
        <summary>Zwraca kolekcję wszystkich relacji poziomu pakietu, które pasują do danego <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />elementu.</summary>
        <returns>Kolekcja relacji poziomu pakietu, które pasują do określonego <paramref name="relationshipType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A>nigdy nie zwróci `null`; jednak zwracana kolekcja może zawierać zero elementów, jeśli nie ma żadnych relacji poziomu pakietu zgodnych z określonym. `relationshipType`  
  
 W poniższej tabeli przedstawiono identyfikatory URI na poziomie `relationshipType` pakietu zdefiniowane przez specyfikację Open Package Conventions (OPC).  
  
|Relacja poziomu pakietu|Identyfikator URI typu relacji|  
|---------------------------------|---------------------------|  
|Właściwości podstawowe|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Podpis cyfrowy|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Certyfikat podpisu cyfrowego|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Źródło podpisu cyfrowego|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Miniatura|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać relacje, które zostały zdefiniowane dla pakietu.  Aby uzyskać pełny przykład, zobacz [odczytywanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relationshipType" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="relationshipType" />jest pustym ciągiem.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera pakiet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>jest domyślnym typem pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metodę.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć nowy <xref:System.IO.Packaging.Package> , który <xref:System.IO.Packaging.PackageRelationship> obejmuje, w którym <xref:System.IO.Packaging.PackagePart> znajdują się dane i elementy, wraz z przechowywanymi danymi.  Pełny przykład można znaleźć w artykule [pisanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień we/wy, w którym ma zostać otwarty pakiet.</param>
        <summary>Otwiera pakiet w danym strumieniu we/wy.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>jest domyślnym typem pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metodę.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Pakiet do otwarcia wymaga uprawnień do odczytu lub odczytu/zapisu, a określony <paramref name="stream" /> jest tylko do zapisu. lub, pakiet do otwarcia wymaga uprawnień do zapisu lub odczytu i zapisu, a określony <paramref name="stream" /> element jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka i nazwa pliku pakietu.</param>
        <summary>Otwiera pakiet pod daną ścieżką i nazwą pliku.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>jest domyślnym typem pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metodę.  
  
 Ta <xref:System.IO.Packaging.Package.Open%2A> Metoda otwiera pakiet z domyślnymi atrybutami <xref:System.IO.FileAccess.ReadWrite> <xref:System.IO.FileMode.OpenOrCreate>, i <xref:System.IO.FileShare.None> (aby określić różne atrybuty, użyj jednego z innych przeciążeń metody Open).  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć nowy <xref:System.IO.Packaging.Package> , który <xref:System.IO.Packaging.PackageRelationship> obejmuje, w którym <xref:System.IO.Packaging.PackagePart> znajdują się dane i elementy, wraz z przechowywanymi danymi.  Pełny przykład można znaleźć w artykule [pisanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień we/wy, w którym ma zostać otwarty pakiet.</param>
        <param name="packageMode">Tryb pliku, w którym ma zostać otwarty pakiet.</param>
        <summary>Otwiera pakiet z danym strumieńem we/wy i trybem pliku.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>jest domyślnym typem pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metodę.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="packageMode" />wartość jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Pakiet do otwarcia wymaga uprawnień do odczytu lub odczytu/zapisu, a określony <paramref name="stream" /> jest tylko do zapisu. lub, pakiet do otwarcia wymaga uprawnień do zapisu lub odczytu i zapisu, a określony <paramref name="stream" /> element jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka i nazwa pliku pakietu.</param>
        <param name="packageMode">Tryb pliku, w którym ma zostać otwarty pakiet.</param>
        <summary>Otwiera pakiet w danej ścieżce przy użyciu danego trybu pliku.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>jest domyślnym typem pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metodę.  
  
 Ta <xref:System.IO.Packaging.Package.Open%2A> Metoda otwiera pakiet z domyślnymi atrybutami <xref:System.IO.FileShare.None> <xref:System.IO.FileAccess.ReadWrite> i (aby określić różne atrybuty, użyj jednego z innych przeciążeń metody Open).  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć nowy <xref:System.IO.Packaging.Package> , który <xref:System.IO.Packaging.PackageRelationship> obejmuje, w którym <xref:System.IO.Packaging.PackagePart> znajdują się dane i elementy, wraz z przechowywanymi danymi.  Pełny przykład można znaleźć w artykule [pisanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość parametru <paramref name="packageMode" /> jest nieprawidłowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień we/wy, w którym ma zostać otwarty pakiet.</param>
        <param name="packageMode">Tryb pliku, w którym ma zostać otwarty pakiet.</param>
        <param name="packageAccess">Dostęp do pliku, w którym ma zostać otwarty pakiet.</param>
        <summary>Otwiera pakiet z danym strumieniem we/wy, trybem plików i ustawieniem dostępu do pliku.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>jest domyślnym typem pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metodę.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="packageMode" /> lub<paramref name="packageAccess" /> jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Pakiet do otwarcia wymaga uprawnień do odczytu lub odczytu/zapisu, a określony <paramref name="stream" /> jest tylko do zapisu. lub pakiet, który ma zostać otwarty, wymaga uprawnień do zapisu lub odczytu i <paramref name="stream" /> zapisu, a określony jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka i nazwa pliku pakietu.</param>
        <param name="packageMode">Tryb pliku, w którym ma zostać otwarty pakiet.</param>
        <param name="packageAccess">Dostęp do pliku, w którym ma zostać otwarty pakiet.</param>
        <summary>Otwiera pakiet w danej ścieżce przy użyciu danego ustawienia trybu pliku i dostępu do pliku.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>jest domyślnym typem pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metodę.  
  
 Ta <xref:System.IO.Packaging.Package.Open%2A> Metoda otwiera pakiet z atrybutem domyślnym <xref:System.IO.FileShare.None> (aby określić inny atrybut, <xref:System.IO.Packaging.Package.Open%2A> Użyj przeciążenia metody).  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak otwierać i odczytywać <xref:System.IO.Packaging.Package> elementy, które zawierają <xref:System.IO.Packaging.PackagePart> <xref:System.IO.Packaging.PackageRelationship> i wraz z przechowywanymi danymi.  Aby uzyskać pełny przykład, zobacz [odczytywanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="packageMode" /> Wartość lub <paramref name="packageAccess" /> jest nieprawidłowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess, packageShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka i nazwa pliku pakietu.</param>
        <param name="packageMode">Tryb pliku, w którym ma zostać otwarty pakiet.</param>
        <param name="packageAccess">Dostęp do pliku, w którym ma zostać otwarty pakiet.</param>
        <param name="packageShare">Tryb udostępniania plików, w którym ma zostać otwarty pakiet.</param>
        <summary>Otwiera pakiet w danej ścieżce przy użyciu danego trybu pliku, dostępu do pliku i ustawienia udziału plików.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>jest domyślnym typem pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metodę.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć nowy <xref:System.IO.Packaging.Package> , który <xref:System.IO.Packaging.PackageRelationship> obejmuje, w którym <xref:System.IO.Packaging.PackagePart> znajdują się dane i elementy, wraz z przechowywanymi danymi.  Pełny przykład można znaleźć w artykule [pisanie przykładowego pakietu](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość parametru <paramref name="packageMode" />, <paramref name="packageAccess" />lub <paramref name="packageShare" /> jest nieprawidłowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PackageProperties : System.IO.Packaging.PackageProperties" Usage="System.IO.Packaging.Package.PackageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera podstawowe właściwości pakietu.</summary>
        <value>Podstawowe właściwości pakietu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać dodatkowe informacje o właściwościach pakietu podstawowego, zobacz sekcję 3,1 w specyfikacji Open Package Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania w witrynie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member PartExists : Uri -&gt; bool&#xA;override this.PartExists : Uri -&gt; bool" Usage="package.PartExists partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri"><see cref="T:System.Uri" /> Część do sprawdzenia.</param>
        <summary>Wskazuje, czy część z danym identyfikatorem URI znajduje się w pakiecie.</summary>
        <returns><see langword="true" />Jeśli część z określonym <paramref name="partUri" /> elementem znajduje się w pakiecie; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` Powinien zaczynać się znakiem ukośnika "/" i być bezwzględnym od elementu głównego pakietu.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />jest nieprawidłowy <see cref="T:System.IO.Packaging.PackagePart" />. [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="package.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Relacja, dla której ma zostać wyszukane.</param>
        <summary>Wskazuje, czy relacja poziomu pakietu o danym IDENTYFIKATORze jest zawarta w pakiecie.</summary>
        <returns><see langword="true" />Jeśli relacja poziomu pakietu z określoną <paramref name="id" /> opcją znajduje się w pakiecie; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację Open pakowanie Conventions (OPC) dostępną <https://go.microsoft.com/fwlink/?LinkID=71255>do pobrania na stronie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />nie jest prawidłowym identyfikatorem XML.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> został wywołany).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu.</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczony do użycia przez aplikacje.  Zamiast tego użyj metody bezpiecznego <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> typu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="26e89d81152bf959a5f5d5e7816e69f656353584" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683149" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje kontener może przechowywać wiele obiektów danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package> jest klasą abstrakcyjną, która może służyć do organizowanie obiektów w pojedynczej jednostki zdefiniowanej fizycznym formacie przenośność i wydajny dostęp.  
  
 Plik ZIP jest podstawowy format fizycznej <xref:System.IO.Packaging.Package>.  Inne <xref:System.IO.Packaging.Package> implementacje może użyć innych formatów fizycznych, takich jak dokument XML, bazy danych, lub usługi sieci Web.  
  
 Jak system plików elementów zawartych w <xref:System.IO.Packaging.Package> odwołuje się hierarchiczna organizacja folderów i plików.  
  
 Mimo że <xref:System.IO.Packaging.Package> jest klasą abstrakcyjną <xref:System.IO.Packaging.ZipPackage> klasy pochodnej jest używana jako domyślna przez <xref:System.IO.Packaging.Package.Open%2A> metody.  
  
 A <xref:System.IO.Packaging.PackagePart> ("części") jest klasa abstrakcyjna, która reprezentuje obiekt, który jest przechowywany w <xref:System.IO.Packaging.Package>.  
  
 A <xref:System.IO.Packaging.PackageRelationship> ("relacji") definiuje skojarzenia między źródłem <xref:System.IO.Packaging.Package> lub <xref:System.IO.Packaging.PackagePart> i obiekt docelowy.  A <xref:System.IO.Packaging.PackageRelationship> może być jedna z dwóch typów, z których każdy może być jedną z dwóch formach:  
  
-   Relacja pakietu na poziomie (utworzony przez <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> — metoda) odnosi się <xref:System.IO.Packaging.Package> jednej:  
  
    -   Element docelowy w pakiecie.  
  
    -   Zasób docelowy poza pakietem.  
  
-   Poziom części relacji (utworzony przez <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> — metoda) odnosi się źródłem <xref:System.IO.Packaging.PackagePart> jednej:  
  
    -   Inny docelowy part w pakiecie.  
  
    -   Zasób docelowy poza pakietem.  
  
 Źródło relacji <xref:System.IO.Packaging.Package> lub źródło <xref:System.IO.Packaging.PackagePart> jest traktowane jako "właściciela" w relacji.  Po usunięciu obiektu źródłowego są także usuwane wszystkie relacje należących do obiektu źródłowego.  Proces tworzenia lub usuwania relacji nie zmienia się fizycznie źródłową lub docelową obiektów w dowolny sposób.  
  
 A <xref:System.IO.Packaging.PackageDigitalSignature> ("podpis cyfrowy") jest złożeniem części i relacje reprezentujący podpisu cyfrowego dołączonego <xref:System.IO.Packaging.Package>.  Podpis cyfrowy identyfikuje inicjatorem i weryfikuje, czy podpisem części i relacje zawarte w <xref:System.IO.Packaging.Package> nie zostały zmodyfikowane.  
  
 Pakiety również obsługiwać zarządzania prawami cyfrowymi (DRM) umożliwiający elementy zawartości w <xref:System.IO.Packaging.Package> szyfrowania z określone prawa dostępu przyznane dla autoryzowanych użytkowników.  
  
 Na podstawie <xref:System.IO.Packaging.Package> architektury, <xref:System.Windows.Xps.Packaging.XpsDocument> jest typem pakiet przeznaczony do przechowywania dokumentów opartych na otwieranie [XML Paper Specification (XPS)](http://go.microsoft.com/fwlink/?LinkID=65761).  
  
 .NET Framework używa pakietów do przechowywania zawartości, zasobów i relacje dla stron i dokumenty przy użyciu standardowego pliku ZIP domyślnie. Zgodnie z dowolnego pliku ZIP, aplikacja może używać <xref:System.IO.Packaging> klasy do przechowywania i opcjonalnie ochrony dowolnego typu lub liczby plików danych w jeden kontener wydajny dostęp.  
  
 Aby uzyskać więcej informacji, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono podstawowe kroki tworzenia <xref:System.IO.Packaging.Package>.  W tym przykładzie tworzona jest pakiet zawiera dokumentu wraz z obrazem, który jest wyświetlany jako część dokumentu.  (Jest to podobne do sprawę, w którym znajduje się plik HTML \<IMG > tag, który odwołuje się do zewnętrznego pliku obrazu.)  Dwa <xref:System.IO.Packaging.PackageRelationship> elementy znajdują się również w pakiecie.  Pierwszy relację "pakiet poziom" definiuje części dokumentu jako element główny pakietu.  Relacja drugiej, "części poziom" definiuje skojarzenie między części dokumentu ("źródła" relacji części poziom) i jego użycia części obrazu ("target" relacji części poziomie).  Pełny przykład, zobacz [zapisywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Packaging.Package" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Uprawnienia we/wy pliku dla pakietu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Packaging.Package" /> klasy, który używa danej <see cref="T:System.IO.FileAccess" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> Konstruktor chroniony z jest <xref:System.IO.Packaging.Package> abstrakcyjnej klasy podstawowej. Po wywołaniu w klasie pochodnej <xref:System.IO.Packaging.Package.%23ctor%2A> Konstruktor inicjuje nowe wystąpienie klasy pochodnej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="openFileAccess" /> jest nieprawidłowa.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
        <Parameter Name="streaming" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Uprawnienia we/wy pliku dla pakietu.</param>
        <param name="streaming">
          <see langword="true" /> Aby otworzyć pakiet do przesyłania strumieniowego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Packaging.Package" /> klasy, który używa danej <see cref="T:System.IO.FileAccess" /> i przesyłania strumieniowego opcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> Konstruktor chroniony z jest <xref:System.IO.Packaging.Package> abstrakcyjnej podstawowej abstrakcyjna klasa podstawowa. Po wywołaniu w klasie pochodnej <xref:System.IO.Packaging.Package.%23ctor%2A> Konstruktor inicjuje nowe wystąpienie klasy pochodnej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="openFileAccess" /> jest nieprawidłowa.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje zapisanie i zamknięcie pakietu oraz wszystkich strumieni części podstawowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla <xref:System.IO.Packaging.Package> klasy <xref:System.IO.Packaging.Package.Close%2A> i <xref:System.IO.Packaging.Package.Dispose%2A> do tej samej operacji — to nie ma powodu do wywołania <xref:System.IO.Packaging.Package.Dispose%2A> połączeń <xref:System.IO.Packaging.Package.Close%2A>, lub na odwrót.  
  
 <xref:System.IO.Packaging.Package.Close%2A> i <xref:System.IO.Packaging.Package.Dispose%2A> wewnętrznie wywołania <xref:System.IO.Packaging.Package.Flush%2A>.  
  
> [!NOTE]
>  `using` Instrukcji (inne niż `using` dyrektywy przestrzeni nazw) jest zalecanym sposobem <xref:System.IO.Packaging.Package.Close%2A> i <xref:System.IO.Packaging.Package.Dispose%2A> pakietu.  [Pisanie przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160055) i [odczytywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160034) pokazują, jak zamknąć i usuwania pakietu przy użyciu `using` instrukcji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe części pakietu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Inicjuje pustą <xref:System.IO.Stream> nowe części.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> — Metoda może zostać użyty do uzyskania odwołania do wystąpienia strumienia skojarzonego z części.  
  
 Aby uzyskać więcej informacji na temat części pakietów, zobacz sekcję 1.1 specyfikacji otwarte konwencje pakietów (OPC) dostępny do pobrania w [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia nowego <xref:System.IO.Packaging.PackagePart> , a następnie zapisać dane do części.  Pełny przykład, zobacz [zapisywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> wewnętrznie wywołuje klasy pochodnej <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> metodę w celu utworzenia faktycznie element na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] z nowej strony.</param>
        <param name="contentType">Typ zawartości strumienia danych.</param>
        <summary>Tworzy nowy element nieskompresowanych z danego identyfikatora URI i typu zawartości.</summary>
        <returns>Nowe części utworzone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Inicjuje pustą <xref:System.IO.Stream> nowe części.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> — Metoda może zostać użyty do uzyskania odwołania do wystąpienia strumienia skojarzonego z części.  
  
 Część <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> jest <xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>.  
  
 Aby uzyskać dodatkowe informacje na temat części pakietów, zobacz sekcję 1.1 w specyfikacji otwarte konwencje pakietów (OPC) dostępny do pobrania w [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia nowego <xref:System.IO.Packaging.PackagePart> , a następnie zapisać dane do części.  Pełny przykład, zobacz [zapisywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> lub <paramref name="contentType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> nie jest prawidłową <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Element z określonym <paramref name="partUri" /> znajduje się już w pakiecie.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu (nie można dodać nowej części).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" /> wewnętrznie wywołuje klasy pochodnej <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> metodę w celu utworzenia faktycznie element na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] z nowej strony.</param>
        <param name="contentType">Typ zawartości strumienia danych.</param>
        <param name="compressionOption">Opcję kompresji dla strumienia danych <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> lub <see cref="F:System.IO.Packaging.CompressionOption.Normal" /> kompresji.</param>
        <summary>Tworzy nowy part z danego identyfikatora URI, typu zawartości i opcję kompresji.</summary>
        <returns>Nowe części utworzone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla domyślnej <xref:System.IO.Packaging.ZipPackage> klasy, <xref:System.IO.Packaging.Package.CreatePart%2A> metoda obsługuje tylko dwa `compressionOption` wartości, <xref:System.IO.Packaging.CompressionOption.NotCompressed> lub <xref:System.IO.Packaging.CompressionOption.Normal> kompresji.  Inne <xref:System.IO.Packaging.CompressionOption> wartości <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, lub <xref:System.IO.Packaging.CompressionOption.SuperFast> użyj <xref:System.IO.Packaging.CompressionOption.Normal> kompresji.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Tworzy pustą <xref:System.IO.Stream> nowe części.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> — Metoda może zostać użyty do uzyskania odwołania do wystąpienia strumienia skojarzonego z części.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia nowego <xref:System.IO.Packaging.PackagePart> , a następnie zapisać dane do części.  Pełny przykład, zobacz [zapisywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> lub <paramref name="contentType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> nie jest prawidłową <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Element z określonym <paramref name="partUri" /> znajduje się już w pakiecie.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="compressionOption" /> Wartość jest nieprawidłowa.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu (nie można dodać nowej części).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> wewnętrznie wywołuje klasy pochodnej <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> metodę w celu utworzenia faktycznie element na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Części tworzona.</param>
        <param name="contentType">Typ zawartości strumienia danych.</param>
        <param name="compressionOption">Opcję kompresji dla strumienia danych.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej tworzy nowe części pakietu.</summary>
        <returns>Część utworzony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pochodne <xref:System.IO.Packaging.Package.CreatePartCore%2A> metoda jest wywoływana przez <xref:System.IO.Packaging.Package.CreatePart%2A> metodę w celu utworzenia części na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.  
  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> implementacji klasy abstrakcyjnej klasy pochodnej <xref:System.IO.Packaging.Package> klasa ma być dostarczana i używane.  W operacji domyślne <xref:System.IO.Packaging.Package.CreatePart%2A> wewnętrznie wywołuje <xref:System.IO.Packaging.Package.CreatePartCore%2A> z <xref:System.IO.Packaging.ZipPackage> klasy w celu utworzenia nowej części w pliku ZIP.  
  
 Dla domyślnej <xref:System.IO.Packaging.ZipPackage> klasy, <xref:System.IO.Packaging.Package.CreatePartCore%2A> metoda obsługuje tylko dwa `compressionOption` wartości, <xref:System.IO.Packaging.CompressionOption.NotCompressed> lub <xref:System.IO.Packaging.CompressionOption.Normal> kompresji.  Inne <xref:System.IO.Packaging.CompressionOption> wartości <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, lub <xref:System.IO.Packaging.CompressionOption.SuperFast> użyj <xref:System.IO.Packaging.CompressionOption.Normal> kompresji.  
  
 Aby uzyskać więcej informacji na temat modelu pakietu i części pakietów, zobacz rozdział 1 specyfikacji otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Pochodne <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> wdrażania należy się upewnić, nie założenia dotyczące zamówienia lub operacje wykonywane przez <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> metodę, która wywołuje go.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy relację poziom pakietu z danym elementem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziom pakietu definiuje skojarzenie między pakietu i skojarzone docelowy part lub zasobu.  Relacja poziom pakietu może być jedną z dwóch formach.  
  
-   Między <xref:System.IO.Packaging.Package> do docelowego elementu <xref:System.IO.Packaging.PackagePart> w pakiecie.  
  
-   Między <xref:System.IO.Packaging.Package> do zasobu docelowego poza pakietem.  
  
 W relacji pakietu pakietu jest traktowana jako "właściciela" w relacji.  Jeśli pakiet został usunięty, są także usuwane wszystkie relacje należących do pakietu.  Proces tworzenia lub usuwania relacji nie zmienia fizycznie części docelowej lub zasobu w dowolny sposób.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład przedstawia tworzenie <xref:System.IO.Packaging.PackageRelationship> między <xref:System.IO.Packaging.Package> i element główny dokumentu.  Pełny przykład, zobacz [zapisywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Części docelowej.</param>
        <param name="targetMode">Wskazuje, czy element docelowy jest <see cref="F:System.IO.Packaging.TargetMode.Internal" /> lub <see cref="F:System.IO.Packaging.TargetMode.External" /> do pakietu.</param>
        <param name="relationshipType">Identyfikator URI, który unikatowo definiuje roli relacji.</param>
        <summary>Tworzy relację poziom pakietu z elementem z danego identyfikatora URI, tryb obiektu docelowego i typ relacji.</summary>
        <returns>Poziom pakietu relacji z określonej części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziom pakietu definiuje skojarzenie między pakietu i skojarzone docelowy part lub zasobu.  Relacja poziom pakietu może być jedną z dwóch formach.  
  
-   Między <xref:System.IO.Packaging.Package> z elementem docelowym w pakiecie.  
  
-   Między <xref:System.IO.Packaging.Package> do zasobu docelowego poza pakietem.  
  
 W relacji pakietu pakietu jest traktowana jako "właściciela" w relacji.  Jeśli pakiet został usunięty, są także usuwane wszystkie relacje należących do pakietu.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> nie fizycznie zmienia części docelowej lub zasobu w dowolny sposób.  
  
 Element docelowy relacji nie może być w innej relacji.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` musi być względnym identyfikatorem URI, który został utworzony zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) Specyfikacja ogólna składnia identyfikatora URI (Uniform Resource).  Wewnętrzny względnego identyfikatora URI może być albo ścieżkę bezwzględną, która rozpoczyna się od ukośnika ("/") znaków takich jak "/ page1.xaml" lub "/ images/picture4.jpg", lub ścieżką względną, takie jak "... / imagespicture1.jpg "rozwiązań przed katalog główny pakietu ("/ ") jako podstawowy identyfikator URI.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.External>, `targetUri` może być albo bezwzględnym lub względnym identyfikatorem URI utworzony zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) Specyfikacja ogólna składnia identyfikatora URI (Uniform Resource).  "http://www.microsoft.com/page2.xml" jest przykładem bezwzględny identyfikator URI, który odwołuje się do zasobu docelowego zewnętrzne "page2.xml".  Przykładem względnym identyfikatorem URI również odwołuje się do docelowego zewnętrznych zasobów "1.jpg" ale która rozwiązuje względem adresu URI pakietu jest "images/picture1.jpg".  
  
 `relationshipType` musi być [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] który został utworzony zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) Specyfikacja ogólna składnia identyfikatora URI (Uniform Resource).  W poniższej tabeli przedstawiono poziom pakietu `relationshipType` identyfikatorów URI zdefiniowanych przez specyfikację otwarte konwencje pakietów (OPC).  
  
|Poziom pakietu relacji|Identyfikator URI typu relacji|  
|---------------------------------|---------------------------|  
|Właściwości podstawowe|http://schemas.openxmlformats.org/package/2006/relationships/meta właściwości/core danych|  
|Podpis cyfrowy|http://schemas.openxmlformats.org/package/2006/relationships/digit Al — podpis/podpisu|  
|Certyfikat podpisu|http://schemas.openxmlformats.org/package/2006/relationships/digit certyfikat Al podpisu|  
|Podpis cyfrowy źródła|http://schemas.openxmlformats.org/package/2006/relationships/digit źródłem Al podpisu|  
|Miniatur|http://schemas.openxmlformats.org/package/2006/relationships/meta Data/miniatur|  
  
 Aby uzyskać więcej informacji na temat tworzenia pakietów i relacje pakietu sekcji 1.3 specyfikacji otwarte konwencje pakietów (OPC) dostępny do pobrania w [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób użycia <xref:System.IO.Packaging.Package.CreateRelationship%2A> utworzyć <xref:System.IO.Packaging.PackageRelationship> między <xref:System.IO.Packaging.Package> i element główny dokumentu.  Pełny przykład, zobacz [zapisywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> lub <paramref name="relationshipType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetUri" /> Części <see cref="T:System.IO.Packaging.PackageRelationship" />, lub <paramref name="targetMode" /> jest <see cref="F:System.IO.Packaging.TargetMode.Internal" /> i <paramref name="targetUri" /> jest bezwzględnym identyfikatorem URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="targetMode" /> jest nieprawidłowa.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu.</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Części docelowej.</param>
        <param name="targetMode">Wskazuje, czy element docelowy jest <see cref="F:System.IO.Packaging.TargetMode.Internal" /> lub <see cref="F:System.IO.Packaging.TargetMode.External" /> do pakietu.</param>
        <param name="relationshipType">Identyfikator URI, który unikatowo definiuje roli relacji.</param>
        <param name="id">Unikatowy identyfikator XML.</param>
        <summary>Tworzy relację poziom pakietu z elementem z danym identyfikatorem URI, tryb docelowej, typ relacji i [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</summary>
        <returns>Poziom pakietu relacji z określonej części.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziom pakietu definiuje skojarzenie między pakietu i skojarzone docelowy part lub zasobu.  Relacja poziom pakietu może być jedną z dwóch formach.  
  
-   Między <xref:System.IO.Packaging.Package> z elementem docelowym w pakiecie.  
  
-   Między <xref:System.IO.Packaging.Package> do zasobu docelowego poza pakietem.  
  
 W relacji pakietu pakietu jest traktowana jako "właściciela" w relacji.  Jeśli pakiet został usunięty, są także usuwane wszystkie relacje należących do pakietu.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> nie fizycznie zmienia części docelowej lub zasobu w dowolny sposób.  
  
 Element docelowy relacji nie może być w innej relacji.  
  
 `id` Musi być prawidłowym identyfikatorem XML.  `id` Typ to xsd:ID, należy wykonać opisane w części 2 schematu XML konwencje nazewnictwa: specyfikacja typy danych (zobacz [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Jeśli `id` jest określony jako `null` będą automatycznie generowane Unikatowy identyfikator.  `id` Określony przez pusty ciąg jest nieprawidłowy.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` musi być względnym identyfikatorem URI, który został utworzony zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) Specyfikacja ogólna składnia identyfikatora URI (Uniform Resource).  Wewnętrzny względnego identyfikatora URI może być albo ścieżkę bezwzględną, która rozpoczyna się od ukośnika ("/") znaków takich jak "/ page1.xaml" lub "/ images/picture4.jpg", lub ścieżką względną, takie jak "... / imagespicture1.jpg "rozwiązań przed katalog główny pakietu ("/ ") jako podstawowy identyfikator URI.  
  
 Jeśli `targetMode` jest określony jako <xref:System.IO.Packaging.TargetMode.External>, `targetUri` może być albo bezwzględnym lub względnym identyfikatorem URI utworzony zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) Specyfikacja ogólna składnia identyfikatora URI (Uniform Resource).  "http://www.microsoft.com/page2.xml" jest przykładem bezwzględny identyfikator URI, który odwołuje się do zasobu docelowego zewnętrzne "page2.xml".  Przykładem względnym identyfikatorem URI również odwołuje się do docelowego zewnętrznych zasobów "1.jpg" ale która rozwiązuje względem adresu URI pakietu jest "images/picture1.jpg".  
  
 `relationshipType` musi być identyfikatorem URI, który został utworzony zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) Specyfikacja ogólna składnia identyfikatora URI (Uniform Resource).  W poniższej tabeli przedstawiono poziom pakietu `relationshipType` identyfikatorów URI zdefiniowanych przez specyfikację otwarte konwencje pakietów (OPC).  
  
|Poziom pakietu relacji|Identyfikator URI typu relacji|  
|---------------------------------|---------------------------|  
|Właściwości podstawowe|http://schemas.openxmlformats.org/package/2006/relationships/meta właściwości/core danych|  
|Podpis cyfrowy|http://schemas.openxmlformats.org/package/2006/relationships/digit Al — podpis/podpisu|  
|Certyfikat podpisu|http://schemas.openxmlformats.org/package/2006/relationships/digit certyfikat Al podpisu|  
|Podpis cyfrowy źródła|http://schemas.openxmlformats.org/package/2006/relationships/digit źródłem Al podpisu|  
|Miniatur|http://schemas.openxmlformats.org/package/2006/relationships/meta Data/miniatur|  
  
 Aby uzyskać dodatkowe informacje dotyczące tworzenia pakietów i relacje pakietu, zobacz sekcję 1.3 specyfikacji otwarte konwencje pakietów (OPC) dostępny do pobrania w [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób użycia <xref:System.IO.Packaging.Package.CreateRelationship%2A> utworzyć <xref:System.IO.Packaging.PackageRelationship> między <xref:System.IO.Packaging.Package> i element główny dokumentu.  Pełny przykład, zobacz [zapisywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> lub <paramref name="relationshipType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="targetUri" /> Części <see cref="T:System.IO.Packaging.PackageRelationship" />, lub <paramref name="targetMode" /> jest <see cref="F:System.IO.Packaging.TargetMode.Internal" /> i <paramref name="targetUri" /> jest bezwzględnym identyfikatorem URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="targetMode" /> jest nieprawidłowa.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> nie jest prawidłowy identyfikator XML; lub części z określonym <paramref name="id" /> występuje już w pakiecie.</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] Części do usunięcia.</param>
        <summary>Usuwa element z danym identyfikatorem URI z pakietu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` musi być względnym identyfikatorem URI, który składa się z ścieżką bezwzględną, która rozpoczyna się od ukośnika ("/") znaków.  Ścieżka bezwzględna jest względem katalogu głównego pakietu oraz jest sformatowany zgodnie z [RFC 3986](http://tools.ietf.org/html/rfc3986) Specyfikacja ogólna składnia identyfikatora URI (Uniform Resource).  "/ page1.xaml" i "/ images/picture4.jpg" przedstawiono część prawidłowy identyfikator URI.  
  
 Nie jest wyjątek, jeśli element z określonym `partUri` nie znajduje się w pakiecie.  (Można użyć <xref:System.IO.Packaging.Package.PartExists%2A> metodę, aby określić, czy element z określonym `partUri` w pakiecie.)  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> nie jest prawidłową <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> wewnętrznie wywołuje klasy pochodnej <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> metoda usuwa element na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.</para>
        </block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">
          <see cref="P:System.IO.Packaging.PackagePart.Uri" /> z <see cref="T:System.IO.Packaging.PackagePart" /> do usunięcia.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej usuwa element z danym identyfikatorem URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> implementacji klasy abstrakcyjnej klasy pochodnej <xref:System.IO.Packaging.Package> klasa ma być dostarczana i używane.  W operacji domyślne <xref:System.IO.Packaging.Package.DeletePart%2A> wewnętrznie wywołuje <xref:System.IO.Packaging.Package.DeletePartCore%2A> z <xref:System.IO.Packaging.ZipPackage> klasy do wykonania rzeczywiste usunięcie operacji na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.  
  
 Aby uzyskać więcej informacji na temat modelu pakietu i części pakietów, zobacz rozdział 1 specyfikacji otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Klasa pochodna <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> implementacji jest wywoływana przez <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> metody określonej części na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.  
  
 Pochodne <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> wdrażania należy się upewnić, nie założenia dotyczące zamówienia lub operacje wykonywane przez <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> metodę, która wywołuje go.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> z <see cref="T:System.IO.Packaging.PackageRelationship" /> do usunięcia.</param>
        <summary>Usuwa relacji poziom pakietu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relacja poziom pakietu definiuje skojarzenie między pakietu i skojarzone docelowy part lub zasobu.  Relacja poziom pakietu może być jedną z dwóch formach.  
  
-   Między <xref:System.IO.Packaging.Package> z elementem docelowym w pakiecie.  
  
-   Między <xref:System.IO.Packaging.Package> do zasobu docelowego poza pakietem.  
  
 W relacji pakietu pakietu jest traktowana jako "właściciela" w relacji.  Jeśli pakiet został usunięty, są także usuwane wszystkie relacje należących do pakietu.  
  
 Nie jest wyjątek, jeśli relacji z określonym `id` nie znajduje się w pakiecie.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A> nie zmienia fizycznie element docelowy w dowolny sposób.  
  
 Aby uzyskać więcej informacji na temat relacji pakietu, zobacz sekcję 1.3 specyfikacji otwarte konwencje pakietów (OPC) dostępny do pobrania w [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> nie jest prawidłowym identyfikatorem XML.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Liczba opróżnień i zapisuje zawartość wszystkich części i relacje, zamyka pakietu i zwalnia wszystkie zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby upewnić się, że wszystkie zmiany są prawidłowo zapisywane, <xref:System.IO.Packaging.Package.Dispose%2A> również Kończenie znajdujących się opróżnia i zamyka wszystkie części i relacje, które są zawarte w pakiecie.  
  
 Dla <xref:System.IO.Packaging.Package> klasy <xref:System.IO.Packaging.Package.Dispose%2A> i <xref:System.IO.Packaging.Package.Close%2A> do tej samej operacji — nie ma powodu do wywołania <xref:System.IO.Packaging.Package.Dispose%2A> połączeń <xref:System.IO.Packaging.Package.Close%2A>, lub na odwrót.  
  
 <xref:System.IO.Packaging.Package.Close%2A> i <xref:System.IO.Packaging.Package.Dispose%2A> wewnętrznie wywołania <xref:System.IO.Packaging.Package.Flush%2A>.  
  
 Klasy pochodne, których alokacji zasobów i zarządzanie nimi z systemem innym niż pamięci powinny przesłaniać tę metodę, aby zwolnić zasoby przy <xref:System.IO.Packaging.Package.Dispose%2A> jest wywoływana. Zastąpienia klas pochodnych należy także wywołać <xref:System.IO.Packaging.Package.Flush%2A> i klasa podstawowa <xref:System.IO.Packaging.Package.Dispose%2A> metody, aby upewnić się, który Oczyszczanie klasa podstawowa jest zawsze przeprowadzane.  
  
> [!NOTE]
>  `using` Instrukcji (inne niż `using` dyrektywy przestrzeni nazw) jest zalecanym sposobem <xref:System.IO.Packaging.Package.Close%2A> i <xref:System.IO.Packaging.Package.Dispose%2A> pakietu. [Pisanie przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160055) pokazano, jak zamknąć i usuwania pakietu przy użyciu `using` instrukcji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dostęp do plików pobiera ustawienie dla pakietu.</summary>
        <value>Jeden z <see cref="T:System.IO.FileAccess" /> wartości: <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, lub <see cref="F:System.IO.FileAccess.ReadWrite" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FileOpenAccess%2A> Właściwość nie ma wartości domyślnej.  Ustawienia dostępu do pliku jest określona w <xref:System.IO.Packaging.Package.%23ctor%2A> wywołać konstruktora, podczas tworzenia nowego pakietu, lub w <xref:System.IO.Packaging.Package.Open%2A> wywołań podczas otwierania istniejącego pakietu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje zawartość wszystkich części i relacje, które są zawarte w pakiecie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A> wewnętrznie wywołuje klasy pochodnej <xref:System.IO.Packaging.Package.FlushCore%2A> Jawna implementacja do wykonania bieżącej operacji opróżniania specyficzne dla formatu.  Klasy pochodne <xref:System.IO.Packaging.Package.FlushCore%2A> metoda jest odpowiedzialna za faktycznie zapisywania zawartości części i relacji do wykonania określonej klasy pochodnej fizycznych.  
  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> pochodnych implementacji klasy abstrakcyjnej <xref:System.IO.Packaging.Package> ma być dostarczana i używane przez klasę podstawową. W operacji domyślne <xref:System.IO.Packaging.Package.Flush%2A> wewnętrznie wywołuje <xref:System.IO.Packaging.Package.FlushCore%2A> można zapisać części i relacje w pakiecie pliku ZIP.  
  
 <xref:System.IO.Packaging.Package.Flush%2A> jest wywoływana automatycznie przez <xref:System.IO.Packaging.Package.Close%2A> i <xref:System.IO.Packaging.Package.Dispose%2A> metody.  Gdy <xref:System.IO.Packaging.Package.Close%2A> lub <xref:System.IO.Packaging.Package.Dispose%2A> jest nazywany nie trzeba wywołać <xref:System.IO.Packaging.Package.Flush%2A> oddzielnie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do odczytu i nie może być modyfikowany.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.Flush" /> wewnętrznie wywołuje klasy pochodnej <see cref="M:System.IO.Packaging.Package.FlushCore" /> metoda faktycznie opróżnić część oparta na fizycznym formacie zaimplementowana w klasie pochodnej.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zapisuje zawartość wszystkich części i relacji w magazynie klasy pochodnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A> Metoda jest wywoływana przez <xref:System.IO.Packaging.Package.Flush%2A> metoda wykonania bieżącej operacji opróżniania na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Pochodne <see cref="M:System.IO.Packaging.Package.FlushCore" /> implementacji, nie należy wprowadzać żadnych założenia dotyczące zamówienia lub operacje wykonywane przez <see cref="M:System.IO.Packaging.Package.Flush" /> metodę, która wywołuje go.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Części do zwrócenia.</param>
        <summary>Zwraca część z danym identyfikatorem URI.</summary>
        <returns>Element z określonym <paramref name="partUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> Jest generowany, jeśli element z określonym `partUri` nie istnieje.  
  
 <xref:System.IO.Packaging.Package.PartExists%2A> Metoda może służyć do określenia czy `partUri` odwołuje się do istniejącej części.  
  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> pochodnych implementacji klasy abstrakcyjnej <xref:System.IO.Packaging.Package> ma być dostarczana i używane przez klasę podstawową.  W operacji domyślne <xref:System.IO.Packaging.Package.GetPart%2A> wewnętrznie wywołuje <xref:System.IO.Packaging.Package.GetPartCore%2A> z <xref:System.IO.Packaging.ZipPackage> klasy, aby zwrócić żądanej części z pliku ZIP.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak znaleźć, pobierania i odczytywania części, które są zawarte w pakiecie.  Pełny przykład, zobacz [odczytywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> nie jest prawidłową <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Element z określonym <paramref name="partUri" /> nie znajduje się w pakiecie.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> wewnętrznie wywołuje klasy pochodnej <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> metoda faktycznie opróżnić część oparta na fizycznym formacie zaimplementowana w klasie pochodnej.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Części do pobrania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej zwraca część dotyczy danego identyfikatora URI.</summary>
        <returns>Żądanej części; lub <see langword="null" />, jeśli element z określonym <paramref name="partUri" /> nie znajduje się w pakiecie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> pochodnych implementacji klasy abstrakcyjnej <xref:System.IO.Packaging.Package> klasa ma być dostarczana i używane.  W operacji domyślne <xref:System.IO.Packaging.Package.GetPart%2A> wewnętrznie wywołuje <xref:System.IO.Packaging.Package.GetPartCore%2A> z <xref:System.IO.Packaging.ZipPackage> klasy można pobrać części z pliku ZIP.  
  
 Aby uzyskać więcej informacji na temat modelu pakietu i części pakietów, zobacz rozdział 1 specyfikacji otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Klasa pochodna <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> implementacji jest wywoływana przez <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> metody dostępu i zwracać element określony na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.  
  
 Pochodne <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> wdrażania należy się upewnić, nie założenia dotyczące zamówienia lub operacje wykonywane przez <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> metodę, która wywołuje go.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję wszystkich części pakietu.</summary>
        <returns>Kolekcja wszystkich <see cref="T:System.IO.Packaging.PackagePart" /> elementy, które są zawarte w pakiecie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A> Zwraca kolekcję wszystkich części, które są zawarte w tym pakiecie <xref:System.IO.Packaging.PackageRelationship> części.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A> nigdy nie zwróci `null`; jednak zwracana kolekcja będzie zawierać żadnego elementu, jeśli pakiet nie zawiera żadnych części.  
  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> pochodnych implementacji klasy abstrakcyjnej <xref:System.IO.Packaging.Package> ma być dostarczana i używane przez klasę podstawową.  W operacji domyślne <xref:System.IO.Packaging.Package.GetParts%2A> wywołania <xref:System.IO.Packaging.Package.GetPartsCore%2A> metody <xref:System.IO.Packaging.ZipPackage> służącą do zwracania części z pliku ZIP.  
  
 Aby uzyskać więcej informacji o pakietach i części pakietów, zobacz sekcję 1.1 specyfikacji otwarte konwencje pakietów (OPC) dostępny do pobrania w [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.IO.Packaging.Package.GetParts%2A> metodę, aby uzyskać kolekcję elementów, które są zawarte w <xref:System.IO.Packaging.Package>.  Dla programu pełny kod źródłowy, zobacz [utworzenie pakietu z przykładowym podpisu cyfrowego](http://go.microsoft.com/fwlink/?LinkID=159966).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetParts" /> wewnętrznie wywołuje klasy pochodnej <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> metoda faktycznie opróżnić część oparta na fizycznym formacie zaimplementowana w klasie pochodnej.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej zwraca tablicę wszystkich części pakietu.</summary>
        <returns>Tablica części, które są zawarte w pakiecie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa pochodna <xref:System.IO.Packaging.Package.GetPartsCore%2A> implementacji jest wywoływana przez <xref:System.IO.Packaging.Package.GetParts%2A> metody dostępu i zwraca tablicę części na podstawie fizycznej formatu zaimplementowana w klasie pochodnej.  
  
 Domyślnie <xref:System.IO.Packaging.ZipPackage> pochodnych implementacji klasy abstrakcyjnej <xref:System.IO.Packaging.Package> klasa ma być dostarczana i używane.  W operacji domyślne <xref:System.IO.Packaging.Package.GetParts%2A> wewnętrznie wywołuje <xref:System.IO.Packaging.Package.GetPartCore%2A> z <xref:System.IO.Packaging.ZipPackage> klasy można pobrać części z pliku ZIP.  
  
 Aby uzyskać więcej informacji na temat modelu pakietu i części pakietów, zobacz rozdział 1 specyfikacji otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Pochodne <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> wdrażania należy się upewnić, nie założenia dotyczące zamówienia lub operacje wykonywane przez <see cref="M:System.IO.Packaging.Package.GetParts" /> metodę, która wywołuje go.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Relacji do zwrócenia.</param>
        <summary>Zwraca poziom pakietu relację z danym identyfikatorem.</summary>
        <returns>Poziom pakietu relacji z określonym <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Musi być prawidłowym identyfikatorem XML.  `id` Typ to xsd:ID, należy wykonać opisane w części 2 schematu XML konwencje nazewnictwa: specyfikacja typy danych (zobacz [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Aby uzyskać dodatkowe informacje dotyczące tworzenia pakietów i relacje pakietu, zobacz sekcję 1.3 specyfikacji otwarte konwencje pakietów (OPC) dostępny do pobrania w [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> nie jest prawidłowym identyfikatorem XML.</exception>
        <exception cref="T:System.InvalidOperationException">Relacja z określonym <paramref name="id" /> nie znajduje się w pakiecie.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję wszystkie relacje poziom pakietu.</summary>
        <returns>Kolekcja wszystkie relacje poziomie pakietu, które są zawarte w pakiecie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> nigdy nie zwróci `null`; jednak zwracana Kolekcja może zawierać żadnego elementu, jeśli pakiet nie zawiera żadnych relacji poziom pakietu.  
  
 Relacja poziom pakietu definiuje skojarzenie między pakietu i skojarzone docelowy part lub zasobu.  Relacja poziom pakietu może być jedną z dwóch formach.  
  
-   Między <xref:System.IO.Packaging.Package> z elementem docelowym w pakiecie.  
  
-   Między <xref:System.IO.Packaging.Package> do zasobu docelowego poza pakietem.  
  
 W relacji pakietu pakietu jest traktowana jako "właściciela" w relacji.  Jeśli pakiet został usunięty, są także usuwane wszystkie relacje należących do pakietu.  Proces tworzenia lub usuwania relacji nie zmienia fizycznie części docelowej lub zasobu w dowolny sposób.  
  
 Aby uzyskać dodatkowe informacje dotyczące tworzenia pakietów i relacje pakietu, zobacz sekcję 1.3 specyfikacji otwarte konwencje pakietów (OPC) dostępny do pobrania w [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">
          <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> Umożliwia dopasowanie i zwracany w kolekcji.</param>
        <summary>Zwraca kolekcję wszystkie relacje poziomie pakietu, które odpowiada danym <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />.</summary>
        <returns>Kolekcja relacji poziomie pakietu, które pasują do określonego <paramref name="relationshipType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> nigdy nie zwróci `null`; jednak jeśli żadnych relacji poziomie pakietu, które pasują do określonego zwrócona Kolekcja może zawierać żadnego elementu `relationshipType`.  
  
 W poniższej tabeli przedstawiono poziom pakietu `relationshipType` identyfikatorów URI zdefiniowanych przez specyfikację otwarte konwencje pakietów (OPC).  
  
|Poziom pakietu relacji|Identyfikator URI typu relacji|  
|---------------------------------|---------------------------|  
|Właściwości podstawowe|http://schemas.openxmlformats.org/package/2006/relationships/meta właściwości/core danych|  
|Podpis cyfrowy|http://schemas.openxmlformats.org/package/2006/relationships/digit Al — podpis/podpisu|  
|Certyfikat podpisu|http://schemas.openxmlformats.org/package/2006/relationships/digit certyfikat Al podpisu|  
|Podpis cyfrowy źródła|http://schemas.openxmlformats.org/package/2006/relationships/digit źródłem Al podpisu|  
|Miniatur|http://schemas.openxmlformats.org/package/2006/relationships/meta Data/miniatur|  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można pobrać relacji, które zostały zdefiniowane dla pakietu.  Pełny przykład, zobacz [odczytywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" /> jest pustym ciągiem.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera pakiet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> jest to domyślny typ pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metody.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia nowego <xref:System.IO.Packaging.Package> który obejmuje <xref:System.IO.Packaging.PackageRelationship> i <xref:System.IO.Packaging.PackagePart> elementów wraz z przechowywanych danych.  Pełny przykład, zobacz [zapisywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień we/wy, na której można otworzyć pakietu.</param>
        <summary>Otwiera pakiet na dany strumień we/wy.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> jest to domyślny typ pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metody.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wymaga pakietu, aby otworzyć do odczytu lub odczytu/zapisu, uprawnienia i określonego <paramref name="stream" /> jest tylko do zapisu; lub pakiet, aby otworzyć wymaga zapisu lub uprawnienia odczytu/zapisu i określonego <paramref name="stream" /> jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa i ścieżka pliku pakietu.</param>
        <summary>Otwiera pakietu w danym ścieżkę i nazwę.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> jest to domyślny typ pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metody.  
  
 To <xref:System.IO.Packaging.Package.Open%2A> metody otwiera pakiet z domyślnymi atrybutami <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>, i <xref:System.IO.FileShare.None> (Aby określić różnych atrybutów, użyj jednej z inne przeciążenia metody Open).  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia nowego <xref:System.IO.Packaging.Package> który obejmuje <xref:System.IO.Packaging.PackageRelationship> i <xref:System.IO.Packaging.PackagePart> elementów wraz z przechowywanych danych.  Pełny przykład, zobacz [zapisywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień we/wy, na której można otworzyć pakietu.</param>
        <param name="packageMode">Tryb pliku, w którym można otworzyć pakietu.</param>
        <summary>Otwiera pakiet z danym trybem strumienia i plik we/wy.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> jest to domyślny typ pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metody.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="packageMode" /> wartość jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wymaga pakietu, aby otworzyć do odczytu lub odczytu/zapisu, uprawnienia i określonego <paramref name="stream" /> jest tylko do zapisu; lub pakiet, aby otworzyć wymaga zapisu lub uprawnienia odczytu/zapisu i określonego <paramref name="stream" /> jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa i ścieżka pliku pakietu.</param>
        <param name="packageMode">Tryb pliku, w którym można otworzyć pakietu.</param>
        <summary>Otwiera pakietu w podanej ścieżce przy użyciu trybu danego pliku.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> jest to domyślny typ pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metody.  
  
 To <xref:System.IO.Packaging.Package.Open%2A> metody otwiera pakiet z domyślnymi atrybutami <xref:System.IO.FileAccess.ReadWrite> i <xref:System.IO.FileShare.None> (Aby określić różnych atrybutów, użyj jednej z inne przeciążenia metody Open).  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia nowego <xref:System.IO.Packaging.Package> który obejmuje <xref:System.IO.Packaging.PackageRelationship> i <xref:System.IO.Packaging.PackagePart> elementów wraz z przechowywanych danych.  Pełny przykład, zobacz [zapisywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="packageMode" /> jest nieprawidłowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień we/wy, na której można otworzyć pakietu.</param>
        <param name="packageMode">Tryb pliku, w którym można otworzyć pakietu.</param>
        <param name="packageAccess">Dostęp do plików do otwarcia pakietu.</param>
        <summary>Zostanie otwarta pakietu z danego strumienia we/wy, tryb pliku i ustawienia dostępu do pliku.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> jest to domyślny typ pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metody.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="packageMode" /> lub <paramref name="packageAccess" /> jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.IOException">Wymaga pakietu, aby otworzyć do odczytu lub odczytu/zapisu, uprawnienia i określonego <paramref name="stream" /> jest tylko do zapisu; lub pakiet, aby otworzyć wymaga zapisu lub uprawnienia odczytu/zapisu i określonego <paramref name="stream" /> jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa i ścieżka pliku pakietu.</param>
        <param name="packageMode">Tryb pliku, w którym można otworzyć pakietu.</param>
        <param name="packageAccess">Dostęp do plików do otwarcia pakietu.</param>
        <summary>Otwiera pakietu w podanej ścieżce przy użyciu danego pliku tryb i ustawienia dostępu do pliku.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> jest to domyślny typ pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metody.  
  
 To <xref:System.IO.Packaging.Package.Open%2A> metody otwiera pakiet z domyślną <xref:System.IO.FileShare.None> atrybutu (Aby określić inny atrybut, użyj <xref:System.IO.Packaging.Package.Open%2A> przeciążenie metody).  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak otwieranie i Odczyt <xref:System.IO.Packaging.Package> zawierający <xref:System.IO.Packaging.PackageRelationship> i <xref:System.IO.Packaging.PackagePart> elementów wraz z przechowywanych danych.  Pełny przykład, zobacz [odczytywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="packageMode" /> lub <paramref name="packageAccess" /> jest nieprawidłowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa i ścieżka pliku pakietu.</param>
        <param name="packageMode">Tryb pliku, w którym można otworzyć pakietu.</param>
        <param name="packageAccess">Dostęp do plików do otwarcia pakietu.</param>
        <param name="packageShare">Tryb, w którym można otworzyć pakietu udostępniania plików.</param>
        <summary>Otwiera pakietu w podanej ścieżce przy użyciu trybu danego pliku, dostęp do plików i udziału plików ustawienie.</summary>
        <returns>Otwarty pakiet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> jest to domyślny typ pakietu, który jest używany przez <xref:System.IO.Packaging.Package.Open%2A> metody.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia nowego <xref:System.IO.Packaging.Package> który obejmuje <xref:System.IO.Packaging.PackageRelationship> i <xref:System.IO.Packaging.PackagePart> elementów wraz z przechowywanych danych.  Pełny przykład, zobacz [zapisywania przykładowy pakiet](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="packageMode" />, <paramref name="packageAccess" />, lub <paramref name="packageShare" /> jest nieprawidłowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera właściwości core pakietu.</summary>
        <value>Właściwości podstawowe pakietu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać dodatkowe informacje o podstawowych właściwości pakietu, zobacz sekcję 3.1 w specyfikacji otwarte konwencje pakietów (OPC) dostępny do pobrania w [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">
          <see cref="T:System.Uri" /> Części do sprawdzenia.</param>
        <summary>Wskazuje, czy części o danym identyfikatorze URI znajduje się w pakiecie.</summary>
        <returns>
          <see langword="true" /> Jeśli część z określonym <paramref name="partUri" /> znajduje się w pakiecie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` Powinien zaczynać się od ukośnika do przodu "/" i być bezwzględna z głównym pakietu.  
  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> nie jest prawidłową <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu (nie można odczytać informacji).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> Relacji do sprawdzenia.</param>
        <summary>Wskazuje, czy relacja poziom pakietu z podanym Identyfikatorem znajduje się w pakiecie.</summary>
        <returns>
          <see langword="true" /> Jeśli pakiet poziom relacji z określonym <paramref name="id" /> znajduje się w pakiecie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać dodatkowe informacje, zobacz specyfikację otwarte konwencje pakietów (OPC) można pobrać [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> nie jest prawidłowym identyfikatorem XML.</exception>
        <exception cref="T:System.ObjectDisposedException">Pakiet nie jest otwarty (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> lub <see cref="M:System.IO.Packaging.Package.Close" /> została wywołana).</exception>
        <exception cref="T:System.IO.IOException">Pakiet jest tylko do zapisu.</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użytku w aplikacji.  Użyj typu palety <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> metody zamiast tego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
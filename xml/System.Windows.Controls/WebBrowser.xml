<Type Name="WebBrowser" FullName="System.Windows.Controls.WebBrowser">
  <Metadata><Meta Name="ms.openlocfilehash" Value="170928e727efaba52e450ecc148edafa5eefae05" /><Meta Name="ms.sourcegitcommit" Value="f9e71795ba0f9c2dfaa74bec233343ed0f3ffd99" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/14/2019" /><Meta Name="ms.locfileid" Value="57924346" /></Metadata><TypeSignature Language="C#" Value="public sealed class WebBrowser : System.Windows.Interop.ActiveXHost" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed WebBrowser extends System.Windows.Interop.ActiveXHost" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.WebBrowser" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WebBrowser&#xA;Inherits ActiveXHost" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebBrowser sealed : System::Windows::Interop::ActiveXHost" />
  <TypeSignature Language="F#" Value="type WebBrowser = class&#xA;    inherit ActiveXHost" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Interop.ActiveXHost</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Docs>
    <summary>Hosty i przechodzi między dokumentami HTML. Umożliwia współdziałanie między kodem WPF, zarządzanych i HTML skrypt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.WebBrowser> Control oferuje następujące możliwości:  
  
 **Nawigacja**: <xref:System.Windows.Controls.WebBrowser.Source%2A>, <xref:System.Windows.Controls.WebBrowser.Navigate%2A>, <xref:System.Windows.Controls.WebBrowser.NavigateToStream%2A>, <xref:System.Windows.Controls.WebBrowser.NavigateToString%2A>, i <xref:System.Windows.Controls.WebBrowser.Refresh%2A>.  
  
 **Okres istnienia nawigacji**: <xref:System.Windows.Controls.WebBrowser.Navigating>, <xref:System.Windows.Controls.WebBrowser.Navigated>, i <xref:System.Windows.Controls.WebBrowser.LoadCompleted>.  
  
 **Rejestrowanie nawigacji**: <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A>, <xref:System.Windows.Controls.WebBrowser.GoBack%2A>, <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A>, i <xref:System.Windows.Controls.WebBrowser.GoForward%2A>.  
  
 **Współdziałanie WPF/HTML**: <xref:System.Windows.Controls.WebBrowser.InvokeScript%2A> i <xref:System.Windows.Controls.WebBrowser.ObjectForScripting%2A>, i <xref:System.Windows.Controls.WebBrowser.Document%2A>.  
  
 <xref:System.Windows.Controls.WebBrowser> jest ograniczone przez ograniczenia zabezpieczeń [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aplikacji, który jest hostem <xref:System.Windows.Controls.WebBrowser>:  
  
-   Gdy <xref:System.Windows.Controls.WebBrowser> jest hostowana przez pełnego zaufania [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aplikacji (aplikacji autonomicznej, na przykład), <xref:System.Windows.Controls.WebBrowser> może obsługiwać [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] dokumentów z dowolnego miejsca.  
  
-   Gdy <xref:System.Windows.Controls.WebBrowser> jest hostowana przez częściowego zaufania [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aplikacji ( [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)], na przykład), <xref:System.Windows.Controls.WebBrowser> może obsługiwać tylko dokumenty, które są **witryny pochodzenia** pliki danych aplikacji. Aby uzyskać więcej informacji, zobacz [zasoby aplikacji WPF, zawartość i pliki danych](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md).  
  
> [!CAUTION]
>  <xref:System.Windows.Controls.WebBrowser> Kontroli tworzy wewnętrznie macierzystym formancie WebBrowser ActiveX. WPF umożliwia włączenie funkcji zabezpieczeń dzięki zastosowaniu funkcji kontrolek do formantu WebBrowser ActiveX. Formanty funkcji, które są stosowane różnią się dla aplikacji XBAP i aplikacje autonomiczne. Niektóre aplikacje należy stosować dodatkowych funkcji kontroli w celu zapobieżenia złośliwej zawartości uruchamianie. Aby uzyskać więcej informacji, zobacz sekcję "WebBrowser kontroli i formanty funkcji" w [zabezpieczenia (WPF)](~/docs/framework/wpf/security-wpf.md) i [WebBrowser — formant omówienia i samouczki](https://go.microsoft.com/fwlink/?LinkId=179388).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób konfigurowania <xref:System.Windows.Controls.WebBrowser> można przejść do [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] dokumentu przy użyciu tylko znaczników.  
  
```xaml  
<!-- Web Browser Control that hosts a web page. -->  
<WebBrowser x:Name="webBrowser" Source="http://msdn.com"   
  Width="600" Height="600"  />  
```  
  
 Poniższy przykład przedstawia sposób konfigurowania <xref:System.Windows.Controls.WebBrowser> można przejść do dokumentu przy użyciu znaczników i związane z kodem.  
  
```xaml  
<StackPanel>  
    <StackPanel Orientation="Horizontal">  
        <TextBox x:Name="addressTextBox" Width="200" />  
        <Button Click="goNavigateButton_Click">Go</Button>  
    </StackPanel>  
    <WebBrowser x:Name="myWebBrowser" />  
</StackPanel>  
```  
  
```csharp  
private void goNavigateButton_Click(object sender, RoutedEventArgs e)  
{  
    // Get URI to navigate to  
    Uri uri = new Uri(this.addressTextBox.Text, UriKind.RelativeOrAbsolute);  
  
    // Only absolute URIs can be navigated to  
    if (!uri.IsAbsoluteUri)  
    {  
        MessageBox.Show("The Address URI must be absolute eg 'http://www.microsoft.com'");  
        return;  
    }  
  
    // Navigate to the desired URL by calling the .Navigate method  
    this.myWebBrowser.Navigate(uri);  
}  
```  
  
 Poniższy przykład pokazuje, jak obsługiwać `NewWindow2` zdarzeń i podobne zdarzenia przy użyciu <xref:System.Windows.Controls.WebBrowser> kontroli. W tym przykładzie wymaga odwołania do **SHDocVw.dll**, `using System.Runtime.InteropServices;` instrukcji, a <xref:System.Windows.Controls.WebBrowser> formantu o nazwie `webBrowser1`.  
  
```csharp  
public MainWindow()  
{  
    InitializeComponent();  
  
    var serviceProvider = (IServiceProvider)webBrowser1.Document;  
    if (serviceProvider != null)  
    {  
        Guid serviceGuid = new Guid("0002DF05-0000-0000-C000-000000000046");  
        Guid iid = typeof(SHDocVw.WebBrowser).GUID;  
        var webBrowserPtr = (SHDocVw.WebBrowser)serviceProvider  
            .QueryService(ref serviceGuid, ref iid);  
        if (webBrowserPtr != null)  
        {  
            webBrowserPtr.NewWindow2 += webBrowser1_NewWindow2;  
        }  
    }  
}  
  
private void webBrowser1_NewWindow2(ref object ppDisp, ref bool Cancel)  
{  
    // Handle the event.  
}  
  
[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]  
[Guid("6d5140c1-7436-11ce-8034-00aa006009fa")]  
internal interface IServiceProvider  
{  
    [return: MarshalAs(UnmanagedType.IUnknown)]  
    object QueryService(ref Guid guidService, ref Guid riid);  
}  
```  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160056">Przykład Silverlight hostingu XBAP</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebBrowser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebBrowser();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Controls.WebBrowser" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.WebBrowserPermission">Aby wywołać tę metodę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.WebBrowserPermissionLevel.Safe" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoBack : bool" Usage="System.Windows.Controls.WebBrowser.CanGoBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy istnieje dokument, aby przejść z powrotem do.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, która wskazuje, czy istnieje dokument, aby przejść z powrotem do.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak przejść z powrotem do poprzedniego dokumentu przez wywołanie metody <xref:System.Windows.Controls.WebBrowser.GoBack%2A>. Przykład najpierw sprawdza, czy są dokumenty, aby przejść z powrotem do, sprawdzając <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A>.  
  
```csharp  
private void backButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the previous HTML document, if there is one  
  if (this.webBrowser.CanGoBack)  
  {  
    this.webBrowser.GoBack();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoBack" />
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoForward : bool" Usage="System.Windows.Controls.WebBrowser.CanGoForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy istnieje dokument, aby przejść do przodu do.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, która wskazuje, czy istnieje dokument, aby przejść do przodu do.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak poruszać się w przód na następny [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] dokumentu przez wywołanie metody <xref:System.Windows.Controls.WebBrowser.GoForward%2A>. Przykład najpierw sprawdza, czy są dokumenty, aby przejść do przodu do, sprawdzając <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A>.  
  
```csharp  
private void forwardButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the next HTML document, if there is one  
  if (this.webBrowser.CanGoForward)  
  {  
    this.webBrowser.GoForward();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoForward" />
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoBack" />
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public object Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Document { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : obj" Usage="System.Windows.Controls.WebBrowser.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt dokumentu, który reprezentuje hostowanej [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] strony.</summary>
        <value>Obiekt dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt dokumentu musi być rzutowane na interfejs COM, który jest oczekiwany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Windows.Controls.WebBrowser" /> Wystąpienia nie jest już prawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Odwołanie do podstawowej native <c>WebBrowser</c> nie można pobrać.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywołać tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberSignature Language="F#" Value="member this.GoBack : unit -&gt; unit" Usage="webBrowser.GoBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przejdź z powrotem do poprzedniego dokumentu, jeśli taka istnieje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wywołasz <xref:System.Windows.Controls.WebBrowser.GoBack%2A> i nie ma żadnych dokumentów, aby wrócić do <xref:System.Windows.Controls.WebBrowser> nie wykonuje nawigacji i zgłaszany jest wyjątek. Jeśli zachodzi potrzeba, można sprawdzić wartość <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A> właściwości w celu określenia, czy istnieją dokumenty, aby przejść z powrotem do.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak przejść z powrotem do poprzedniego [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] dokumentu przez wywołanie metody <xref:System.Windows.Controls.WebBrowser.GoBack%2A>. Przykład najpierw sprawdza, czy istnieją [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] dokumenty, aby przejść z powrotem do, sprawdzając <xref:System.Windows.Controls.WebBrowser.CanGoBack%2A>.  
  
```csharp  
private void backButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the previous HTML document, if there is one  
  if (this.webBrowser.CanGoBack)  
  {  
    this.webBrowser.GoBack();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Windows.Controls.WebBrowser" /> Wystąpienia nie jest już prawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Odwołanie do podstawowej native <c>WebBrowser</c> nie można pobrać.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Nie istnieje żaden dokument, aby przejść z powrotem do.</exception>
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoBack" />
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberSignature Language="F#" Value="member this.GoForward : unit -&gt; unit" Usage="webBrowser.GoForward " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Poruszanie się w przód na następny [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] dokumentów, jeśli taka istnieje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wywołasz <xref:System.Windows.Controls.WebBrowser.GoForward%2A> i nie ma żadnych dokumentów, aby przejść do przodu, <xref:System.Windows.Controls.WebBrowser> nie wykonuje nawigacji i zgłaszany jest wyjątek. Jeśli zachodzi potrzeba, można sprawdzić wartość <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A> właściwości w celu określenia, czy istnieją dokumenty, aby przejść do przodu do.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak przez wywołanie metody, a następnie przejdź do przodu do następnego dokumentu <xref:System.Windows.Controls.WebBrowser.GoForward%2A>. Przykład najpierw sprawdza, czy są dokumenty, aby przejść do przodu do, sprawdzając <xref:System.Windows.Controls.WebBrowser.CanGoForward%2A>.  
  
```csharp  
private void forwardButton_Click(object sender, RoutedEventArgs e)  
{  
  // Navigate to the next HTML document, if there is one  
  if (this.webBrowser.CanGoForward)  
  {  
    this.webBrowser.GoForward();  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Windows.Controls.WebBrowser" /> Wystąpienia nie jest już prawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Odwołanie do podstawowej native <c>WebBrowser</c> nie można pobrać.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Nie istnieje żaden dokument, aby przejść do przodu do.</exception>
        <altmember cref="P:System.Windows.Controls.WebBrowser.CanGoForward" />
        <altmember cref="M:System.Windows.Controls.WebBrowser.GoBack" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeScript">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje funkcję wykonywania skryptów zdefiniowane w aktualnie załadowanych dokumentów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.InvokeScript(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string -&gt; obj" Usage="webBrowser.InvokeScript scriptName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scriptName">Nazwa funkcji skryptu do wykonania.</param>
        <summary>Wykonuje funkcję skryptu, który jest implementowany przez aktualnie załadowanych dokumentów.</summary>
        <returns>Obiekt zwrócony przez wywołanie wykonywanie aktywnych skryptów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%29> nie powinna być wywoływana przed zakończeniem ładowania dokumentu, który implementuje go. Wykryć, kiedy zakończono ładowanie dokumentu obsługi <xref:System.Windows.Controls.WebBrowser.LoadCompleted> zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać funkcję skryptu w dokumencie z [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aplikację za pomocą <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%29>. W tym przykładzie funkcja skryptu nie ma parametrów.  
  
 Poniżej przedstawiono [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] dokument, który implementuje funkcję skryptu, który zostanie wywołany z [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].  
  
```html  
<html>  
    <head>  
        <script type="text/javascript">  
            // Function Without Parameters  
            function JavaScriptFunctionWithoutParameters()    
            {  
              outputID.innerHTML = "JavaScript function called!";  
            }  
        </script>  
    </head>  
    <body>  
    <div id="outputID" style="color:Red; font-size:16">  
        Hello from HTML document with script!  
    </div>  
    </body>  
</html>  
```  
  
 Poniższej przedstawiono [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] implementacji w wywołaniu funkcji skryptu [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] dokumentu.  
  
```csharp  
private void callScriptFunctionNoParamButton_Click(object sender, RoutedEventArgs e)  
{  
  // Make sure the HTML document has loaded before attempting to  
  // invoke script of the document page. You could set loadCompleted  
  // to true when the LoadCompleted event on the WebBrowser fires.  
  if (this.loadCompleted)  
  {  
    try  
    {  
      this.webBrowser.InvokeScript("JavaScriptFunctionWithoutParameters");  
    }  
    catch (Exception ex)  
    {  
      string msg = "Could not call script: " +  
                   ex.Message +  
                  "\n\nPlease click the 'Load HTML Document with Script' button to load.";  
      MessageBox.Show(msg);  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Windows.Controls.WebBrowser" /> Wystąpienia nie jest już prawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Odwołanie do podstawowej native <c>WebBrowser</c> nie można pobrać.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Funkcja skryptu nie istnieje.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.InvokeScript(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string * obj[] -&gt; obj" Usage="webBrowser.InvokeScript (scriptName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="scriptName">Nazwa funkcji skryptu do wykonania.</param>
        <param name="args">Parametry do przekazania do funkcji skryptu.</param>
        <summary>Wykonuje funkcję skryptu, który jest zdefiniowany w aktualnie załadowanych dokumentów.</summary>
        <returns>Obiekt zwrócony przez wywołanie wykonywanie aktywnych skryptów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%2CSystem.Object%5B%5D%29> nie powinna być wywoływana przed zakończeniem ładowania dokumentu, który implementuje go. Wykryć, kiedy zakończono ładowanie dokumentu obsługi <xref:System.Windows.Controls.WebBrowser.LoadCompleted> zdarzeń.  
  
 Jeśli nie przekazuj za mało wartości parametrów do skryptu, który jest parametry, które nie są przekazywane wartości będzie miał wartość niezdefiniowana. Jeśli przekażesz zbyt wiele wartości parametrów, nadmiarowe wartości są ignorowane.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób wywołania funkcji skryptu w dokumencie z aplikacji przy użyciu <xref:System.Windows.Controls.WebBrowser.InvokeScript%28System.String%2CSystem.Object%5B%5D%29>. W tym przykładzie funkcji skryptu wymagane parametry.  
  
 Oto dokument, który implementuje funkcje skryptu, które będą wywoływane z [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].  
  
```html  
<html>  
    <head>  
        <script type="text/javascript">  
            // Function Without Parameters  
            function JavaScriptFunctionWithoutParameters()    
            {  
              outputID.innerHTML = "JavaScript function 'called: " + message + ".";  
            }  
        </script>  
    </head>  
    <body>  
    <div id="outputID" style="color:Red; font-size:16">  
        Hello from HTML document with script!  
    </div>  
    </body>  
</html>  
```  
  
 Poniższej przedstawiono [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] implementacji do wywoływania skryptu funkcje w [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] dokumentu.  
  
```csharp  
private void callScriptFunctionNoParamButton_Click(object sender, RoutedEventArgs e)  
{  
  // Make sure the HTML document has loaded before attempting to  
  // invoke script of the document page. You could set loadCompleted  
  // to true when the LoadCompleted event on the WebBrowser fires.  
  if (this.loadCompleted)  
  {  
    try  
    {  
      this.webBrowser.InvokeScript("JavaScriptFunctionWithoutParameters", this.messageTextBox.Text);  
    }  
    catch (Exception ex)  
    {  
      string msg = "Could not call script: " +  
                   ex.Message +  
                  "\n\nPlease click the 'Load HTML Document with Script' button to load.";  
      MessageBox.Show(msg);  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Windows.Controls.WebBrowser" /> Wystąpienia nie jest już prawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Odwołanie do podstawowej native <c>WebBrowser</c> nie można pobrać.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Funkcja skryptu nie istnieje.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.WebBrowser.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy dokument do zakończył pobieranie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Programy obsługi zdarzeń nawigować są przekazywane wystąpienie <xref:System.Windows.Navigation.NavigationEventArgs> klasy, która dostarcza informacje kontekstowe dotyczące nawigacji, w tym szczegóły odpowiedzi sieci Web.  
  
 To zdarzenie zostanie wyzwolone tylko dla tego najwyższego poziomu.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigating" />
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigated" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie przejdź do dokumentu w określonym <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(System::String ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : string -&gt; unit" Usage="webBrowser.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source">Adres URL, aby przejść do.</param>
        <summary>Asynchronicznie przechodzi do strony dokumentu pod określonym adresem URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%29> metodę, aby przejść do adresu URL, który może zawierać znaki ucieczki. Użyj <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29> metody, aby przejść do <xref:System.Uri> nie zawiera znaki specjalne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(Uri ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; unit" Usage="webBrowser.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source"><see cref="T:System.Uri" /> Można przejść do.</param>
        <summary>Asynchronicznie przejdź do dokumentu w określonym <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29> ma ten sam efekt jak ustawienie <xref:System.Windows.Controls.WebBrowser.Source%2A> właściwości. <xref:System.Windows.Controls.WebBrowser.Source%2A> jest używana z kodu znaczników przez deweloperów, którzy chcą deklaratywne określenie początkowego dokumentu, który <xref:System.Windows.Controls.WebBrowser> przechodzi do kiedy <xref:System.Windows.Controls.WebBrowser> został zainicjowany.  
  
 Użyj <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%29> metodę, aby przejść do adresu URL, który może zawierać znaki ucieczki. Użyj <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29> metody, aby przejść do <xref:System.Uri> nie zawiera znaki specjalne.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Controls.WebBrowser> można przejść do dokumentu za pomocą <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%29> metody.  
  
```xaml  
<StackPanel>  
    <StackPanel Orientation="Horizontal">  
        <TextBox x:Name="addressTextBox" Width="200" />  
        <Button Click="goNavigateButton_Click">Go</Button>  
    </StackPanel>  
    <WebBrowser x:Name="myWebBrowser" />  
</StackPanel>  
```  
  
```csharp  
private void goNavigateButton_Click(object sender, RoutedEventArgs e)  
{  
    // Get URI to navigate to  
    Uri uri = new Uri(this.addressTextBox.Text, UriKind.RelativeOrAbsolute);  
  
    // Only absolute URIs can be navigated to  
    if (!uri.IsAbsoluteUri)  
    {  
        MessageBox.Show("The Address URI must be absolute eg 'http://www.microsoft.com'");  
        return;  
    }  
  
    // Navigate to the desired URL by calling the .Navigate method  
    this.myWebBrowser.Navigate(uri);  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Windows.Controls.WebBrowser" /> Wystąpienia nie jest już prawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Odwołanie do podstawowej native <c>WebBrowser</c> nie można pobrać.</exception>
        <exception cref="T:System.Security.SecurityException">Nawigacja z aplikacji, która działa w trybie częściowego zaufania do <see cref="T:System.Uri" /> który nie znajduje się w miejscu pochodzenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (string source, string targetFrameName, byte[] postData, string additionalHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(string source, string targetFrameName, unsigned int8[] postData, string additionalHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.String,System.String,System.Byte[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As String, targetFrameName As String, postData As Byte(), additionalHeaders As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(System::String ^ source, System::String ^ targetFrameName, cli::array &lt;System::Byte&gt; ^ postData, System::String ^ additionalHeaders);" />
      <MemberSignature Language="F#" Value="member this.Navigate : string * string * byte[] * string -&gt; unit" Usage="webBrowser.Navigate (source, targetFrameName, postData, additionalHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetFrameName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="postData" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="additionalHeaders" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source">Adres URL, aby przejść do.</param>
        <param name="targetFrameName">Nazwa ramki, aby wyświetlić zawartość dokumentu.</param>
        <param name="postData">Dane POST protokołu HTTP do wysyłania do serwera, jeśli wymagane są źródłem.</param>
        <param name="additionalHeaders">Nagłówki HTTP do wysłania na serwer zleconą źródła.</param>
        <summary>Asynchronicznie przechodzi do strony dokumentu pod określonym adresem URL, a następnie określ ramki docelowej do załadowania zawartości dokumentu. Dodatkowe dane żądania HTTP POST i nagłówkami HTTP mogą być wysyłane do serwera jako część żądania nawigacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29> metodę, aby przejść do adresu URL, który może zawierać znaki ucieczki. Użyj <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29> metody, aby przejść do <xref:System.Uri> nie zawiera znaki specjalne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (Uri source, string targetFrameName, byte[] postData, string additionalHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(class System.Uri source, string targetFrameName, unsigned int8[] postData, string additionalHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Navigate(System.Uri,System.String,System.Byte[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (source As Uri, targetFrameName As String, postData As Byte(), additionalHeaders As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(Uri ^ source, System::String ^ targetFrameName, cli::array &lt;System::Byte&gt; ^ postData, System::String ^ additionalHeaders);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * string * byte[] * string -&gt; unit" Usage="webBrowser.Navigate (source, targetFrameName, postData, additionalHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="targetFrameName" Type="System.String" />
        <Parameter Name="postData" Type="System.Byte[]" />
        <Parameter Name="additionalHeaders" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source"><see cref="T:System.Uri" /> Można przejść do.</param>
        <param name="targetFrameName">Nazwa ramki, aby wyświetlić zawartość dokumentu.</param>
        <param name="postData">Dane POST protokołu HTTP do wysyłania do serwera, jeśli wymagane są źródłem.</param>
        <param name="additionalHeaders">Nagłówki HTTP do wysłania na serwer zleconą źródła.</param>
        <summary>Asynchronicznie przejdź do dokumentu w określonym <see cref="T:System.Uri" /> i określ ramki docelowej do załadowania zawartości dokumentu. Dodatkowe dane żądania HTTP POST i nagłówkami HTTP mogą być wysyłane do serwera jako część żądania nawigacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Controls.WebBrowser.Navigate%28System.String%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29> metodę, aby przejść do adresu URL, który może zawierać znaki ucieczki. Użyj <xref:System.Windows.Controls.WebBrowser.Navigate%28System.Uri%2CSystem.String%2CSystem.Byte%5B%5D%2CSystem.String%29> metody, aby przejść do <xref:System.Uri> nie zawiera znaki specjalne.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak przejść do dokumentu i otwórz go w nowym oknie przeglądarki, określając "o: puste" target.  
  
```xaml  
<StackPanel>  
    <StackPanel Orientation="Horizontal">  
        <TextBox x:Name="addressTextBox" Width="200" />  
        <Button Click="goNavigateButton_Click">Go</Button>  
    </StackPanel>  
    <WebBrowser x:Name="myWebBrowser" />  
</StackPanel>  
```  
  
```csharp  
private void goNavigateButton_Click(object sender, RoutedEventArgs e)  
{  
    // Get URI to navigate to  
    Uri uri = new Uri(this.addressTextBox.Text, UriKind.RelativeOrAbsolute);  
  
    // Only absolute URIs can be navigated to  
    if (!uri.IsAbsoluteUri)  
    {  
        MessageBox.Show("The Address URI must be absolute eg 'http://www.microsoft.com'");  
        return;  
    }  
  
    // Navigate to the desired URL by calling the .Navigate method  
    this.myWebBrowser.Navigate(uri, "_blank", null, null);  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Windows.Controls.WebBrowser" /> Wystąpienia nie jest już prawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Odwołanie do podstawowej native <c>WebBrowser</c> nie można pobrać.</exception>
        <exception cref="T:System.Security.SecurityException">Nawigacja z aplikacji, która działa w trybie częściowego zaufania: 
— Do <see cref="T:System.Uri" /> który nie znajduje się w miejscu pochodzenia, lub 
-   <paramref name="targetFrameName" /> Nazwa nie jest <see langword="null" /> lub jest pusty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.WebBrowser.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy dokument do znajduje się i rozpoczęciu pobierania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Programy obsługi zdarzeń nawigować są przekazywane wystąpienie <xref:System.Windows.Navigation.NavigationEventArgs> klasy, która dostarcza informacje kontekstowe dotyczące nawigacji, w tym szczegóły odpowiedzi sieci Web.  
  
 To zdarzenie zostanie wyzwolone tylko dla tego najwyższego poziomu.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigating" />
        <altmember cref="E:System.Windows.Controls.WebBrowser.LoadCompleted" />
      </Docs>
    </Member>
    <Member MemberName="NavigateToStream">
      <MemberSignature Language="C#" Value="public void NavigateToStream (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NavigateToStream(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.NavigateToStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NavigateToStream(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.NavigateToStream : System.IO.Stream -&gt; unit" Usage="webBrowser.NavigateToStream stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><see cref="T:System.IO.Stream" /> Zawierający zawartość dokumentu.</param>
        <summary>Przejdź asynchronicznie do <see cref="T:System.IO.Stream" /> zawierający zawartość dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `stream` parametr jest `null`, <xref:System.Windows.Controls.WebBrowser> przechodzi do pusty dokument ("o: puste").  
  
 Jeśli parametr strumienia nie jest w prawidłowym [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] formatu, która będzie wyświetlana jako zwykły tekst.  
  
 Po nawigacji <xref:System.Windows.Controls.WebBrowser.Source%2A> będzie `null`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak przechodzić do strumienia, który zawiera dokument.  
  
```csharp  
private void goNavigateToStreamButton_Click(object sender, RoutedEventArgs e)  
{  
  // Load HTML document as a stream  
  Uri uri = new Uri(@"pack://application:,,,/HTMLDocumentWithScript.html", UriKind.Absolute);  
  Stream source = Application.GetResourceStream(uri).Stream;  
  
  // Navigate to HTML document stream  
  this.webBrowser.NavigateToStream(source);  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Windows.Controls.WebBrowser" /> Wystąpienia nie jest już prawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Odwołanie do podstawowej native <c>WebBrowser</c> nie można pobrać.</exception>
        <altmember cref="M:System.Windows.Controls.WebBrowser.NavigateToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="NavigateToString">
      <MemberSignature Language="C#" Value="public void NavigateToString (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NavigateToString(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.NavigateToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub NavigateToString (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NavigateToString(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.NavigateToString : string -&gt; unit" Usage="webBrowser.NavigateToString text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text"><see cref="T:System.String" /> Zawierający zawartość dokumentu.</param>
        <summary>Przejdź asynchronicznie do <see cref="T:System.String" /> zawierający zawartość dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `text` parametr jest `null`, <xref:System.Windows.Controls.WebBrowser> przechodzi do pusty dokument ("o: puste").  
  
 Jeśli parametr tekst nie jest nieprawidłowe [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] formatu, która będzie wyświetlana jako zwykły tekst.  
  
 Po nawigacji <xref:System.Windows.Controls.WebBrowser.Source%2A> będzie `null`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można przejść do ciągu, który zawiera dokument.  
  
```csharp  
private void goNavigateToStringButton_Click(object sender, RoutedEventArgs e)  
{  
  // Load HTML document as a string  
  Uri uri = new Uri(@"pack://application:,,,/HTMLDocumentWithoutScript.html", UriKind.Absolute);  
  Stream stream = Application.GetResourceStream(uri).Stream;  
  using (StreamReader reader = new StreamReader(stream))  
  {  
    // Navigate to HTML document string  
    this.webBrowser.NavigateToString(reader.ReadToEnd());  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Windows.Controls.WebBrowser" /> Wystąpienia nie jest już prawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Odwołanie do podstawowej native <c>WebBrowser</c> nie można pobrać.</exception>
        <altmember cref="M:System.Windows.Controls.WebBrowser.NavigateToStream(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.WebBrowser.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje bezpośrednio przed nawigacji do dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po procedury obsługi zdarzeń są przekazywane wystąpienie <xref:System.Windows.Navigation.NavigatingCancelEventArgs> klasy. Anuluj nawigacji, ustawiając <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> właściwość <xref:System.Windows.Navigation.NavigatingCancelEventArgs> obiekt `true`.  
  
 To zdarzenie zostanie wyzwolone tylko dla tego najwyższego poziomu.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.WebBrowser.Navigated" />
        <altmember cref="E:System.Windows.Controls.WebBrowser.LoadCompleted" />
      </Docs>
    </Member>
    <Member MemberName="ObjectForScripting">
      <MemberSignature Language="C#" Value="public object ObjectForScripting { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ObjectForScripting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.ObjectForScripting" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectForScripting As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ObjectForScripting { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ObjectForScripting : obj with get, set" Usage="System.Windows.Controls.WebBrowser.ObjectForScripting" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wystąpienie klasy publicznej implementowane przez aplikację hosta, który może zostać oceniony przez skrypt z hostowanej dokumentu.</summary>
        <value><see cref="T:System.Object" /> Oznacza to wystąpienie <see langword="public" /> klasy zaimplementowane przez aplikację hosta, który może zostać oceniony przez skrypt z hostowanej dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę właściwość można ustawić dla wszystkich obiektów widoczne dla modelu COM, dla którego chcesz jego właściwości publiczne i dostępne do wykonywania skryptów kodu metody. Możesz wprowadzić klasy widoczne COM, oznaczenie go atrybutem <xref:System.Runtime.InteropServices.ComVisibleAttribute>.  
  
 Obiekt, który jest ustawiony dla skryptów jest uwidaczniany w bieżącym dokumencie, [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] przy użyciu modelu DOM `window.external` właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Windows.Controls.WebBrowser.ObjectForScripting" /> została ustawiona za pomocą wystąpienia typu, który nie jest <see langword="COMVisible" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ponownie ładuje bieżącej strony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="webBrowser.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ponownie ładuje bieżącej strony.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Windows.Controls.WebBrowser" /> Wystąpienia nie jest już prawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Odwołanie do podstawowej native <c>WebBrowser</c> nie można pobrać.</exception>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (bool noCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(bool noCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.Refresh(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (noCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(bool noCache);" />
      <MemberSignature Language="F#" Value="member this.Refresh : bool -&gt; unit" Usage="webBrowser.Refresh noCache" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="noCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="noCache">Określa, czy należy odświeżyć bez sprawdzania poprawności w pamięci podręcznej.</param>
        <summary>Ponownie ładuje bieżącej strony z weryfikacją opcjonalną pamięcią podręczną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `noCache` jest `true`, <xref:System.Windows.Controls.WebBrowser> kontrolować odświeża bez sprawdzania poprawności w pamięci podręcznej, wysyłając "Pragma:no — pamięć podręczna" nagłówek do serwera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Windows.Controls.WebBrowser" /> Wystąpienia nie jest już prawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Odwołanie do podstawowej native <c>WebBrowser</c> nie można pobrać.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.WebBrowser.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Controls.WebBrowser.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Uri" /> z bieżącego dokumentu hostowanego w <see cref="T:System.Windows.Controls.WebBrowser" />.</summary>
        <value><see cref="T:System.Uri" /> Dla bieżącego [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie powoduje, że właściwość źródła <xref:System.Windows.Controls.WebBrowser> można przejść do dokumentu, określonego przez <xref:System.Uri>. Jeśli <xref:System.Uri> jest `null`, jest wyświetlany pusty dokument ("o: puste").  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób konfigurowania <xref:System.Windows.Controls.WebBrowser> można przejść do [!INCLUDE[TLA2#tla_html](~/includes/tla2sharptla-html-md.md)] dokumentu przy użyciu tylko znaczników.  
  
```xaml  
<!-- Web Browser Control that hosts a web page. -->  
<WebBrowser x:Name="webBrowser" Source="http://msdn.com"   
  Width="600" Height="600"  />  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Windows.Controls.WebBrowser" /> Wystąpienia nie jest już prawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Odwołanie do podstawowej native <c>WebBrowser</c> nie można pobrać.</exception>
        <exception cref="T:System.Security.SecurityException">Nawigacja z aplikacji, która działa w trybie częściowego zaufania do <see cref="T:System.Uri" /> który nie znajduje się w miejscu pochodzenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TabInto">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TabInto (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TabInto(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.System#Windows#Interop#IKeyboardInputSink#TabInto(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Function TabInto (request As TraversalRequest) As Boolean Implements IKeyboardInputSink.TabInto" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TabInto(System::Windows::Input::TraversalRequest ^ request) = System::Windows::Interop::IKeyboardInputSink::TabInto;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5" />
      </Parameters>
      <Docs>
        <param name="request">Określa, czy zespół powinien być ustawiony na pierwszym lub ostatnim tabulatora.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)" />.</summary>
        <returns><see langword="true" /> Jeśli fokus został ustawiony zgodnie z żądaniem; <see langword="false" />, jeśli nie ma żadnych tabulatorów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.WebBrowser> wystąpienia jest rzutowany na <xref:System.Windows.Interop.IKeyboardInputSink> interfejsu.

]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md">Omówienie współdziałanie Win32 i WPF</related>
        <related type="Article" href="~/docs/framework/wpf/advanced/input-overview.md">Przegląd Dane wejściowe</related>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TranslateAccelerator (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.System#Windows#Interop#IKeyboardInputSink#TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Function TranslateAccelerator (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean Implements IKeyboardInputSink.TranslateAccelerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers) = System::Windows::Interop::IKeyboardInputSink::TranslateAccelerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" Index="1" FrameworkAlternate="netframework-3.0;netframework-3.5" />
      </Parameters>
      <Docs>
        <param name="msg">Wiadomości i powiązane dane. Nie należy modyfikować tej struktury. Jest on przekazywany przez odwołanie, tylko ze względu na wydajność.</param>
        <param name="modifiers">Klawisze modyfikujące.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />.</summary>
        <returns><see langword="true" /> Jeśli wiadomość była obsługiwana przez implementację metody; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.WebBrowser> wystąpienia jest rzutowany na <xref:System.Windows.Interop.IKeyboardInputSink> interfejsu.

]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md">Omówienie współdziałanie Win32 i WPF</related>
        <related type="Article" href="~/docs/framework/wpf/advanced/input-overview.md">Przegląd Dane wejściowe</related>
      </Docs>
    </Member>
    <Member MemberName="TabIntoCore">
      <MemberSignature Language="C#" Value="protected override bool TabIntoCore (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool TabIntoCore(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.TabIntoCore(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function TabIntoCore (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool TabIntoCore(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.TabIntoCore : System.Windows.Input.TraversalRequest -&gt; bool" Usage="webBrowser.TabIntoCore request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="request">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslateAcceleratorCore">
      <MemberSignature Language="C#" Value="protected override bool TranslateAcceleratorCore (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool TranslateAcceleratorCore(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.WebBrowser.TranslateAcceleratorCore(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function TranslateAcceleratorCore (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool TranslateAcceleratorCore(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers);" />
      <MemberSignature Language="F#" Value="override this.TranslateAcceleratorCore :  * System.Windows.Input.ModifierKeys -&gt; bool" Usage="webBrowser.TranslateAcceleratorCore (msg, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="msg">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
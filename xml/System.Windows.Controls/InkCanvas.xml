<Type Name="InkCanvas" FullName="System.Windows.Controls.InkCanvas">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9eb4962ac21ee85bd3662a268679aaf37aef0ec5" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53499608" /></Metadata><TypeSignature Language="C#" Value="public class InkCanvas : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi InkCanvas extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.InkCanvas" />
  <TypeSignature Language="VB.NET" Value="Public Class InkCanvas&#xA;Inherits FrameworkElement&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class InkCanvas : System::Windows::FrameworkElement, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type InkCanvas = class&#xA;    inherit FrameworkElement&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ContentProperty("Children")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje obszar, który odbiera i wyświetlane pociągnięcia odręczne.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> Jest elementem, który może służyć do odbierania i wyświetlania danych wejściowych pisma odręcznego. Często można to zrobić za pomocą pióra, która współdziała z dyskretyzatora, aby wygenerować pociągnięć odręcznych przy użyciu pióra lub myszy. Utworzono pociągnięć są reprezentowane jako <xref:System.Windows.Ink.Stroke> obiektów i może być manipulowane albo programowo lub na podstawie danych wejściowych użytkownika. <xref:System.Windows.Controls.InkCanvas> Umożliwia użytkownikom zmodyfikować lub usunąć istniejące <xref:System.Windows.Ink.Stroke>.  
  
 <xref:System.Windows.Controls.InkCanvas> Może być powiązana ze źródłem danych. Na przykład, można powiązać <xref:System.Windows.Controls.InkCanvas.Strokes%2A> właściwości: base-64, zakodowany ciąg, który zawiera dane serializowane pisma odręcznego formatu (ISF); lub nawet do pismo odręczne <xref:System.Windows.Controls.InkCanvas.Strokes%2A> własności innej <xref:System.Windows.Controls.InkCanvas>. Możesz również powiązać właściwości, takie jak <xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes%2A> i <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>, z innymi źródłami danych.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak zasymulować użycie pióra i wyróżnienia, w tym samym <xref:System.Windows.Controls.InkCanvas>. W przykładzie założono, że element główny pliku markup language (XAML) jest <xref:System.Windows.Controls.DockPanel> o nazwie `root`. Przyjęto również założenie, że istnieje <xref:System.Windows.Controls.Button> o nazwie `switchHighlighter` oraz że zarówno <xref:System.Windows.Controls.Primitives.ButtonBase.Click> i <xref:System.Windows.FrameworkElement.Loaded> zdarzenia są podłączone do obsługi zdarzeń w tym przykładzie.  
  
 [!code-csharp[DrawingAttributes#3](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingAttributes/CSharp/Window1.xaml.cs#3)]
 [!code-vb[DrawingAttributes#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingAttributes/VisualBasic/Window1.xaml.vb#3)]  
  
 Poniższy przykład deklaruje dwie <xref:System.Windows.Controls.InkCanvas> obiekty w XAML i ustanawia powiązanie danych między nimi i innymi źródłami danych. Pierwszy <xref:System.Windows.Controls.InkCanvas>, co jest nazywane `ic`, jest powiązany z dwoma źródłami danych. <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> i <xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes%2A> właściwości `ic` są powiązane z <xref:System.Windows.Controls.ListBox> obiektów, które z kolei są powiązane z tablic zdefiniowane w XAML. <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>, <xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes%2A>, I <xref:System.Windows.Controls.InkCanvas.Strokes%2A> właściwości drugiego <xref:System.Windows.Controls.InkCanvas> są zobowiązane do pierwszego <xref:System.Windows.Controls.InkCanvas> w poniższym kodzie.  
  
 [!code-xaml[InkCanvasBindingSnippet#1](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasBindingSnippet/CS/Window1.xaml#1)]   
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms771466(v=vs.90)">Przykładu z galerii kontrolki WPF</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InkCanvas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InkCanvas();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy InkCanvas.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveEditingMode">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.InkCanvasEditingMode ActiveEditingMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.InkCanvasEditingMode ActiveEditingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.ActiveEditingMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveEditingMode As InkCanvasEditingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::InkCanvasEditingMode ActiveEditingMode { System::Windows::Controls::InkCanvasEditingMode get(); };" />
      <MemberSignature Language="F#" Value="member this.ActiveEditingMode : System.Windows.Controls.InkCanvasEditingMode" Usage="System.Windows.Controls.InkCanvas.ActiveEditingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasEditingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący tryb edycji <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <value>Bieżący tryb edycji <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> Właściwość wskazuje bieżący <xref:System.Windows.Controls.InkCanvasEditingMode> z <xref:System.Windows.Controls.InkCanvas>.  Załóżmy, że <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> ustawiono <xref:System.Windows.Controls.InkCanvasEditingMode.Ink> i <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> ustawiono <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>.  Gdy pióro jest używany w pozycji odwróconą <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> ma wartość <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>. W przeciwnym razie jego wartość wynosi <xref:System.Windows.Controls.InkCanvasEditingMode.Ink>.  
  
<a name="dependencyPropertyInfo_ActiveEditingMode"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.ActiveEditingModeProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład raporty wartość <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> zawsze, gdy zmienia się.  
  
 [!code-csharp[InkCanvasSamples#36](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#36)]
 [!code-vb[InkCanvasSamples#36](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveEditingModeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler ActiveEditingModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler ActiveEditingModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.ActiveEditingModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ActiveEditingModeChanged As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ ActiveEditingModeChanged;" />
      <MemberSignature Language="F#" Value="member this.ActiveEditingModeChanged : System.Windows.RoutedEventHandler " Usage="member this.ActiveEditingModeChanged : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie bieżącego trybu edycji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> Zawsze, gdy zmienia się właściwość <xref:System.Windows.Controls.InkCanvas> wprowadza nowy tryb edycji. Na przykład załóżmy, że <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> ustawiono <xref:System.Windows.Controls.InkCanvasEditingMode.Ink> i <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> ustawiono <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>. Gdy użytkownik zmieni porady pióra, <xref:System.Windows.Controls.InkCanvas.ActiveEditingModeChanged> wystąpi zdarzenie.  
  
<a name="routedEventInfo_ActiveEditingModeChanged"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.ActiveEditingModeChangedEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 Poniższy przykład raporty wartość <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> zawsze, gdy zmienia się.  
  
 [!code-csharp[InkCanvasSamples#36](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#36)]
 [!code-vb[InkCanvasSamples#36](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#36)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnActiveEditingModeChanged(System.Windows.RoutedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ActiveEditingModeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ActiveEditingModeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ActiveEditingModeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.ActiveEditingModeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActiveEditingModeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ActiveEditingModeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActiveEditingModeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.ActiveEditingModeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Controls.InkCanvas.ActiveEditingModeChanged" /> zdarzenia trasowanego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveEditingModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActiveEditingModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActiveEditingModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.ActiveEditingModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActiveEditingModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActiveEditingModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActiveEditingModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.ActiveEditingModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.InkCanvas.ActiveEditingMode" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeSize);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="inkCanvas.ArrangeOverride arrangeSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeSize">Końcowe obszar nadrzędnym, która powinna być używana ten element, aby rozmieścić wraz z jego elementów podrzędnych.</param>
        <summary>Określa położenie elementów podrzędnych i określa rozmiar dla <see cref="T:System.Windows.Controls.InkCanvas" /> obiektu.</summary>
        <returns>Jeśli rozmiar rzeczywisty jest używany.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Background : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.InkCanvas.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.Brush" />. Pędzel, jest używany do wypełnienia obramowania wokół obszaru <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <value>A <see cref="T:System.Windows.Media.Brush" /> używany do wypełniania obramowanie wokół obszaru <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Background"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.BackgroundProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak ustawić <xref:System.Windows.Controls.InkCanvas.Background%2A> właściwość <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#37](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#37)]
 [!code-vb[InkCanvasSamples#37](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#37)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BackgroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.InkCanvas.Background" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="see GetBottom, and SetBottom" />
      <MemberSignature Language="ILAsm" Value="see GetBottom, and SetBottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Bottom" />
      <MemberSignature Language="VB.NET" Value="see GetBottom, and SetBottom" />
      <MemberSignature Language="F#" Value="see GetBottom, and SetBottom" Usage="see GetBottom, and SetBottom" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub Ustawia odległość między dolnej części elementu i u dołu nadrzędnego <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Bottom"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.BottomProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
<a name="xamlAttributeUsage_Bottom"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object InkCanvas.Bottom="double"/>  
- or -  
<object InkCanvas.Bottom="qualifiedDouble"/>  
```  
  
<a name="xamlValues_Bottom"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 Ciąg reprezentujący <xref:System.Double> wartość. To jest interpretowane jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi jawnie zawierać separatorów dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 *qualifiedDouble*  
 A *double* wartość zgodnie z opisem powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` centymetrów; 1cm==(96/2.54) piks.  
  
 `pt` jest punktów. 1pt==(96/72) piks.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak ustawić położenie <xref:System.Windows.Controls.Label> na <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-xml[InkCanvasSamples#35](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BottomProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BottomProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BottomProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.BottomProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BottomProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BottomProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BottomProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.BottomProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.InkCanvas.Bottom" /> dołączona właściwość.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanPaste">
      <MemberSignature Language="C#" Value="public bool CanPaste ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanPaste() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.CanPaste" />
      <MemberSignature Language="VB.NET" Value="Public Function CanPaste () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanPaste();" />
      <MemberSignature Language="F#" Value="member this.CanPaste : unit -&gt; bool" Usage="inkCanvas.CanPaste " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy zawartość Schowka można wkleić do <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <returns><see langword="true" /> Jeśli zawartość Schowka można wkleić w; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> Może obsługiwać danych ze Schowka w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] formacie [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]i format tekstu.  
  
   
  
## Examples  
 Poniższy przykład kopiuje element do Schowka i wkleja je do <xref:System.Windows.Controls.InkCanvas>. W tym przykładzie przyjęto założenie, że istnieje element o nazwie `rect1`oraz że <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenia zostaną podłączone do obsługi zdarzeń w przykładzie.  
  
 [!code-csharp[InkCanvasSamples#1](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#1)]
 [!code-vb[InkCanvasSamples#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Uprawnienia do Wklej zawartość Schowka do <see cref="T:System.Windows.Controls.InkCanvas" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.UIPermissionClipboard.AllClipboard" />.</permission>
        <altmember cref="M:System.Windows.Controls.InkCanvas.CopySelection" />
        <altmember cref="Overload:System.Windows.Controls.InkCanvas.Paste" />
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.UIElementCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.UIElementCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As UIElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::UIElementCollection ^ Children { System::Windows::Controls::UIElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Controls.UIElementCollection" Usage="System.Windows.Controls.InkCanvas.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.UIElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera elementy podrzędne <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <value>Kolekcja elementów podrzędnych znajdujących się na <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlPropertyElementUsage_Children"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  OneOrMoreUIElements  
</object>  
```  
  
<a name="xamlValues_Children"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *OneOrMoreUIElements*  
 Co najmniej jeden <xref:System.Windows.UIElement> obiektów.  
  
   
  
## Examples  
 W poniższym przykładzie dodano <xref:System.Windows.Controls.TextBlock> do <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#8](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#8)]
 [!code-vb[InkCanvasSamples#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySelection">
      <MemberSignature Language="C#" Value="public void CopySelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopySelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.CopySelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopySelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopySelection();" />
      <MemberSignature Language="F#" Value="member this.CopySelection : unit -&gt; unit" Usage="inkCanvas.CopySelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje wybranych pociągnięć i/lub elementów do Schowka.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> Może obsługiwać danych ze Schowka w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] formacie [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]i format tekstu. Pociągnięć do Schowka są [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] formacie [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)].  
  
   
  
## Examples  
 Poniższy przykład wybiera dwa elementy na <xref:System.Windows.Controls.InkCanvas> i kopiuje je do Schowka. W tym przykładzie przyjęto założenie, że istnieje <xref:System.Windows.Controls.TextBox> o nazwie `textbox1` i <xref:System.Windows.Controls.Button> o nazwie `button1 -` i formanty thatboth są elementami podrzędnymi <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#3](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#3)]
 [!code-vb[InkCanvasSamples#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.CanPaste" />
        <altmember cref="Overload:System.Windows.Controls.InkCanvas.Paste" />
      </Docs>
    </Member>
    <Member MemberName="CutSelection">
      <MemberSignature Language="C#" Value="public void CutSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CutSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.CutSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub CutSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CutSelection();" />
      <MemberSignature Language="F#" Value="member this.CutSelection : unit -&gt; unit" Usage="inkCanvas.CutSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usunięcie wybranych pociągnięć i elementów i kopiuje je do Schowka.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> Może obsługiwać danych ze Schowka w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] formacie [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]i format tekstu. Pociągnięć do Schowka są [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] formacie [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)].  
  
   
  
## Examples  
 W poniższym przykładzie wybiera i skraca dwa elementy na <xref:System.Windows.Controls.InkCanvas>. W tym przykładzie przyjęto założenie, że istnieje <xref:System.Windows.Controls.TextBox> o nazwie `textbox1` i <xref:System.Windows.Controls.Button> o nazwie `button1` — i obie kontrolki znajdują się elementy podrzędne <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#4](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#4)]
 [!code-vb[InkCanvasSamples#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultDrawingAttributes">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.DrawingAttributes DefaultDrawingAttributes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Ink.DrawingAttributes DefaultDrawingAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultDrawingAttributes As DrawingAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Ink::DrawingAttributes ^ DefaultDrawingAttributes { System::Windows::Ink::DrawingAttributes ^ get(); void set(System::Windows::Ink::DrawingAttributes ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultDrawingAttributes : System.Windows.Ink.DrawingAttributes with get, set" Usage="System.Windows.Controls.InkCanvas.DefaultDrawingAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.DrawingAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia atrybuty rysowania, które są stosowane do nowych pociągnięcia odręczne na <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <value>Domyślnie atrybuty rysowania <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości obejmie tylko nowych obiektów, które zostały wprowadzone po ustawieniu tej właściwości. Aby zastosować nowe atrybuty rysowania ma już utworzony <xref:System.Windows.Ink.Stroke> obiektów, uzyskiwać do nich dostęp oddzielnie przy użyciu <xref:System.Windows.Controls.InkCanvas.Strokes%2A> właściwości.  
  
<a name="dependencyPropertyInfo_DefaultDrawingAttributes"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributesProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak za pomocą dwóch <xref:System.Windows.Ink.DrawingAttributes> obiektów, aby symulować doświadczenia przy użyciu pióra i wyróżnienia, w tym samym <xref:System.Windows.Controls.InkCanvas>. W przykładzie założono, że element główny pliku markup language (XAML) jest <xref:System.Windows.Controls.DockPanel> o nazwie `root`. Przyjęto również założenie, że istnieje <xref:System.Windows.Controls.Button> o nazwie `switchHilighter` i <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzeń jest podłączony do narzędzia obsługi zdarzeń.  
  
 [!code-csharp[DrawingAttributes#3](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingAttributes/CSharp/Window1.xaml.cs#3)]
 [!code-vb[DrawingAttributes#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingAttributes/VisualBasic/Window1.xaml.vb#3)]  
  
 Poniższy przykład pokazuje jak powiązać <xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes%2A> właściwość ze źródłem danych.  
  
 [!code-xaml[InkCanvasBindingSnippet#3](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasBindingSnippet/CS/Window2.xaml#3)]  
 [!code-xaml[InkCanvasBindingSnippet#4](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasBindingSnippet/CS/Window2.xaml#4)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.InkCanvas.Strokes" />
      </Docs>
    </Member>
    <Member MemberName="DefaultDrawingAttributesProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DefaultDrawingAttributesProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DefaultDrawingAttributesProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.DefaultDrawingAttributesProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultDrawingAttributesProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DefaultDrawingAttributesProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultDrawingAttributesProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.DefaultDrawingAttributesProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultDrawingAttributesReplaced">
      <MemberSignature Language="C#" Value="public event System.Windows.Ink.DrawingAttributesReplacedEventHandler DefaultDrawingAttributesReplaced;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Ink.DrawingAttributesReplacedEventHandler DefaultDrawingAttributesReplaced" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.DefaultDrawingAttributesReplaced" />
      <MemberSignature Language="VB.NET" Value="Public Event DefaultDrawingAttributesReplaced As DrawingAttributesReplacedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Ink::DrawingAttributesReplacedEventHandler ^ DefaultDrawingAttributesReplaced;" />
      <MemberSignature Language="F#" Value="member this.DefaultDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventHandler " Usage="member this.DefaultDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.DrawingAttributesReplacedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes" /> zastępuje właściwość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza wartość <xref:System.Windows.Ink.DrawingAttributes.IsHighlighter%2A> właściwości nowej <xref:System.Windows.Ink.DrawingAttributes> obiektu.  
  
 [!code-csharp[DrawingAttributes#17](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingAttributes/CSharp/Window1.xaml.cs#17)]
 [!code-vb[DrawingAttributes#17](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingAttributes/VisualBasic/Window1.xaml.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStylusPointDescription">
      <MemberSignature Language="C#" Value="public System.Windows.Input.StylusPointDescription DefaultStylusPointDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.StylusPointDescription DefaultStylusPointDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.DefaultStylusPointDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultStylusPointDescription As StylusPointDescription" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::StylusPointDescription ^ DefaultStylusPointDescription { System::Windows::Input::StylusPointDescription ^ get(); void set(System::Windows::Input::StylusPointDescription ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStylusPointDescription : System.Windows.Input.StylusPointDescription with get, set" Usage="System.Windows.Controls.InkCanvas.DefaultStylusPointDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusPointDescription</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia opis punktu pióro <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <value>Opis punktu pióro <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Windows.Controls.InkCanvas> przechowuje tylko <xref:System.Windows.Input.StylusPointProperties.X>, <xref:System.Windows.Input.StylusPointProperties.Y>, i <xref:System.Windows.Input.StylusPointProperties.NormalPressure> właściwości dla każdego <xref:System.Windows.Input.StylusPoint> należących do obrysu. Właściwość DefaultStylusPointDescription służy do przechowywania dodatkowych informacji o punktach wchodzących w skład pociągnięć na <xref:System.Windows.Controls.InkCanvas>. Ustawienie tej właściwości obejmie tylko nowych obiektów, które zostały wprowadzone po ustawieniu właściwości.  
  
<a name="xamlTextUsage_DefaultStylusPointDescription"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Nie można użyć tej właściwości w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład ustawia <xref:System.Windows.Controls.InkCanvas.DefaultStylusPointDescription%2A> tak, aby punkty pióro pociągnięć na <xref:System.Windows.Controls.InkCanvas> zawierają <xref:System.Windows.Input.StylusPointProperties.X>, <xref:System.Windows.Input.StylusPointProperties.Y>, <xref:System.Windows.Input.StylusPointProperties.NormalPressure>, i <xref:System.Windows.Input.StylusPointProperties.TipButton> właściwości.  
  
> [!NOTE]
>  Tylko kresek, które są dodawane do <xref:System.Windows.Controls.InkCanvas> po <xref:System.Windows.Controls.InkCanvas.DefaultStylusPointDescription%2A> jest ustawiona na zawiera dodatkowe właściwości.  
  
 [!code-csharp[InkCanvasSamples#9](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#9)]
 [!code-vb[InkCanvasSamples#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.StylusPointProperties" />
        <altmember cref="T:System.Windows.Input.StylusPointProperty" />
        <altmember cref="T:System.Windows.Input.StylusPointPropertyInfo" />
      </Docs>
    </Member>
    <Member MemberName="DynamicRenderer">
      <MemberSignature Language="C#" Value="protected System.Windows.Input.StylusPlugIns.DynamicRenderer DynamicRenderer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.StylusPlugIns.DynamicRenderer DynamicRenderer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.DynamicRenderer" />
      <MemberSignature Language="VB.NET" Value="Protected Property DynamicRenderer As DynamicRenderer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Input::StylusPlugIns::DynamicRenderer ^ DynamicRenderer { System::Windows::Input::StylusPlugIns::DynamicRenderer ^ get(); void set(System::Windows::Input::StylusPlugIns::DynamicRenderer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicRenderer : System.Windows.Input.StylusPlugIns.DynamicRenderer with get, set" Usage="System.Windows.Controls.InkCanvas.DynamicRenderer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusPlugIns.DynamicRenderer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia mechanizm renderujący oznacza dynamicznie rysuje pismo odręczne na <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <value>Mechanizm renderujący czy dynamicznie rysuje pismo odręczne na <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz ustawić <xref:System.Windows.Controls.InkCanvas.DynamicRenderer%2A> właściwości do niestandardowego <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> Jeśli chcesz dostosować pisma odręcznego.  
  
> [!NOTE]
>  <xref:System.Windows.Controls.InkCanvas.DynamicRenderer%2A> Jest elementem członkowskim <xref:System.Windows.UIElement.StylusPlugIns%2A> kolekcji. Po ustawieniu <xref:System.Windows.Controls.InkCanvas.DynamicRenderer%2A>, <xref:System.Windows.Controls.InkCanvas> usuwa stare <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> z <xref:System.Windows.Input.StylusPlugIns.StylusPlugInCollection> i dodaje nowe <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> na końcu kolekcji. Może to spowodować zmianę zachowania <xref:System.Windows.Controls.InkCanvas>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingMode">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.InkCanvasEditingMode EditingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.InkCanvasEditingMode EditingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.EditingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property EditingMode As InkCanvasEditingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::InkCanvasEditingMode EditingMode { System::Windows::Controls::InkCanvasEditingMode get(); void set(System::Windows::Controls::InkCanvasEditingMode value); };" />
      <MemberSignature Language="F#" Value="member this.EditingMode : System.Windows.Controls.InkCanvasEditingMode with get, set" Usage="System.Windows.Controls.InkCanvas.EditingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasEditingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia użytkownika używany przez urządzenie wskazujące aktywny tryb edycji.</summary>
        <value>Tryb edycji używany, gdy urządzenie wskazujące (na przykład pióra lub myszy) jest aktywny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> jest <xref:System.Windows.Controls.InkCanvasEditingMode.Ink>. Zmiana <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> czyści wszystkie wybrane istniejących.  
  
 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> Określa tryb urządzenia wskazującego, jak współpracuje z usługą <xref:System.Windows.Controls.InkCanvas>. <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> jest używana przez niektóre digitizerów, gdy "koniec gumki" pióro kontaktuje się dyskretyzatora.  
  
<a name="dependencyPropertyInfo_EditingMode"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.EditingModeProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład tworzy aplikację, która używa różnych typów tryby edycji na <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[ICEditingModeSample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ICEditingModeSample/CSharp/Window1.xaml.cs#1)]
 [!code-vb[ICEditingModeSample#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ICEditingModeSample/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.InkCanvas.EditingModeInverted" />
      </Docs>
    </Member>
    <Member MemberName="EditingModeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler EditingModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler EditingModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.EditingModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EditingModeChanged As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ EditingModeChanged;" />
      <MemberSignature Language="F#" Value="member this.EditingModeChanged : System.Windows.RoutedEventHandler " Usage="member this.EditingModeChanged : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Controls.InkCanvas.EditingMode" /> właściwość <see cref="T:System.Windows.Controls.InkCanvas" /> obiekt został zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje po zmianie trybu edycji; zmiany są uwzględniane w <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> właściwość <xref:System.Windows.Controls.InkCanvas>.  
  
<a name="routedEventInfo_EditingModeChanged"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.EditingModeChangedEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 Następujące testy przykład czy <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> właściwość jest ustawiona na <xref:System.Windows.Controls.InkCanvasEditingMode.Ink> lub <xref:System.Windows.Controls.InkCanvasEditingMode.Select>.  
  
 [!code-csharp[InkCanvasSamples#21](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#21)]
 [!code-vb[InkCanvasSamples#21](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent EditingModeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent EditingModeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.EditingModeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditingModeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ EditingModeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditingModeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.EditingModeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Controls.InkCanvas.EditingModeChanged" /> zdarzenia trasowanego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeInverted">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.InkCanvasEditingMode EditingModeInverted { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.InkCanvasEditingMode EditingModeInverted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.EditingModeInverted" />
      <MemberSignature Language="VB.NET" Value="Public Property EditingModeInverted As InkCanvasEditingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::InkCanvasEditingMode EditingModeInverted { System::Windows::Controls::InkCanvasEditingMode get(); void set(System::Windows::Controls::InkCanvasEditingMode value); };" />
      <MemberSignature Language="F#" Value="member this.EditingModeInverted : System.Windows.Controls.InkCanvasEditingMode with get, set" Usage="System.Windows.Controls.InkCanvas.EditingModeInverted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasEditingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia użytkownika tryb edycji, gdy pióro jest zmieniany przy wchodzi w interakcję <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <value>Odwrócony tryb edycji <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość określa akcje, które są wykonywane, gdy pióro jest odwrócony.  
  
 Podobnie <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> właściwość określa akcje, które są wykonywane, gdy pióro znajduje się w stanie standardowe, porada w dół względem dyskretyzatora,  
  
<a name="dependencyPropertyInfo_EditingModeInverted"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.EditingModeInvertedProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak umożliwić użytkownikowi częściowo wymazać pociągnięć końcówką odwróconą pióra. Eliptyczne kursora jest wyświetlany na <xref:System.Windows.Controls.InkCanvas> po użytkownik wymazanie pisma odręcznego.  
  
 [!code-csharp[InkCanvasSamples#6](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#6)]
 [!code-vb[InkCanvasSamples#6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeInvertedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler EditingModeInvertedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler EditingModeInvertedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.EditingModeInvertedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EditingModeInvertedChanged As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ EditingModeInvertedChanged;" />
      <MemberSignature Language="F#" Value="member this.EditingModeInvertedChanged : System.Windows.RoutedEventHandler " Usage="member this.EditingModeInvertedChanged : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Controls.InkCanvas.EditingModeInverted" /> właściwość <see cref="T:System.Windows.Controls.InkCanvas" /> obiekt został zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje po zmianie odwróconą tryb edycji. Te zmiany zostaną odzwierciedlone w <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> właściwość <xref:System.Windows.Controls.InkCanvas>.  
  
<a name="routedEventInfo_EditingModeInvertedChanged"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.EditingModeInvertedChangedEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 Następujące testy przykład czy <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> właściwość jest ustawiona na <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint> lub <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByStroke>.  
  
 [!code-csharp[InkCanvasSamples#20](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#20)]
 [!code-vb[InkCanvasSamples#20](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeInvertedChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent EditingModeInvertedChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent EditingModeInvertedChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.EditingModeInvertedChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditingModeInvertedChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ EditingModeInvertedChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditingModeInvertedChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.EditingModeInvertedChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Controls.InkCanvas.EditingModeInvertedChanged" /> zdarzenia trasowanego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeInvertedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EditingModeInvertedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EditingModeInvertedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.EditingModeInvertedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditingModeInvertedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ EditingModeInvertedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditingModeInvertedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.EditingModeInvertedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.InkCanvas.EditingModeInverted" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EditingModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EditingModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.EditingModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditingModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ EditingModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditingModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.EditingModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.InkCanvas.EditingMode" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EraserShape">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StylusShape EraserShape { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Ink.StylusShape EraserShape" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.EraserShape" />
      <MemberSignature Language="VB.NET" Value="Public Property EraserShape As StylusShape" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Ink::StylusShape ^ EraserShape { System::Windows::Ink::StylusShape ^ get(); void set(System::Windows::Ink::StylusShape ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EraserShape : System.Windows.Ink.StylusShape with get, set" Usage="System.Windows.Controls.InkCanvas.EraserShape" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StylusShape</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Ink.StylusShape" /> używany do punktu wymazywanie pisma odręcznego z <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <value>Kształt gumki skojarzone z <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten kształt będzie służyć do wymazanie pisma odręcznego z <xref:System.Windows.Controls.InkCanvas> podczas bieżącej <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> ustawiono <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>.  
  
 Poszczególne właściwości <xref:System.Windows.Ink.StylusShape> nie może być modyfikowany po utworzeniu kształtu.  
  
 Jeśli zmienisz <xref:System.Windows.Controls.InkCanvas.EraserShape%2A>, kursor renderowania na <xref:System.Windows.Controls.InkCanvas> nie jest aktualizowana, aż do następnej <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> zmiany.  
  
<a name="xamlTextUsage_EraserShape"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Ta właściwość nie jest zazwyczaj używany w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak umożliwić użytkownikowi częściowo wymazać pociągnięć końcówką odwróconą pióra. Eliptyczne kursora jest wyświetlany na <xref:System.Windows.Controls.InkCanvas> po użytkownik wymazanie pisma odręcznego.  
  
 [!code-csharp[InkCanvasSamples#6](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#6)]
 [!code-vb[InkCanvasSamples#6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Ink.StylusShape" />
      </Docs>
    </Member>
    <Member MemberName="Gesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasGestureEventHandler Gesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasGestureEventHandler Gesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.Gesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Gesture As InkCanvasGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasGestureEventHandler ^ Gesture;" />
      <MemberSignature Language="F#" Value="member this.Gesture : System.Windows.Controls.InkCanvasGestureEventHandler " Usage="member this.Gesture : System.Windows.Controls.InkCanvasGestureEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="T:System.Windows.Controls.InkCanvas" /> wykryciu gestu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_Gesture"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.GestureEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.Controls.InkCanvasGestureEventHandler>|  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak skonfigurować <xref:System.Windows.Controls.InkCanvas> rozpoznać gesty aplikacji.  
  
 [!code-csharp[GestureSample#3](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#3)]
 [!code-vb[GestureSample#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#3)]  
[!code-csharp[GestureSample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#1)]
[!code-vb[GestureSample#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.GestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.GestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Controls.InkCanvas.Gesture" /> zdarzenia trasowanego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBottom">
      <MemberSignature Language="C#" Value="public static double GetBottom (System.Windows.UIElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetBottom(class System.Windows.UIElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetBottom(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBottom (element As UIElement) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetBottom(System::Windows::UIElement ^ element);" />
      <MemberSignature Language="F#" Value="static member GetBottom : System.Windows.UIElement -&gt; double" Usage="System.Windows.Controls.InkCanvas.GetBottom element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="element">Element, którego można pobrać właściwości dolnej.</param>
        <summary>Pobiera wartość <see cref="P:System.Windows.Controls.InkCanvas.Bottom" /> dołączona właściwość zależności danego obiektu.</summary>
        <returns>Współrzędna dolnej obiektu zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać położenie <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[InkCanvasSamples#34](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#34)]
 [!code-vb[InkCanvasSamples#34](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnabledGestures">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Ink.ApplicationGesture&gt; GetEnabledGestures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;valuetype System.Windows.Ink.ApplicationGesture&gt; GetEnabledGestures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetEnabledGestures" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnabledGestures () As ReadOnlyCollection(Of ApplicationGesture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Ink::ApplicationGesture&gt; ^ GetEnabledGestures();" />
      <MemberSignature Language="F#" Value="member this.GetEnabledGestures : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Ink.ApplicationGesture&gt;" Usage="inkCanvas.GetEnabledGestures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Ink.ApplicationGesture&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję gesty aplikacji, które są rozpoznawane przez <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <returns>Kolekcja gesty, które <see cref="T:System.Windows.Controls.InkCanvas" /> rozpoznaje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać gesty aplikacji obsługującej z <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#24](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#24)]
 [!code-vb[InkCanvasSamples#24](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Controls.InkCanvas.IsGestureRecognizerAvailable" /> Właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLeft">
      <MemberSignature Language="C#" Value="public static double GetLeft (System.Windows.UIElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetLeft(class System.Windows.UIElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetLeft(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLeft (element As UIElement) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetLeft(System::Windows::UIElement ^ element);" />
      <MemberSignature Language="F#" Value="static member GetLeft : System.Windows.UIElement -&gt; double" Usage="System.Windows.Controls.InkCanvas.GetLeft element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="element">Element, którego można pobrać właściwości po lewej stronie.</param>
        <summary>Pobiera wartość <see cref="P:System.Windows.Controls.InkCanvas.Left" /> dołączona właściwość zależności danego obiektu.</summary>
        <returns>Współrzędna lewej obiektu zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać położenie <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[InkCanvasSamples#31](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#31)]
 [!code-vb[InkCanvasSamples#31](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRight">
      <MemberSignature Language="C#" Value="public static double GetRight (System.Windows.UIElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetRight(class System.Windows.UIElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetRight(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRight (element As UIElement) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetRight(System::Windows::UIElement ^ element);" />
      <MemberSignature Language="F#" Value="static member GetRight : System.Windows.UIElement -&gt; double" Usage="System.Windows.Controls.InkCanvas.GetRight element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="element">Element, z którego mają zostać pobrane prawej właściwości.</param>
        <summary>Pobiera wartość <see cref="P:System.Windows.Controls.InkCanvas.Right" /> dołączona właściwość zależności danego obiektu.</summary>
        <returns>Współrzędna prawej obiektu zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać położenie <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[InkCanvasSamples#32](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#32)]
 [!code-vb[InkCanvasSamples#32](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSelectedElements">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.UIElement&gt; GetSelectedElements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.UIElement&gt; GetSelectedElements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSelectedElements () As ReadOnlyCollection(Of UIElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::UIElement ^&gt; ^ GetSelectedElements();" />
      <MemberSignature Language="F#" Value="member this.GetSelectedElements : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.UIElement&gt;" Usage="inkCanvas.GetSelectedElements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.UIElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.FrameworkElement" /> obiekty, które są wybrane w <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <returns>Tablica <see cref="T:System.Windows.FrameworkElement" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta zwraca tylko <xref:System.Windows.FrameworkElement> obiekty nie <xref:System.Windows.Ink.Stroke> obiektów.  
  
 Można pobrać wybrane <xref:System.Windows.Ink.Stroke> obiektów, wywołaj <xref:System.Windows.Controls.InkCanvas.GetSelectedStrokes%2A> metody.  
  
 Jeśli <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> z <xref:System.Windows.Controls.InkCanvas> ustawiono <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>, użytkownicy mogą wybrać <xref:System.Windows.Ink.Stroke> obiektów i <xref:System.Windows.FrameworkElement> obiektów. Alternatywnie, oba rodzaje obiektów można wybrać przy użyciu kodu: po prostu Wywołaj <xref:System.Windows.Controls.InkCanvas.Select%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład podwaja wysokość i szerokość każdego elementu wybranego na <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#12](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#12)]
 [!code-vb[InkCanvasSamples#12](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="Overload:System.Windows.Controls.InkCanvas.Select" />
      </Docs>
    </Member>
    <Member MemberName="GetSelectedStrokes">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StrokeCollection GetSelectedStrokes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Ink.StrokeCollection GetSelectedStrokes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSelectedStrokes () As StrokeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Ink::StrokeCollection ^ GetSelectedStrokes();" />
      <MemberSignature Language="F#" Value="member this.GetSelectedStrokes : unit -&gt; System.Windows.Ink.StrokeCollection" Usage="inkCanvas.GetSelectedStrokes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StrokeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Ink.StrokeCollection" /> który reprezentuje wybrane <see cref="T:System.Windows.Ink.Stroke" /> obiektów na <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <returns>Kolekcja wybranych pociągnięć.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca <xref:System.Windows.Ink.Stroke> obiektów tylko. Można pobrać wybrane <xref:System.Windows.FrameworkElement> obiektów, wywołaj <xref:System.Windows.Controls.InkCanvas.GetSelectedElements%2A> metody.  
  
 Jeśli <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> z <xref:System.Windows.Controls.InkCanvas> ustawiono <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>, użytkownicy mogą wybrać <xref:System.Windows.Ink.Stroke> obiektów i <xref:System.Windows.FrameworkElement> obiektów. Alternatywnie, oba rodzaje obiektów można wybrać przy użyciu kodu: po prostu Wywołaj <xref:System.Windows.Controls.InkCanvas.Select%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład zmienia kolor każdego wybranego obrysu na <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#11](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#11)]
 [!code-vb[InkCanvasSamples#11](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Controls.InkCanvas.Select" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="GetSelectionBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetSelectionBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetSelectionBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetSelectionBounds" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSelectionBounds () As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetSelectionBounds();" />
      <MemberSignature Language="F#" Value="member this.GetSelectionBounds : unit -&gt; System.Windows.Rect" Usage="inkCanvas.GetSelectionBounds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera granice wybranych pociągnięć i elementów dla <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <returns>Najmniejszego prostokąta, który obejmuje wszystkich wybranych pociągnięć i elementów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład uniemożliwia użytkownikowi dokonanie wyboru jest mniejszy niż oryginalny rozmiar.  
  
 [!code-csharp[InkCanvasSamples#16](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#16)]
 [!code-vb[InkCanvasSamples#16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTop">
      <MemberSignature Language="C#" Value="public static double GetTop (System.Windows.UIElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetTop(class System.Windows.UIElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetTop(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTop (element As UIElement) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetTop(System::Windows::UIElement ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTop : System.Windows.UIElement -&gt; double" Usage="System.Windows.Controls.InkCanvas.GetTop element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="element">Element, którego można pobrać właściwość top.</param>
        <summary>Pobiera wartość <see cref="P:System.Windows.Controls.InkCanvas.Top" /> dołączona właściwość zależności danego obiektu.</summary>
        <returns>Współrzędne obiektu zależności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać położenie <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[InkCanvasSamples#33](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#33)]
 [!code-vb[InkCanvasSamples#33](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="inkCanvas.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu podrzędnego żądanego elementu w kolekcji.</param>
        <summary>Zastępuje <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />i zwraca kolekcję elementów podrzędnych elementu podrzędnego wskazywanego przez określony indeks.</summary>
        <returns>Element podrzędny żądanej. To nie powinna zwracać <see langword="null" />; Jeśli podany indeks jest poza zakres, zgłaszany jest wyjątek.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParams);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HitTestCore (hitTestParams As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParams);" />
      <MemberSignature Language="F#" Value="override this.HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult" Usage="inkCanvas.HitTestCore hitTestParams" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParams" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParams">Obiekt, który określa <see cref="T:System.Windows.Point" /> aby trafić Testuj pod względem.</param>
        <summary>Określa, czy dany punkt mieści się w granicach renderowania <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <returns>Obiekt, który reprezentuje <see cref="T:System.Windows.Media.Visual" /> zwrócone z hit test.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestSelection">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.InkCanvasSelectionHitResult HitTestSelection (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Controls.InkCanvasSelectionHitResult HitTestSelection(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.HitTestSelection(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Controls::InkCanvasSelectionHitResult HitTestSelection(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.HitTestSelection : System.Windows.Point -&gt; System.Windows.Controls.InkCanvasSelectionHitResult" Usage="inkCanvas.HitTestSelection point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasSelectionHitResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Wskaż przeprowadzanie testu trafienia.</param>
        <summary>Zwraca wartość wskazującą, które część wyboru moduł definiowania układu przecina lub otacza określony punkt.</summary>
        <returns>Wartość, która wskazuje, która część wyboru moduł definiowania układu przecina lub otacza określony punkt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Controls.InkCanvas.HitTestSelection%2A> metodę pozwala ustalić, czy punkt znajduje się w granicach wyboru pociągnięć lub jednego z ośmiu uchwyty.  Jest to przydatne, gdy wykonywanie operacje przeciągania i upuszczania.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Controls.InkCanvas.HitTestSelection%2A> do ustalenia, czy należy utworzyć <xref:System.Windows.DataObject> zainicjować przeciągania i upuszczania.  Aby zaimplementować przeciągania i upuszczania między dwoma <xref:System.Windows.Controls.InkCanvas> obiekty, zobacz [jak: Przeciąganie i upuszczanie pisma odręcznego](~/docs/framework/wpf/advanced/how-to-drag-and-drop-ink.md).  
  
 [!code-csharp[InkDragDrop#3](~/samples/snippets/csharp/VS_Snippets_Wpf/InkDragDrop/CSharp/Window1.xaml.cs#3)]
 [!code-vb[InkDragDrop#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkDragDrop/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InkPresenter">
      <MemberSignature Language="C#" Value="protected System.Windows.Controls.InkPresenter InkPresenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.InkPresenter InkPresenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.InkPresenter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property InkPresenter As InkPresenter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Controls::InkPresenter ^ InkPresenter { System::Windows::Controls::InkPresenter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InkPresenter : System.Windows.Controls.InkPresenter" Usage="System.Windows.Controls.InkCanvas.InkPresenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkPresenter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Prezenter pisma odręcznego wyświetlanego pismo odręczne na <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <value>Prezenter pisma odręcznego wyświetlanego pismo odręczne na <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGestureRecognizerAvailable">
      <MemberSignature Language="C#" Value="public bool IsGestureRecognizerAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGestureRecognizerAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.IsGestureRecognizerAvailable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGestureRecognizerAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGestureRecognizerAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGestureRecognizerAvailable : bool" Usage="System.Windows.Controls.InkCanvas.IsGestureRecognizerAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera (określa) czy składnik rozpoznawania gestów jest dostępne w systemie użytkownika.</summary>
        <value><see langword="true" /> Jeśli składnik Rozpoznawanie jest dostępna; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak skonfigurować <xref:System.Windows.Controls.InkCanvas> rozpoznać gesty aplikacji.  
  
 [!code-csharp[GestureSample#3](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#3)]
 [!code-vb[GestureSample#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#3)]  
[!code-csharp[GestureSample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#1)]
[!code-vb[GestureSample#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="see GetLeft, and SetLeft" />
      <MemberSignature Language="ILAsm" Value="see GetLeft, and SetLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Left" />
      <MemberSignature Language="VB.NET" Value="see GetLeft, and SetLeft" />
      <MemberSignature Language="F#" Value="see GetLeft, and SetLeft" Usage="see GetLeft, and SetLeft" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub Ustawia odległość między po lewej stronie elementu i lewą stroną jego elementu nadrzędnego <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Left"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.LeftProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
<a name="xamlAttributeUsage_Left"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object InkCanvas.Left="double"/>  
- or -  
<object InkCanvas.Left="qualifiedDouble"/>  
```  
  
<a name="xamlValues_Left"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 Ciąg reprezentujący <xref:System.Double> wartość. To jest interpretowane jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi jawnie zawierać separatorów dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 *qualifiedDouble*  
 A *double* wartość zgodnie z opisem powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` centymetrów; 1cm==(96/2.54) piks.  
  
 `pt` jest punktów. 1pt==(96/72) piks.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak ustawić położenie <xref:System.Windows.Controls.Label> na <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-xml[InkCanvasSamples#35](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.InkCanvas.Left" /> dołączona właściwość.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.InkCanvas.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca moduł wyliczający do elementów podrzędnych logicznego.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="inkCanvas.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Dostępny rozmiar tego elementu można przydzielić do elementów podrzędnych. Infinity można określić jako wartość, aby wskazać, że element rozmiar zostanie zmieniony na dowolną zawartość jest dostępna.</param>
        <summary>Mierzy rozmiaru w układzie wymagane dla elementów podrzędnych i określa rozmiar dla <see cref="System.Windows.Controls.InkCanvas" /> obiektu.</summary>
        <returns>Rozmiar ten element określa ona musi podczas układu, w oparciu o obliczenia rozmiarów elementu podrzędnego.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="MoveEnabled">
      <MemberSignature Language="C#" Value="public bool MoveEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MoveEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.MoveEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property MoveEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MoveEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MoveEnabled : bool with get, set" Usage="System.Windows.Controls.InkCanvas.MoveEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość logiczną, która wskazuje, czy użytkownik jest aktywny, można przenieść wybranych pociągnięć i/lub elementów <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <value><see langword="true" /> Jeśli użytkownik może przejść pociągnięć lub elementów <see cref="T:System.Windows.Controls.InkCanvas" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest ustawiona `true`, obramowania moduł definiowania układu kodu jest rysowane wokół pociągnięć odręcznych lub elementów, gdy są zaznaczone. To obramowanie umożliwia użytkownikowi przenoszenie zaznaczonych obiektów. Jeśli <xref:System.Windows.Controls.InkCanvas.ResizeEnabled%2A> jest `true`, moduł definiowania układu umożliwia użytkownikowi zmienianie rozmiaru pociągnięć lub elementów również.  
  
 Jeśli ta właściwość jest ustawiona `false` zaznaczeniu pociągnięć odręcznych lub elementów obramowania moduł definiowania układu kodu zostaną automatycznie usunięte z zaznaczonych obiektów.  
  
   
  
## Examples  
 Poniższy przykład uniemożliwia użytkownikowi przenoszenie i zmienianie rozmiaru elementów i obrysy na <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#7](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#7)]
 [!code-vb[InkCanvasSamples#7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActiveEditingModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnActiveEditingModeChanged (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActiveEditingModeChanged(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnActiveEditingModeChanged(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActiveEditingModeChanged (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActiveEditingModeChanged(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActiveEditingModeChanged : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnActiveEditingModeChanged : System.Windows.RoutedEventArgs -&gt; unit" Usage="inkCanvas.OnActiveEditingModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.ActiveEditingModeChanged" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="inkCanvas.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia odpowiednią <see cref="T:System.Windows.Automation.Peers.InkCanvasAutomationPeer" /> implementacji dla tej kontrolki, jako część [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] infrastruktury.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDefaultDrawingAttributesReplaced">
      <MemberSignature Language="C#" Value="protected virtual void OnDefaultDrawingAttributesReplaced (System.Windows.Ink.DrawingAttributesReplacedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDefaultDrawingAttributesReplaced(class System.Windows.Ink.DrawingAttributesReplacedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnDefaultDrawingAttributesReplaced(System.Windows.Ink.DrawingAttributesReplacedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDefaultDrawingAttributesReplaced (e As DrawingAttributesReplacedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDefaultDrawingAttributesReplaced(System::Windows::Ink::DrawingAttributesReplacedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDefaultDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventArgs -&gt; unit&#xA;override this.OnDefaultDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventArgs -&gt; unit" Usage="inkCanvas.OnDefaultDrawingAttributesReplaced e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Ink.DrawingAttributesReplacedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.DefaultDrawingAttributesReplaced" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEditingModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEditingModeChanged (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEditingModeChanged(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnEditingModeChanged(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEditingModeChanged (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEditingModeChanged(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEditingModeChanged : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnEditingModeChanged : System.Windows.RoutedEventArgs -&gt; unit" Usage="inkCanvas.OnEditingModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.EditingModeChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje po zmianie trybu edycji; zmiany są uwzględniane w <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> właściwość <xref:System.Windows.Controls.InkCanvas>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEditingModeInvertedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEditingModeInvertedChanged (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEditingModeInvertedChanged(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnEditingModeInvertedChanged(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEditingModeInvertedChanged (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEditingModeInvertedChanged(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEditingModeInvertedChanged : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnEditingModeInvertedChanged : System.Windows.RoutedEventArgs -&gt; unit" Usage="inkCanvas.OnEditingModeInvertedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.EditingModeInvertedChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje po zmianie odwróconą tryb edycji; zmiany zostaną uwzględnione w <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> właściwość <xref:System.Windows.Controls.InkCanvas>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnGesture (System.Windows.Controls.InkCanvasGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGesture(class System.Windows.Controls.InkCanvasGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnGesture(System.Windows.Controls.InkCanvasGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGesture (e As InkCanvasGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGesture(System::Windows::Controls::InkCanvasGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGesture : System.Windows.Controls.InkCanvasGestureEventArgs -&gt; unit&#xA;override this.OnGesture : System.Windows.Controls.InkCanvasGestureEventArgs -&gt; unit" Usage="inkCanvas.OnGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.Gesture" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="inkCanvas.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia, które opisuje właściwość, która się zmieniła, a także starej i nowej wartości.</param>
        <summary>Wywoływane, gdy wartość dowolnej właściwości zależności, w tym <see cref="T:System.Windows.FrameworkElement" /> został zaktualizowany. Zmieniona właściwość konkretnej zależności jest zgłaszany w parametrze argumentów. Zastępuje <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanged : EventArgs -&gt; unit&#xA;override this.OnSelectionChanged : EventArgs -&gt; unit" Usage="inkCanvas.OnSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.SelectionChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy zestaw pociągnięć odręcznych lub elementów został wybrany przez użytkownika i została zastosowana zmiana zaznaczenia. Przed zastosowaniem zmian <xref:System.Windows.Controls.InkCanvas.OnSelectionChanging%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionChanging(System.Windows.Controls.InkCanvasSelectionChangingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanging (System.Windows.Controls.InkCanvasSelectionChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanging(class System.Windows.Controls.InkCanvasSelectionChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionChanging(System.Windows.Controls.InkCanvasSelectionChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanging (e As InkCanvasSelectionChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanging(System::Windows::Controls::InkCanvasSelectionChangingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanging : System.Windows.Controls.InkCanvasSelectionChangingEventArgs -&gt; unit&#xA;override this.OnSelectionChanging : System.Windows.Controls.InkCanvasSelectionChangingEventArgs -&gt; unit" Usage="inkCanvas.OnSelectionChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasSelectionChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.SelectionChanging" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy nowy wyboru pociągnięć lub elementów przez użytkownika, ale zanim zmiana zostanie zastosowana. Po zastosowaniu zmiany <xref:System.Windows.Controls.InkCanvas.OnSelectionChanged%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionMoved (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionMoved(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionMoved(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionMoved (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionMoved(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionMoved : EventArgs -&gt; unit&#xA;override this.OnSelectionMoved : EventArgs -&gt; unit" Usage="inkCanvas.OnSelectionMoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Nie używany.</param>
        <summary>Zdarzenie ogłaszamy, że użytkownik zaznaczone, a następnie przenieść wyboru pociągnięć lub elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana po przeniesieniu przez użytkownika wyboru pociągnięć lub elementów i zmiana została zastosowana. Przed zastosowaniem zmian <xref:System.Windows.Controls.InkCanvas.OnSelectionMoving%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionMoving(System.Windows.Controls.InkCanvasSelectionEditingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionMoving (System.Windows.Controls.InkCanvasSelectionEditingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionMoving(class System.Windows.Controls.InkCanvasSelectionEditingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionMoving(System.Windows.Controls.InkCanvasSelectionEditingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionMoving (e As InkCanvasSelectionEditingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionMoving(System::Windows::Controls::InkCanvasSelectionEditingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionMoving : System.Windows.Controls.InkCanvasSelectionEditingEventArgs -&gt; unit&#xA;override this.OnSelectionMoving : System.Windows.Controls.InkCanvasSelectionEditingEventArgs -&gt; unit" Usage="inkCanvas.OnSelectionMoving e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasSelectionEditingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.SelectionMoving" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana po użytkownik zażąda przeniesienia wyboru pociągnięć lub elementów i zanim zmiana zostanie zastosowana. Po zastosowaniu zmiany <xref:System.Windows.Controls.InkCanvas.OnSelectionMoved%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionMoved(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionResized">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionResized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionResized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionResized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionResized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionResized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionResized : EventArgs -&gt; unit&#xA;override this.OnSelectionResized : EventArgs -&gt; unit" Usage="inkCanvas.OnSelectionResized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.SelectionResized" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana po wyboru pociągnięć lub elementów został zmieniony przez użytkownika i zmiana została zastosowana. Przed zastosowaniem zmian <xref:System.Windows.Controls.InkCanvas.OnSelectionResizing%2A> metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionResizing(System.Windows.Controls.InkCanvasSelectionEditingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionResizing">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionResizing (System.Windows.Controls.InkCanvasSelectionEditingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionResizing(class System.Windows.Controls.InkCanvasSelectionEditingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionResizing(System.Windows.Controls.InkCanvasSelectionEditingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionResizing (e As InkCanvasSelectionEditingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionResizing(System::Windows::Controls::InkCanvasSelectionEditingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionResizing : System.Windows.Controls.InkCanvasSelectionEditingEventArgs -&gt; unit&#xA;override this.OnSelectionResizing : System.Windows.Controls.InkCanvasSelectionEditingEventArgs -&gt; unit" Usage="inkCanvas.OnSelectionResizing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasSelectionEditingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.SelectionResizing" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana po użytkownik zażąda wyboru pociągnięć lub elementów można zmienić jego rozmiaru i zanim zmiana zostanie zastosowana. Po zastosowaniu zmiany <xref:System.Windows.Controls.InkCanvas.OnSelectionResized%2A> metoda zostanie wywołana.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionResized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStrokeCollected">
      <MemberSignature Language="C#" Value="protected virtual void OnStrokeCollected (System.Windows.Controls.InkCanvasStrokeCollectedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStrokeCollected(class System.Windows.Controls.InkCanvasStrokeCollectedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnStrokeCollected(System.Windows.Controls.InkCanvasStrokeCollectedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStrokeCollected (e As InkCanvasStrokeCollectedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStrokeCollected(System::Windows::Controls::InkCanvasStrokeCollectedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStrokeCollected : System.Windows.Controls.InkCanvasStrokeCollectedEventArgs -&gt; unit&#xA;override this.OnStrokeCollected : System.Windows.Controls.InkCanvasStrokeCollectedEventArgs -&gt; unit" Usage="inkCanvas.OnStrokeCollected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasStrokeCollectedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.StrokeCollected" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas.OnStrokeCollected%2A> jest wywoływana, gdy użytkownik fizycznie kończy pociągnięcia, na przykład poprzez podnoszenie pióra od tablecie po wprowadzeniu ruchu.  
  
 Programowe Dodawanie naciśniętych <xref:System.Windows.Controls.InkCanvas.Strokes%2A> kolekcji nie wywoła <xref:System.Windows.Controls.InkCanvas.OnStrokeCollected%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStrokeErased">
      <MemberSignature Language="C#" Value="protected virtual void OnStrokeErased (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStrokeErased(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnStrokeErased(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStrokeErased (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStrokeErased(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStrokeErased : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnStrokeErased : System.Windows.RoutedEventArgs -&gt; unit" Usage="inkCanvas.OnStrokeErased e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.StrokeErased" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStrokeErasing">
      <MemberSignature Language="C#" Value="protected virtual void OnStrokeErasing (System.Windows.Controls.InkCanvasStrokeErasingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStrokeErasing(class System.Windows.Controls.InkCanvasStrokeErasingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnStrokeErasing(System.Windows.Controls.InkCanvasStrokeErasingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStrokeErasing (e As InkCanvasStrokeErasingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStrokeErasing(System::Windows::Controls::InkCanvasStrokeErasingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStrokeErasing : System.Windows.Controls.InkCanvasStrokeErasingEventArgs -&gt; unit&#xA;override this.OnStrokeErasing : System.Windows.Controls.InkCanvasStrokeErasingEventArgs -&gt; unit" Usage="inkCanvas.OnStrokeErasing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasStrokeErasingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.StrokeErasing" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStrokesReplaced">
      <MemberSignature Language="C#" Value="protected virtual void OnStrokesReplaced (System.Windows.Controls.InkCanvasStrokesReplacedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStrokesReplaced(class System.Windows.Controls.InkCanvasStrokesReplacedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnStrokesReplaced(System.Windows.Controls.InkCanvasStrokesReplacedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStrokesReplaced (e As InkCanvasStrokesReplacedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStrokesReplaced(System::Windows::Controls::InkCanvasStrokesReplacedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStrokesReplaced : System.Windows.Controls.InkCanvasStrokesReplacedEventArgs -&gt; unit&#xA;override this.OnStrokesReplaced : System.Windows.Controls.InkCanvasStrokesReplacedEventArgs -&gt; unit" Usage="inkCanvas.OnStrokesReplaced e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasStrokesReplacedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane dotyczące zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Controls.InkCanvas.StrokesReplaced" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Paste">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wkleja zawartość Schowka do <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> Może obsługiwać danych ze Schowka w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] formacie [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]i format tekstu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Paste" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste();" />
      <MemberSignature Language="F#" Value="member this.Paste : unit -&gt; unit" Usage="inkCanvas.Paste " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wkleja zawartość Schowka do lewego górnego rogu <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> Może obsługiwać danych ze Schowka w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] formacie [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]i format tekstu.  
  
   
  
## Examples  
 Poniższy przykład kopiuje element do Schowka i wkleja je do <xref:System.Windows.Controls.InkCanvas>. W tym przykładzie przyjęto założenie, że istnieje element o nazwie `rect1`oraz że <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenia zostaną podłączone do obsługi zdarzeń w przykładzie.  
  
 [!code-csharp[InkCanvasSamples#1](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#1)]
 [!code-vb[InkCanvasSamples#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wklejenie zawartości Schowka w celu <see cref="T:System.Windows.Controls.InkCanvas" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.UIPermissionClipboard.AllClipboard" />.</permission>
        <altmember cref="M:System.Windows.Controls.InkCanvas.CopySelection" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.CanPaste" />
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Paste(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.Paste : System.Windows.Point -&gt; unit" Usage="inkCanvas.Paste point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Punkt, w którym należy wkleić pociągnięć.</param>
        <summary>Wkleja zawartość Schowka do <see cref="T:System.Windows.Controls.InkCanvas" /> w danym momencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> Może obsługiwać danych ze Schowka w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] formacie [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]i format tekstu.  
  
   
  
## Examples  
 Poniższy przykład kopiuje element do Schowka i wkleja je do <xref:System.Windows.Controls.InkCanvas>. W tym przykładzie przyjęto założenie, że istnieje element o nazwie `rect1`oraz że <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenia są podłączone do obsługi zdarzeń w przykładzie.  
  
 [!code-csharp[InkCanvasSamples#1](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#1)]
 [!code-vb[InkCanvasSamples#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Uprawnienia do Wklej zawartość Schowka do <see cref="T:System.Windows.Controls.InkCanvas" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.UIPermissionClipboard.AllClipboard" />.</permission>
        <altmember cref="M:System.Windows.Controls.InkCanvas.CopySelection" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.CanPaste" />
      </Docs>
    </Member>
    <Member MemberName="PreferredPasteFormats">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Controls.InkCanvasClipboardFormat&gt; PreferredPasteFormats { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Windows.Controls.InkCanvasClipboardFormat&gt; PreferredPasteFormats" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.PreferredPasteFormats" />
      <MemberSignature Language="VB.NET" Value="Public Property PreferredPasteFormats As IEnumerable(Of InkCanvasClipboardFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Controls::InkCanvasClipboardFormat&gt; ^ PreferredPasteFormats { System::Collections::Generic::IEnumerable&lt;System::Windows::Controls::InkCanvasClipboardFormat&gt; ^ get(); void set(System::Collections::Generic::IEnumerable&lt;System::Windows::Controls::InkCanvasClipboardFormat&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PreferredPasteFormats : seq&lt;System.Windows.Controls.InkCanvasClipboardFormat&gt; with get, set" Usage="System.Windows.Controls.InkCanvas.PreferredPasteFormats" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Controls.InkCanvasClipboardFormat&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia formaty, które można wkleić na <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <value>Kolekcja wartości wyliczenia. Wartość domyślna to <see cref="F:System.Windows.Controls.InkCanvasClipboardFormat.InkSerializedFormat" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlPropertyElementUsage_PreferredPasteFormats"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.PreferredPasteFormats>  
    InkCanvasClipboardFormats  
  </object.PreferredPasteFormats>  
</object>  
```  
  
<a name="xamlValues_PreferredPasteFormats"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *InkCanvasClipboardFormats*  
 Tablica <xref:System.Windows.Controls.InkCanvasClipboardFormat> wartości wyliczenia. Określanie tablicy w XAML wymaga `x:Array` użycia. Określenie wartości wyliczenia jako element, który deklaruje element członkowski tablicy wymaga `x:Static` użycia. Aby uzyskać więcej informacji, zobacz [x: Array — rozszerzenie znaczników](~/docs/framework/xaml-services/x-array-markup-extension.md) i [x: Static — rozszerzenie znaczników](~/docs/framework/xaml-services/x-static-markup-extension.md).  
  
   
  
## Examples  
 Poniższy przykład ustawia <xref:System.Windows.Controls.InkCanvas.PreferredPasteFormats%2A> się <xref:System.Windows.Controls.InkCanvas> zaakceptować [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] formacie [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)].  
  
 [!code-csharp[InkCanvasSamples#26](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#26)]
 [!code-vb[InkCanvasSamples#26](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#26)]  
  
 Poniższy przykład wykonuje ten sam efekt w [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].  
  
 [!code-xaml[InkCanvasSamples#38](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window2.xaml#38)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizeEnabled">
      <MemberSignature Language="C#" Value="public bool ResizeEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResizeEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.ResizeEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ResizeEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeEnabled : bool with get, set" Usage="System.Windows.Controls.InkCanvas.ResizeEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość logiczną wskazującą, czy użytkownik może zmieniać rozmiar wybranych pociągnięć i/lub elementów na <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <value><see langword="true" /> Jeśli użytkownik rozmiar można zmieniać pociągnięć lub elementów na <see cref="T:System.Windows.Controls.InkCanvas" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest ustawiona `true`, obramowania moduł definiowania układu kodu jest rysowane wokół pociągnięć odręcznych lub elementów, gdy są zaznaczone. To obramowanie umożliwia użytkownikowi zmianę rozmiaru wybranych obiektów. Jeśli <xref:System.Windows.Controls.InkCanvas.MoveEnabled%2A> jest `true`, moduł definiowania układu umożliwia użytkownikowi przenoszenie pociągnięć lub elementów również.  
  
 Jeśli ta właściwość jest ustawiona `false` zaznaczeniu pociągnięć odręcznych lub elementów obramowania moduł definiowania układu kodu zostanie automatycznie usunięty z wybranych obiektów.  
  
   
  
## Examples  
 Poniższy przykład uniemożliwia użytkownikowi przenoszenie i zmienianie rozmiaru elementów i obrysy na <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#7](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#7)]
 [!code-vb[InkCanvasSamples#7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="see GetRight, and SetRight" />
      <MemberSignature Language="ILAsm" Value="see GetRight, and SetRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Right" />
      <MemberSignature Language="VB.NET" Value="see GetRight, and SetRight" />
      <MemberSignature Language="F#" Value="see GetRight, and SetRight" Usage="see GetRight, and SetRight" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub Ustawia odległość między po prawej stronie element po prawej stronie jego elementu nadrzędnego <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Right"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.RightProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
<a name="xamlAttributeUsage_Right"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object InkCanvas.Right="double"/>  
- or -  
<object InkCanvas.Right="qualifiedDouble"/>  
```  
  
<a name="xamlValues_Right"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 Ciąg reprezentujący <xref:System.Double> wartość. To jest interpretowane jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi jawnie zawierać separatorów dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 *qualifiedDouble*  
 A *double* wartość zgodnie z opisem powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` centymetrów; 1cm==(96/2.54) piks.  
  
 `pt` jest punktów. 1pt==(96/72) piks.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak ustawić położenie <xref:System.Windows.Controls.Label> na <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-xml[InkCanvasSamples#35](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.RightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ RightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable RightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.RightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.InkCanvas.Right" /> dołączone propertyy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wybiera zestaw pisma odręcznego <see cref="T:System.Windows.Ink.Stroke" /> obiektów i/lub <see cref="T:System.Windows.FrameworkElement" /> obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> Może zawierać <xref:System.Windows.Ink.Stroke> obiektów, które są tworzone w odpowiedzi na dane wejściowe użytkownika pióra, i <xref:System.Windows.FrameworkElement> obiekty, takie jak <xref:System.Windows.Controls.Image> i <xref:System.Windows.Controls.Button> obiektów.  
  
 Wybranych pociągnięć będą wyświetlane przy użyciu modułu definiowania układu wokół nich w celu ułatwienia uznania i manipulowania. <xref:System.Windows.FrameworkElement> obiekty nie są wyświetlane inaczej w przypadku wybrania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Collections.Generic.IEnumerable&lt;System.Windows.UIElement&gt; selectedElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.UIElement&gt; selectedElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Select(System.Collections.Generic.IEnumerable{System.Windows.UIElement})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (selectedElements As IEnumerable(Of UIElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Collections::Generic::IEnumerable&lt;System::Windows::UIElement ^&gt; ^ selectedElements);" />
      <MemberSignature Language="F#" Value="member this.Select : seq&lt;System.Windows.UIElement&gt; -&gt; unit" Usage="inkCanvas.Select selectedElements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectedElements" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.UIElement&gt;" />
      </Parameters>
      <Docs>
        <param name="selectedElements">Kolekcja <see cref="T:System.Windows.UIElement" /> obiektów do wybrania.</param>
        <summary>Wybiera zestaw <see cref="T:System.Windows.UIElement" /> obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> Może zawierać <xref:System.Windows.Ink.Stroke> obiektów, które są tworzone w odpowiedzi na dane wejściowe użytkownika pióra i <xref:System.Windows.UIElement> obiekty, takie jak <xref:System.Windows.Controls.Image> i <xref:System.Windows.Controls.Button> obiektów.  
  
 Moduł definiowania układu wokół nich w celu ułatwienia uznania i manipulowania wybranych pociągnięć są wyświetlane. <xref:System.Windows.UIElement> obiekty nie są wyświetlane inaczej w przypadku wybrania. Jeśli <xref:System.Windows.UIElement> w `selectedElements` nie znajduje się w kolekcji elementów podrzędnych <xref:System.Windows.Controls.InkCanvas.Select%2A> ignoruje <xref:System.Windows.UIElement>.  
  
   
  
## Examples  
 Następujące wybiera przykładzie wszystkie i dwóch elementów w <xref:System.Windows.Controls.InkCanvas>. W tym przykładzie przyjęto założenie, że istnieje <xref:System.Windows.Controls.TextBox> o nazwie `textbox1` i <xref:System.Windows.Controls.Button> o nazwie `button1` — i obie kontrolki znajdują się elementy podrzędne <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#2](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#2)]
 [!code-vb[InkCanvasSamples#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Windows.Ink.StrokeCollection selectedStrokes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Windows.Ink.StrokeCollection selectedStrokes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Select(System.Windows.Ink.StrokeCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (selectedStrokes As StrokeCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Windows::Ink::StrokeCollection ^ selectedStrokes);" />
      <MemberSignature Language="F#" Value="member this.Select : System.Windows.Ink.StrokeCollection -&gt; unit" Usage="inkCanvas.Select selectedStrokes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectedStrokes" Type="System.Windows.Ink.StrokeCollection" />
      </Parameters>
      <Docs>
        <param name="selectedStrokes">Kolekcja <see cref="T:System.Windows.Ink.Stroke" /> obiektów do wybrania.</param>
        <summary>Wybiera zestaw pisma odręcznego <see cref="T:System.Windows.Ink.Stroke" /> obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> Może zawierać <xref:System.Windows.Ink.Stroke> obiektów, które są tworzone w odpowiedzi na dane wejściowe użytkownika pióra, i <xref:System.Windows.FrameworkElement> obiekty, takie jak <xref:System.Windows.Controls.Image> i <xref:System.Windows.Controls.Button> obiektów.  
  
 Moduł definiowania układu wokół nich w celu ułatwienia uznania i manipulowania wybranych pociągnięć są wyświetlane. <xref:System.Windows.FrameworkElement> obiekty nie są wyświetlane inaczej w przypadku wybrania.  
  
   
  
## Examples  
 Następujące wybiera przykładzie wszystkie i dwóch elementów w <xref:System.Windows.Controls.InkCanvas>.  W tym przykładzie przyjęto założenie, że istnieje <xref:System.Windows.Controls.TextBox> o nazwie `textbox1` i <xref:System.Windows.Controls.Button> o nazwie `button1` — i obie kontrolki znajdują się elementy podrzędne <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#2](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#2)]
 [!code-vb[InkCanvasSamples#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden pociągnięć w <paramref name="selectedStrokes" /> nie znajduje się w <see cref="P:System.Windows.Controls.InkCanvas.Strokes" /> właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Windows.Ink.StrokeCollection selectedStrokes, System.Collections.Generic.IEnumerable&lt;System.Windows.UIElement&gt; selectedElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Windows.Ink.StrokeCollection selectedStrokes, class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.UIElement&gt; selectedElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Select(System.Windows.Ink.StrokeCollection,System.Collections.Generic.IEnumerable{System.Windows.UIElement})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (selectedStrokes As StrokeCollection, selectedElements As IEnumerable(Of UIElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Windows::Ink::StrokeCollection ^ selectedStrokes, System::Collections::Generic::IEnumerable&lt;System::Windows::UIElement ^&gt; ^ selectedElements);" />
      <MemberSignature Language="F#" Value="member this.Select : System.Windows.Ink.StrokeCollection * seq&lt;System.Windows.UIElement&gt; -&gt; unit" Usage="inkCanvas.Select (selectedStrokes, selectedElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectedStrokes" Type="System.Windows.Ink.StrokeCollection" />
        <Parameter Name="selectedElements" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.UIElement&gt;" />
      </Parameters>
      <Docs>
        <param name="selectedStrokes">Kolekcja <see cref="T:System.Windows.Ink.Stroke" /> obiektów do wybrania.</param>
        <param name="selectedElements">Kolekcja <see cref="T:System.Windows.UIElement" /> obiektów do wybrania.</param>
        <summary>Wybiera kombinacji <see cref="T:System.Windows.Ink.Stroke" /> i <see cref="T:System.Windows.UIElement" /> obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> Może zawierać <xref:System.Windows.Ink.Stroke> obiektów, które są tworzone w odpowiedzi na dane wejściowe użytkownika pióra i <xref:System.Windows.UIElement> obiekty, takie jak <xref:System.Windows.Controls.Image> i <xref:System.Windows.Controls.Button> obiektów.  
  
 Wybranych pociągnięć będą wyświetlane przy użyciu modułu definiowania układu wokół nich w celu ułatwienia uznania i manipulowania. <xref:System.Windows.UIElement> obiekty nie są wyświetlane inaczej w przypadku wybrania. Jeśli <xref:System.Windows.UIElement> w `selectedElements` nie znajduje się w kolekcji elementów podrzędnych <xref:System.Windows.Controls.InkCanvas.Select%2A> ignoruje <xref:System.Windows.UIElement>.  
  
   
  
## Examples  
 Następujące wybiera przykładzie wszystkie i dwóch elementów w <xref:System.Windows.Controls.InkCanvas>.  W tym przykładzie przyjęto założenie, że istnieje <xref:System.Windows.Controls.TextBox> o nazwie `textbox1` i <xref:System.Windows.Controls.Button> o nazwie `button1` — i obie kontrolki znajdują się elementy podrzędne <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#2](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#2)]
 [!code-vb[InkCanvasSamples#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden pociągnięć w <paramref name="selectedStrokes" /> nie są objęte <see cref="P:System.Windows.Controls.InkCanvas.Strokes" /> właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanged : EventHandler " Usage="member this.SelectionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie wyboru w <see cref="T:System.Windows.Controls.InkCanvas" /> zmiany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane po został wybrany zestaw pociągnięć odręcznych lub elementów i stosowane przez użytkownika.  
  
 Jeśli zamiast tego należy samodzielnie żądania, które wybrać zestaw pociągnięć odręcznych lub elementów przed zastosowaniem wyboru, Dodaj program obsługi zdarzeń do <xref:System.Windows.Controls.InkCanvas.SelectionChanging> zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład uniemożliwia użytkownikowi dokonanie wyboru jest mniejszy niż oryginalny rozmiar.  
  
 [!code-csharp[InkCanvasSamples#16](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#16)]
 [!code-vb[InkCanvasSamples#16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionChanging" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SelectionChanging">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasSelectionChangingEventHandler SelectionChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasSelectionChangingEventHandler SelectionChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionChanging" />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionChanging As InkCanvasSelectionChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasSelectionChangingEventHandler ^ SelectionChanging;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanging : System.Windows.Controls.InkCanvasSelectionChangingEventHandler " Usage="member this.SelectionChanging : System.Windows.Controls.InkCanvasSelectionChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasSelectionChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wybrano nowy zestaw pociągnięć odręcznych lub elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas.SelectionChanging> Zdarzenie jest zgłaszane w przypadku pociągnięć i/lub elementy są wybrane przez użytkownika —, ale zanim zmiana zostanie zastosowana.  
  
 <xref:System.Windows.Controls.InkCanvas.SelectionChanging> Zdarzenie zostanie przetworzone po <xref:System.Windows.Controls.InkCanvasSelectionChangingEventHandler> odbiera <xref:System.Windows.Controls.InkCanvasSelectionChangingEventArgs> obiektu. <xref:System.Windows.Controls.InkCanvasSelectionChangingEventArgs> udostępnia metody do uzyskiwania dostępu do <xref:System.Windows.FrameworkElement> i <xref:System.Windows.Ink.StrokeCollection> obiektów po ich zaznaczeniu przez użytkownika.  
  
 Po zastosowaniu zmiany <xref:System.Windows.Controls.InkCanvas.SelectionChanged> zdarzenie jest wywoływane.  
  
> [!NOTE]
>  <xref:System.Windows.Controls.InkCanvas.SelectionChanging> Zdarzenie nie występuje podczas usuwania wybranych pociągnięć lub <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> zmiany właściwości.  
  
   
  
## Examples  
 Poniższy przykład wykonuje wybranych pociągnięć ciemnoniebieskim.  
  
 [!code-csharp[InkCanvasSamples#14](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#14)]
 [!code-vb[InkCanvasSamples#14](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvasSelectionChangingEventArgs.GetSelectedElements" />
        <altmember cref="M:System.Windows.Controls.InkCanvasSelectionChangingEventArgs.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvasSelectionChangingEventArgs.SetSelectedElements(System.Collections.Generic.IEnumerable{System.Windows.UIElement})" />
        <altmember cref="M:System.Windows.Controls.InkCanvasSelectionChangingEventArgs.SetSelectedStrokes(System.Windows.Ink.StrokeCollection)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionMoved">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionMoved" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionMoved" />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionMoved As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionMoved;" />
      <MemberSignature Language="F#" Value="member this.SelectionMoved : EventHandler " Usage="member this.SelectionMoved : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po użytkownik przesuwa wyboru pociągnięć lub elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje po przeniesieniu wyboru pociągnięć lub elementów, ale przed pociągnięć lub elementów dane są aktualizowane, aby zarejestrować jego nowego położenia. Dodawanie obsługi zdarzeń do <xref:System.Windows.Controls.InkCanvas.SelectionMoving> zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład usuwa elementy na <xref:System.Windows.Controls.InkCanvas> po użytkownik przenosi je.  
  
 [!code-csharp[InkCanvasSamples#19](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#19)]
 [!code-vb[InkCanvasSamples#19](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#19)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionMoving" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SelectionMoving">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasSelectionEditingEventHandler SelectionMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasSelectionEditingEventHandler SelectionMoving" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionMoving" />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionMoving As InkCanvasSelectionEditingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasSelectionEditingEventHandler ^ SelectionMoving;" />
      <MemberSignature Language="F#" Value="member this.SelectionMoving : System.Windows.Controls.InkCanvasSelectionEditingEventHandler " Usage="member this.SelectionMoving : System.Windows.Controls.InkCanvasSelectionEditingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasSelectionEditingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, zanim zostaną przeniesione wybranych pociągnięć i elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje po użytkownik zażąda przeniesienia wyboru pociągnięć lub elementów, ale zanim zmiana zostanie zastosowana.  
  
 Program obsługi zdarzeń odbierze argumentu typu <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs> za pomocą dwie właściwości: <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.OldRectangle%2A> i <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.NewRectangle%2A>. <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.OldRectangle%2A> Definiuje granice wyboru przed przeniesieniem i <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.NewRectangle%2A> definiuje granice wybór po przeniesieniu.  
  
 Po zastosowaniu zmiany <xref:System.Windows.Controls.InkCanvas.SelectionMoved> wystąpi zdarzenie.  
  
   
  
## Examples  
 Poniższy przykład uniemożliwia użytkownikowi przenoszenie wybranych elementów w pionie na <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#13](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#13)]
 [!code-vb[InkCanvasSamples#13](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionMoved" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SelectionResized">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionResized" />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionResized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionResized;" />
      <MemberSignature Language="F#" Value="member this.SelectionResized : EventHandler " Usage="member this.SelectionResized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyboru pociągnięć lub elementów został zmieniony przez użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest inicjowane po zmianie rozmiaru wyboru pociągnięć lub elementów.  
  
 Jeśli zamiast tego należy obsłużyć żądanie, aby zmienić rozmiar zaznaczenia, zanim zmiany rozmiaru pociągnięć lub elementów, Dodaj program obsługi zdarzeń do <xref:System.Windows.Controls.InkCanvas.SelectionResizing> zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład usuwa wszystkie elementy na <xref:System.Windows.Controls.InkCanvas> po użytkownik ponownie rozmiarach zaznaczenia.  
  
 [!code-csharp[InkCanvasSamples#23](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#23)]
 [!code-vb[InkCanvasSamples#23](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#23)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionResizing" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SelectionResizing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasSelectionEditingEventHandler SelectionResizing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasSelectionEditingEventHandler SelectionResizing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionResizing" />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionResizing As InkCanvasSelectionEditingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasSelectionEditingEventHandler ^ SelectionResizing;" />
      <MemberSignature Language="F#" Value="member this.SelectionResizing : System.Windows.Controls.InkCanvasSelectionEditingEventHandler " Usage="member this.SelectionResizing : System.Windows.Controls.InkCanvasSelectionEditingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasSelectionEditingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, zanim zmiany rozmiaru wybranych pociągnięć i elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje po użytkownik zażąda, że można zmienić rozmiaru wyboru pociągnięć lub elementów, ale zanim zmiana zostanie zastosowana.  
  
 Program obsługi zdarzeń odbierze argumentu typu <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs> zawierający dwie właściwości: <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.OldRectangle%2A> i <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.NewRectangle%2A>. <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.OldRectangle%2A> Definiuje granice wyboru przed wykonaniem operacji zmiany rozmiaru i <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.NewRectangle%2A> definiuje granice zaznaczenie po operacji zmiany rozmiaru.  
  
 Po pociągnięć lub elementów, które są aktualizowane przy użyciu nowego rozmiaru <xref:System.Windows.Controls.InkCanvas.SelectionResized> zdarzenie jest wywoływane.  
  
   
  
## Examples  
 Poniższy przykład uniemożliwia użytkownikowi dokonanie wyboru jest mniejszy niż oryginalny rozmiar.  
  
 [!code-csharp[InkCanvasSamples#16](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#16)]
 [!code-vb[InkCanvasSamples#16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionResized" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SetBottom">
      <MemberSignature Language="C#" Value="public static void SetBottom (System.Windows.UIElement element, double length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBottom(class System.Windows.UIElement element, float64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetBottom(System.Windows.UIElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBottom (element As UIElement, length As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBottom(System::Windows::UIElement ^ element, double length);" />
      <MemberSignature Language="F#" Value="static member SetBottom : System.Windows.UIElement * double -&gt; unit" Usage="System.Windows.Controls.InkCanvas.SetBottom (element, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="length" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Element, na którym można ustawić właściwości dolnej.</param>
        <param name="length">Współrzędna dolnej <paramref name="element" />.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.InkCanvas.Bottom" /> dołączona właściwość zależności danego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak ustawić położenie <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[InkCanvasSamples#28](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#28)]
 [!code-vb[InkCanvasSamples#28](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEnabledGestures">
      <MemberSignature Language="C#" Value="public void SetEnabledGestures (System.Collections.Generic.IEnumerable&lt;System.Windows.Ink.ApplicationGesture&gt; applicationGestures);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetEnabledGestures(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Windows.Ink.ApplicationGesture&gt; applicationGestures) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetEnabledGestures(System.Collections.Generic.IEnumerable{System.Windows.Ink.ApplicationGesture})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetEnabledGestures (applicationGestures As IEnumerable(Of ApplicationGesture))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetEnabledGestures(System::Collections::Generic::IEnumerable&lt;System::Windows::Ink::ApplicationGesture&gt; ^ applicationGestures);" />
      <MemberSignature Language="F#" Value="member this.SetEnabledGestures : seq&lt;System.Windows.Ink.ApplicationGesture&gt; -&gt; unit" Usage="inkCanvas.SetEnabledGestures applicationGestures" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationGestures" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.Ink.ApplicationGesture&gt;" />
      </Parameters>
      <Docs>
        <param name="applicationGestures">Kolekcja aplikacji gesty, które <see cref="T:System.Windows.Controls.InkCanvas" /> rozpozna.</param>
        <summary>Ustawia gesty aplikacji, która <see cref="T:System.Windows.Controls.InkCanvas" /> rozpozna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższym przykładzie pokazano, jak skonfigurować <xref:System.Windows.Controls.InkCanvas> rozpoznać gesty aplikacji.  
  
 [!code-csharp[GestureSample#3](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#3)]
 [!code-vb[GestureSample#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#3)]  
[!code-csharp[GestureSample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#1)]
[!code-vb[GestureSample#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Controls.InkCanvas.IsGestureRecognizerAvailable" /> Właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLeft">
      <MemberSignature Language="C#" Value="public static void SetLeft (System.Windows.UIElement element, double length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLeft(class System.Windows.UIElement element, float64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetLeft(System.Windows.UIElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLeft (element As UIElement, length As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLeft(System::Windows::UIElement ^ element, double length);" />
      <MemberSignature Language="F#" Value="static member SetLeft : System.Windows.UIElement * double -&gt; unit" Usage="System.Windows.Controls.InkCanvas.SetLeft (element, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="length" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Element, dla której chcesz ustawić właściwość po lewej stronie.</param>
        <param name="length">Współrzędna lewej <paramref name="element" />.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.InkCanvas.Left" /> dołączona właściwość zależności danego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak ustawić położenie <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[InkCanvasSamples#29](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#29)]
 [!code-vb[InkCanvasSamples#29](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#29)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetRight">
      <MemberSignature Language="C#" Value="public static void SetRight (System.Windows.UIElement element, double length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetRight(class System.Windows.UIElement element, float64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetRight(System.Windows.UIElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetRight (element As UIElement, length As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetRight(System::Windows::UIElement ^ element, double length);" />
      <MemberSignature Language="F#" Value="static member SetRight : System.Windows.UIElement * double -&gt; unit" Usage="System.Windows.Controls.InkCanvas.SetRight (element, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="length" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Element, dla której chcesz ustawić prawej właściwości.</param>
        <param name="length">Współrzędna prawej <paramref name="element" />.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.InkCanvas.Right" /> dołączona właściwość zależności danego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak ustawić położenie <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[InkCanvasSamples#30](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#30)]
 [!code-vb[InkCanvasSamples#30](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTop">
      <MemberSignature Language="C#" Value="public static void SetTop (System.Windows.UIElement element, double length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTop(class System.Windows.UIElement element, float64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetTop(System.Windows.UIElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTop (element As UIElement, length As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTop(System::Windows::UIElement ^ element, double length);" />
      <MemberSignature Language="F#" Value="static member SetTop : System.Windows.UIElement * double -&gt; unit" Usage="System.Windows.Controls.InkCanvas.SetTop (element, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="length" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Element, dla której chcesz ustawić właściwość top.</param>
        <param name="length">Górną współrzędną <paramref name="element" />.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.InkCanvas.Top" /> dołączona właściwość zależności danego obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak ustawić położenie <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[InkCanvasSamples#27](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#27)]
 [!code-vb[InkCanvasSamples#27](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeCollected">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasStrokeCollectedEventHandler StrokeCollected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasStrokeCollectedEventHandler StrokeCollected" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.StrokeCollected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StrokeCollected As InkCanvasStrokeCollectedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasStrokeCollectedEventHandler ^ StrokeCollected;" />
      <MemberSignature Language="F#" Value="member this.StrokeCollected : System.Windows.Controls.InkCanvasStrokeCollectedEventHandler " Usage="member this.StrokeCollected : System.Windows.Controls.InkCanvasStrokeCollectedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasStrokeCollectedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy pociągnięcia przez użytkownika jest dodawany do <see cref="P:System.Windows.Controls.InkCanvas.Strokes" /> właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane, gdy użytkownik kończy pociągnięcia za pomocą urządzenia wskazującego. Na przykład użytkownik mogą zgłaszać pióra od dyskretyzatora po wprowadzeniu ruchu, a tym samym zakończeniu pociągnięcia.  
  
 Program obsługi zdarzeń odbierze argumentu typu <xref:System.Windows.Controls.InkCanvasStrokeCollectedEventArgs>, odwołujące się obrysu ukończone. Stroke jest także dodawane do <xref:System.Windows.Controls.InkCanvas.Strokes%2A> właściwość <xref:System.Windows.Controls.InkCanvas>.  
  
 Programowe Dodawanie <xref:System.Windows.Ink.Stroke> obiekt <xref:System.Windows.Controls.InkCanvas.Strokes%2A> kolekcji nie Zgłoś to zdarzenie.  
  
<a name="routedEventInfo_StrokeCollected"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.StrokeCollectedEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.Controls.InkCanvasStrokeCollectedEventHandler>|  
  
   
  
## Examples  
 Poniższy przykład oszczędza czas jako właściwości niestandardowych, gdy użytkownik doda obrysu <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#22](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#22)]
 [!code-vb[InkCanvasSamples#22](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Ink.Stroke.AddPropertyData(System.Guid,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="StrokeCollectedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StrokeCollectedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StrokeCollectedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.StrokeCollectedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StrokeCollectedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StrokeCollectedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StrokeCollectedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.StrokeCollectedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Controls.InkCanvas.StrokeCollected" /> zdarzenia trasowanego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeErased">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler StrokeErased;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler StrokeErased" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.StrokeErased" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StrokeErased As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ StrokeErased;" />
      <MemberSignature Language="F#" Value="member this.StrokeErased : System.Windows.RoutedEventHandler " Usage="member this.StrokeErased : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik wymazaniu pociągnięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje, gdy użytkownik wymazanie pisma odręcznego czy <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> właściwość jest ustawiona na <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint> lub <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByStroke>.  
  
<a name="routedEventInfo_StrokeErasing"></a>   
## <a name="routed-event-information"></a>Informacje dotyczące kierowanego zdarzenia  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.StrokeErasedEvent>|  
|Strategii routingu|Propagacja|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 Poniższy przykład zgłasza liczbę pociągnięć, które znajdują się na <xref:System.Windows.Controls.InkCanvas> podczas <xref:System.Windows.Controls.InkCanvas.StrokeErased> wystąpi zdarzenie. Jeśli <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> ustawiono <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint> i użytkownik usuwa środka pociągnięcia, liczba pociągnięć na <xref:System.Windows.Controls.InkCanvas> zwiększa się. Jest to spowodowane stare obrysu została zastąpiona dwóch nowych obiektów.  
  
 [!code-csharp[InkCanvasSamples#18](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#18)]
 [!code-vb[InkCanvasSamples#18](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeErasedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StrokeErasedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StrokeErasedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.StrokeErasedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StrokeErasedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StrokeErasedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StrokeErasedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.StrokeErasedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="E:System.Windows.Controls.InkCanvas.StrokeErased" /> zdarzenia trasowanego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeErasing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasStrokeErasingEventHandler StrokeErasing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasStrokeErasingEventHandler StrokeErasing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.StrokeErasing" />
      <MemberSignature Language="VB.NET" Value="Public Event StrokeErasing As InkCanvasStrokeErasingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasStrokeErasingEventHandler ^ StrokeErasing;" />
      <MemberSignature Language="F#" Value="member this.StrokeErasing : System.Windows.Controls.InkCanvasStrokeErasingEventHandler " Usage="member this.StrokeErasing : System.Windows.Controls.InkCanvasStrokeErasingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasStrokeErasingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje zaraz przed, użytkownik wymazaniu pociągnięcia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługa tego zdarzenia, kiedy chcesz sprawdzić, czy pociągnięcia powinny być usuwane. Ustaw <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> właściwość `true` aby zapobiec wymazanie stroke. Możesz użyć tej techniki, gdy <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> lub <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> właściwość jest ustawiona na <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByStroke> lub <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>.  
  
   
  
## Examples  
 Poniższy przykład uniemożliwia obrys renderowane jako wyróżnienia wymazanie. W przykładzie założono, że <xref:System.Windows.Controls.InkCanvas> jest podłączony do obsługi zdarzeń.  
  
 [!code-csharp[DrawingAttributes#16](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingAttributes/CSharp/Window1.xaml.cs#16)]
 [!code-vb[DrawingAttributes#16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingAttributes/VisualBasic/Window1.xaml.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Strokes">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StrokeCollection Strokes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Ink.StrokeCollection Strokes" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Strokes" />
      <MemberSignature Language="VB.NET" Value="Public Property Strokes As StrokeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Ink::StrokeCollection ^ Strokes { System::Windows::Ink::StrokeCollection ^ get(); void set(System::Windows::Ink::StrokeCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Strokes : System.Windows.Ink.StrokeCollection with get, set" Usage="System.Windows.Controls.InkCanvas.Strokes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StrokeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję pisma odręcznego <see cref="T:System.Windows.Ink.Stroke" /> zbieranych przez obiekty <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <value>Kolekcja <see cref="T:System.Windows.Ink.Stroke" /> obiektów zawartych w <see cref="T:System.Windows.Controls.InkCanvas" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Strokes"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.StrokesProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak za pomocą dwóch <xref:System.Windows.Ink.StrokeCollection> obiektów tego samego <xref:System.Windows.Controls.InkCanvas>. W tym przykładzie player jeden, jak i odtwarzacz dwóch każdego użycia poszczególnych "pisma odręcznego powierzchni" nawet współużytkować ten sam <xref:System.Windows.Controls.InkCanvas>. W tym przykładzie przyjęto założenie, zdarzenie click jest podłączony do narzędzia obsługi zdarzeń `switchPlayersButton_Click`.  
  
 [!code-csharp[InkCanvasSamples#15](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#15)]
 [!code-vb[InkCanvasSamples#15](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#15)]  
  
 Poniższy przykład pokazuje jak powiązać <xref:System.Windows.Controls.InkCanvas.Strokes%2A> właściwość <xref:System.Windows.Controls.InkCanvas> do innego <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-xaml[InkCanvasBindingSnippet#2](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasBindingSnippet/CS/Window2.xaml#2)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Ink.StrokeCollection" />
      </Docs>
    </Member>
    <Member MemberName="StrokesProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StrokesProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StrokesProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.StrokesProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StrokesProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StrokesProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StrokesProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.StrokesProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.InkCanvas.Strokes" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokesReplaced">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasStrokesReplacedEventHandler StrokesReplaced;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasStrokesReplacedEventHandler StrokesReplaced" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.StrokesReplaced" />
      <MemberSignature Language="VB.NET" Value="Public Event StrokesReplaced As InkCanvasStrokesReplacedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasStrokesReplacedEventHandler ^ StrokesReplaced;" />
      <MemberSignature Language="F#" Value="member this.StrokesReplaced : System.Windows.Controls.InkCanvasStrokesReplacedEventHandler " Usage="member this.StrokesReplaced : System.Windows.Controls.InkCanvasStrokesReplacedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasStrokesReplacedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Controls.InkCanvas.Strokes" /> zastępuje właściwość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak za pomocą dwóch <xref:System.Windows.Ink.StrokeCollection> obiektów, które jest kolokowane na tym samym <xref:System.Windows.Controls.InkCanvas>. W tym przykładzie player jeden, jak i odtwarzacz dwóch każdego użycia poszczególnych "pisma odręcznego powierzchni" nawet współużytkować ten sam <xref:System.Windows.Controls.InkCanvas>. W tym przykładzie założono, że `switchPlayersButton_Click` zdarzeń jest podłączony do narzędzia obsługi zdarzeń.  
  
 [!code-csharp[InkCanvasSamples#15](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#15)]
 [!code-vb[InkCanvasSamples#15](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt podrzędny do dodania.</param>
        <summary>Dodaje określony obiekt do <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (textData As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ textData) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Nie używany.</param>
        <summary>Dodaje tekst, w znacznikach w znacznikach. Zawsze zgłasza <see cref="T:System.ArgumentException" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="see GetTop, and SetTop" />
      <MemberSignature Language="ILAsm" Value="see GetTop, and SetTop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Top" />
      <MemberSignature Language="VB.NET" Value="see GetTop, and SetTop" />
      <MemberSignature Language="F#" Value="see GetTop, and SetTop" Usage="see GetTop, and SetTop" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub Ustawia odległość między górą elementu i górą jego elementu nadrzędnego <see cref="T:System.Windows.Controls.InkCanvas" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Top"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.InkCanvas.TopProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
<a name="xamlAttributeUsage_Top"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object InkCanvas.Top="double"/>  
- or -  
<object InkCanvas.Top="qualifiedDouble"/>  
```  
  
<a name="xamlValues_Top"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 Ciąg reprezentujący <xref:System.Double> wartość. To jest interpretowane jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi jawnie zawierać separatorów dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 *qualifiedDouble*  
 A *double* wartość zgodnie z opisem powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` centymetrów; 1cm==(96/2.54) piks.  
  
 `pt` jest punktów. 1pt==(96/72) piks.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak ustawić położenie <xref:System.Windows.Controls.Label> na <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-xml[InkCanvasSamples#35](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.InkCanvas.Top" /> dołączona właściwość.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseCustomCursor">
      <MemberSignature Language="C#" Value="public bool UseCustomCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseCustomCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.UseCustomCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property UseCustomCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseCustomCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseCustomCursor : bool with get, set" Usage="System.Windows.Controls.InkCanvas.UseCustomCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość logiczną wskazującą, czy mają być zastępowane standard <see cref="T:System.Windows.Controls.InkCanvas" /> kursora funkcje obsługujące niestandardowe kursora.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Windows.Controls.InkCanvas" /> używa niestandardowych kursora; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> Ulegnie zmianie stylu kursora, aby odzwierciedlić bieżący <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> podczas, gdy kursor znajduje się w granicach <xref:System.Windows.Controls.InkCanvas>. Jeśli to zachowanie jest niepożądana, na przykład, kiedy <xref:System.Windows.Controls.InkCanvas> używa niestandardowego kursora, ustaw tę właściwość na `true`, i nie zmienia się w kursor <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia kursor, który jest inny niż ten, który został dostarczony przez <xref:System.Windows.Controls.InkCanvas>.  
  
 [!code-csharp[InkCanvasSamples#5](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#5)]
 [!code-vb[InkCanvasSamples#5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.Controls.InkCanvas.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów podrzędnych visual w ramach tego elementu.</summary>
        <value>Liczba elementów podrzędnych visual dla tego elementu.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      </Docs>
    </Member>
  </Members>
</Type>
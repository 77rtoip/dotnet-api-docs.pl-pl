<Type Name="RowDefinitionCollection" FullName="System.Windows.Controls.RowDefinitionCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f5bfd9a3f2bc03e0fe7aea87639975b73e547b16" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37522734" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RowDefinitionCollection : System.Collections.Generic.ICollection&lt;System.Windows.Controls.RowDefinition&gt;, System.Collections.Generic.IEnumerable&lt;System.Windows.Controls.RowDefinition&gt;, System.Collections.Generic.IList&lt;System.Windows.Controls.RowDefinition&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RowDefinitionCollection extends System.Object implements class System.Collections.Generic.ICollection`1&lt;class System.Windows.Controls.RowDefinition&gt;, class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Controls.RowDefinition&gt;, class System.Collections.Generic.IList`1&lt;class System.Windows.Controls.RowDefinition&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.RowDefinitionCollection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RowDefinitionCollection&#xA;Implements ICollection(Of RowDefinition), IEnumerable(Of RowDefinition), IList, IList(Of RowDefinition)" />
  <TypeSignature Language="C++ CLI" Value="public ref class RowDefinitionCollection sealed : System::Collections::Generic::ICollection&lt;System::Windows::Controls::RowDefinition ^&gt;, System::Collections::Generic::IEnumerable&lt;System::Windows::Controls::RowDefinition ^&gt;, System::Collections::Generic::IList&lt;System::Windows::Controls::RowDefinition ^&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type RowDefinitionCollection = class&#xA;    interface IList&lt;RowDefinition&gt;&#xA;    interface ICollection&lt;RowDefinition&gt;&#xA;    interface seq&lt;RowDefinition&gt;&#xA;    interface IEnumerable&#xA;    interface IList&#xA;    interface ICollection" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Windows.Controls.RowDefinition&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Windows.Controls.RowDefinition&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;System.Windows.Controls.RowDefinition&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zapewnia dostęp do uporządkowanej, silnie typizowaną kolekcją <see cref="T:System.Windows.Controls.RowDefinition" /> obiektów.</summary>
    <remarks>To be added.</remarks>
    <altmember cref="T:System.Windows.Controls.RowDefinition" />
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Windows.Controls.RowDefinition value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(class System.Windows.Controls.RowDefinition value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.Add(System.Windows.Controls.RowDefinition)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (value As RowDefinition)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Windows::Controls::RowDefinition ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Windows.Controls.RowDefinition -&gt; unit&#xA;override this.Add : System.Windows.Controls.RowDefinition -&gt; unit" Usage="rowDefinitionCollection.Add value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Controls.RowDefinition" />
      </Parameters>
      <Docs>
        <param name="value">Identyfikuje <see cref="T:System.Windows.Controls.RowDefinition" /> do dodania do kolekcji.</param>
        <summary>Dodaje <see cref="T:System.Windows.Controls.RowDefinition" /> elementu <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Windows.Controls.RowDefinitionCollection.Add%2A> metody w celu dodania <xref:System.Windows.Controls.RowDefinition> do <xref:System.Windows.Controls.RowDefinitionCollection>.  
  
 [!code-csharp[columndefinitionsgrid#3](~/samples/snippets/csharp/VS_Snippets_Wpf/ColumnDefinitionsGrid/CSharp/Window1.xaml.cs#3)]
 [!code-vb[columndefinitionsgrid#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColumnDefinitionsGrid/VisualBasic/Window1.xaml.vb#3)]  
  
 Aby wyświetlić pełny przykład, zobacz [porady: Manipulowanie kolumnami i wierszami przy użyciu ColumnDefinitionsCollections i RowDefinitionsCollections](~/docs/framework/wpf/controls/manipulate-columns-and-rows-by-using-columndefinitionscollections.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.RowDefinition" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="rowDefinitionCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści zawartość <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Windows.Controls.RowDefinitionCollection.Clear%2A> metodę, aby wyczyścić zawartość <xref:System.Windows.Controls.RowDefinitionCollection>.  
  
 [!code-csharp[columndefinitionsgrid#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ColumnDefinitionsGrid/CSharp/Window1.xaml.cs#4)]
 [!code-vb[columndefinitionsgrid#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColumnDefinitionsGrid/VisualBasic/Window1.xaml.vb#4)]  
  
 Aby wyświetlić pełny przykład, zobacz [porady: Manipulowanie kolumnami i wierszami przy użyciu ColumnDefinitionsCollections i RowDefinitionsCollections](~/docs/framework/wpf/controls/manipulate-columns-and-rows-by-using-columndefinitionscollections.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.RowDefinition" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Controls.RowDefinition value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(class System.Windows.Controls.RowDefinition value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.Contains(System.Windows.Controls.RowDefinition)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As RowDefinition) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Windows::Controls::RowDefinition ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Contains : System.Windows.Controls.RowDefinition -&gt; bool&#xA;override this.Contains : System.Windows.Controls.RowDefinition -&gt; bool" Usage="rowDefinitionCollection.Contains value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Controls.RowDefinition" />
      </Parameters>
      <Docs>
        <param name="value">Identyfikuje <see cref="T:System.Windows.Controls.RowDefinition" /> jest poddawana testom.</param>
        <summary>Określa, czy dany <see cref="T:System.Windows.Controls.RowDefinition" /> istnieje w ramach <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Controls.RowDefinition" /> istnieje w kolekcji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Windows.Controls.RowDefinitionCollection.Contains%2A> metodę pozwala ustalić czy <xref:System.Windows.Controls.RowDefinition> istnieje w <xref:System.Windows.Controls.RowDefinitionCollection>.  
  
 [!code-csharp[columndefinitionsgrid#8](~/samples/snippets/csharp/VS_Snippets_Wpf/ColumnDefinitionsGrid/CSharp/Window1.xaml.cs#8)]
 [!code-vb[columndefinitionsgrid#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColumnDefinitionsGrid/VisualBasic/Window1.xaml.vb#8)]  
  
 Aby wyświetlić pełny przykład, zobacz [porady: Manipulowanie kolumnami i wierszami przy użyciu ColumnDefinitionsCollections i RowDefinitionsCollections](~/docs/framework/wpf/controls/manipulate-columns-and-rows-by-using-columndefinitionscollections.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.RowDefinition" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Windows.Controls.RowDefinition[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Windows.Controls.RowDefinition[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.CopyTo(System.Windows.Controls.RowDefinition[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As RowDefinition(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::Windows::Controls::RowDefinition ^&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.Windows.Controls.RowDefinition[] * int -&gt; unit&#xA;override this.CopyTo : System.Windows.Controls.RowDefinition[] * int -&gt; unit" Usage="rowDefinitionCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Windows.Controls.RowDefinition[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica <see cref="T:System.Windows.Controls.RowDefinition" /> obiektów.</param>
        <param name="index">Identyfikuje pozycji indeksu w ramach <c>tablicy</c> do której <see cref="T:System.Windows.Controls.RowDefinition" /> obiekty są kopiowane.</param>
        <summary>Kopiuje tablicę <see cref="T:System.Windows.Controls.RowDefinition" /> obiekty do danego indeks w ramach <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RowDefinitionCollection> wykorzystuje system indeksowania zaczynającego się od zera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> ma charakter wielowymiarowy.  - lub - liczba elementów w źródle <see cref="T:System.Collections.ICollection" /> jest większa niż dostępne miejsce od indeksu do końca tablicy docelowej.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero.</exception>
        <altmember cref="T:System.Windows.Controls.RowDefinition" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RowDefinitionCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.Controls.RowDefinitionCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą liczbę elementów w tym wystąpieniu programu <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</summary>
        <value>Całkowita liczba elementów w kolekcji. Ta właściwość nie ma wartości domyślnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RowDefinitionCollection> wykorzystuje system indeksowania zaczynającego się od zera.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Windows.Controls.RowDefinitionCollection.Count%2A> właściwości.  
  
 [!code-csharp[columndefinitionsgrid#7](~/samples/snippets/csharp/VS_Snippets_Wpf/ColumnDefinitionsGrid/CSharp/Window1.xaml.cs#7)]
 [!code-vb[columndefinitionsgrid#7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColumnDefinitionsGrid/VisualBasic/Window1.xaml.vb#7)]  
  
 Aby wyświetlić pełny przykład, zobacz [porady: Manipulowanie kolumnami i wierszami przy użyciu ColumnDefinitionsCollections i RowDefinitionsCollections](~/docs/framework/wpf/controls/manipulate-columns-and-rows-by-using-columndefinitionscollections.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.RowDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (System.Windows.Controls.RowDefinition value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(class System.Windows.Controls.RowDefinition value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.IndexOf(System.Windows.Controls.RowDefinition)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As RowDefinition) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Windows::Controls::RowDefinition ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : System.Windows.Controls.RowDefinition -&gt; int&#xA;override this.IndexOf : System.Windows.Controls.RowDefinition -&gt; int" Usage="rowDefinitionCollection.IndexOf value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Controls.RowDefinition" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Windows.Controls.RowDefinition" /> Których pozycja indeksu jest pożądane.</param>
        <summary>Zwraca indeks z danym <see cref="T:System.Windows.Controls.RowDefinition" /> w ramach <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</summary>
        <returns>Indeks <paramref name="value" /> Jeśli w kolekcji; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Windows.Controls.RowDefinitionCollection.IndexOf%2A> metodę pozwala ustalić pozycja indeksu parametru <xref:System.Windows.Controls.RowDefinition> w ramach <xref:System.Windows.Controls.RowDefinitionCollection>.  
  
 [!code-csharp[columndefinitionsgrid#9](~/samples/snippets/csharp/VS_Snippets_Wpf/ColumnDefinitionsGrid/CSharp/Window1.xaml.cs#9)]
 [!code-vb[columndefinitionsgrid#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColumnDefinitionsGrid/VisualBasic/Window1.xaml.vb#9)]  
  
 Aby wyświetlić pełny przykład, zobacz [porady: Manipulowanie kolumnami i wierszami przy użyciu ColumnDefinitionsCollections i RowDefinitionsCollections](~/docs/framework/wpf/controls/manipulate-columns-and-rows-by-using-columndefinitionscollections.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.RowDefinition" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, System.Windows.Controls.RowDefinition value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, class System.Windows.Controls.RowDefinition value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.Insert(System.Int32,System.Windows.Controls.RowDefinition)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, value As RowDefinition)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, System::Windows::Controls::RowDefinition ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * System.Windows.Controls.RowDefinition -&gt; unit&#xA;override this.Insert : int * System.Windows.Controls.RowDefinition -&gt; unit" Usage="rowDefinitionCollection.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Windows.Controls.RowDefinition" />
      </Parameters>
      <Docs>
        <param name="index">Położenie w obrębie kolekcji polegający na wstawieniu elementu.</param>
        <param name="value">
          <see cref="T:System.Windows.Controls.RowDefinition" /> Do wstawienia.</param>
        <summary>Wstawia <see cref="T:System.Windows.Controls.RowDefinition" /> w położeniu określonego indeksu w ramach <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RowDefinitionCollection> wykorzystuje system indeksowania zaczynającego się od zera.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Windows.Controls.RowDefinitionCollection.Insert%2A> metodę, aby wstawić <xref:System.Windows.Controls.RowDefinition> z konkretnym `index` położenie w obrębie <xref:System.Windows.Controls.RowDefinitionCollection>.  
  
 [!code-csharp[columndefinitionsgrid#9](~/samples/snippets/csharp/VS_Snippets_Wpf/ColumnDefinitionsGrid/CSharp/Window1.xaml.cs#9)]
 [!code-vb[columndefinitionsgrid#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColumnDefinitionsGrid/VisualBasic/Window1.xaml.vb#9)]  
  
 Aby wyświetlić pełny przykład, zobacz [porady: Manipulowanie kolumnami i wierszami przy użyciu ColumnDefinitionsCollections i RowDefinitionsCollections](~/docs/framework/wpf/controls/manipulate-columns-and-rows-by-using-columndefinitionscollections.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <altmember cref="T:System.Windows.Controls.RowDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RowDefinitionCollection.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.Controls.RowDefinitionCollection.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Controls.RowDefinitionCollection" /> jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli kolekcja jest tylko do odczytu. w przeciwnym razie <see langword="false" />. Ta właściwość nie ma wartości domyślnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak uzyskać wartość <xref:System.Windows.Controls.RowDefinitionCollection.IsReadOnly%2A> właściwości.  
  
 [!code-csharp[columndefinitionsgrid#10](~/samples/snippets/csharp/VS_Snippets_Wpf/ColumnDefinitionsGrid/CSharp/Window1.xaml.cs#10)]
 [!code-vb[columndefinitionsgrid#10](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColumnDefinitionsGrid/VisualBasic/Window1.xaml.vb#10)]  
  
 Aby wyświetlić pełny przykład, zobacz [porady: Manipulowanie kolumnami i wierszami przy użyciu ColumnDefinitionsCollections i RowDefinitionsCollections](~/docs/framework/wpf/controls/manipulate-columns-and-rows-by-using-columndefinitionscollections.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.RowDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RowDefinitionCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Windows.Controls.RowDefinitionCollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy uzyskują dostęp do tego <see cref="T:System.Windows.Controls.RowDefinitionCollection" /> jest synchronizowany (bezpieczna wątkowo).</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do tej kolekcji jest zsynchronizowana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania lub przechwytywać wyjątki, które są wynikiem zmian wprowadzonych przez inne wątki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.RowDefinition this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.RowDefinition Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RowDefinitionCollection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As RowDefinition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::RowDefinition ^ default[int] { System::Windows::Controls::RowDefinition ^ get(int index); void set(int index, System::Windows::Controls::RowDefinition ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : System.Windows.Controls.RowDefinition with get, set" Usage="System.Windows.Controls.RowDefinitionCollection.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.RowDefinition</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Bieżący element w kolekcji.</param>
        <summary>Pobiera wartość, która wskazuje bieżący element w obrębie <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RowDefinitionCollection> wykorzystuje system indeksowania zaczynającego się od zera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest prawidłowy indeks w kolekcji.</exception>
        <altmember cref="T:System.Windows.Controls.RowDefinition" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (System.Windows.Controls.RowDefinition value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(class System.Windows.Controls.RowDefinition value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.Remove(System.Windows.Controls.RowDefinition)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (value As RowDefinition) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::Windows::Controls::RowDefinition ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Remove : System.Windows.Controls.RowDefinition -&gt; bool&#xA;override this.Remove : System.Windows.Controls.RowDefinition -&gt; bool" Usage="rowDefinitionCollection.Remove value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Controls.RowDefinition" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Windows.Controls.RowDefinition" /> Do usunięcia z kolekcji.</param>
        <summary>Usuwa <see cref="T:System.Windows.Controls.RowDefinition" /> z <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Controls.RowDefinition" /> został znaleziony w kolekcji i usunięty; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Controls.RowDefinition" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="rowDefinitionCollection.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Położenie w obrębie kolekcji, w którym <see cref="T:System.Windows.Controls.RowDefinition" /> zostanie usunięty.</param>
        <summary>Usuwa <see cref="T:System.Windows.Controls.RowDefinition" /> z <see cref="T:System.Windows.Controls.RowDefinitionCollection" /> w położeniu określonego indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RowDefinitionCollection> wykorzystuje system indeksowania zaczynającego się od zera.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Windows.Controls.RowDefinitionCollection.RemoveAt%2A> metodę, aby usunąć <xref:System.Windows.Controls.RowDefinition> do <xref:System.Windows.Controls.RowDefinitionCollection> na konkretnym `index` pozycji.  
  
 [!code-csharp[columndefinitionsgrid#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ColumnDefinitionsGrid/CSharp/Window1.xaml.cs#5)]
 [!code-vb[columndefinitionsgrid#5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColumnDefinitionsGrid/VisualBasic/Window1.xaml.vb#5)]  
  
 Aby wyświetlić pełny przykład, zobacz [porady: Manipulowanie kolumnami i wierszami przy użyciu ColumnDefinitionsCollections i RowDefinitionsCollections](~/docs/framework/wpf/controls/manipulate-columns-and-rows-by-using-columndefinitionscollections.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.RowDefinition" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="rowDefinitionCollection.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Położenie w obrębie kolekcji, w którym pierwsza <see cref="T:System.Windows.Controls.RowDefinition" /> zostanie usunięty.</param>
        <param name="count">Całkowita liczba <see cref="T:System.Windows.Controls.RowDefinition" /> obiektów do usunięcia z kolekcji.</param>
        <summary>Usuwa zakres <see cref="T:System.Windows.Controls.RowDefinition" /> obiekty <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RowDefinitionCollection> wykorzystuje system indeksowania zaczynającego się od zera.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Windows.Controls.RowDefinitionCollection.RemoveRange%2A> metodę, aby usunąć zakres <xref:System.Windows.Controls.RowDefinition> elementy z <xref:System.Windows.Controls.RowDefinitionCollection>.  
  
 [!code-csharp[columndefinitionsgrid#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ColumnDefinitionsGrid/CSharp/Window1.xaml.cs#6)]
 [!code-vb[columndefinitionsgrid#6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColumnDefinitionsGrid/VisualBasic/Window1.xaml.vb#6)]  
  
 Aby wyświetlić pełny przykład, zobacz [porady: Manipulowanie kolumnami i wierszami przy użyciu ColumnDefinitionsCollections i RowDefinitionsCollections](~/docs/framework/wpf/controls/manipulate-columns-and-rows-by-using-columndefinitionscollections.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.RowDefinition" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RowDefinitionCollection.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Windows.Controls.RowDefinitionCollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania lub przechwytywać wyjątki, które są wynikiem zmian wprowadzonych przez inne wątki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Windows.Controls.RowDefinition&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Windows.Controls.RowDefinition&gt; IEnumerable&lt;RowDefinition&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;class System.Windows.Controls.RowDefinition&gt; System.Collections.Generic.IEnumerable&lt;System.Windows.Controls.RowDefinition&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.System#Collections#Generic#IEnumerable&lt;System#Windows#Controls#RowDefinition&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of RowDefinition) Implements IEnumerable(Of RowDefinition).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Windows::Controls::RowDefinition ^&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Windows.Controls.RowDefinition&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Windows::Controls::RowDefinition ^&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Windows.Controls.RowDefinition&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Obiekt, który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.RowDefinitionCollection> wystąpienia jest rzutowany na <xref:System.Collections.Generic.IEnumerable%601> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Liczony od zera <see cref="T:System.Array" /> odbierająca skopiowane elementy z <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</param>
        <param name="index">Pierwszą pozycję na określonym <see cref="T:System.Array" /> do odbierania skopiowane dane.</param>
        <summary>Kopiuje elementy kolekcji do <see cref="T:System.Array" />, rozpoczynając od określonego <see cref="T:System.Array" /> indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.RowDefinitionCollection> wystąpienia jest rzutowany na <xref:System.Collections.ICollection> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RowDefinitionCollection.CopyTo(System.Windows.Controls.RowDefinition[],System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Obiekt, który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.RowDefinitionCollection> wystąpienia jest rzutowany na <xref:System.Collections.IEnumerable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Do dodania do <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</param>
        <summary>Dodaje element do kolekcji.</summary>
        <returns>Pozycja, do którego dodano nowy element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.RowDefinitionCollection> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RowDefinitionCollection.Add(System.Windows.Controls.RowDefinition)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Do zlokalizowania w <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</param>
        <summary>Określa, czy kolekcja zawiera określoną wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Object" /> znajduje się w <see cref="T:System.Windows.Controls.RowDefinitionCollection" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.RowDefinitionCollection> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Do zlokalizowania w <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</param>
        <summary>Określa indeks konkretny element w kolekcji.</summary>
        <returns>Indeks <paramref name="value" /> Jeśli na liście; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.RowDefinitionCollection> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RowDefinitionCollection.IndexOf(System.Windows.Controls.RowDefinition)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w której mają zostać wstawione <see cref="T:System.Object" />.</param>
        <param name="value">
          <see cref="T:System.Object" /> Do wstawienia do <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</param>
        <summary>Wstawia element do kolekcji pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.RowDefinitionCollection> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RowDefinitionCollection.Insert(System.Int32,System.Windows.Controls.RowDefinition)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RowDefinitionCollection.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Windows.Controls.RowDefinitionCollection.System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kolekcja o stałym rozmiarze.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Controls.RowDefinitionCollection" /> ma stały rozmiar; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.RowDefinitionCollection> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RowDefinitionCollection.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Windows.Controls.RowDefinitionCollection.System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać pobrany lub skonfigurowany.</param>
        <summary>Pobieranie lub konfigurowanie elementów pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[index]`.  
  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.RowDefinitionCollection> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest prawidłowym indeksem pozycji na liście.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RowDefinitionCollection.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Do usunięcia z <see cref="T:System.Windows.Controls.RowDefinitionCollection" />.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.RowDefinitionCollection> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RowDefinitionCollection.Remove(System.Windows.Controls.RowDefinition)" />
      </Docs>
    </Member>
  </Members>
</Type>
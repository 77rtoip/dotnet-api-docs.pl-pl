<Type Name="ItemsControl" FullName="System.Windows.Controls.ItemsControl">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7533b11f9a20b5b51dfac6e259cc607792414bf7" /><Meta Name="ms.sourcegitcommit" Value="f9e71795ba0f9c2dfaa74bec233343ed0f3ffd99" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/14/2019" /><Meta Name="ms.locfileid" Value="57946199" /></Metadata><TypeSignature Language="C#" Value="public class ItemsControl : System.Windows.Controls.Control, System.Windows.Controls.Primitives.IContainItemStorage, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ItemsControl extends System.Windows.Controls.Control implements class System.Windows.Controls.Primitives.IContainItemStorage, class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.ItemsControl" />
  <TypeSignature Language="VB.NET" Value="Public Class ItemsControl&#xA;Inherits Control&#xA;Implements IAddChild, IContainItemStorage" />
  <TypeSignature Language="C++ CLI" Value="public ref class ItemsControl : System::Windows::Controls::Control, System::Windows::Controls::Primitives::IContainItemStorage, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type ItemsControl = class&#xA;    inherit Control&#xA;    interface IAddChild&#xA;    interface IContainItemStorage" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Controls.Primitives.IContainItemStorage</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("OnItemsChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Items")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Items")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="ItemContainerStyle", StyleTargetType=typeof(System.Windows.FrameworkElement))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kontrolkę, która może służyć do prezentowania kolekcji elementów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ItemsControl> Jest typem <xref:System.Windows.Controls.Control> zawierających wiele elementów, takich jak ciągi, obiektów i innych elementów. Poniższa ilustracja przedstawia <xref:System.Windows.Controls.ListBox> formant, który zawiera różne rodzaje elementów:  
  
-   Ciąg.  
  
-   Element <xref:System.DateTime> obiektu.  
  
-   Element <xref:System.Windows.UIElement> obiektu.  
  
-   A <xref:System.Windows.Controls.Panel> kontrolkę zawierającą <xref:System.Windows.Shapes.Ellipse> i <xref:System.Windows.Controls.TextBlock>.  
  
 ![Pola listy z czterema typami zawartości](~/add/media/controlcontentmodellistbox2.PNG "ListBox przy użyciu czterech typów zawartości")  
ListBox, który zawiera wiele typów obiektów  
  
 Użyj jednej <xref:System.Windows.Controls.ItemsControl.Items%2A> lub <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> właściwości w celu określenia kolekcji służące do generowania zawartości Twojej <xref:System.Windows.Controls.ItemsControl>. Możesz ustawić <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> właściwości do dowolnego typu, który implementuje <xref:System.Collections.IEnumerable>. <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> Zazwyczaj służy do wyświetlania zbierania danych lub powiązać <xref:System.Windows.Controls.ItemsControl> do obiektu kolekcji.  
  
 Jeśli nie chcesz używać obiektu, który implementuje <xref:System.Collections.IEnumerable> do wypełniania <xref:System.Windows.Controls.ItemsControl>, można dodać elementy przy użyciu <xref:System.Windows.Controls.ItemsControl.Items%2A> właściwości. Elementy w <xref:System.Windows.Controls.ItemsControl> mogą mieć różne typy. Na przykład <xref:System.Windows.Controls.ListBox> może zawierać jeden element, który jest ciągiem i inny element, który jest <xref:System.Windows.Controls.Image>.  
  
 Gdy <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> ustawiono właściwość <xref:System.Windows.Controls.ItemsControl.Items%2A> kolekcji jest ustawiona na tylko do odczytu i stałym rozmiarze. Oznacza to, że nie można dodać elementów do kolekcji bezpośrednio. Gdy <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> jest w użyciu, ustawienie dla właściwości `null` spowoduje usunięcie kolekcji i przywrócenie użycia <xref:System.Windows.Controls.ItemsControl.Items%2A>, który będzie stanowić pustego <xref:System.Windows.Controls.ItemCollection>.  
  
 Każdy <xref:System.Windows.Controls.ItemsControl> typ ma odpowiedni typ kontenera elementu. Odpowiedniego kontenera elementu dla każdego <xref:System.Windows.Controls.ItemsControl> dołącza `Item` na jego nazwę. Na przykład w przypadku <xref:System.Windows.Controls.ListBox>, kontenery elementu są <xref:System.Windows.Controls.ListBoxItem> kontroluje; dla <xref:System.Windows.Controls.ComboBox>, są one <xref:System.Windows.Controls.ComboBoxItem> kontrolki. Można jawnie utworzyć typ kontenera dla każdego elementu w <xref:System.Windows.Controls.ItemsControl>, ale nie jest konieczne. Tworząc nie jawnie typ kontenera, zostanie on wygenerowany zawierający element danych w kolekcji elementów. Na przykład, gdy powiąże kolekcję obiektów ciągu <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> właściwość <xref:System.Windows.Controls.ListBox>, nie należy jawnie tworzyć <xref:System.Windows.Controls.ListBoxItem> obiektów, ale <xref:System.Windows.Controls.ListBox> wygeneruje, jeden dla każdego ciągu. Wygenerowany kontener elementów mieli dostęp za pomocą <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A> właściwości.  
  
> [!NOTE]
>  Niektóre funkcje automatyzacji interfejsu użytkownika nie będą działać poprawnie po <xref:System.Windows.Controls.ItemsControl> zawiera zduplikowane obiekty.   Jeśli obiekt pojawia się wiele razy, tylko pierwsze wystąpienie pojawi się w drzewie automatyzacji.   (Dwa obiekty **x** i **y** są traktowane jako duplikaty, jeśli `Object.Equals(x, y)` zwraca `true`.)  
>   
>  Podczas gdy obiekt **x** jest używany przez <xref:System.Windows.Controls.ItemsControl> wartość zwrócona przez obiekt **x.**`GetHashCode()` nie należy zmieniać.  Zmiany tej wartości są nieobsługiwane i prowadzić do nieprzewidywalne zachowanie.  
  
 Właściwości zależności dla tego formantu może być ustawione przez domyślnego stylu. Jeśli właściwość jest ustawiana przez domyślnego stylu, zmienić właściwość z jego wartość domyślną gdy formant ma być wyświetlany w aplikacji. Domyślny styl jest określona, przez który motyw pulpitu jest używany podczas działania aplikacji. Aby uzyskać więcej informacji, zobacz [domyślne motywy WPF](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 W poniższych przykładach pokazano powiązanie danych z <xref:System.Windows.Controls.ItemsControl>. Pierwszy przykład tworzy klasę o nazwie `MyData` będący kolekcją prostego ciągu.  
  
 [!code-csharp[ControlContentOverviewSnippets#8](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#8)]
 [!code-vb[ControlContentOverviewSnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#8)]  
  
 Poniższy przykład tworzy powiązanie <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> obiektu <xref:System.Windows.Controls.ItemsControl> do `MyData`.  
  
 [!code-xaml[ControlContentOverviewSnippets#7](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#7)]  
[!code-xaml[ControlContentOverviewSnippets#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#6)]  
  
 [!code-csharp[ControlContentOverviewSnippets#9](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#9)]
 [!code-vb[ControlContentOverviewSnippets#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#9)]  
  
 Poniższa ilustracja przedstawia <xref:System.Windows.Controls.ListBox> utworzony w poprzednim przykładzie.  
  
 ![ListBox](~/add/media/controlcontentmodellistbox1.PNG "ListBox")  
  
 Poniższy przykład pokazuje, jak wypełnić <xref:System.Windows.Controls.ItemsControl> przy użyciu <xref:System.Windows.Controls.ItemsControl.Items%2A> właściwości. W przykładzie dodano różne rodzaje elementów do <xref:System.Windows.Controls.ListBox>:  
  
-   Ciąg.  
  
-   Element <xref:System.DateTime> obiektu.  
  
-   Element <xref:System.Windows.UIElement> obiektu.  
  
-   A <xref:System.Windows.Controls.Panel> formant, który zawiera inne <xref:System.Windows.UIElement> obiektów.  
  
 [!code-xaml[ControlContentOverviewSnippets#3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#3)]  
  
 [!code-csharp[ControlContentOverviewSnippets#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#4)]
 [!code-vb[ControlContentOverviewSnippets#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#4)]  
  
 Poniższa ilustracja przedstawia <xref:System.Windows.Controls.ListBox> utworzony w poprzednim przykładzie.  
  
 ![Pola listy z czterema typami zawartości](~/add/media/controlcontentmodellistbox2.PNG "ListBox przy użyciu czterech typów zawartości")  
  
 Poniższy przykład ilustruje sposób używania różnych stylów i właściwości związane z szablonów, które są dostarczane przez <xref:System.Windows.Controls.ItemsControl>. <xref:System.Windows.Controls.ItemsControl> w tym przykładzie jest powiązana z kolekcją `Task` obiektów. Demonstracyjne celów, style i szablony, w tym przykładzie są wszystkie wbudowane zadeklarowane.  
  
 [!code-xaml[DataTemplatingIntro_snip#ItemsControlProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#itemscontrolproperties)]  
  
 Na rysunku poniżej przedstawiono zrzut ekranu przykładu, gdy jest on renderowany.  
  
 ![Zrzut ekranu przykładu elementu ItemsControl](~/add/media/databinding-itemscontrolproperties.png "elementu ItemsControl Przykładowy zrzut ekranu")  
  
 Dwie inne stylu związane właściwości <xref:System.Windows.Controls.ItemsControl> , nie są wyświetlane w tym miejscu są <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> i <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.ItemCollection" />
    <altmember cref="T:System.Windows.Controls.ItemContainerGenerator" />
    <altmember cref="T:System.Windows.Controls.ItemsPresenter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ItemsControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ItemsControl();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Controls.ItemsControl" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="AddChild">
      <MemberSignature Language="C#" Value="protected virtual void AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddChild (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddChild(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member AddChild : obj -&gt; unit&#xA;override this.AddChild : obj -&gt; unit" Usage="itemsControl.AddChild value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do dodania jako element podrzędny.</param>
        <summary>Dodaje określony obiekt jako element podrzędny <see cref="T:System.Windows.Controls.ItemsControl" /> obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddText">
      <MemberSignature Language="C#" Value="protected virtual void AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddText (text As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddText(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member AddText : string -&gt; unit&#xA;override this.AddText : string -&gt; unit" Usage="itemsControl.AddText text" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg do dodania.</param>
        <summary>Dodaje ciąg tekstu określony do <see cref="T:System.Windows.Controls.ItemsControl" /> obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationCount">
      <MemberSignature Language="C#" Value="public int AlternationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AlternationCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.AlternationCount" />
      <MemberSignature Language="VB.NET" Value="Public Property AlternationCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AlternationCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AlternationCount : int with get, set" Usage="System.Windows.Controls.ItemsControl.AlternationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia liczbę kontenerów naprzemiennych elementów w <see cref="T:System.Windows.Controls.ItemsControl" />, który umożliwia tym kontenerom uzyskanie unikatowego wyglądu.</summary>
        <value>Liczbę kontenerów naprzemiennych elementów w <see cref="T:System.Windows.Controls.ItemsControl" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> i <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> właściwości umożliwiają określenie wyglądu dla co najmniej dwóch tym kontenerom elementu. Na przykład można określić różne kolory tła dla każdego trzeciego elementu w <xref:System.Windows.Controls.ItemsControl>.  <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> Jest przypisany do każdego elementu kontenera <xref:System.Windows.Controls.ItemsControl>.  <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> rozpoczyna się od 0, zwiększa się, dopóki nie zostanie <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> minus 1, a następnie ponownego uruchomienia w lokalizacji 0. Na przykład jeśli <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> 3 wiąże się z siedem elementów w <xref:System.Windows.Controls.ItemsControl>, w poniższej tabeli wymieniono <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> dla każdego elementu.  
  
|Położenie elementu <xref:System.Windows.Controls.ItemsControl>|<xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>|  
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|1|0|  
|2|1|  
|3|2|  
|4|0|  
|5|1|  
|6|2|  
|7|0|  
  
 Istnieje kilka metod, których można użyć, aby określić inny wygląd na tym kontenerom elementu. Jedną z metod jest można powiązać właściwości kontener elementów <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>. Następnie można użyć <xref:System.Windows.Controls.AlternationConverter> określić wartość, która ma zostać zastosowany do kontenera elementu, który ma określony <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> wartość. Umożliwia także wyzwalaczy na zmianę wartości właściwości kontenera elementu w zależności od wartości jego <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład określa, że <xref:System.Windows.Controls.ListBox> (który dziedziczy z <xref:System.Windows.Controls.ItemsControl>) ma alternatywnych kontenerów elementów (są typu <xref:System.Windows.Controls.ListBoxItem>) i umożliwia określenie różnych tła i pierwszego planu dla każdej z nich.  Przykład wiąże <xref:System.Windows.Controls.Control.Background%2A> i <xref:System.Windows.Controls.Control.Foreground%2A> właściwości <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> i zapewnia <xref:System.Windows.Controls.AlternationConverter> dla każdej właściwości.  
  
 [!code-xaml[AlternationIndexSnippets#2](~/samples/snippets/csharp/VS_Snippets_Wpf/AlternationIndexSnippets/CS/Window1.xaml#2)]  
  
 Poniższy przykład działa tak samo jak w poprzednim przykładzie za pomocą <xref:System.Windows.Trigger> obiektów.  
  
 [!code-xaml[AlternationIndexSnippets#1](~/samples/snippets/csharp/VS_Snippets_Wpf/AlternationIndexSnippets/CS/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationCountProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AlternationCountProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AlternationCountProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.AlternationCountProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AlternationCountProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AlternationCountProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AlternationCountProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.AlternationCountProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationIndex">
      <MemberSignature Language="C#" Value="see GetAlternationIndex, and SetAlternationIndex" />
      <MemberSignature Language="ILAsm" Value="see GetAlternationIndex, and SetAlternationIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.AlternationIndex" />
      <MemberSignature Language="VB.NET" Value="see GetAlternationIndex, and SetAlternationIndex" />
      <MemberSignature Language="F#" Value="see GetAlternationIndex, and SetAlternationIndex" Usage="see GetAlternationIndex, and SetAlternationIndex" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera przypisaną wartością kontener elementów, gdy są używane w tym kontenerom elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> i <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> właściwości umożliwiają określenie wyglądu dla co najmniej dwóch tym kontenerom elementu. Na przykład można określić różne kolory tła dla każdego trzeciego elementu w <xref:System.Windows.Controls.ItemsControl>.  <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> Jest przypisany do każdego elementu kontenera <xref:System.Windows.Controls.ItemsControl>.  <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> rozpoczyna się od 0, zwiększa się, dopóki nie zostanie <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> minus 1, a następnie ponownego uruchomienia w lokalizacji 0. Na przykład jeśli <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> 3 wiąże się z siedem elementów w <xref:System.Windows.Controls.ItemsControl>, w poniższej tabeli wymieniono <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> dla każdego elementu.  
  
|Położenie elementu <xref:System.Windows.Controls.ItemsControl>|<xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>|  
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|1|0|  
|2|1|  
|3|2|  
|4|0|  
|5|1|  
|6|2|  
|7|0|  
  
 Istnieje kilka metod, których można użyć, aby określić inny wygląd na tym kontenerom elementu. Jedną z metod jest można powiązać właściwości kontener elementów <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>. Następnie można użyć <xref:System.Windows.Controls.AlternationConverter> określić wartość, która ma zostać zastosowany do kontenera elementu, który ma określony <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> wartość. Umożliwia także wyzwalaczy na zmianę wartości właściwości kontenera elementu w zależności od wartości jego <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład określa, że <xref:System.Windows.Controls.ListBox> (który dziedziczy z <xref:System.Windows.Controls.ItemsControl>) ma alternatywnych kontenerów elementów (są typu <xref:System.Windows.Controls.ListBoxItem>) i umożliwia określenie różnych tła i pierwszego planu dla każdej z nich.  Przykład wiąże <xref:System.Windows.Controls.Control.Background%2A> i <xref:System.Windows.Controls.Control.Foreground%2A> właściwości <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> i zapewnia <xref:System.Windows.Controls.AlternationConverter> dla każdej właściwości.  
  
 [!code-xml[AlternationIndexSnippets#2](~/samples/snippets/csharp/VS_Snippets_Wpf/AlternationIndexSnippets/CS/Window1.xaml#2)]  
  
 Poniższy przykład działa tak samo jak w poprzednim przykładzie za pomocą <xref:System.Windows.Trigger> obiektów.  
  
 [!code-xml[AlternationIndexSnippets#1](~/samples/snippets/csharp/VS_Snippets_Wpf/AlternationIndexSnippets/CS/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationIndexProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AlternationIndexProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AlternationIndexProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.AlternationIndexProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AlternationIndexProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AlternationIndexProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AlternationIndexProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.AlternationIndexProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public override void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void BeginInit();" />
      <MemberSignature Language="F#" Value="override this.BeginInit : unit -&gt; unit" Usage="itemsControl.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oznacza to, że Inicjalizacja <see cref="T:System.Windows.Controls.ItemsControl" /> obiekt ma uruchomić.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="ClearContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected virtual void ClearContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ClearContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member ClearContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit&#xA;override this.ClearContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="itemsControl.ClearContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="element">Element kontenera.</param>
        <param name="item">Element.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, cofa skutki <see cref="M:System.Windows.Controls.ItemsControl.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowa implementacja nic nie robi.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ContainerFromElement">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kontener, który należy do bieżącego <see cref="T:System.Windows.Controls.ItemsControl" /> , który jest właścicielem elementu danego kontenera.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContainerFromElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject ContainerFromElement (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject ContainerFromElement(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ContainerFromElement(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainerFromElement (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ ContainerFromElement(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="member this.ContainerFromElement : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="itemsControl.ContainerFromElement element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Elementu do zwrócenia kontenera.</param>
        <summary>Zwraca kontener, który należy do bieżącego <see cref="T:System.Windows.Controls.ItemsControl" /> , który jest właścicielem danego elementu.</summary>
        <returns>Kontener, który należy do bieżącego <see cref="T:System.Windows.Controls.ItemsControl" /> , który jest właścicielem danego elementu lub <see langword="null" /> Jeśli brak kontenera takie istnieje.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="ContainerFromElement">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject ContainerFromElement (System.Windows.Controls.ItemsControl itemsControl, System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject ContainerFromElement(class System.Windows.Controls.ItemsControl itemsControl, class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ContainerFromElement(System.Windows.Controls.ItemsControl,System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ ContainerFromElement(System::Windows::Controls::ItemsControl ^ itemsControl, System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member ContainerFromElement : System.Windows.Controls.ItemsControl * System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Controls.ItemsControl.ContainerFromElement (itemsControl, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemsControl" Type="System.Windows.Controls.ItemsControl" />
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="itemsControl"><see cref="T:System.Windows.Controls.ItemsControl" /> Do zwrócenia kontenera.</param>
        <param name="element">Elementu do zwrócenia kontenera.</param>
        <summary>Zwraca kontener, który należy do określonego <see cref="T:System.Windows.Controls.ItemsControl" /> , który jest właścicielem elementu danego kontenera.</summary>
        <returns>Kontener, który należy do określonego <see cref="T:System.Windows.Controls.ItemsControl" /> , który jest właścicielem danego elementu, jeśli <paramref name="itemsControl" /> nie <see langword="null" />. Jeśli <paramref name="itemsControl" /> jest <see langword="null" />, zwraca najbliższy kontener, który należy do żadnej <see cref="T:System.Windows.Controls.ItemsControl" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMemberPath">
      <MemberSignature Language="C#" Value="public string DisplayMemberPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayMemberPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayMemberPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayMemberPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayMemberPath : string with get, set" Usage="System.Windows.Controls.ItemsControl.DisplayMemberPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ścieżkę do wartości w obiekcie źródłowym, który ma pełnić rolę wizualnej reprezentacji obiektu.</summary>
        <value>Ścieżka do wartości w obiekcie źródłowym. Może to być dowolną ścieżkę lub wyrażenie XPath takich jak "@Name". Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest prostym sposobem definiowania szablonu domyślnego, który opisuje sposób wyświetlania obiektów danych.  
  
<a name="dependencyPropertyInfo_DisplayMemberPath"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ItemsControl.DisplayMemberPathProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 W poniższym przykładzie statycznych zasobów o nazwie `places` jest zdefiniowany jako kolekcja `Place` obiektów, w których każdy `Place` obiekt ma `CityName` właściwości i `State` właściwości. Prefiks `src` jest zamapowana na przestrzeń nazw gdzie źródło danych `Places` jest zdefiniowana. Prefiksy `scm` i `dat` są mapowane na <xref:System.ComponentModel> i <xref:System.Windows.Data> przestrzeni nazw, odpowiednio.  
  
 Poniższy przykład tworzy widok zbierania danych, które są sortowane według nazwy miasta i pogrupowane według stanu.  
  
 [!code-xaml[CollectionViewSource#1](~/samples/snippets/csharp/VS_Snippets_Wpf/CollectionViewSource/CS/window1.xaml#1)]  
  
 Widok może być źródło powiązania, jak w poniższym przykładzie. Ze względu na określony <xref:System.Windows.Controls.ItemsControl.DisplayMemberPath%2A>, każdy`Place` obiektu jest przedstawiana wraz z jego `CityName` wartość. Jeśli <xref:System.Windows.Controls.ItemsControl.DisplayMemberPath%2A> nie jest określona i ma nie <xref:System.Windows.DataTemplate>, a następnie <xref:System.Windows.Controls.ListBox> Wyświetla reprezentację ciągu każdego obiektu w kolekcji źródłowej (w tym przypadku "SDKSample.Place").  
  
 [!code-xaml[CollectionViewSource#2](~/samples/snippets/csharp/VS_Snippets_Wpf/CollectionViewSource/CS/window1.xaml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMemberPathProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DisplayMemberPathProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DisplayMemberPathProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.DisplayMemberPathProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DisplayMemberPathProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DisplayMemberPathProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DisplayMemberPathProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.DisplayMemberPathProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public override void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndInit();" />
      <MemberSignature Language="F#" Value="override this.EndInit : unit -&gt; unit" Usage="itemsControl.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oznacza to, że Inicjalizacja <see cref="T:System.Windows.Controls.ItemsControl" /> obiektu zostało zakończone.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAlternationIndex">
      <MemberSignature Language="C#" Value="public static int GetAlternationIndex (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetAlternationIndex(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.GetAlternationIndex(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAlternationIndex (element As DependencyObject) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetAlternationIndex(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetAlternationIndex : System.Windows.DependencyObject -&gt; int" Usage="System.Windows.Controls.ItemsControl.GetAlternationIndex element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt, z którego można pobrać <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" />.</param>
        <summary>Pobiera <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" /> dla określonego obiektu.</summary>
        <returns>Wartość <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.DependencyObject GetContainerForItemOverride ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.DependencyObject GetContainerForItemOverride() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.GetContainerForItemOverride" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetContainerForItemOverride () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::DependencyObject ^ GetContainerForItemOverride();" />
      <MemberSignature Language="F#" Value="abstract member GetContainerForItemOverride : unit -&gt; System.Windows.DependencyObject&#xA;override this.GetContainerForItemOverride : unit -&gt; System.Windows.DependencyObject" Usage="itemsControl.GetContainerForItemOverride " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy lub identyfikuje element, który służy do wyświetlania danego elementu.</summary>
        <returns>Element, który służy do wyświetlania danego elementu.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="GetItemsOwner">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.ItemsControl GetItemsOwner (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Controls.ItemsControl GetItemsOwner(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.GetItemsOwner(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetItemsOwner (element As DependencyObject) As ItemsControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::ItemsControl ^ GetItemsOwner(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetItemsOwner : System.Windows.DependencyObject -&gt; System.Windows.Controls.ItemsControl" Usage="System.Windows.Controls.ItemsControl.GetItemsOwner element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemsControl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Element hosta.</param>
        <summary>Zwraca <see cref="T:System.Windows.Controls.ItemsControl" /> określony element znajduje się elementy.</summary>
        <returns><see cref="T:System.Windows.Controls.ItemsControl" /> Określony element znajduje się elementy, lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Controls.Panel.IsItemsHost%2A> jest ustawiona na `true` na `element` w stylu lub jeśli `element` jest utworzony przez panel <xref:System.Windows.Controls.ItemsPresenter> dla <xref:System.Windows.Controls.ItemsControl>, <xref:System.Windows.Controls.ItemsControl> jest zwracana; w przeciwnym razie `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupStyle">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ObservableCollection&lt;System.Windows.Controls.GroupStyle&gt; GroupStyle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ObservableCollection`1&lt;class System.Windows.Controls.GroupStyle&gt; GroupStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.GroupStyle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GroupStyle As ObservableCollection(Of GroupStyle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ObservableCollection&lt;System::Windows::Controls::GroupStyle ^&gt; ^ GroupStyle { System::Collections::ObjectModel::ObservableCollection&lt;System::Windows::Controls::GroupStyle ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GroupStyle : System.Collections.ObjectModel.ObservableCollection&lt;System.Windows.Controls.GroupStyle&gt;" Usage="System.Windows.Controls.ItemsControl.GroupStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ObservableCollection&lt;System.Windows.Controls.GroupStyle&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Windows.Controls.GroupStyle" /> obiekty, które określają wygląd każdego poziomu grupy.</summary>
        <value>Kolekcja <see cref="T:System.Windows.Controls.GroupStyle" /> obiekty, które określają wygląd każdego poziomu grupy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wpis pod indeksem 0 opisuje grup najwyższego poziomu, wpis pod indeksem 1 w tym artykule opisano następnego poziomu, i tak dalej. W przypadku więcej poziomy grupowania niż wpisów w kolekcji ostatni wpis jest używany dla dodatkowych poziomów.  
  
<a name="xamlPropertyElementUsage_GroupStyle"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  <object.GroupStyle>  
    OneOrMoreGroupStyleObjects  
  </object.GroupStyle>  
</object>  
  
```  
  
<a name="xamlValues_GroupStyle"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *OneOrMoreGroupStyleObjects*  
 Co najmniej jeden <xref:System.Windows.Controls.GroupStyle> obiektów.  
  
   
  
## Examples  
 W poniższych przykładach pokazano <xref:System.Windows.Controls.ItemsControl> , jest powiązany z <xref:System.Windows.Data.XmlDataProvider> i zawartości związanym z kodem, który zawiera logikę do dodawania i usuwania grupowania. Gdy pole wyboru jest zaznaczone, zawartość <xref:System.Windows.Controls.ItemsControl> są grupowane według `Type` atrybutu.  
  
 Każda grupa jest typu <xref:System.Windows.Data.CollectionViewGroup>. <xref:System.Windows.Controls.GroupStyle> <xref:System.Windows.Controls.GroupStyle.HeaderTemplate%2A> Jest określony, aby była ona wyświetlana jako <xref:System.Windows.Controls.TextBlock> wyświetlającą <xref:System.Windows.Data.CollectionViewGroup.Name%2A> każdej grupy. W tym przypadku <xref:System.Windows.Data.CollectionViewGroup.Name%2A> jest `Work` lub `Home`.  
  
 [!code-xaml[GroupingSample#XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml#xaml)]  
  
 [!code-csharp[GroupingSample#Code](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#code)]
 [!code-vb[GroupingSample#Code](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#code)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" />
      </Docs>
    </Member>
    <Member MemberName="GroupStyleSelector">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.GroupStyleSelector GroupStyleSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.GroupStyleSelector GroupStyleSelector" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property GroupStyleSelector As GroupStyleSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::GroupStyleSelector ^ GroupStyleSelector { System::Windows::Controls::GroupStyleSelector ^ get(); void set(System::Windows::Controls::GroupStyleSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.GroupStyleSelector : System.Windows.Controls.GroupStyleSelector with get, set" Usage="System.Windows.Controls.ItemsControl.GroupStyleSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.GroupStyleSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia metodę, która pozwala na dostarczenie logikę niestandardowy wybór <see cref="T:System.Windows.Controls.GroupStyle" /> do zastosowania do każdej grupy w kolekcji.</summary>
        <value>Metoda, która pozwala na dostarczenie logikę niestandardowy wybór <see cref="T:System.Windows.Controls.GroupStyle" /> do zastosowania do każdej grupy w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_GroupStyleSelector"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ItemsControl.GroupStyleSelectorProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.PropertyGroupDescription" />
      </Docs>
    </Member>
    <Member MemberName="GroupStyleSelectorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty GroupStyleSelectorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty GroupStyleSelectorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.GroupStyleSelectorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GroupStyleSelectorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ GroupStyleSelectorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable GroupStyleSelectorProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.GroupStyleSelectorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasItems">
      <MemberSignature Language="C#" Value="public bool HasItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasItems" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.HasItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasItems As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasItems { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasItems : bool" Usage="System.Windows.Controls.ItemsControl.HasItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Controls.ItemsControl" /> zawiera elementy.</summary>
        <value><see langword="true" /> Jeśli liczba elementów jest większa niż 0. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_HasItems"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ItemsControl.HasItemsProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasItemsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HasItemsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HasItemsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.HasItemsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HasItemsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HasItemsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HasItemsProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.HasItemsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.HasItems" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGrouping">
      <MemberSignature Language="C#" Value="public bool IsGrouping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGrouping" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.IsGrouping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGrouping As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGrouping { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGrouping : bool" Usage="System.Windows.Controls.ItemsControl.IsGrouping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kontrolka jest korzystanie z grupowania.</summary>
        <value><see langword="true" /> Jeśli formant jest korzystanie z grupowania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsGrouping"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ItemsControl.IsGroupingProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGroupingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsGroupingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsGroupingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.IsGroupingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsGroupingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsGroupingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsGroupingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.IsGroupingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.IsGrouping" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsItemItsOwnContainer">
      <MemberSignature Language="C#" Value="public bool IsItemItsOwnContainer (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsItemItsOwnContainer(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.IsItemItsOwnContainer(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsItemItsOwnContainer (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsItemItsOwnContainer(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="member this.IsItemItsOwnContainer : obj -&gt; bool" Usage="itemsControl.IsItemItsOwnContainer item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.Controls.IGeneratorHost.IsItemItsOwnContainer(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">Element do sprawdzenia.</param>
        <summary>Określa, czy określony element jest (lub kwalifikuje się jako) własnym kontenerze.</summary>
        <returns><see langword="true" /> Jeśli element jest (lub kwalifikuje się jako) własnym kontenerze; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.Windows.Controls.ItemsControl.IsItemItsOwnContainerOverride%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsItemItsOwnContainerOverride">
      <MemberSignature Language="C#" Value="protected virtual bool IsItemItsOwnContainerOverride (object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsItemItsOwnContainerOverride(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.IsItemItsOwnContainerOverride(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsItemItsOwnContainerOverride (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsItemItsOwnContainerOverride(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member IsItemItsOwnContainerOverride : obj -&gt; bool&#xA;override this.IsItemItsOwnContainerOverride : obj -&gt; bool" Usage="itemsControl.IsItemItsOwnContainerOverride item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Element do sprawdzenia.</param>
        <summary>Określa, czy określony element jest (lub kwalifikuje się jako) własnym kontenerze.</summary>
        <returns><see langword="true" /> Jeśli element jest (lub kwalifikuje się jako) własnym kontenerze; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchCaseSensitive">
      <MemberSignature Language="C#" Value="public bool IsTextSearchCaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTextSearchCaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTextSearchCaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTextSearchCaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTextSearchCaseSensitive : bool with get, set" Usage="System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy przypadek ma miejsce podczas wyszukiwania elementów.</summary>
        <value><see langword="true" /> Jeśli podczas wyszukiwania tekstu jest rozróżniana wielkość liter; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Controls.ItemsControl.IsTextSearchEnabled%2A> właściwość jest ustawiona na `true`, <xref:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive%2A> właściwość określa, czy przypadku określa, czy element jest zaznaczony na <xref:System.Windows.Controls.ItemsControl>. Na przykład jeśli <xref:System.Windows.Controls.ItemsControl> zawiera dwa ciągi, które różnią się tylko w przypadku, takie jak "ITEM" i "item" pierwszy ciąg będzie zawsze należy wybrać, niezależnie od tego, w przypadku danych wejściowych.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Windows.Controls.ComboBox> zawierającą ciągi, "DOG", "CAT", "dog" i "cat". Przykład wiąże <xref:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive%2A> właściwości <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A> właściwość <xref:System.Windows.Controls.CheckBox>. Jeśli pole wyboru jest zaznaczone, a użytkownik wpisze "dog" trzeci element w <xref:System.Windows.Controls.ItemsControl> jest zaznaczone. Jeśli użytkownik usuwa pole wyboru i typy "dog", jest zaznaczony pierwszy element, ponieważ przypadek nie jest warunku wyszukiwania.  
  
 [!code-xaml[ComboBoxProps_snip#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxProps_snip/CS/pane1.xaml#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchCaseSensitiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsTextSearchCaseSensitiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsTextSearchCaseSensitiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsTextSearchCaseSensitiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsTextSearchCaseSensitiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsTextSearchCaseSensitiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchEnabled">
      <MemberSignature Language="C#" Value="public bool IsTextSearchEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTextSearchEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.IsTextSearchEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTextSearchEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTextSearchEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTextSearchEnabled : bool with get, set" Usage="System.Windows.Controls.ItemsControl.IsTextSearchEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Windows.Controls.TextSearch" /> jest włączona na <see cref="T:System.Windows.Controls.ItemsControl" /> wystąpienia.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Windows.Controls.TextSearch" /> jest włączone; w przeciwnym razie <see langword="true" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsTextSearchEnabled"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ItemsControl.IsTextSearchEnabledProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsTextSearchEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsTextSearchEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.IsTextSearchEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsTextSearchEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsTextSearchEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsTextSearchEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.IsTextSearchEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.IsTextSearchEnabled" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemBindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup ItemBindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup ItemBindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemBindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ ItemBindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemBindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.Controls.ItemsControl.ItemBindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Data.BindingGroup" /> kopiowana do każdego elementu <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value><see cref="T:System.Windows.Data.BindingGroup" /> Kopiowana do każdego elementu <see cref="T:System.Windows.Controls.ItemsControl" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po ustawieniu <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A> pobiera każdego kontenera elementu właściwości <xref:System.Windows.Data.BindingGroup> ma taką samą <xref:System.Windows.Controls.ValidationRule> obiektów jako <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A>, ale właściwości, które opisują dane w powiązaniach, takich jak <xref:System.Windows.Data.BindingGroup.Items%2A> i <xref:System.Windows.Data.BindingGroup.BindingExpressions%2A>, są specyficzne dla danych dla każdego elementu w <xref:System.Windows.Controls.ItemsControl>.  Należy przejść do kontenera elementu <xref:System.Windows.FrameworkContentElement.BindingGroup%2A> przeprowadzić operacje takie jak weryfikacja danych i sprawdzanie pod kątem błędów elementu.  
  
   
  
## Examples  
 Poniższy przykład jest częścią aplikacji, który monituje użytkownika o wprowadzenie wielu klientów i przypisać przedstawiciel handlowy do każdego klienta, a następnie sprawdza, czy klient i przedstawicielem handlowym firmy należą do tego samego regionu. Przykład ustawia <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A> z <xref:System.Windows.Controls.ItemsControl> więc <xref:System.Windows.Controls.ValidationRule>, `AreasMatch`, zostanie przeprowadzona Weryfikacja każdej pozycji. W przykładzie jest tworzony również <xref:System.Windows.Controls.Label> wyświetlającą błędy sprawdzania poprawności. Należy zauważyć, że <xref:System.Windows.Controls.ContentControl.Content%2A> z <xref:System.Windows.Controls.Label> jest powiązany z <xref:System.Windows.Controls.ValidationError> pobierające z <xref:System.Windows.Controls.Validation.ValidationAdornerSiteForProperty?displayProperty=nameWithType> właściwości. Wartość <xref:System.Windows.Controls.Validation.ValidationAdornerSiteForProperty?displayProperty=nameWithType> jest kontenerem elementu, który zawiera błąd.  
  
 [!code-xaml[BindingGroupSnippets#ItemBindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml#itembindinggroup)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSiteFor](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml#validationadornersitefor)]  
  
 Poniższy przykład pobiera kontener elementów i wywołania <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> dla kontenera <xref:System.Windows.Data.BindingGroup> sprawdzania poprawności danych. Należy sprawdzić poprawność danych przez wywołanie metody w kontenerze elementu <xref:System.Windows.FrameworkContentElement.BindingGroup%2A>nie na <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A> z <xref:System.Windows.Controls.ItemsControl>.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSources](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#updatesources)]
 [!code-vb[BindingGroupSnippets#UpdateSources](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#updatesources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemBindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemBindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemBindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemBindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemBindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemBindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemBindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemBindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerGenerator">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ItemContainerGenerator ItemContainerGenerator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ItemContainerGenerator ItemContainerGenerator" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemContainerGenerator As ItemContainerGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ItemContainerGenerator ^ ItemContainerGenerator { System::Windows::Controls::ItemContainerGenerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemContainerGenerator : System.Windows.Controls.ItemContainerGenerator" Usage="System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemContainerGenerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Controls.ItemContainerGenerator" /> skojarzonym z kontrolką.</summary>
        <value><see cref="T:System.Windows.Controls.ItemContainerGenerator" /> Skojarzonym z kontrolką. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A> Jest odpowiedzialny za wygenerowanie [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] jej hosta, takich jak <xref:System.Windows.Controls.ItemsControl>. Ta funkcja obsługuje skojarzenie między elementami w widoku danych formantu i odpowiedni <xref:System.Windows.UIElement> obiektów. Każdy <xref:System.Windows.Controls.ItemsControl> ma kontenera skojarzonego elementu, który zawiera element danych w kolekcji elementów. Możesz użyć <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A> właściwości dostępu do kontenera elementu, który jest skojarzony z <xref:System.Windows.Controls.ItemsControl>. Na przykład, jeśli masz powiązanych z danymi <xref:System.Windows.Controls.TreeView> kontroli i chcesz uzyskać <xref:System.Windows.Controls.TreeViewItem> na podstawie jego indeksu lub jego element danych skojarzony, możesz użyć <xref:System.Windows.Controls.ItemContainerGenerator.ContainerFromIndex%2A?displayProperty=nameWithType> lub <xref:System.Windows.Controls.ItemContainerGenerator.ContainerFromItem%2A?displayProperty=nameWithType> metody. Alternatywnie, można użyć <xref:System.Windows.Controls.ItemContainerGenerator.IndexFromContainer%2A?displayProperty=nameWithType> lub <xref:System.Windows.Controls.ItemContainerGenerator.ItemFromContainer%2A?displayProperty=nameWithType> metodę, aby uzyskać indeks lub danych element, który jest skojarzony z elementem dany kontener wygenerowany.  
  
 <xref:System.Windows.Controls.Primitives.IItemContainerGenerator> Interfejs jest również używany w zaawansowanych scenariuszach. Zazwyczaj zaawansowane aplikacje, które mają własne implementacji wirtualizacji panelu wywołują elementy członkowskie interfejsu.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms750552(v=vs.90)">Pobierz element pola kombi</related>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style ItemContainerStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style ItemContainerStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemContainerStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ ItemContainerStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemContainerStyle : System.Windows.Style with get, set" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Content")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Style" /> mający zastosowanie do elementu kontenera, generowany dla każdego elementu.</summary>
        <value><see cref="T:System.Windows.Style" /> Mający zastosowanie do elementu kontenera, generowany dla każdego elementu. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest używana lub <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> właściwości do ustawienia stylu wpłynie na wygląd elementów, które zawierają elementy danych. Na przykład w przypadku <xref:System.Windows.Controls.ListBox>, wygenerowany kontenery są <xref:System.Windows.Controls.ListBoxItem> kontroluje; dla <xref:System.Windows.Controls.ComboBox>, są one <xref:System.Windows.Controls.ComboBoxItem> kontrolki.  
  
 <xref:System.Windows.Controls.ItemsControl> Zapewnia dużą elastyczność dostosowywania wizualne i zawiera wiele właściwości Tworzenie szablonów i stylów. Aby mieć wpływ na układ elementów, należy użyć <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> właściwości. Jeśli używasz grupowania na kontrolki, możesz użyć <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> lub <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> właściwości. Aby określić wizualizacji obiektów danych, użyj <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> lub <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> właściwości. Aby uzyskać więcej informacji o tym, kiedy określ <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A>, zobacz [Przegląd Szablonowanie danych](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="xamlAttributeUsage_ItemContainerStyle"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object ItemContainerStyle="ResourceExtension StyleResourceKey"/>  
```  
  
<a name="xamlValues_ItemContainerStyle"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *ResourceExtension*  
 Jedną z następujących: `StaticResource`, lub `DynamicResource`. O ile style, samodzielnie zawierają odwołania do potencjalnych odwołania środowiska wykonawczego, takich jak zasoby systemowe lub preferencje użytkownika `StaticResource` odwołanie do stylu zazwyczaj jest zalecane w przypadku wydajności.  
  
 *StyleResourceKey*  
 `x:Key` wartość ciągu, odnoszące się do stylu żądanej jako zasób.  
  
<a name="dependencyPropertyInfo_ItemContainerStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ItemsControl.ItemContainerStyleProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać tej właściwości. Uwzględnij następujące kwestie związane z danymi <xref:System.Windows.Controls.ListBox>:  
  
 [!code-xaml[StylingIntroSnippet#UIListBox](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSnippet/CS/window1.xaml#uilistbox)]   
  
 Aby utworzyć styl dla elementów, które zawierają elementy danych, Utwórz <xref:System.Windows.Controls.ListBoxItem> stylu, jak pokazano w poniższym przykładzie. Styl jest stosowane do wszystkich <xref:System.Windows.Controls.ListBoxItem> elementów w zakresie styl jest zdefiniowany w.  
  
 [!code-xaml[StylingIntroSnippet#ListBoxItemStyle](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSnippet/CS/window1.xaml#listboxitemstyle)]   
  
 <xref:System.Windows.Controls.ListBoxItem> Jest elementem kontenera <xref:System.Windows.Controls.ListBox> kontroli. Dlatego zamiast kroku jest można ustawić <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> właściwość <xref:System.Windows.Controls.ListBox> na styl zdefiniowany. Aby to zrobić, nadaj <xref:System.Windows.Controls.ListBoxItem> styl `x:Key` , jest ona dostępna jako zasób:  
  
 [!code-xaml[StylingIntroSample_snippet#ContainerStyle1](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#containerstyle1)]   
  
 Następnym etapem jest skonfigurowanie <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> właściwości zasobów, jak w poniższym przykładzie:  
  
 [!code-xaml[StylingIntroSample_snippet#ListBox](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#listbox)]   
  
 Zarówno z powyższych scenariuszy generuje ten sam wynik. Jednak jest jedną z zalet udostępnia styl jako zasób, możesz użyć stylu. Ustawienie <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> właściwość jawnie zapewnia także większą czytelność.  
  
 Aby uzyskać kompletny przykład, zobacz [wprowadzenie do przykładowych szablonów i stylów](https://go.microsoft.com/fwlink/?LinkID=160010).  
  
 Poniższy przykład zaprojektowano w celu zilustrowania funkcja różnych szablonów i stylów powiązane właściwości dostarczonych przez <xref:System.Windows.Controls.ItemsControl>. <xref:System.Windows.Controls.ItemsControl> w tym przykładzie jest powiązana z kolekcją `Task` obiektów. Demonstracyjne celów, style i szablony, w tym przykładzie są wszystkie wbudowane zadeklarowane.  
  
 [!code-xaml[DataTemplatingIntro_snip#ItemsControlProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#itemscontrolproperties)]  
  
 Poniżej przedstawiono zrzut ekranu przykładu, gdy jest on renderowany:  
  
 ![Zrzut ekranu przykładu elementu ItemsControl](~/add/media/databinding-itemscontrolproperties.png "elementu ItemsControl Przykładowy zrzut ekranu")  
  
 Dwie inne stylu związane właściwości <xref:System.Windows.Controls.ItemsControl> , nie są wyświetlane w tym miejscu są <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> i <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A>.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160009">Wprowadzenie do próbki Szablonowanie danych</related>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemContainerStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemContainerStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemContainerStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemContainerStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemContainerStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemContainerStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyleSelector">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.StyleSelector ItemContainerStyleSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.StyleSelector ItemContainerStyleSelector" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemContainerStyleSelector As StyleSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::StyleSelector ^ ItemContainerStyleSelector { System::Windows::Controls::StyleSelector ^ get(); void set(System::Windows::Controls::StyleSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemContainerStyleSelector : System.Windows.Controls.StyleSelector with get, set" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Content")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.StyleSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia logikę zaznaczenie style niestandardowe style, które mogą być stosowane do każdego elementu wygenerowany kontener.</summary>
        <value>A <see cref="T:System.Windows.Controls.StyleSelector" /> obiekt, który zawiera logikę, która wybiera styl do użycia jako <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" />. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> właściwości do ustawienia stylu wpłynie na wygląd elementów, które zawierają elementy danych. Na przykład w przypadku <xref:System.Windows.Controls.ListBox>, wygenerowany kontenery są <xref:System.Windows.Controls.ListBoxItem> kontroluje; dla <xref:System.Windows.Controls.ComboBox>, są one <xref:System.Windows.Controls.ComboBoxItem> kontrolki. Jeśli masz więcej niż jednego stylu zdefiniowane i, należy podać logiki, aby wybrać, który z nich do zastosowania, a następnie używasz <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> właściwości zamiast <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> właściwości. Należy pamiętać, że ta właściwość jest ignorowana, jeśli <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> właściwość jest ustawiona.  
  
 <xref:System.Windows.Controls.ItemsControl> Zapewnia dużą elastyczność dostosowywania wizualne i zawiera wiele właściwości Tworzenie szablonów i stylów. Aby mieć wpływ na układ elementów, należy użyć <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> właściwości. Jeśli używasz grupowania na kontrolki, możesz użyć <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> lub <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> właściwości. Aby określić wizualizacji obiektów danych, użyj <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> lub <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> właściwości. Aby uzyskać więcej informacji o tym, kiedy określ <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A>, zobacz [Przegląd Szablonowanie danych](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="dependencyPropertyInfo_ItemContainerStyleSelector"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyleSelectorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemContainerStyleSelectorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemContainerStyleSelectorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemContainerStyleSelectorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemContainerStyleSelectorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemContainerStyleSelectorProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ItemCollection Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ItemCollection Items" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As ItemCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ItemCollection ^ Items { System::Windows::Controls::ItemCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Windows.Controls.ItemCollection" Usage="System.Windows.Controls.ItemsControl.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję używany do generowania zawartości <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value>Kolekcja, która służy do generowania zawartości <see cref="T:System.Windows.Controls.ItemsControl" />. Wartością domyślną jest pusta kolekcja.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość może służyć do dodawania elementów do <xref:System.Windows.Controls.ItemsControl>. Dodawanie element podrzędny <xref:System.Windows.Controls.ItemsControl> obiektu niejawnie dodaje go do <xref:System.Windows.Controls.ItemCollection> dla <xref:System.Windows.Controls.ItemsControl> obiektu.  
  
> [!NOTE]
>  Tę właściwość można ustawić tylko [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] za pomocą składni kolekcji pokazano lub uzyskiwania dostępu do obiektu kolekcji, a przy użyciu jego różnych metod, takich jak `Add`. Właściwość do dostępu do samego obiektu kolekcji jest tylko do odczytu, a sama kolekcja jest odczytu i zapisu.  
  
 Należy pamiętać, użyj jednej <xref:System.Windows.Controls.ItemsControl.Items%2A> lub <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> właściwości w celu określenia kolekcji, które mają być używane do generowania zawartości Twojej <xref:System.Windows.Controls.ItemsControl>. Gdy <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> ustawiono właściwość <xref:System.Windows.Controls.ItemsControl.Items%2A> kolekcji składa się tylko do odczytu i stałym rozmiarze.  
  
 Gdy <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> jest w użyciu ustawienia <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> właściwości `null` spowoduje usunięcie kolekcji i przywrócenie użycia <xref:System.Windows.Controls.ItemsControl.Items%2A>, który będzie stanowić pustego <xref:System.Windows.Controls.ItemCollection>.  
  
<a name="xamlPropertyElementUsage_Items"></a>   
## <a name="xaml-property-element-usage"></a>Użycie elementu właściwości języka XAML  
  
```  
<object>  
  OneOrMoreElements  
</object>  
```  
  
<a name="xamlValues_Items"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *OneOrMoreElements*  
 Co najmniej jeden <xref:System.Windows.UIElement> obiektów.  
  
   
  
## Examples  
 W poniższych przykładach pokazano powiązanie danych z <xref:System.Windows.Controls.ItemsControl>. Pierwszy przykład tworzy klasę o nazwie `MyData` będący kolekcją prostego ciągu.  
  
 [!code-csharp[ControlContentOverviewSnippets#8](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#8)]
 [!code-vb[ControlContentOverviewSnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#8)]  
  
 Poniższy przykład tworzy powiązanie <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> obiektu <xref:System.Windows.Controls.ItemsControl> do `MyData`.  
  
 [!code-xaml[ControlContentOverviewSnippets#7](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#7)]  
[!code-xaml[ControlContentOverviewSnippets#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#6)]  
  
 [!code-csharp[ControlContentOverviewSnippets#9](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#9)]
 [!code-vb[ControlContentOverviewSnippets#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#9)]  
  
 Poniższa ilustracja przedstawia <xref:System.Windows.Controls.ListBox> utworzony w poprzednim przykładzie.  
  
 ![ListBox](~/add/media/controlcontentmodellistbox1.PNG "ListBox")  
  
 Poniższy przykład pokazuje, jak wypełnić <xref:System.Windows.Controls.ItemsControl> przy użyciu <xref:System.Windows.Controls.ItemsControl.Items%2A> właściwości. W przykładzie dodano różne rodzaje elementów do <xref:System.Windows.Controls.ListBox>:  
  
-   Ciąg.  
  
-   Element <xref:System.DateTime> obiektu.  
  
-   Element <xref:System.Windows.UIElement> obiektu.  
  
-   A <xref:System.Windows.Controls.Panel> formant, który zawiera inne <xref:System.Windows.UIElement> obiektów.  
  
 [!code-xaml[ControlContentOverviewSnippets#3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#3)]  
  
 [!code-csharp[ControlContentOverviewSnippets#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#4)]
 [!code-vb[ControlContentOverviewSnippets#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#4)]  
  
 Poniższa ilustracja przedstawia <xref:System.Windows.Controls.ListBox> utworzony w poprzednim przykładzie.  
  
 ![Pola listy z czterema typami zawartości](~/add/media/controlcontentmodellistbox2.PNG "ListBox przy użyciu czterech typów zawartości")  
  
 Należy pamiętać, że <xref:System.Windows.Controls.ItemCollection> jest widok, aby można było używać Wyświetl powiązane funkcje, takie jak sortowanie, filtrowanie i grupowanie.  
  
 Na przykład, jeśli masz wystąpienie <xref:System.Windows.Controls.ListBox>, `myListBox`, można wykonać następujące polecenie, aby posortować zawartość <xref:System.Windows.Controls.ListBox>. W tym przykładzie `Content` jest nazwą właściwości, aby posortować według.  
  
 [!code-csharp[ListBoxSort_snip#Sort](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxSort_snip/CSharp/Window1.xaml.cs#sort)]
 [!code-vb[ListBoxSort_snip#Sort](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxSort_snip/visualbasic/window1.xaml.vb#sort)]  
  
 Należy pamiętać, że w przypadku możesz to zrobić, jeśli kontrolka jest powiązana z kolekcją bezpośrednio, jest używany domyślny widok kolekcji i kryteriów sortowania są stosowane do wszystkich innych formantów powiązany z tej samej kolekcji bezpośrednio. Widok nie będzie widok domyślny, jeśli <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> właściwość jest powiązana z <xref:System.Windows.Data.CollectionViewSource>.  
  
 Jeśli Twoje <xref:System.Windows.Controls.ItemsControl> jest powiązana bezpośrednio do kolekcji, a następnie może wykonać następujące polecenie, aby pobrać domyślny widok:  
  
 [!code-csharp[GroupingSample#MyView](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#myview)]
 [!code-vb[GroupingSample#MyView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#myview)]  
[!code-csharp[GroupingSample#GetView](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#getview)]
[!code-vb[GroupingSample#GetView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#getview)]  
  
 Alternatywnie można określić filtrowanie, sortowanie i grupowanie kryteria [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] lub kodu za pomocą <xref:System.Windows.Data.CollectionViewSource>.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://github.com/Microsoft/WPF-Samples/tree/master/Data%20Binding/SortFilter">Sortowanie i filtrowanie elementów w przykładzie widoku</related>
      </Docs>
    </Member>
    <Member MemberName="ItemsControlFromItemContainer">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.ItemsControl ItemsControlFromItemContainer (System.Windows.DependencyObject container);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Controls.ItemsControl ItemsControlFromItemContainer(class System.Windows.DependencyObject container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ItemsControlFromItemContainer(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ItemsControlFromItemContainer (container As DependencyObject) As ItemsControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::ItemsControl ^ ItemsControlFromItemContainer(System::Windows::DependencyObject ^ container);" />
      <MemberSignature Language="F#" Value="static member ItemsControlFromItemContainer : System.Windows.DependencyObject -&gt; System.Windows.Controls.ItemsControl" Usage="System.Windows.Controls.ItemsControl.ItemsControlFromItemContainer container" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemsControl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="container">Element kontenera, aby zwrócić <see cref="T:System.Windows.Controls.ItemsControl" /> dla.</param>
        <summary>Zwraca <see cref="T:System.Windows.Controls.ItemsControl" /> , który jest właścicielem elementu w określonym kontenerze.</summary>
        <returns><see cref="T:System.Windows.Controls.ItemsControl" /> , Który jest właścicielem elementu w określonym kontenerze.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="ItemsPanel">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ItemsPanelTemplate ItemsPanel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ItemsPanelTemplate ItemsPanel" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemsPanel" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemsPanel As ItemsPanelTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ItemsPanelTemplate ^ ItemsPanel { System::Windows::Controls::ItemsPanelTemplate ^ get(); void set(System::Windows::Controls::ItemsPanelTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemsPanel : System.Windows.Controls.ItemsPanelTemplate with get, set" Usage="System.Windows.Controls.ItemsControl.ItemsPanel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemsPanelTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szablon definiujący panel, który kontroluje układ elementów.</summary>
        <value><see cref="T:System.Windows.Controls.ItemsPanelTemplate" /> Definiujący panelu układu elementów na użytek. Wartością domyślną dla <see cref="T:System.Windows.Controls.ItemsControl" /> jest <see cref="T:System.Windows.Controls.ItemsPanelTemplate" /> określający <see cref="T:System.Windows.Controls.StackPanel" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać <xref:System.Windows.Controls.ListBox>, domyślnie <xref:System.Windows.Controls.ItemsPanelTemplate> Określa <xref:System.Windows.Controls.VirtualizingStackPanel>. Aby uzyskać <xref:System.Windows.Controls.MenuItem>, domyślnie używa <xref:System.Windows.Controls.WrapPanel>. Aby uzyskać <xref:System.Windows.Controls.Primitives.StatusBar>, domyślnie używa <xref:System.Windows.Controls.DockPanel>.  
  
 Wpływ na układ elementów w <xref:System.Windows.Controls.ItemsControl>, ta właściwość jest używana do określenia <xref:System.Windows.Controls.ItemsPanelTemplate>.  
  
 <xref:System.Windows.Controls.ItemsControl> Zapewnia dużą elastyczność dostosowywania wizualne i zawiera wiele właściwości Tworzenie szablonów i stylów. Możesz użyć <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> właściwości lub <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> właściwości do ustawienia stylu wpłynie na wygląd elementów, które zawierają elementy danych. Na przykład w przypadku <xref:System.Windows.Controls.ListBox>, wygenerowany kontenery są <xref:System.Windows.Controls.ListBoxItem> kontroluje; dla <xref:System.Windows.Controls.ComboBox>, są one <xref:System.Windows.Controls.ComboBoxItem> kontrolki. Jeśli używasz grupowania na kontrolki, możesz użyć <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> lub <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> właściwości. Aby określić wizualizacji obiektów danych, użyj <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> lub <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> właściwości. Aby uzyskać więcej informacji, zobacz [Przegląd Szablonowanie danych](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="dependencyPropertyInfo_ItemsPanel"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ItemsControl.ItemsPanelProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Aby utworzyć poziomej <xref:System.Windows.Controls.ListBox>, można utworzyć szablon, który określa poziomy <xref:System.Windows.Controls.StackPanel> i ustaw go jako <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> właściwości. W poniższym przykładzie przedstawiono <xref:System.Windows.Controls.ListBox> <xref:System.Windows.Style> tworząca poziomej <xref:System.Windows.Controls.ListBox>.  
  
 [!code-xaml[StylingIntroSample_snippet#ItemsPanel](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#itemspanel)] 
  
 W poniższym przykładzie użyto <xref:System.Windows.Controls.ControlTemplate> do utworzenia poziomej <xref:System.Windows.Controls.ListBox> , ma zaokrąglone rogi. W tym przykładzie zamiast ustawiać <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> właściwości, tak jak w poprzednim przykładzie, poziomej <xref:System.Windows.Controls.StackPanel> jest określona w ramach <xref:System.Windows.Controls.ControlTemplate>. <xref:System.Windows.Controls.Panel.IsItemsHost%2A> Właściwość jest ustawiona na `true` na <xref:System.Windows.Controls.StackPanel>, co oznacza, że wygenerowane elementy powinny przejść w panelu. W przypadku określenia w ten sposób <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> nie może być zastąpiony użytkownika formantu bez użycia <xref:System.Windows.Controls.ControlTemplate>. W związku z tym tylko tym jeśli wiesz, że nie należy na panelu, aby zastąpić bez użycia szablonu.  
  
 [!code-xaml[StylingIntroSnippet#ListBoxCT](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSnippet/CS/window1.xaml#listboxct)]   
  
 Alternatywnie można wykonać następujące polecenie, aby osiągnąć takie same wyniki. W tym przypadku <xref:System.Windows.Controls.ItemsPresenter> tworzy panelu układu elementów, w oparciu o co określoną przez <xref:System.Windows.Controls.ItemsPanelTemplate>.  
  
 [!code-xaml[StyleOvw01#ItemsPanelTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#itemspaneltemplate)]   
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160010">Wprowadzenie do przykładowych szablonów i stylów</related>
      </Docs>
    </Member>
    <Member MemberName="ItemsPanelProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemsPanelProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemsPanelProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemsPanelProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemsPanelProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemsPanelProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemsPanelProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemsPanelProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsSource">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ItemsSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerable ItemsSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemsSource" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemsSource As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IEnumerable ^ ItemsSource { System::Collections::IEnumerable ^ get(); void set(System::Collections::IEnumerable ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemsSource : System.Collections.IEnumerable with get, set" Usage="System.Windows.Controls.ItemsControl.ItemsSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję używaną do generowania zawartości <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value>Kolekcja, która służy do generowania zawartości <see cref="T:System.Windows.Controls.ItemsControl" />. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Content Model:** Ta właściwość może służyć do dodawania elementów do <xref:System.Windows.Controls.ItemsControl>.  
  
 Typowym scenariuszem jest użycie <xref:System.Windows.Controls.ItemsControl> takich jak <xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ListView>, lub <xref:System.Windows.Controls.TreeView> do wyświetlenia zbierania danych lub powiązać <xref:System.Windows.Controls.ItemsControl> do obiektu kolekcji. Aby powiązać <xref:System.Windows.Controls.ItemsControl> do obiektu kolekcji, użyj <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> właściwości. Należy pamiętać, że <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> obsługuje właściwość <xref:System.Windows.Data.BindingMode.OneWay> powiązanie domyślnie.  
  
 Gdy <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> ustawiono właściwość <xref:System.Windows.Controls.ItemsControl.Items%2A> kolekcji składa się tylko do odczytu i stałym rozmiarze.  
  
 Gdy <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> jest w użyciu, ustawienie dla właściwości `null` spowoduje usunięcie kolekcji i przywrócenie użycia <xref:System.Windows.Controls.ItemsControl.Items%2A>, który będzie stanowić pustego <xref:System.Windows.Controls.ItemCollection>. Gdy <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> jest nieużywany, wartość tej właściwości jest `null`i ustawieniem dla niego `null` nie ma wpływu.  
  
> [!NOTE]
>  W większości przypadków nie trzeba implementować własne kolekcje. Zamiast tego Rozważ użycie <xref:System.Collections.ObjectModel.ObservableCollection%601> lub innych istniejących kolekcji. Aby uzyskać więcej informacji, zobacz "Kolekcji obiektów używane jako powiązania źródło" w [Przegląd wiązanie źródeł](~/docs/framework/wpf/data/binding-sources-overview.md).  
  
<a name="xamlAttributeUsage_ItemsSource"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object ItemsSource="bindingDeclaration"/>  
```  
  
<a name="xamlValues_ItemsSource"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *bindingDeclaration*  
 A <xref:System.Windows.Data.Binding> deklaracji. Zobacz [— rozszerzenie znaczników powiązania](~/docs/framework/wpf/advanced/binding-markup-extension.md) Aby uzyskać więcej informacji.  
  
<a name="dependencyPropertyInfo_ItemsSource"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ItemsControl.ItemsSourceProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsSourceProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemsSourceProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemsSourceProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemsSourceProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemsSourceProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemsSourceProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemsSourceProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemsSourceProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemStringFormat">
      <MemberSignature Language="C#" Value="public string ItemStringFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ItemStringFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemStringFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemStringFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ItemStringFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemStringFormat : string with get, set" Usage="System.Windows.Controls.ItemsControl.ItemStringFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia złożony ciąg, który określa sposób formatowania elementów w <see cref="T:System.Windows.Controls.ItemsControl" /> jeśli są one wyświetlane jako ciągi.</summary>
        <value>Złożony ciąg, który określa sposób formatowania elementów w <see cref="T:System.Windows.Controls.ItemsControl" /> jeśli są one wyświetlane jako ciągi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ItemsControl.ItemStringFormat%2A> można wstępnie zdefiniowanych, złożonych lub niestandardowy ciąg formatu. Aby uzyskać więcej informacji na temat ciągów formatów, zobacz [typy formatowania](~/docs/standard/base-types/formatting-types.md). Jeśli ustawisz <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> lub <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> z <xref:System.Windows.Controls.ItemsControl>, <xref:System.Windows.Controls.ItemsControl.ItemStringFormat%2A> właściwość jest ignorowana.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Windows.Controls.ItemsControl.ItemStringFormat%2A> do określania formatu listy <xref:System.DateTime> obiektów.  
  
 [!code-xaml[ContentStringSnippets#ItemsControl](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentStringSnippets/CSharp/Window1.xaml#itemscontrol)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemStringFormatProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemStringFormatProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemStringFormatProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemStringFormatProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemStringFormatProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemStringFormatProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemStringFormatProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemStringFormatProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTemplate">
      <MemberSignature Language="C#" Value="public System.Windows.DataTemplate ItemTemplate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DataTemplate ItemTemplate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemTemplate As DataTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DataTemplate ^ ItemTemplate { System::Windows::DataTemplate ^ get(); void set(System::Windows::DataTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemTemplate : System.Windows.DataTemplate with get, set" Usage="System.Windows.Controls.ItemsControl.ItemTemplate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DataTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.DataTemplate" /> używany do wyświetlania każdego elementu.</summary>
        <value>A <see cref="T:System.Windows.DataTemplate" /> określający wizualizacji obiektów danych. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> do określenia wizualizacji obiektów danych. Jeśli usługi <xref:System.Windows.Controls.ItemsControl> jest powiązana z kolekcją obiektów i nie są oferowane instrukcje wyświetlania określonego przy użyciu <xref:System.Windows.DataTemplate>, wynikowy [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] każdego elementu jest reprezentacją ciągu każdego obiektu w kolekcji źródłowej.  
  
 Po ustawieniu <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> na <xref:System.Windows.Controls.ItemsControl>, [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] jest generowany w następujący sposób (przy użyciu <xref:System.Windows.Controls.ListBox> jako przykład):  
  
1.  Podczas generowania zawartości <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> inicjuje żądanie <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A> można utworzyć kontenera dla każdego elementu danych. Aby uzyskać <xref:System.Windows.Controls.ListBox>, kontener jest <xref:System.Windows.Controls.ListBoxItem>. Ponownie wywołuje generator <xref:System.Windows.Controls.ItemsControl> przygotowanie kontenera.  
  
2.  Część przygotowanie polega na kopiowaniu <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> z <xref:System.Windows.Controls.ListBox> jako <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> z <xref:System.Windows.Controls.ListBoxItem>.  
  
3.  Podobnie jak wszystkie <xref:System.Windows.Controls.ContentControl> typów <xref:System.Windows.Controls.ControlTemplate> z <xref:System.Windows.Controls.ListBoxItem> zawiera <xref:System.Windows.Controls.ContentPresenter>. Po zastosowaniu szablonu tworzy <xref:System.Windows.Controls.ContentPresenter> którego <xref:System.Windows.Controls.ContentPresenter.ContentTemplate%2A> jest powiązany z <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> z <xref:System.Windows.Controls.ListBoxItem>.  
  
4.  Na koniec <xref:System.Windows.Controls.ContentPresenter> ma zastosowanie, <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> z samym sobą, i który tworzy [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  
  
 Jeśli masz więcej niż jedną <xref:System.Windows.DataTemplate> zdefiniowane i chcesz podać logikę w celu programowego. Wybieranie i stosowanie <xref:System.Windows.DataTemplate>, użyj <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> właściwości.  
  
 <xref:System.Windows.Controls.ItemsControl> Zapewnia dużą elastyczność dostosowywania wizualne i zawiera wiele właściwości Tworzenie szablonów i stylów. Użyj <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> właściwości lub <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> właściwości do ustawienia stylu wpłynie na wygląd elementów, które zawierają elementy danych. Na przykład w przypadku <xref:System.Windows.Controls.ListBox>, wygenerowany kontenery są <xref:System.Windows.Controls.ListBoxItem> kontroluje; dla <xref:System.Windows.Controls.ComboBox>, są one <xref:System.Windows.Controls.ComboBoxItem> kontrolki. Aby mieć wpływ na układ elementów, należy użyć <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> właściwości. Jeśli używasz grupowania na kontrolki, możesz użyć <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> lub <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> właściwości.  
  
 Aby uzyskać więcej informacji, zobacz [Przegląd Szablonowanie danych](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="xamlAttributeUsage_ItemTemplate"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object ItemTemplate=" ResourceExtension TemplateResourceKey"/>  
```  
  
<a name="xamlValues_ItemTemplate"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *ResourceExtension*  
 Jeden z poniższych: [Staticresource — rozszerzenie znaczników](~/docs/framework/wpf/advanced/staticresource-markup-extension.md), lub [dynamicresource — rozszerzenie znaczników](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md). O ile style, samodzielnie zawierają odwołania do potencjalnych odwołania środowiska wykonawczego, takich jak zasoby systemowe lub preferencje użytkownika [staticresource — rozszerzenie znaczników](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) odwołanie do stylu zazwyczaj jest zalecane w przypadku wydajności.  
  
 *TemplateResourceKey*  
 [x: Key — dyrektywa](~/docs/framework/xaml-services/x-key-directive.md) wartość ciągu odwołujące się do szablonu wnioskuje jako zasób.  
  
<a name="dependencyPropertyInfo_ItemTemplate"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ItemsControl.ItemTemplateProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć <xref:System.Windows.DataTemplate> wbudowanego. <xref:System.Windows.DataTemplate> Określa, czy każdy element danych jest wyświetlana jako trzy <xref:System.Windows.Controls.TextBlock> elementów w obrębie <xref:System.Windows.Controls.StackPanel>. W tym przykładzie obiekt danych jest klasę o nazwie `Task`. Należy pamiętać, że każdy <xref:System.Windows.Controls.TextBlock> element w tym szablonie jest powiązana z właściwością `Task` klasy.  
  
 [!code-xaml[DataTemplatingIntro_snip#Inline](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#inline)]  
  
 Jest to bardziej powszechne, aby zdefiniować <xref:System.Windows.DataTemplate> w sekcji zasobów, aby mogło być ono obiekt wielokrotnego użytku, jak w poniższym przykładzie:  
  
 [!code-xaml[DataTemplatingIntro_snip#R1](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r1)]  
[!code-xaml[DataTemplatingIntro_snip#AsResource](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#asresource)]  
[!code-xaml[DataTemplatingIntro_snip#R2](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r2)]  
  
 Teraz możesz używać `myTaskTemplate` jako zasób, jak w poniższym przykładzie:  
  
 [!code-xaml[DataTemplatingIntro_snip#MyTaskTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#mytasktemplate)]  
  
 Aby uzyskać pełny przykład, zobacz [wprowadzenie do próbki Szablonowanie danych](https://go.microsoft.com/fwlink/?LinkID=160009).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" />
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" />
      </Docs>
    </Member>
    <Member MemberName="ItemTemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemTemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemTemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemTemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemTemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemTemplateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemTemplateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemTemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTemplateSelector">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.DataTemplateSelector ItemTemplateSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.DataTemplateSelector ItemTemplateSelector" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemTemplateSelector As DataTemplateSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::DataTemplateSelector ^ ItemTemplateSelector { System::Windows::Controls::DataTemplateSelector ^ get(); void set(System::Windows::Controls::DataTemplateSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemTemplateSelector : System.Windows.Controls.DataTemplateSelector with get, set" Usage="System.Windows.Controls.ItemsControl.ItemTemplateSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.DataTemplateSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia logikę niestandardową dotyczące wybierania szablonu, używany do wyświetlania każdego elementu.</summary>
        <value>Niestandardowy <see cref="T:System.Windows.Controls.DataTemplateSelector" /> obiekt, który zawiera logikę i zwraca <see cref="T:System.Windows.DataTemplate" />. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> do określenia wizualizacji obiektów danych. Jeśli masz więcej niż jeden szablon zdefiniowany i chcesz podać logikę do zwrócenia szablon do użycia, możesz użyć tej właściwości. Należy pamiętać, że ta właściwość jest ignorowana, jeśli <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> jest ustawiona.  
  
 <xref:System.Windows.Controls.ItemsControl> Zapewnia dużą elastyczność dostosowywania wizualne i zawiera wiele właściwości Tworzenie szablonów i stylów. Użyj <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> właściwości lub <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> właściwości do ustawienia stylu wpłynie na wygląd elementów, które zawierają elementy danych. Na przykład w przypadku <xref:System.Windows.Controls.ListBox>, wygenerowany kontenery są <xref:System.Windows.Controls.ListBoxItem> kontroluje; dla <xref:System.Windows.Controls.ComboBox>, są one <xref:System.Windows.Controls.ComboBoxItem> kontrolki. Aby mieć wpływ na układ elementów, należy użyć <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> właściwości. Jeśli używasz grupowania na kontrolki, możesz użyć <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> lub <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> właściwości.  
  
 Aby uzyskać więcej informacji, zobacz [Przegląd Szablonowanie danych](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="xamlAttributeUsage_ItemTemplateSelector"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object ItemTemplateSelector="ResourceExtension SelectorResourceKey"/>  
```  
  
<a name="xamlValues_ItemTemplateSelector"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *ResourceExtension*  
 Jedną z następujących: `StaticResource`, lub `DynamicResource`. O ile style, samodzielnie zawierają odwołania do potencjalnych odwołania środowiska wykonawczego, takich jak zasoby systemowe lub preferencje użytkownika `StaticResource` odwołanie do stylu zazwyczaj jest zalecane w przypadku wydajności.  
  
 *SelectorResourceKey*  
 `x:Key` wartość ciągu, odnoszące się do selektora żądanej jako zasób.  
  
<a name="dependencyPropertyInfo_ItemTemplateSelector"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 W poniższym przykładzie `auctionItemDataTemplateSelector` Nazwa zasobu (odpowiadający `AuctionItemDataTemplateSelector` klasy) jest przypisany do <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> właściwość <xref:System.Windows.Controls.ItemsControl>.  
  
 [!code-xaml[DataTemplateSelector#ItemTemplateSelector](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplateSelector/CSharp/Window1.xaml#itemtemplateselector)]  
  
 W poniższym przykładzie pokazano implementację `AuctionItemDataTemplateSelector` klasy za pomocą zastąpienia z <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> metody:  
  
 [!code-csharp[DataTemplateSelector#DataTemplateSelector](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplateSelector/CSharp/AuctionItemDataTemplateSelector.cs#datatemplateselector)]
 [!code-vb[DataTemplateSelector#DataTemplateSelector](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DataTemplateSelector/visualbasic/auctionitemdatatemplateselector.vb#datatemplateselector)]  
  
 W takim przypadku w ramach <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> metody klasy, jest logikę do zwrócenia odpowiedniego szablonu na podstawie wartości z `SpecialFeatures` właściwość `item` przekazany obiekt. Szablon do zwrócenia zostanie znaleziony w zasoby obejmujące <xref:System.Windows.Window> elementu.  
  
 Po ustawieniu <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> właściwości <xref:System.Windows.Controls.ItemsControl> zostaje skierowany do automatycznie wywołują <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> metody `AuctionItemDataTemplateSelector` dla każdego z elementów w kolekcji, do którego <xref:System.Windows.Controls.ItemsControl> jest powiązany. Wywołanie przekazuje element danych jako obiektu. <xref:System.Windows.DataTemplate> Zwracanym przez metodę jest następnie używany do wyświetlania tego elementu danych.  
  
 Inny przykład, zobacz [Przegląd Szablonowanie danych](~/docs/framework/wpf/data/data-templating-overview.md).  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160009">Wprowadzenie do próbki Szablonowanie danych</related>
      </Docs>
    </Member>
    <Member MemberName="ItemTemplateSelectorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemTemplateSelectorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemTemplateSelectorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemTemplateSelectorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemTemplateSelectorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemTemplateSelectorProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.ItemsControl.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł wyliczający dla podrzędnych logicznego obiektów <see cref="T:System.Windows.Controls.ItemsControl" /> obiektu.</summary>
        <value>Moduł wyliczający dla obiektów podrzędnych logicznego <see cref="T:System.Windows.Controls.ItemsControl" /> obiektu. Wartość domyślna to <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAlternationCountChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAlternationCountChanged (int oldAlternationCount, int newAlternationCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAlternationCountChanged(int32 oldAlternationCount, int32 newAlternationCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnAlternationCountChanged(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAlternationCountChanged (oldAlternationCount As Integer, newAlternationCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAlternationCountChanged(int oldAlternationCount, int newAlternationCount);" />
      <MemberSignature Language="F#" Value="abstract member OnAlternationCountChanged : int * int -&gt; unit&#xA;override this.OnAlternationCountChanged : int * int -&gt; unit" Usage="itemsControl.OnAlternationCountChanged (oldAlternationCount, newAlternationCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldAlternationCount" Type="System.Int32" />
        <Parameter Name="newAlternationCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldAlternationCount">Stara wartość <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" />.</param>
        <param name="newAlternationCount">Nowa wartość <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" />.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayMemberPathChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayMemberPathChanged (string oldDisplayMemberPath, string newDisplayMemberPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayMemberPathChanged(string oldDisplayMemberPath, string newDisplayMemberPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnDisplayMemberPathChanged(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayMemberPathChanged (oldDisplayMemberPath As String, newDisplayMemberPath As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayMemberPathChanged(System::String ^ oldDisplayMemberPath, System::String ^ newDisplayMemberPath);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayMemberPathChanged : string * string -&gt; unit&#xA;override this.OnDisplayMemberPathChanged : string * string -&gt; unit" Usage="itemsControl.OnDisplayMemberPathChanged (oldDisplayMemberPath, newDisplayMemberPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDisplayMemberPath" Type="System.String" />
        <Parameter Name="newDisplayMemberPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldDisplayMemberPath">Stara wartość <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> właściwości.</param>
        <param name="newDisplayMemberPath">Nowa wartość <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> właściwości.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGroupStyleSelectorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnGroupStyleSelectorChanged (System.Windows.Controls.GroupStyleSelector oldGroupStyleSelector, System.Windows.Controls.GroupStyleSelector newGroupStyleSelector);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGroupStyleSelectorChanged(class System.Windows.Controls.GroupStyleSelector oldGroupStyleSelector, class System.Windows.Controls.GroupStyleSelector newGroupStyleSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnGroupStyleSelectorChanged(System.Windows.Controls.GroupStyleSelector,System.Windows.Controls.GroupStyleSelector)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGroupStyleSelectorChanged (oldGroupStyleSelector As GroupStyleSelector, newGroupStyleSelector As GroupStyleSelector)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGroupStyleSelectorChanged(System::Windows::Controls::GroupStyleSelector ^ oldGroupStyleSelector, System::Windows::Controls::GroupStyleSelector ^ newGroupStyleSelector);" />
      <MemberSignature Language="F#" Value="abstract member OnGroupStyleSelectorChanged : System.Windows.Controls.GroupStyleSelector * System.Windows.Controls.GroupStyleSelector -&gt; unit&#xA;override this.OnGroupStyleSelectorChanged : System.Windows.Controls.GroupStyleSelector * System.Windows.Controls.GroupStyleSelector -&gt; unit" Usage="itemsControl.OnGroupStyleSelectorChanged (oldGroupStyleSelector, newGroupStyleSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldGroupStyleSelector" Type="System.Windows.Controls.GroupStyleSelector" />
        <Parameter Name="newGroupStyleSelector" Type="System.Windows.Controls.GroupStyleSelector" />
      </Parameters>
      <Docs>
        <param name="oldGroupStyleSelector">Stara wartość <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" /> właściwości.</param>
        <param name="newGroupStyleSelector">Nowa wartość <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" /> właściwości.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemBindingGroupChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemBindingGroupChanged (System.Windows.Data.BindingGroup oldItemBindingGroup, System.Windows.Data.BindingGroup newItemBindingGroup);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemBindingGroupChanged(class System.Windows.Data.BindingGroup oldItemBindingGroup, class System.Windows.Data.BindingGroup newItemBindingGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemBindingGroupChanged(System.Windows.Data.BindingGroup,System.Windows.Data.BindingGroup)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemBindingGroupChanged (oldItemBindingGroup As BindingGroup, newItemBindingGroup As BindingGroup)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemBindingGroupChanged(System::Windows::Data::BindingGroup ^ oldItemBindingGroup, System::Windows::Data::BindingGroup ^ newItemBindingGroup);" />
      <MemberSignature Language="F#" Value="abstract member OnItemBindingGroupChanged : System.Windows.Data.BindingGroup * System.Windows.Data.BindingGroup -&gt; unit&#xA;override this.OnItemBindingGroupChanged : System.Windows.Data.BindingGroup * System.Windows.Data.BindingGroup -&gt; unit" Usage="itemsControl.OnItemBindingGroupChanged (oldItemBindingGroup, newItemBindingGroup)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemBindingGroup" Type="System.Windows.Data.BindingGroup" />
        <Parameter Name="newItemBindingGroup" Type="System.Windows.Data.BindingGroup" />
      </Parameters>
      <Docs>
        <param name="oldItemBindingGroup">Stara wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />.</param>
        <param name="newItemBindingGroup">Nowa wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemContainerStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemContainerStyleChanged (System.Windows.Style oldItemContainerStyle, System.Windows.Style newItemContainerStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemContainerStyleChanged(class System.Windows.Style oldItemContainerStyle, class System.Windows.Style newItemContainerStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemContainerStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemContainerStyleChanged (oldItemContainerStyle As Style, newItemContainerStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemContainerStyleChanged(System::Windows::Style ^ oldItemContainerStyle, System::Windows::Style ^ newItemContainerStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnItemContainerStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnItemContainerStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="itemsControl.OnItemContainerStyleChanged (oldItemContainerStyle, newItemContainerStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemContainerStyle" Type="System.Windows.Style" />
        <Parameter Name="newItemContainerStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldItemContainerStyle">Stara wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> właściwości.</param>
        <param name="newItemContainerStyle">Nowa wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> właściwości.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemContainerStyleSelectorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemContainerStyleSelectorChanged (System.Windows.Controls.StyleSelector oldItemContainerStyleSelector, System.Windows.Controls.StyleSelector newItemContainerStyleSelector);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemContainerStyleSelectorChanged(class System.Windows.Controls.StyleSelector oldItemContainerStyleSelector, class System.Windows.Controls.StyleSelector newItemContainerStyleSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemContainerStyleSelectorChanged(System.Windows.Controls.StyleSelector,System.Windows.Controls.StyleSelector)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemContainerStyleSelectorChanged (oldItemContainerStyleSelector As StyleSelector, newItemContainerStyleSelector As StyleSelector)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemContainerStyleSelectorChanged(System::Windows::Controls::StyleSelector ^ oldItemContainerStyleSelector, System::Windows::Controls::StyleSelector ^ newItemContainerStyleSelector);" />
      <MemberSignature Language="F#" Value="abstract member OnItemContainerStyleSelectorChanged : System.Windows.Controls.StyleSelector * System.Windows.Controls.StyleSelector -&gt; unit&#xA;override this.OnItemContainerStyleSelectorChanged : System.Windows.Controls.StyleSelector * System.Windows.Controls.StyleSelector -&gt; unit" Usage="itemsControl.OnItemContainerStyleSelectorChanged (oldItemContainerStyleSelector, newItemContainerStyleSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemContainerStyleSelector" Type="System.Windows.Controls.StyleSelector" />
        <Parameter Name="newItemContainerStyleSelector" Type="System.Windows.Controls.StyleSelector" />
      </Parameters>
      <Docs>
        <param name="oldItemContainerStyleSelector">Stara wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> właściwości.</param>
        <param name="newItemContainerStyleSelector">Nowa wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> właściwości.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemsChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemsChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemsChanged (e As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemsChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnItemsChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit&#xA;override this.OnItemsChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="itemsControl.OnItemsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Informacje o zmianie.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.Controls.ItemsControl.Items" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsPanelChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemsPanelChanged (System.Windows.Controls.ItemsPanelTemplate oldItemsPanel, System.Windows.Controls.ItemsPanelTemplate newItemsPanel);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemsPanelChanged(class System.Windows.Controls.ItemsPanelTemplate oldItemsPanel, class System.Windows.Controls.ItemsPanelTemplate newItemsPanel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemsPanelChanged(System.Windows.Controls.ItemsPanelTemplate,System.Windows.Controls.ItemsPanelTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemsPanelChanged (oldItemsPanel As ItemsPanelTemplate, newItemsPanel As ItemsPanelTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemsPanelChanged(System::Windows::Controls::ItemsPanelTemplate ^ oldItemsPanel, System::Windows::Controls::ItemsPanelTemplate ^ newItemsPanel);" />
      <MemberSignature Language="F#" Value="abstract member OnItemsPanelChanged : System.Windows.Controls.ItemsPanelTemplate * System.Windows.Controls.ItemsPanelTemplate -&gt; unit&#xA;override this.OnItemsPanelChanged : System.Windows.Controls.ItemsPanelTemplate * System.Windows.Controls.ItemsPanelTemplate -&gt; unit" Usage="itemsControl.OnItemsPanelChanged (oldItemsPanel, newItemsPanel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemsPanel" Type="System.Windows.Controls.ItemsPanelTemplate" />
        <Parameter Name="newItemsPanel" Type="System.Windows.Controls.ItemsPanelTemplate" />
      </Parameters>
      <Docs>
        <param name="oldItemsPanel">Stara wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> właściwości.</param>
        <param name="newItemsPanel">Nowa wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> właściwości.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsSourceChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemsSourceChanged (System.Collections.IEnumerable oldValue, System.Collections.IEnumerable newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemsSourceChanged(class System.Collections.IEnumerable oldValue, class System.Collections.IEnumerable newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemsSourceChanged(System.Collections.IEnumerable,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemsSourceChanged (oldValue As IEnumerable, newValue As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemsSourceChanged(System::Collections::IEnumerable ^ oldValue, System::Collections::IEnumerable ^ newValue);" />
      <MemberSignature Language="F#" Value="abstract member OnItemsSourceChanged : System.Collections.IEnumerable * System.Collections.IEnumerable -&gt; unit&#xA;override this.OnItemsSourceChanged : System.Collections.IEnumerable * System.Collections.IEnumerable -&gt; unit" Usage="itemsControl.OnItemsSourceChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Collections.IEnumerable" />
        <Parameter Name="newValue" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="oldValue">Stara wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> właściwości.</param>
        <param name="newValue">Nowa wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> właściwości.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemStringFormatChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemStringFormatChanged (string oldItemStringFormat, string newItemStringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemStringFormatChanged(string oldItemStringFormat, string newItemStringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemStringFormatChanged(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemStringFormatChanged (oldItemStringFormat As String, newItemStringFormat As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemStringFormatChanged(System::String ^ oldItemStringFormat, System::String ^ newItemStringFormat);" />
      <MemberSignature Language="F#" Value="abstract member OnItemStringFormatChanged : string * string -&gt; unit&#xA;override this.OnItemStringFormatChanged : string * string -&gt; unit" Usage="itemsControl.OnItemStringFormatChanged (oldItemStringFormat, newItemStringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemStringFormat" Type="System.String" />
        <Parameter Name="newItemStringFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldItemStringFormat">Stara wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" /> właściwości.</param>
        <param name="newItemStringFormat">Nowa wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" /> właściwości.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemTemplateChanged (System.Windows.DataTemplate oldItemTemplate, System.Windows.DataTemplate newItemTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemTemplateChanged(class System.Windows.DataTemplate oldItemTemplate, class System.Windows.DataTemplate newItemTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemTemplateChanged(System.Windows.DataTemplate,System.Windows.DataTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemTemplateChanged (oldItemTemplate As DataTemplate, newItemTemplate As DataTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemTemplateChanged(System::Windows::DataTemplate ^ oldItemTemplate, System::Windows::DataTemplate ^ newItemTemplate);" />
      <MemberSignature Language="F#" Value="abstract member OnItemTemplateChanged : System.Windows.DataTemplate * System.Windows.DataTemplate -&gt; unit&#xA;override this.OnItemTemplateChanged : System.Windows.DataTemplate * System.Windows.DataTemplate -&gt; unit" Usage="itemsControl.OnItemTemplateChanged (oldItemTemplate, newItemTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemTemplate" Type="System.Windows.DataTemplate" />
        <Parameter Name="newItemTemplate" Type="System.Windows.DataTemplate" />
      </Parameters>
      <Docs>
        <param name="oldItemTemplate">Stary <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" /> wartości właściwości.</param>
        <param name="newItemTemplate">Nowy <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" /> wartości właściwości.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemTemplateSelectorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemTemplateSelectorChanged (System.Windows.Controls.DataTemplateSelector oldItemTemplateSelector, System.Windows.Controls.DataTemplateSelector newItemTemplateSelector);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemTemplateSelectorChanged(class System.Windows.Controls.DataTemplateSelector oldItemTemplateSelector, class System.Windows.Controls.DataTemplateSelector newItemTemplateSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemTemplateSelectorChanged(System.Windows.Controls.DataTemplateSelector,System.Windows.Controls.DataTemplateSelector)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemTemplateSelectorChanged (oldItemTemplateSelector As DataTemplateSelector, newItemTemplateSelector As DataTemplateSelector)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemTemplateSelectorChanged(System::Windows::Controls::DataTemplateSelector ^ oldItemTemplateSelector, System::Windows::Controls::DataTemplateSelector ^ newItemTemplateSelector);" />
      <MemberSignature Language="F#" Value="abstract member OnItemTemplateSelectorChanged : System.Windows.Controls.DataTemplateSelector * System.Windows.Controls.DataTemplateSelector -&gt; unit&#xA;override this.OnItemTemplateSelectorChanged : System.Windows.Controls.DataTemplateSelector * System.Windows.Controls.DataTemplateSelector -&gt; unit" Usage="itemsControl.OnItemTemplateSelectorChanged (oldItemTemplateSelector, newItemTemplateSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemTemplateSelector" Type="System.Windows.Controls.DataTemplateSelector" />
        <Parameter Name="newItemTemplateSelector" Type="System.Windows.Controls.DataTemplateSelector" />
      </Parameters>
      <Docs>
        <param name="oldItemTemplateSelector">Stara wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" /> właściwości.</param>
        <param name="newItemTemplateSelector">Nowa wartość <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" /> właściwości.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="itemsControl.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Informacje o zdarzeniu.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.UIElement.KeyDown" /> odebraniu zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected override void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="itemsControl.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Informacje o zdarzeniu.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.UIElement.TextInput" /> odebraniu zdarzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected virtual void PrepareContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void PrepareContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub PrepareContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void PrepareContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member PrepareContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit&#xA;override this.PrepareContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="itemsControl.PrepareContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="element">Element służący do wyświetlania określonego elementu.</param>
        <param name="item">Określony element.</param>
        <summary>Przygotowuje określony element, aby wyświetlić określony element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trwa przygotowywanie elementu może obejmować stosowanie stylów, ustawienia powiązania i tak dalej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldApplyItemContainerStyle">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldApplyItemContainerStyle (System.Windows.DependencyObject container, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldApplyItemContainerStyle(class System.Windows.DependencyObject container, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ShouldApplyItemContainerStyle(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldApplyItemContainerStyle (container As DependencyObject, item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldApplyItemContainerStyle(System::Windows::DependencyObject ^ container, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member ShouldApplyItemContainerStyle : System.Windows.DependencyObject * obj -&gt; bool&#xA;override this.ShouldApplyItemContainerStyle : System.Windows.DependencyObject * obj -&gt; bool" Usage="itemsControl.ShouldApplyItemContainerStyle (container, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="container">Element kontenera.</param>
        <param name="item">Element zainteresowania.</param>
        <summary>Zwraca wartość wskazującą, czy zastosować styl z <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> lub <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> właściwość element kontenera określonego elementu.</summary>
        <returns>Zawsze <see langword="true" /> dla podstawowej implementacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeGroupStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeGroupStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeGroupStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ShouldSerializeGroupStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeGroupStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeGroupStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeGroupStyle : unit -&gt; bool" Usage="itemsControl.ShouldSerializeGroupStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy procesy serializacji należy serializować wartość <see cref="P:System.Windows.Controls.ItemsControl.GroupStyle" /> właściwości.</summary>
        <returns><see langword="true" /> Jeśli <see cref="P:System.Windows.Controls.ItemsControl.GroupStyle" /> wartość właściwości powinna być Zserializowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeItems">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeItems ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ShouldSerializeItems" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeItems () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeItems();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeItems : unit -&gt; bool" Usage="itemsControl.ShouldSerializeItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy procesy serializacji należy serializować wartość <see cref="P:System.Windows.Controls.ItemsControl.Items" /> właściwości.</summary>
        <returns><see langword="true" /> Jeśli <see cref="P:System.Windows.Controls.ItemsControl.Items" /> wartość właściwości powinna być Zserializowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.Clear">
      <MemberSignature Language="C#" Value="void IContainItemStorage.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IContainItemStorage.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.Clear() = System::Windows::Controls::Primitives::IContainItemStorage::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie powiązania właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue">
      <MemberSignature Language="C#" Value="void IContainItemStorage.ClearItemValue (object item, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(object item, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#ClearItemValue(System.Object,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Sub ClearItemValue (item As Object, dp As DependencyProperty) Implements IContainItemStorage.ClearItemValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(System::Object ^ item, System::Windows::DependencyProperty ^ dp) = System::Windows::Controls::Primitives::IContainItemStorage::ClearItemValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(System.Object,System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">Skojarzony element.</param>
        <param name="dp">Właściwości skojarzonej.</param>
        <summary>Usuwa skojarzenie określonego elementu i właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.ClearValue">
      <MemberSignature Language="C#" Value="void IContainItemStorage.ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Sub ClearValue (dp As DependencyProperty) Implements IContainItemStorage.ClearValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(System::Windows::DependencyProperty ^ dp) = System::Windows::Controls::Primitives::IContainItemStorage::ClearValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwości do usunięcia.</param>
        <summary>Usuwa określoną właściwość z wszystkie listy właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue">
      <MemberSignature Language="C#" Value="object IContainItemStorage.ReadItemValue (object item, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(object item, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#ReadItemValue(System.Object,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Function ReadItemValue (item As Object, dp As DependencyProperty) As Object Implements IContainItemStorage.ReadItemValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(System::Object ^ item, System::Windows::DependencyProperty ^ dp) = System::Windows::Controls::Primitives::IContainItemStorage::ReadItemValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(System.Object,System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">Element, który ma określony jako wartość właściwości skojarzone z nią.</param>
        <param name="dp">Właściwość o wartości do zwrócenia.</param>
        <summary>Zwraca wartość określonej właściwości, który jest skojarzony z określonym elementem.</summary>
        <returns>Wartość określonej właściwości, który jest skojarzony z określonym elementem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue">
      <MemberSignature Language="C#" Value="void IContainItemStorage.StoreItemValue (object item, System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(object item, class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#StoreItemValue(System.Object,System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub StoreItemValue (item As Object, dp As DependencyProperty, value As Object) Implements IContainItemStorage.StoreItemValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(System::Object ^ item, System::Windows::DependencyProperty ^ dp, System::Object ^ value) = System::Windows::Controls::Primitives::IContainItemStorage::StoreItemValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(System.Object,System.Windows.DependencyProperty,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">Element do skojarzenia z wartości i właściwości.</param>
        <param name="dp">Właściwość, która jest skojarzona z określonego elementu.</param>
        <param name="value">Wartość właściwości skojarzonej.</param>
        <summary>Przechowuje określonej właściwości i wartości i kojarzy je z określonego elementu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do dodania jako element podrzędny.</param>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Tekst, aby dodać.</param>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="itemsControl.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Udostępnia reprezentację ciągu <see cref="T:System.Windows.Controls.ItemsControl" /> obiektu.</summary>
        <returns>Ciąg reprezentujący obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
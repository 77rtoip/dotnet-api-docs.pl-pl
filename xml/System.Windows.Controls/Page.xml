<Type Name="Page" FullName="System.Windows.Controls.Page">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d2b2f547328a5918908d2949cdc123c74c5786fc" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32694922" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Page : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits FrameworkElement&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Windows::FrameworkElement, System::Windows::Markup::IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Content")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Hermetyzuje strony zawartości, która może być przejście i hostowana przez Windows Internet Explorer <see cref="T:System.Windows.Navigation.NavigationWindow" />, i <see cref="T:System.Windows.Controls.Frame" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page> hermetyzuje strony zawartości, która może zostać przesłane i ma następujące elementy członkowskie klucza:  
  
-   **Zarządzanie okresem istnienia**: <xref:System.Windows.Controls.Page.KeepAlive%2A>.  
  
-   **Nawigacji**: <xref:System.Windows.Controls.Page.NavigationService%2A>.  
  
-   **Wygląd**: <xref:System.Windows.Controls.Page.Background%2A>, <xref:System.Windows.Controls.Page.Content%2A>, <xref:System.Windows.Controls.Page.FontFamily%2A>, <xref:System.Windows.Controls.Page.FontSize%2A>, <xref:System.Windows.Controls.Page.Foreground%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>, <xref:System.Windows.Controls.Page.Template%2A>, <xref:System.Windows.Controls.Page.Title%2A>.  
  
-   **Host wygląd okna**: <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowTitle%2A>.  
  
 Strona można zdefiniować przy użyciu znaczników, znaczników i kodu powiązanego lub kodu. Strona jest preferowany sposób zawartość pakietu do nawigacji, z następujących powodów:  
  
-   Jest łatwy do definiowania, ponowne użycie i zarządzania nimi.  
  
-   Można uzyskać dostęp i używać <xref:System.Windows.Navigation.NavigationService> przejście, które do niego.  
  
-   Można zmienić, tytuł, szerokości, wysokości i nawigacja [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] okna hosta (<xref:System.Windows.Controls.Page.WindowTitle%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>).  
  
-   Ma wsparcia projektanta w [!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)].  
  
 Strona może być obsługiwany z <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, lub z poziomu przeglądarki. Ma być obsługiwana strona może być:  
  
-   Bezpośrednie podrzędnym <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, lub <xref:System.Windows.Controls.Frame> element [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
-   Wystąpienie zostało utworzone i Ustaw jako wartość `Content` właściwość <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, i <xref:System.Windows.Controls.Frame>.  
  
-   Ustaw jako [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] źródło `Source` właściwości albo <xref:System.Windows.Navigation.NavigationWindow> lub <xref:System.Windows.Controls.Frame>.  
  
-   Ustaw jako <xref:System.Windows.Application.StartupUri%2A> w autonomicznej aplikacji.  
  
-   Ustaw jako <xref:System.Windows.Application.StartupUri%2A> w [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].  
  
 Zwykle aplikacja ma dwa lub więcej stron, które można nawigować między następującymi metodami:  
  
-   Deklaratywnie przy użyciu <xref:System.Windows.Documents.Hyperlink>.  
  
-   Programowo przy użyciu <xref:System.Windows.Navigation.NavigationService>.  
  
-   Wizualne, używając nawigacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] hosta, w tym [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], <xref:System.Windows.Navigation.NavigationWindow>, i <xref:System.Windows.Controls.Frame>.  
  
 Strukturalne nawigacji za pomocą funkcji strony (<xref:System.Windows.Navigation.PageFunction%601>), zobacz [strukturalnych omówienie nawigacji](~/docs/framework/wpf/app-development/structured-navigation-overview.md) i [— omówienie topologii nawigacji](~/docs/framework/wpf/app-development/navigation-topologies-overview.md).  
  
 Właściwości zależności dla tego formantu może być ustawiona w stylu domyślnym formantu.  Jeśli właściwość jest ustawiona w stylu domyślnym, gdy formant jest wyświetlany w aplikacji właściwość może zmienić ze swojej wartości domyślnej. Domyślny styl jest określana, przez które kompozycji pulpitu jest używana, gdy aplikacja jest uruchomiona.  Aby uzyskać więcej informacji, zobacz [domyślnej kompozycji WPF](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak standardowe strony jest zdefiniowane przy użyciu tylko kod znaczników:  
  
 [!code-xaml[PageSnippets#MarkupPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupPage.xaml#markuppagemarkup)]  
  
 W poniższym przykładzie przedstawiono sposób standardowe strony jest definiowana za pomocą tylko kodu:  
  
 [!code-csharp[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/CodePage.cs#codepagecodebehind)]
 [!code-vb[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/codepage.vb#codepagecodebehind)]  
  
 W poniższym przykładzie pokazano, jak standardowe strony jest zdefiniowane przy użyciu kombinacji znaczników i związane z kodem.  
  
 [!code-xaml[PageSnippets#MarkupAndCodeBehindPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml#markupandcodebehindpagemarkup)]  
  
 [!code-csharp[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml.cs#markupandcodebehindpagecodebehind)]
 [!code-vb[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/markupandcodebehindpage.xaml.vb#markupandcodebehindpagecodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Navigation.PageFunction`1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Controls.Page" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Controls.Page> jest nie jest aktywne (zobacz <xref:System.Windows.Controls.Page.KeepAlive%2A>), musi on implementować konstruktora domyślnego, aby umożliwić [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] do utworzenia nowego wystąpienia gdy przejście na spód lub przesyłane historii nawigacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">Rozmiar układać elementy podrzędne.</param>
        <summary>Rozmieszcza zawartość (elementy podrzędne) <see cref="T:System.Windows.Controls.Page" />.</summary>
        <returns>A <see cref="T:System.Windows.Size" /> reprezentujący uszeregowanych rozmiar strony.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tło <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.Brush" /> Który <see cref="T:System.Windows.Controls.Page" /> używany do rysowania tła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageBackground"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.BackgroundProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.Page.Background" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zawartość <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Obiekt, który zawiera zawartość <see cref="T:System.Windows.Controls.Page" />. Wartość domyślna to <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Controls.Page> może zawierać tylko jeden podrzędny element. Wszystkie elementy na <xref:System.Windows.Controls.Page> musi mieć elementów podrzędnych tego elementu. Zwykle zawartość <xref:System.Windows.Controls.Page> hostuje elementu układu — takie jak <xref:System.Windows.Controls.Grid>, <xref:System.Windows.Controls.StackPanel>, i <xref:System.Windows.Controls.DockPanel>— obsługujące zawartość <xref:System.Windows.Controls.Page>.  
  
<a name="dependencyPropertyInfo_PageContent"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.ContentProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.Page.Content" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font, Modifiability=System.Windows.Modifiability.Unmodifiable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę rodziny określonej czcionki.</summary>
        <value>A <see cref="T:System.Windows.Media.FontFamily" /> czyli rodzinę czcionek zawartości <see cref="T:System.Windows.Controls.Page" />. Wartość domyślna to <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageFontFamily"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.FontFamilyProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.Page.FontFamily" /> właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator <xref:System.Windows.Controls.Page.FontFamily%2A> właściwości zależności.  
  
   
  
## Examples  
 [Przegląd właściwości zależności](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar czcionki.</summary>
        <value>Rozmiar czcionki dla zawartości <see cref="T:System.Windows.Controls.Page" />. Wartość domyślna to <see cref="P:System.Windows.SystemFonts.MessageFontSize" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar czcionki musi być dodatnią liczba i w zakresie <xref:System.Windows.SystemFonts.MessageFontSize%2A>.  
  
<a name="dependencyPropertyInfo_PageFontSize"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.FontSizeProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.Page.FontSize" /> właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator <xref:System.Windows.Controls.Page.FontSize%2A> właściwości zależności.  
  
   
  
## Examples  
 [Przegląd właściwości zależności](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor pierwszego planu dla <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.Brush" /> Który <see cref="T:System.Windows.Controls.Page" /> używa do malowania jego pierwszego planu. Wartość domyślna to <see cref="P:System.Windows.Media.Brushes.Black" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageForeground"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.ForegroundProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.Page.Foreground" /> właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator <xref:System.Windows.Controls.Page.Foreground%2A> właściwości zależności.  
  
   
  
## Examples  
 [Przegląd właściwości zależności](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Windows.Controls.Page" /> wystąpienia jest zachowane w historii nawigacji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Controls.Page" /> wystąpienie jest zachowane w historii nawigacji; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy strona jest najpierw przejście, nowe wystąpienie klasy <xref:System.Windows.Controls.Page> utworzyć klasy. Gdy strona jest opuszczeniu (wstecz lub do przodu), wpis na stronie zostanie dodane do historii nawigacji. Domyślnie wpis nie odwołuje się do obiektu strony. Wpis zawiera pakiet identyfikator uniform resource identifier (URI) dla strony. Gdy wpis dla strony jest przejście do korzystania z historii nawigacji, identyfikatora URI pack służy do utworzenia nowego wystąpienia strony. To zachowanie jest ustawienie domyślne, aby uniknąć nadmiernego pamięć: zachowywanie wystąpień strony może wymagać pamięci, zwłaszcza dla proste ilości zawartości. Ten problem jest rozszerzony faktem, że nie ma żadnego limitu liczba wpisów, które mogą być przechowywane w tle i do przodu stosy historii nawigacji. Z kolei przechowywania pakietu identyfikatorów URI dla stron praktycznie nie ma wpływu na zużycie pamięci.  
  
 Głównego po stronie tworzenia nowych wystąpień strony powoduje, że stan strony nie jest zapamiętanych z jednego wystąpienia strony do innego. W takich przypadkach program Windows Presentation Foundation oferuje kilka technik zapamiętywanie stanu.  
  
 Aby podtrzymywania strony, należy ustawić <xref:System.Windows.Controls.Page.KeepAlive%2A> właściwości `true` (wartość domyślna to `false`).  
  
> [!NOTE]
>  Strony, które są tworzone i przejście przy użyciu tylko kodu (na przykład wywołanie elementu <xref:System.Windows.Navigation.NavigationService.Navigate%2A>), są automatycznie utrzymywane.  
  
 Należy unikać ustawienie <xref:System.Windows.Controls.Page.KeepAlive%2A> do `true` o ile nie trzeba:  
  
-   Jeśli strona jest dużo zawartości, może upłynąć dużo czasu, można utworzyć wystąpienia. Jeśli strona nie jest aktywne, a często przejście strony, kosztów stale uruchamianiu strony może mieć negatywny wpływ na środowisko pracy użytkownika. Jednak z punktu widzenia wydajności należy polegać na domyślne ustawienia i profil wydajności aplikacji; Jeśli testowania identyfikuje strony wraz z czasem obciążenia, które spadną poniżej zakresu, wymagane dla aplikacji, konfigurowaniu stron życiu może być jednym ze sposobów rozwiązania tego problemu.  
  
> [!NOTE]
>  Wpisy dla stron, które są utrzymywane nie zostaną zachowane w historii nawigacji [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] Jeśli użytkownik przechodzi od i do [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]. Tylko pozycje dziennika dla stron, które nie są przechowywane aktywności zostaną zachowane w historii nawigacji.  
  
<a name="dependencyPropertyInfo_PageKeepAlive"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.KeepAliveProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
> [!NOTE]
>  Typem metadanych ta właściwość zależności jest <xref:System.Windows.PropertyMetadata>, a nie <xref:System.Windows.FrameworkPropertyMetadata>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] zachowania wystąpienia <xref:System.Windows.Controls.Page> klasy wielu tego.  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml2)]  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang2)]  
  
 [!code-csharp[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml.cs#setpagekeepalivecodebehind)]
 [!code-vb[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageKeepAliveSnippets/visualbasic/homepage.xaml.vb#setpagekeepalivecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.JournalEntry.KeepAlive" />
      </Docs>
    </Member>
    <Member MemberName="KeepAliveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty KeepAliveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty KeepAliveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeepAliveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ KeepAliveProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.Page.KeepAlive" /> właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator <xref:System.Windows.Controls.Page.KeepAlive%2A> właściwości zależności.  
  
   
  
## Examples  
 [Przegląd właściwości zależności](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca moduł wyliczający dla logicznym podrzędnym elementy <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>
          <see cref="T:System.Collections.IEnumerator" /> Dla elementów podrzędnych logicznej <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Dostępny obszar okna można przekazać jej funkcji podrzędnych.</param>
        <summary>Mierzy elementy podrzędne <see cref="T:System.Windows.Controls.Page" />.</summary>
        <returns>A <see cref="T:System.Windows.Size" /> czyli rzeczywisty rozmiar okna. Metoda może zwracać im większa wartość, w których przypadku nadrzędny może być konieczne dodanie pasków przewijania.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigationService">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.NavigationService NavigationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Navigation.NavigationService NavigationService" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.NavigationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NavigationService As NavigationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Navigation::NavigationService ^ NavigationService { System::Windows::Navigation::NavigationService ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera usługę nawigacji hosta strony używanej do zarządzania nawigacji.</summary>
        <value>
          <see cref="T:System.Windows.Navigation.NavigationService" /> Obiektów, że host strony używa do zarządzania nawigacji, lub <see langword="null" /> Jeśli host nie obsługuje nawigacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Strony może być obsługiwany przez wiele typów hostów, w tym <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>oraz przeglądarkę.  
  
 Strony często muszą ją zintegrować z ich hosta nawigacji, aby zapewnić obsługę nawigacji na stronie. Jednak ponieważ strony może nie wiedzieć, jaki będzie obsługiwać w czasie wykonywania, nie można zintegrować bezpośrednio z jej hosta członków nawigacji, aby to zrobić.  
  
 Zamiast tego można spróbować do używania usługi nawigacji to usługa, która obsługuje nawigacji w stylu przeglądarki i jest hermetyzowany przez <xref:System.Windows.Navigation.NavigationService> klasy. Nie można utworzyć własny <xref:System.Windows.Navigation.NavigationService> wystąpienia, ale. Zamiast tego, takich jak host typy <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, lub przeglądarki tworzyć własne <xref:System.Windows.Navigation.NavigationService> wystąpienie, którego można korzystać z <xref:System.Windows.Controls.Page.NavigationService%2A> właściwości.  
  
 Usługa nawigacji, która jest zwracana z <xref:System.Windows.Controls.Page.NavigationService%2A> właściwość jest wystąpienie <xref:System.Windows.Navigation.NavigationService> klasy, która jest zarządzana przez nawigatora pierwszy w górę drzewa wizualnego. Jeśli nie został znaleziony, `null` jest zwracany, wskazujące na stronie hosta nie obsługuje nawigacji.  
  
> [!NOTE]
>  <xref:System.Windows.Window> Klasa nie obsługuje nawigacji, a nie dostarcza usługi nawigacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak strony Sprawdź, czy jest dostępna usługa nawigacji i, jeśli tak, użyj go, aby wrócić do poprzedniej strony.  
  
 [!code-csharp[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageNavigationServiceSnippets/CSharp/HomePage.xaml.cs#getpagenavigationservicecodebehind)]
 [!code-vb[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageNavigationServiceSnippets/visualbasic/homepage.xaml.vb#getpagenavigationservicecodebehind)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTemplateChanged (oldTemplate As ControlTemplate, newTemplate As ControlTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTemplateChanged(System::Windows::Controls::ControlTemplate ^ oldTemplate, System::Windows::Controls::ControlTemplate ^ newTemplate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">Starego szablonu.</param>
        <param name="newTemplate">Nowy szablon.</param>
        <summary>Wywoływane, gdy szablon <see cref="T:System.Windows.Controls.Page" /> zmiany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Windows.Controls.Control.OnTemplateChanged%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Page.Template" />
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Element nadrzędny poprzedniej. Ustaw <see langword="null" /> Jeśli <see cref="T:System.Windows.DependencyObject" /> nie miał poprzedniej nadrzędnej.</param>
        <summary>Wywoływane, gdy element nadrzędny <see cref="T:System.Windows.Controls.Page" /> zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.UIElement.OnVisualParentChanged%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie jest nadrzędną <see cref="T:System.Windows.Window" /> ani <see cref="T:System.Windows.Controls.Frame" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeShowsNavigationUI ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeShowsNavigationUI() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeShowsNavigationUI () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeShowsNavigationUI();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Klasy pochodne określić zachowanie serializacji umożliwia <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" /> właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli zawartość powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTitle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Klasy pochodne określić zachowanie serializacji umożliwia <see cref="P:System.Windows.Controls.Page.Title" /> właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli zawartość powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowHeight">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowHeight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowHeight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowHeight () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowHeight();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Klasy pochodne określić zachowanie serializacji umożliwia <see cref="P:System.Windows.Controls.Page.WindowHeight" /> właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli zawartość powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowTitle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Klasy pochodne określić zachowanie serializacji umożliwia <see cref="P:System.Windows.Controls.Page.WindowTitle" /> właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli zawartość powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowWidth">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowWidth ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowWidth() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowWidth () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowWidth();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Klasy pochodne określić zachowanie serializacji umożliwia <see cref="P:System.Windows.Controls.Page.WindowWidth" /> właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli zawartość powinny być serializowane; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShowsNavigationUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsNavigationUI" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowsNavigationUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowsNavigationUI { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy nawigacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] z <see cref="T:System.Windows.Navigation.NavigationWindow" /> na [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)] jest widoczny.</summary>
        <value>
          <see langword="true" /> Jeśli nawigacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] hosta <see cref="T:System.Windows.Navigation.NavigationWindow" /> jest widoczne, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationWindow> Wyświetla nawigacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] domyślnie, aby włączyć stylu przeglądarki przodu i do tyłu nawigacji. Jeśli strona jest ustawiony jako <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application> automatycznie otwiera <xref:System.Windows.Navigation.NavigationWindow> do hostowania strony w. Jeśli strona nie chce korzysta z domyślnego <xref:System.Windows.Navigation.NavigationWindow> nawigacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], można ustawić <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> do `false`.  
  
> [!NOTE]
>  Ponieważ [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] nie obsługują nawigacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] dla [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)], zapewnia własnej nawigacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], które pokazywane lub ukryte przez ustawienie <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>. [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] Czy można zintegrować z [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] nawigacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], dlatego ustawienie <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> na stronach [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] nie ma wpływu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] ukrycia nawigacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] z <xref:System.Windows.Navigation.NavigationWindow>.  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml2)]  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang2)]  
  
 [!code-csharp[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml.cs#setpageshowsnavigationuicodebehind)]
 [!code-vb[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageShowsNavigationUISnippets/visualbasic/homepage.xaml.vb#setpageshowsnavigationuicodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" /> Właściwości sprawdzana jest na <see cref="T:System.Windows.Controls.Page" /> wystąpienia, który nie jest obsługiwany przez <see cref="T:System.Windows.Window" />, <see cref="T:System.Windows.Navigation.NavigationWindow" />, lub w przeglądarce.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (obj As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ obj) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Aby dodać obiekt podrzędny.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Markup.IAddChild.AddChild(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.Controls.Page> wystąpienia jest rzutowane na <xref:System.Windows.Markup.IAddChild> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string str);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (str As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ str) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Tekst, aby dodać do obiektu.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Windows.Markup.IAddChild.AddText(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.Controls.Page> wystąpienia jest rzutowane na <xref:System.Windows.Markup.IAddChild> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Template">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ControlTemplate Template { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ControlTemplate Template" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Template" />
      <MemberSignature Language="VB.NET" Value="Public Property Template As ControlTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ControlTemplate ^ Template { System::Windows::Controls::ControlTemplate ^ get(); void set(System::Windows::Controls::ControlTemplate ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ControlTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szablon formantu <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>
          <see cref="T:System.Windows.Controls.ControlTemplate" /> Dla <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_ContentTemplate"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Template="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlValues_ContentTemplate"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Rozszerzenie znacznika określający sposób odwoływać się do zasobu szablonu, albo `StaticResource` lub `DynamicResource`. Zobacz [zasobów XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz identyfikujący selektora żądanego szablonu. Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składni elementu właściwości jest technicznie możliwe, ale nie jest zalecane. Aby uzyskać więcej informacji, zobacz [style wbudowane i szablony](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  
  
<a name="dependencyPropertyInfo_PageTemplate"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.TemplateProperty>|  
|Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TemplateProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.Page.Template" /> właściwości zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tytuł <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Tytuł <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Windows.Controls.Page.Title%2A> właściwość nie jest wyświetlana przez <xref:System.Windows.Controls.Page>, ani nie jest wyświetlana na pasku tytułu okna, który jest hostem <xref:System.Windows.Controls.Page>. Zamiast tego należy ustawić <xref:System.Windows.Controls.Page.WindowTitle%2A> zmienić tytuł okna hosta.  
  
 <xref:System.Windows.Controls.Page.Title%2A> mogą służyć do generowania nazw z wpisem historii nawigacji dla danej zawartości nawigować. Następujące elementy danych są używane do automatycznego tworzenia nazwę wpisu historii nawigacji, w kolejności:  
  
-   Dołączony <xref:System.Windows.Navigation.JournalEntry.Name%2A> atrybutu.  
  
-   <xref:System.Windows.Controls.Page.Title%2A> Właściwości.  
  
-   <xref:System.Windows.Controls.Page.WindowTitle%2A> Właściwości i [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] dla bieżącej strony  
  
-   [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Dla bieżącej strony.  
  
 Jeśli został skojarzony <xref:System.Windows.Navigation.CustomContentState> obiektu z danej zawartości w historii nawigacji, można określić nazwę wyświetlaną w z wpisem historii nawigacji przez zastąpienie <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_PageTitle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.TitleProperty>|  
|Wartość właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.Page.Title" /> właściwości zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator <xref:System.Windows.Controls.Page.Title%2A> właściwości zależności.  
  
   
  
## Examples  
 [Przegląd właściwości zależności](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public double WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowHeight { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia wysokość hosta <see cref="T:System.Windows.Window" /> lub <see cref="T:System.Windows.Navigation.NavigationWindow" /> z <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Wysokość okna, który jest hostem bezpośrednio <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowHeight%2A> jest stosowany tylko wtedy gdy <xref:System.Windows.Controls.Page> znajduje się bezpośrednio przez okno, w tym:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Jeśli <xref:System.Windows.Controls.Page> jest hostowana przez <xref:System.Windows.Controls.Frame>, ustawienie <xref:System.Windows.Controls.Page.WindowHeight%2A> nie obowiązuje, ale nadal można pobrać wartości <xref:System.Windows.Controls.Page.WindowHeight%2A>.  
  
 A <xref:System.Windows.Controls.Page> w [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] można użyć tylko <xref:System.Windows.Controls.Page.WindowHeight%2A> zmienić wysokość [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; nie można zmienić wysokość przez ustawienie <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.MinHeight%2A>, lub <xref:System.Windows.FrameworkElement.MaxHeight%2A>.  
  
 Minimalna wysokość [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] okno jest 150 pikseli. Obsługiwane w przeglądarce stron, oznacza to, że wartość <xref:System.Windows.Controls.Page.WindowHeight%2A> nie może być stosowany, jeśli spowodowałoby całkowitej wysokości [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] okna będzie mniej niż 150 pikseli.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób ustawiania wysokość okna ze strony.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowHeightPage.xaml#setpagewindowheightxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowTitle">
      <MemberSignature Language="C#" Value="public string WindowTitle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WindowTitle { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tytuł hosta <see cref="T:System.Windows.Window" /> lub <see cref="T:System.Windows.Navigation.NavigationWindow" /> z <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Tytuł okna, który jest hostem bezpośrednio <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie, tytuł okna, który hostuje strony, w tym <xref:System.Windows.Navigation.NavigationWindow> i [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], to nazwa pliku, który jest obecnie hostowany (z rozszerzeniem .xaml, jeśli strona jest luźno [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], lub jeśli strona jest częścią rozszerzenie.xbap[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).  
  
 Strona domyślne można zmienić, ustawiając jego <xref:System.Windows.Controls.Page.WindowTitle%2A> właściwości.  
  
 Po stronie Ustawia tytuł okna w ten sposób, aż do innej strony Ustawia tytuł okna nie ulega zmianie <xref:System.Windows.Controls.Page.WindowTitle%2A> , podając inną wartość.  
  
> [!NOTE]
>  <xref:System.Windows.Controls.Page> Musi być znajdujących się na górze elementu zawartości, w oknie, aby <xref:System.Windows.Controls.Page.WindowTitle%2A> mają wpływ; Jeśli <xref:System.Windows.Controls.Page> znajduje się w obrębie <xref:System.Windows.Controls.Frame>, na przykład ustawienie <xref:System.Windows.Controls.Page.WindowTitle%2A> nie zmienia tytuł okna hosta.  
  
 <xref:System.Windows.Controls.Page.WindowTitle%2A> mogą służyć do generowania nazw z wpisem historii nawigacji dla danej zawartości nawigować. Następujące elementy danych są używane do automatycznego tworzenia nazwę wpisu historii nawigacji, w kolejności:  
  
-   Dołączony <xref:System.Windows.Navigation.JournalEntry.Name%2A> atrybutu.  
  
-   <xref:System.Windows.Controls.Page.Title%2A> Właściwości.  
  
-   <xref:System.Windows.Controls.Page.WindowTitle%2A> Właściwości i [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] dla bieżącej strony  
  
-   [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Dla bieżącej strony.  
  
 Jeśli został skojarzony <xref:System.Windows.Navigation.CustomContentState> obiektu z danej zawartości w historii nawigacji, można określić wartości nazwy elementu historii nawigacji przez zastąpienie <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić tytuł okna ze strony.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowTitleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowTitlePage.xaml#setpagewindowtitlexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public double WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowWidth { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szerokość hosta <see cref="T:System.Windows.Window" /> lub <see cref="T:System.Windows.Navigation.NavigationWindow" /> z <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Szerokość okna, który jest hostem bezpośrednio <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowWidth%2A> jest stosowany tylko wtedy gdy <xref:System.Windows.Controls.Page> znajduje się bezpośrednio przez okno, w tym:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Jeśli <xref:System.Windows.Controls.Page> jest hostowana przez <xref:System.Windows.Controls.Frame>, ustawienie <xref:System.Windows.Controls.Page.WindowWidth%2A> nie obowiązuje, ale nadal można pobrać wartości <xref:System.Windows.Controls.Page.WindowWidth%2A>.  
  
 A <xref:System.Windows.Controls.Page> w [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] można użyć tylko <xref:System.Windows.Controls.Page.WindowWidth%2A> zmienić szerokość [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; nie można zmienić szerokość przez ustawienie <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, lub <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  
  
 Minimalna szerokość [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] okno jest 250 pikseli. Obsługiwane w przeglądarce stron, oznacza to, że wartość <xref:System.Windows.Controls.Page.WindowWidth%2A> nie może być stosowany, jeśli spowodowałoby łączna szerokość [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] okna będzie mniej niż 250 pikseli.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić szerokość okna ze strony.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowWidthXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowWidthPage.xaml#setpagewindowwidthxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
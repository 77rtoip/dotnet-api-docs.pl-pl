<Type Name="Page" FullName="System.Windows.Controls.Page">
  <Metadata><Meta Name="ms.openlocfilehash" Value="98d57587b881b8029c8e6be50187dc3f413c32b1" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69213645" /></Metadata><TypeSignature Language="C#" Value="public class Page : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits FrameworkElement&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Windows::FrameworkElement, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type Page = class&#xA;    inherit FrameworkElement&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Content")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Hermetyzuje stronę zawartości, do której można przejść i która jest hostowana w programie Windows Internet Explorer <see cref="T:System.Windows.Navigation.NavigationWindow" />, i <see cref="T:System.Windows.Controls.Frame" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page>hermetyzuje stronę zawartości, która może być przechodzenie i ma następujące elementy:  
  
-   **Zarządzanie**okresem <xref:System.Windows.Controls.Page.KeepAlive%2A>istnienia:.  
  
-   **Nawigacja**: <xref:System.Windows.Controls.Page.NavigationService%2A>.  
  
-   **Wygląd**: <xref:System.Windows.Controls.Page.Background%2A> ,<xref:System.Windows.Controls.Page.Content%2A>, ,,,,<xref:System.Windows.Controls.Page.FontFamily%2A> ,.<xref:System.Windows.Controls.Page.Title%2A> <xref:System.Windows.Controls.Page.FontSize%2A> <xref:System.Windows.Controls.Page.Foreground%2A> <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> <xref:System.Windows.Controls.Page.Template%2A>  
  
-   **Wygląd okna hosta**: <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowTitle%2A>.  
  
 Stronę można zdefiniować przy użyciu znaczników, znaczników i kodu. Strona jest preferowanym sposobem spakowania zawartości na potrzeby nawigacji, z następujących powodów:  
  
-   Można łatwo definiować, ponownie używać i zarządzać nimi.  
  
-   Może uzyskać do niego dostęp i <xref:System.Windows.Navigation.NavigationService> korzystać z niego.  
  
-   Można zmienić tytuł, Szerokość, Wysokość i nawigację [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] swojego okna hosta (<xref:System.Windows.Controls.Page.WindowTitle%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>).  
  
-   Ma ona obsługę projektanta w [!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)]programie.  
  
 Strona może być hostowana z <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>lub z przeglądarki. Strona może być hostowana:  
  
-   Bezpośredni element podrzędny <xref:System.Windows.Window>elementu, <xref:System.Windows.Navigation.NavigationWindow>, lub <xref:System.Windows.Controls.Frame> w [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
-   Tworzone i ustawiane `Content` jako wartość <xref:System.Windows.Window>właściwości, <xref:System.Windows.Navigation.NavigationWindow>, i <xref:System.Windows.Controls.Frame>.  
  
-   Ustaw jako [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] źródło `Source` właściwości <xref:System.Windows.Navigation.NavigationWindow> lub. <xref:System.Windows.Controls.Frame>  
  
-   Ustaw jako <xref:System.Windows.Application.StartupUri%2A> aplikację autonomiczną.  
  
-   Ustaw jako <xref:System.Windows.Application.StartupUri%2A>. [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]  
  
 Aplikacja ma zwykle dwie lub więcej stron, które mogą być przechodzenie między przy użyciu następujących mechanizmów:  
  
-   Deklaratywnie przy użyciu <xref:System.Windows.Documents.Hyperlink>.  
  
-   Programowo przy użyciu <xref:System.Windows.Navigation.NavigationService>.  
  
-   Wizualnie przy użyciu [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] nawigacji hosta, w tym [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], <xref:System.Windows.Navigation.NavigationWindow>, i <xref:System.Windows.Controls.Frame>.  
  
 Aby zapoznać się ze strukturą nawigacji<xref:System.Windows.Navigation.PageFunction%601>przy użyciu funkcji strony (), zobacz [Omówienie nawigacji strukturalnej](~/docs/framework/wpf/app-development/structured-navigation-overview.md) i [topologie nawigacji](~/docs/framework/wpf/app-development/navigation-topologies-overview.md).  
  
 Właściwości zależności dla tego formantu można ustawić przy użyciu domyślnego stylu kontrolki.  Jeśli właściwość jest ustawiana za pomocą stylu domyślnego, właściwość może ulec zmianie z wartości domyślnej, gdy kontrolka pojawi się w aplikacji. Domyślny styl jest określany na podstawie tego, który Motyw pulpitu jest używany, gdy aplikacja jest uruchomiona.  Aby uzyskać więcej informacji, zobacz [domyślne motywy WPF](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak strona standardowa jest definiowana przy użyciu tylko znaczników:  
  
 [!code-xaml[PageSnippets#MarkupPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupPage.xaml#markuppagemarkup)]  
  
 Poniższy przykład pokazuje, jak strona standardowa jest definiowana przy użyciu tylko kodu:  
  
 [!code-csharp[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/CodePage.cs#codepagecodebehind)]
 [!code-vb[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/codepage.vb#codepagecodebehind)]  
  
 Poniższy przykład pokazuje, jak strona standardowa jest definiowana przy użyciu kombinacji znaczników i kodu.  
  
 [!code-xaml[PageSnippets#MarkupAndCodeBehindPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml#markupandcodebehindpagemarkup)]  
  
 [!code-csharp[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml.cs#markupandcodebehindpagecodebehind)]
 [!code-vb[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/markupandcodebehindpage.xaml.vb#markupandcodebehindpagecodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Navigation.PageFunction`1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Controls.Page" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element <xref:System.Windows.Controls.Page> nie jest aktywny (zobacz <xref:System.Windows.Controls.Page.KeepAlive%2A>), musi zaimplementować konstruktora bez parametrów, aby zezwolić [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] na tworzenie nowego wystąpienia w momencie przejścia do historii przeglądania wstecz lub do przodu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="page.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">Rozmiar, który ma zostać użyty do rozmieszczenia elementów podrzędnych.</param>
        <summary>Rozmieszcza zawartość (elementy podrzędne) <see cref="T:System.Windows.Controls.Page" />.</summary>
        <returns><see cref="T:System.Windows.Size" /> Reprezentujący rozmieszczony rozmiar strony.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Background : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.Page.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tło dla elementu <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Ten <see cref="T:System.Windows.Media.Brush" /> program<see cref="T:System.Windows.Controls.Page" /> używa do rysowania tła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageBackground"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.BackgroundProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BackgroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.Page.Background" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Content : obj with get, set" Usage="System.Windows.Controls.Page.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zawartość <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Obiekt, który zawiera zawartość <see cref="T:System.Windows.Controls.Page" />. Wartość domyślna to <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page> Może mieć tylko jeden element podrzędny. Wszystkie inne elementy na <xref:System.Windows.Controls.Page> elementach muszą być elementami potomnymi tego elementu. Zwykle <xref:System.Windows.Controls.Page> zawartość hosta składa się z elementu układu, takiego jak <xref:System.Windows.Controls.StackPanel> <xref:System.Windows.Controls.Grid>,, <xref:System.Windows.Controls.Page>i <xref:System.Windows.Controls.DockPanel> -która hostuje zawartość.  
  
<a name="dependencyPropertyInfo_PageContent"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.ContentProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.ContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.Page.Content" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FontFamily : System.Windows.Media.FontFamily with get, set" Usage="System.Windows.Controls.Page.FontFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font, Modifiability=System.Windows.Modifiability.Unmodifiable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę określonej rodziny czcionek.</summary>
        <value>Jest to rodzina czcionek dla zawartości <see cref="T:System.Windows.Controls.Page" />. <see cref="T:System.Windows.Media.FontFamily" /> Wartość domyślna to <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageFontFamily"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.FontFamilyProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontFamilyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.Page.FontFamily" /> zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator <xref:System.Windows.Controls.Page.FontFamily%2A> właściwości zależności.  
  
   
  
## Examples  
 [Przegląd właściwości zależności](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.FontSize : double with get, set" Usage="System.Windows.Controls.Page.FontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar czcionki.</summary>
        <value>Rozmiar czcionki dla zawartości <see cref="T:System.Windows.Controls.Page" />. Wartość domyślna to <see cref="P:System.Windows.SystemFonts.MessageFontSize" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar czcionki musi być liczbą dodatnią i zakresem <xref:System.Windows.SystemFonts.MessageFontSize%2A>.  
  
<a name="dependencyPropertyInfo_PageFontSize"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.FontSizeProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontSizeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.FontSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.Page.FontSize" /> zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator <xref:System.Windows.Controls.Page.FontSize%2A> właściwości zależności.  
  
   
  
## Examples  
 [Przegląd właściwości zależności](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Foreground : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.Page.Foreground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pierwszy plan dla elementu <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Ten <see cref="T:System.Windows.Media.Brush" /> program<see cref="T:System.Windows.Controls.Page" /> używa do rysowania pierwszego planu. Wartość domyślna to <see cref="P:System.Windows.Media.Brushes.Black" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageForeground"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.ForegroundProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForegroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.ForegroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.Page.Foreground" /> zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator <xref:System.Windows.Controls.Page.Foreground%2A> właściwości zależności.  
  
   
  
## Examples  
 [Przegląd właściwości zależności](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Windows.Controls.Page.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Windows.Controls.Page" /> wystąpienie jest zachowane w historii nawigacji.</summary>
        <value><see langword="true" />Jeśli wystąpienie jest zachowane w historii nawigacji; <see langword="false" />w przeciwnym razie. <see cref="T:System.Windows.Controls.Page" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po pierwszym przejściu do strony zostanie utworzone nowe wystąpienie <xref:System.Windows.Controls.Page> klasy. Po przejściu strony z (Wstecz lub w przód) do historii nawigacji zostaje dodany wpis strony. Domyślnie wpis nie odwołuje się do obiektu strony. Zamiast tego wpis zawiera jednolity identyfikator zasobów pakietu (URI) dla strony. Gdy wpis strony jest przechodzenia do korzystania z historii nawigacji, identyfikator URI pakietu jest używany do utworzenia nowego wystąpienia strony. Jest to zachowanie domyślne, aby uniknąć nadmiernego wykorzystania pamięci: przechowywanie wystąpień stron może szybko zużywać pamięć, szczególnie w przypadku nieprostej ilości zawartości. Ten problem jest rozszerzany przez fakt, że nie ma żadnego limitu liczby wpisów, które mogą być przechowywane w stosach z tyłu i do przodu historii nawigacji. Z kolei przechowywanie identyfikatorów URI pakietów dla stron nie ma praktycznie wpływu na użycie pamięci.  
  
 Głównym efektem ubocznym tworzenia nowych wystąpień strony jest to, że stan strony nie jest zapamiętywany z jednego wystąpienia strony na inną. W takich przypadkach Windows Presentation Foundation oferuje kilka technik zapamiętywania stanu.  
  
 Aby zachować stronę, należy ustawić <xref:System.Windows.Controls.Page.KeepAlive%2A> właściwość na `true` (wartość domyślna to `false`).  
  
> [!NOTE]
>  Strony, które są tworzone i są używane tylko do korzystania z kodu (na przykład wywoływanie <xref:System.Windows.Navigation.NavigationService.Navigate%2A>), są automatycznie obsługiwane.  
  
 Należy unikać ustawiania <xref:System.Windows.Controls.Page.KeepAlive%2A> `true` , chyba że zachodzi taka potrzeba:  
  
-   Gdy strona zawiera wiele zawartości, tworzenie wystąpienia może zająć dużo czasu. Jeśli strona nie jest aktywna, a strona jest często przenoszone do, koszt stałego tworzenia wystąpienia strony może mieć negatywny wpływ na środowisko użytkownika. Jednak z punktu widzenia wydajności należy polegać na ustawieniach domyślnych i profilu wydajności aplikacji; Jeśli testy identyfikują strony z czasy ładowania, które są mniejsze niż zakres wymagany dla aplikacji, skonfigurowanie stron do utrzymania aktywności może być jednym ze sposobów rozwiązania problemu.  
  
> [!NOTE]
>  Wpisy dla stron, które są utrzymywane w stanie aktywności, nie są zachowywane [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] w historii nawigacji w przypadku, gdy użytkownik nawiguje z [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]powrotem do. Tylko wpisy dziennika dla stron, które nie są aktywne, są zachowywane w historii nawigacji.  
  
<a name="dependencyPropertyInfo_PageKeepAlive"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.KeepAliveProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
> [!NOTE]
>  Typ metadanych dla tej właściwości zależności to <xref:System.Windows.PropertyMetadata>, nie. <xref:System.Windows.FrameworkPropertyMetadata>  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak użyć [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] , aby zachować wystąpienie <xref:System.Windows.Controls.Page> klasy dla wielu nawigacji.  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml2)]  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang2)]  
  
 [!code-csharp[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml.cs#setpagekeepalivecodebehind)]
 [!code-vb[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageKeepAliveSnippets/visualbasic/homepage.xaml.vb#setpagekeepalivecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.JournalEntry.KeepAlive" />
      </Docs>
    </Member>
    <Member MemberName="KeepAliveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty KeepAliveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty KeepAliveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeepAliveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ KeepAliveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeepAliveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.Page.KeepAlive" /> zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator <xref:System.Windows.Controls.Page.KeepAlive%2A> właściwości zależności.  
  
   
  
## Examples  
 [Przegląd właściwości zależności](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.Page.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca moduł wyliczający dla logicznych elementów podrzędnych elementu <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Dla logicznych elementów <see cref="T:System.Windows.Controls.Page" />podrzędnych elementu. <see cref="T:System.Collections.IEnumerator" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="page.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Dostępny obszar, który okno może przekazać do jego elementów podrzędnych.</param>
        <summary>Mierzy elementy <see cref="T:System.Windows.Controls.Page" />podrzędne.</summary>
        <returns><see cref="T:System.Windows.Size" /> Jest to rzeczywisty rozmiar okna. Metoda może zwracać większą wartość. w takim przypadku rodzic może potrzebować dodać paski przewijania.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigationService">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.NavigationService NavigationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Navigation.NavigationService NavigationService" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.NavigationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NavigationService As NavigationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Navigation::NavigationService ^ NavigationService { System::Windows::Navigation::NavigationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NavigationService : System.Windows.Navigation.NavigationService" Usage="System.Windows.Controls.Page.NavigationService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera usługę nawigacji, która jest używana przez hosta strony do zarządzania nawigacją.</summary>
        <value>Obiekt używany przez hosta strony do zarządzania nawigacją lub <see langword="null" /> Jeśli host nie obsługuje nawigacji. <see cref="T:System.Windows.Navigation.NavigationService" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Strony mogą być hostowane przez wiele typów hostów, takich <xref:System.Windows.Window>jak <xref:System.Windows.Navigation.NavigationWindow> <xref:System.Windows.Controls.Frame>,, i przeglądarka.  
  
 Strony często muszą zintegrować się z nawigacją hosta, aby zapewnić obsługę nawigacji na stronie. Jednak ze względu na to, że strona może nie wiedzieć, jak jej host będzie w czasie wykonywania, nie można bezpośrednio zintegrować jej z członkami nawigacji hosta.  
  
 Zamiast tego może próbować użyć usługi nawigacji, która jest usługą, która obsługuje nawigację w stylu przeglądarki i jest hermetyzowana przez <xref:System.Windows.Navigation.NavigationService> klasę. Nie można utworzyć własnego <xref:System.Windows.Navigation.NavigationService> wystąpienia, chociaż. Zamiast tego, typy hosta, <xref:System.Windows.Navigation.NavigationWindow>takie <xref:System.Windows.Controls.Frame>jak,, lub przeglądarka tworzą własne <xref:System.Windows.Navigation.NavigationService> wystąpienie, do którego można uzyskać dostęp <xref:System.Windows.Controls.Page.NavigationService%2A> z właściwości.  
  
 Usługa nawigacji zwracana z <xref:System.Windows.Controls.Page.NavigationService%2A> właściwości jest wystąpieniem <xref:System.Windows.Navigation.NavigationService> klasy, która jest zarządzana przez pierwsze drzewo drzewa wizualnego. Jeśli nie zostanie znaleziony, `null` jest zwracana, wskazując, że host strony nie obsługuje nawigacji.  
  
> [!NOTE]
>  <xref:System.Windows.Window> Klasa nie obsługuje nawigacji i nie udostępnia usługi nawigacji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak strona może sprawdzić, czy usługa nawigacji jest dostępna, a jeśli tak, użyj jej do przechodzenia z powrotem do poprzedniej strony.  
  
 [!code-csharp[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageNavigationServiceSnippets/CSharp/HomePage.xaml.cs#getpagenavigationservicecodebehind)]
 [!code-vb[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageNavigationServiceSnippets/visualbasic/homepage.xaml.vb#getpagenavigationservicecodebehind)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTemplateChanged (oldTemplate As ControlTemplate, newTemplate As ControlTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTemplateChanged(System::Windows::Controls::ControlTemplate ^ oldTemplate, System::Windows::Controls::ControlTemplate ^ newTemplate);" />
      <MemberSignature Language="F#" Value="abstract member OnTemplateChanged : System.Windows.Controls.ControlTemplate * System.Windows.Controls.ControlTemplate -&gt; unit&#xA;override this.OnTemplateChanged : System.Windows.Controls.ControlTemplate * System.Windows.Controls.ControlTemplate -&gt; unit" Usage="page.OnTemplateChanged (oldTemplate, newTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">Stary szablon.</param>
        <param name="newTemplate">Nowy szablon.</param>
        <summary>Wywoływana, gdy szablon zostanie <see cref="T:System.Windows.Controls.Page" /> zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zobacz <xref:System.Windows.Controls.Control.OnTemplateChanged%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Page.Template" />
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="page.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Poprzedni element nadrzędny. Ustaw na <see langword="null" /> , <see cref="T:System.Windows.DependencyObject" /> Jeśli nie ma poprzedniego elementu nadrzędnego.</param>
        <summary>Wywoływana, gdy element nadrzędny elementu <see cref="T:System.Windows.Controls.Page" /> zostanie zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.UIElement.OnVisualParentChanged%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nowy element nadrzędny nie jest <see cref="T:System.Windows.Window" /> <see cref="T:System.Windows.Controls.Frame" />ani ani.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeShowsNavigationUI ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeShowsNavigationUI() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeShowsNavigationUI () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeShowsNavigationUI();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeShowsNavigationUI : unit -&gt; bool" Usage="page.ShouldSerializeShowsNavigationUI " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia klasom pochodnym Określanie zachowania <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" /> serializacji właściwości.</summary>
        <returns><see langword="true" />Jeśli zawartość powinna być serializowana; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTitle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTitle : unit -&gt; bool" Usage="page.ShouldSerializeTitle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia klasom pochodnym Określanie zachowania <see cref="P:System.Windows.Controls.Page.Title" /> serializacji właściwości.</summary>
        <returns><see langword="true" />Jeśli zawartość powinna być serializowana; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowHeight">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowHeight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowHeight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowHeight () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowHeight();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeWindowHeight : unit -&gt; bool" Usage="page.ShouldSerializeWindowHeight " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia klasom pochodnym Określanie zachowania <see cref="P:System.Windows.Controls.Page.WindowHeight" /> serializacji właściwości.</summary>
        <returns><see langword="true" />Jeśli zawartość powinna być serializowana; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowTitle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeWindowTitle : unit -&gt; bool" Usage="page.ShouldSerializeWindowTitle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia klasom pochodnym Określanie zachowania <see cref="P:System.Windows.Controls.Page.WindowTitle" /> serializacji właściwości.</summary>
        <returns><see langword="true" />Jeśli zawartość powinna być serializowana; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowWidth">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowWidth ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowWidth() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowWidth () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowWidth();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeWindowWidth : unit -&gt; bool" Usage="page.ShouldSerializeWindowWidth " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia klasom pochodnym Określanie zachowania <see cref="P:System.Windows.Controls.Page.WindowWidth" /> serializacji właściwości.</summary>
        <returns><see langword="true" />Jeśli zawartość powinna być serializowana; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShowsNavigationUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsNavigationUI" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowsNavigationUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowsNavigationUI { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowsNavigationUI : bool with get, set" Usage="System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy nawigacja [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] <see cref="T:System.Windows.Navigation.NavigationWindow" /> [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)] jest widoczna.</summary>
        <value><see langword="true" />Jeśli nawigacja [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] hosta <see cref="T:System.Windows.Navigation.NavigationWindow" /> jest widoczna; w przeciwnym razie, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationWindow>wyświetla domyślnie [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] nawigację, aby włączyć nawigację w stylu przeglądarki do przodu i do tyłu. Jeśli strona jest ustawiona jako <xref:System.Windows.Application.StartupUri%2A>, program <xref:System.Windows.Application> automatycznie otwiera <xref:System.Windows.Navigation.NavigationWindow> , aby hostować stronę w. Jeśli strona nie ma używać <xref:System.Windows.Navigation.NavigationWindow> domyślnej nawigacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] `false`, może ona mieć ustawioną wartość <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> .  
  
> [!NOTE]
>  Ponieważ [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] program nie integruje się z [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] nawigacją dla [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)], udostępnia własną nawigację [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], która może być pokazywana lub Ukryta <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>przez ustawienie. [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]Program integruje się [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] z [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]nawigacją, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> więc ustawienie na [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] stronach w programie nie ma żadnego efektu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] do ukrywania nawigacji [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] elementu <xref:System.Windows.Navigation.NavigationWindow>.  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml2)]  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang2)]  
  
 [!code-csharp[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml.cs#setpageshowsnavigationuicodebehind)]
 [!code-vb[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageShowsNavigationUISnippets/visualbasic/homepage.xaml.vb#setpageshowsnavigationuicodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest sprawdzana <see cref="T:System.Windows.Controls.Page" /> w wystąpieniu, które nie <see cref="T:System.Windows.Window" />jest hostowane przez, <see cref="T:System.Windows.Navigation.NavigationWindow" />lub w przeglądarce. <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" /></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (obj As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ obj) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt podrzędny do dodania.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Windows.Markup.IAddChild.AddChild(System.Object)" />Zobacz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.Controls.Page> gdy wystąpienie jest rzutowane <xref:System.Windows.Markup.IAddChild> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string str);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (str As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ str) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Tekst, który ma zostać dodany do obiektu.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Windows.Markup.IAddChild.AddText(System.String)" />Zobacz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.Controls.Page> gdy wystąpienie jest rzutowane <xref:System.Windows.Markup.IAddChild> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Template">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ControlTemplate Template { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ControlTemplate Template" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Template" />
      <MemberSignature Language="VB.NET" Value="Public Property Template As ControlTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ControlTemplate ^ Template { System::Windows::Controls::ControlTemplate ^ get(); void set(System::Windows::Controls::ControlTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Template : System.Windows.Controls.ControlTemplate with get, set" Usage="System.Windows.Controls.Page.Template" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ControlTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szablon kontrolki dla elementu <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value><see cref="T:System.Windows.Controls.ControlTemplate" /> Dla a<see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_ContentTemplate"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Template="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlValues_ContentTemplate"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *resourceExtension*  
 Rozszerzenie znaczników, które określa, `StaticResource` jak odwoływać się do zasobu szablonu lub. `DynamicResource` Zobacz [zasoby XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Klucz, który identyfikuje żądany selektor szablonu. Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Składnia elementu właściwości jest technicznie możliwa, ale nie jest zalecana. Aby uzyskać więcej informacji, zobacz [style wbudowane i szablony](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  
  
<a name="dependencyPropertyInfo_PageTemplate"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.TemplateProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TemplateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TemplateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.TemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.Page.Template" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Controls.Page.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tytuł elementu <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Tytuł <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Windows.Controls.Page.Title%2A> właściwości nie jest wyświetlana przez <xref:System.Windows.Controls.Page>, ani nie jest wyświetlana na pasku tytułu okna, w którym znajduje się a <xref:System.Windows.Controls.Page>. Zamiast tego należy ustawić <xref:System.Windows.Controls.Page.WindowTitle%2A> opcję zmiany tytułu okna hosta.  
  
 <xref:System.Windows.Controls.Page.Title%2A>można również użyć do wygenerowania nazwy wpisu historii nawigacji dla fragmentu zawartości z nawigacją. Następujące fragmenty danych są używane do automatycznego konstruowania nazwy wpisu historii nawigacji w kolejności:  
  
-   Dołączony <xref:System.Windows.Navigation.JournalEntry.Name%2A> atrybut.  
  
-   <xref:System.Windows.Controls.Page.Title%2A> Właściwość.  
  
-   <xref:System.Windows.Controls.Page.WindowTitle%2A> Właściwość[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] i dla bieżącej strony  
  
-   [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Dla bieżącej strony.  
  
 Jeśli masz skojarzony <xref:System.Windows.Navigation.CustomContentState> obiekt z fragmentem zawartości w historii nawigacji, możesz określić nazwę wyświetlaną w wpisie historii nawigacji przez zastąpienie <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_PageTitle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.Page.TitleProperty>|  
|Właściwości metadanych ustawione na`true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.Page.Title" /> zależności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator <xref:System.Windows.Controls.Page.Title%2A> właściwości zależności.  
  
   
  
## Examples  
 [Przegląd właściwości zależności](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public double WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.WindowHeight : double with get, set" Usage="System.Windows.Controls.Page.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wysokość hosta <see cref="T:System.Windows.Window" /> lub. <see cref="T:System.Windows.Navigation.NavigationWindow" /> <see cref="T:System.Windows.Controls.Page" /></summary>
        <value>Wysokość okna, która bezpośrednio hostuje <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowHeight%2A>jest stosowany tylko wtedy, <xref:System.Windows.Controls.Page> gdy jest hostowany bezpośrednio przez okno, w tym:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Jeśli jest hostowany <xref:System.Windows.Controls.Frame>przez, ustawienie <xref:System.Windows.Controls.Page.WindowHeight%2A> nie ma wpływu, <xref:System.Windows.Controls.Page.WindowHeight%2A>ale nadal można uzyskać wartość. <xref:System.Windows.Controls.Page>  
  
 [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] <xref:System.Windows.FrameworkElement.MinHeight%2A> <xref:System.Windows.FrameworkElement.MaxHeight%2A>W programie <xref:System.Windows.FrameworkElement.Height%2A>można użyć<xref:System.Windows.Controls.Page.WindowHeight%2A> tylko do zmiany wysokości; wysokość nie może być zmieniona przez ustawienie, lub. [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] <xref:System.Windows.Controls.Page>  
  
 Minimalna wysokość [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] okna to 150 pikseli. W przypadku stron hostowanych przez przeglądarkę oznacza to, że wartość <xref:System.Windows.Controls.Page.WindowHeight%2A> nie może być stosowana, jeśli spowoduje to, że łączna wysokość [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] okna będzie mniejsza niż 150 pikseli.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić wysokość okna ze strony.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowHeightPage.xaml#setpagewindowheightxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowTitle">
      <MemberSignature Language="C#" Value="public string WindowTitle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WindowTitle { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTitle : string with get, set" Usage="System.Windows.Controls.Page.WindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tytuł hosta <see cref="T:System.Windows.Window" /> lub. <see cref="T:System.Windows.Navigation.NavigationWindow" /> <see cref="T:System.Windows.Controls.Page" /></summary>
        <value>Tytuł okna, który bezpośrednio hostuje <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie tytuł okna, w którym znajduje się Strona, włącznie <xref:System.Windows.Navigation.NavigationWindow> z i [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], jest nazwą pliku, który jest aktualnie hostowany (z rozszerzeniem. XAML, jeśli strona jest luźna [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]lub rozszerzeniem. XBAP, jeśli strona jest częścią [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).  
  
 Strona może zmienić wartość domyślną przez ustawienie jej <xref:System.Windows.Controls.Page.WindowTitle%2A> właściwości.  
  
 Gdy strona ustawi tytuł okna w ten sposób, tytuł okna nie zmienia się, dopóki inne nie zostaną ustawione <xref:System.Windows.Controls.Page.WindowTitle%2A> z inną wartością.  
  
> [!NOTE]
>  <xref:System.Windows.Controls.Frame> <xref:System.Windows.Controls.Page.WindowTitle%2A> <xref:System.Windows.Controls.Page> Aby można było mieć efekt, <xref:System.Windows.Controls.Page.WindowTitle%2A> musi to być najwyżej fragment zawartości w oknie, dla którego ma to wpływ. Jeśli element znajduje się w, na przykład, ustawienie nie zmienia tytułu okna hosta. <xref:System.Windows.Controls.Page>  
  
 <xref:System.Windows.Controls.Page.WindowTitle%2A>można również użyć do wygenerowania nazwy wpisu historii nawigacji dla fragmentu zawartości z nawigacją. Następujące fragmenty danych są używane do automatycznego konstruowania nazwy wpisu historii nawigacji w kolejności:  
  
-   Dołączony <xref:System.Windows.Navigation.JournalEntry.Name%2A> atrybut.  
  
-   <xref:System.Windows.Controls.Page.Title%2A> Właściwość.  
  
-   <xref:System.Windows.Controls.Page.WindowTitle%2A> Właściwość[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] i dla bieżącej strony  
  
-   [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] Dla bieżącej strony.  
  
 Jeśli masz skojarzony <xref:System.Windows.Navigation.CustomContentState> obiekt z fragmentem zawartości w historii nawigacji, możesz określić wartość Nazwa elementu historii nawigacji przez zastąpienie <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić tytuł okna ze strony.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowTitleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowTitlePage.xaml#setpagewindowtitlexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public double WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.WindowWidth : double with get, set" Usage="System.Windows.Controls.Page.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szerokość hosta <see cref="T:System.Windows.Window" /> lub. <see cref="T:System.Windows.Navigation.NavigationWindow" /> <see cref="T:System.Windows.Controls.Page" /></summary>
        <value>Szerokość okna, która bezpośrednio hostuje <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowWidth%2A>jest stosowany tylko wtedy, <xref:System.Windows.Controls.Page> gdy jest hostowany bezpośrednio przez okno, w tym:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Jeśli jest hostowany <xref:System.Windows.Controls.Frame>przez, ustawienie <xref:System.Windows.Controls.Page.WindowWidth%2A> nie ma wpływu, <xref:System.Windows.Controls.Page.WindowWidth%2A>ale nadal można uzyskać wartość. <xref:System.Windows.Controls.Page>  
  
 A <xref:System.Windows.Controls.Page> [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] <xref:System.Windows.FrameworkElement.Width%2A> <xref:System.Windows.FrameworkElement.MaxWidth%2A>w można użyć <xref:System.Windows.Controls.Page.WindowWidth%2A> tylko do zmiany szerokości; szerokość nie może być zmieniona przez ustawienie, <xref:System.Windows.FrameworkElement.MinWidth%2A>lub. [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]  
  
 Minimalna szerokość [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] okna to 250 pikseli. W przypadku stron hostowanych przez przeglądarkę oznacza to, że wartość <xref:System.Windows.Controls.Page.WindowWidth%2A> nie może być stosowana, jeśli spowodowałoby to, że łączna szerokość [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] okna będzie mniejsza niż 250 pikseli.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak ustawić szerokość okna ze strony.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowWidthXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowWidthPage.xaml#setpagewindowwidthxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

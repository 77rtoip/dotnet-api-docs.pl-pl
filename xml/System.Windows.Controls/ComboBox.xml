<Type Name="ComboBox" FullName="System.Windows.Controls.ComboBox">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e221429fcb5a126daa38656c1c9932093591b314" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39851396" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ComboBox : System.Windows.Controls.Primitives.Selector" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ComboBox extends System.Windows.Controls.Primitives.Selector" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.ComboBox" />
  <TypeSignature Language="VB.NET" Value="Public Class ComboBox&#xA;Inherits Selector" />
  <TypeSignature Language="C++ CLI" Value="public ref class ComboBox : System::Windows::Controls::Primitives::Selector" />
  <TypeSignature Language="F#" Value="type ComboBox = class&#xA;    inherit Selector" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.Selector</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ComboBox)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.StyleTypedProperty(Property="ItemContainerStyle", StyleTargetType=typeof(System.Windows.Controls.ComboBoxItem))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.TemplatePart(Name="PART_EditableTextBox", Type=typeof(System.Windows.Controls.TextBox))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.TemplatePart(Name="PART_Popup", Type=typeof(System.Windows.Controls.Primitives.Popup))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kontrolkę wyboru z listy rozwijanej, które mogą być wyświetlane lub ukryte, klikając strzałkę na formancie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ComboBox> Umożliwia użytkownikowi wybranie elementu z listy rozwijanej lub Opcjonalnie wprowadź nowy tekst w polu tekstowym formantu. <xref:System.Windows.Controls.ComboBox> jest <xref:System.Windows.Controls.ItemsControl>, co oznacza, że może zawierać zbiór obiektów dowolnego typu (na przykład ciąg, obrazu lub panelu). Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Controls.ItemsControl> klasy.  
  
 <xref:System.Windows.Controls.ComboBox.IsEditable%2A> i <xref:System.Windows.Controls.ComboBox.IsReadOnly%2A> właściwości określają sposób, w jaki <xref:System.Windows.Controls.ComboBox> działa, gdy użytkownik wykona jedną z następujących czynności:  
  
-   Wprowadza ciąg, aby wybrać element w <xref:System.Windows.Controls.ComboBox>.  
  
-   Wprowadza ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.  
  
-   Wybiera fragment ciągu, który znajduje się w polu tekstowym.  
  
-   Kopiuje i wkleja wartość w polu tekstowym.  
  
 W poniższej tabeli opisano akcje, które użytkownik może i nie może potrwać w zależności od wartości <xref:System.Windows.Controls.ComboBox.IsEditable%2A> i <xref:System.Windows.Controls.ComboBox.IsReadOnly%2A>.  
  
||<xref:System.Windows.Controls.ComboBox.IsReadOnly%2A> jest `true`|<xref:System.Windows.Controls.ComboBox.IsReadOnly%2A> jest `false`|  
|-|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Windows.Controls.ComboBox.IsEditable%2A> jest `true`|-Nie można wybrać element <xref:System.Windows.Controls.ComboBox> , wprowadzając ciąg.<br />— Nie można wprowadzić ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.<br />— Można wybrać fragment ciągu w <xref:System.Windows.Controls.ComboBox> pola tekstowego.<br />— Można skopiować ciąg w <xref:System.Windows.Controls.ComboBox> tekst pola, ale nie można wkleić ciąg do <xref:System.Windows.Controls.ComboBox> pola tekstowego.|— Można wybrać element <xref:System.Windows.Controls.ComboBox> , wprowadzając ciąg.<br />— Można wprowadzić ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.<br />— Można wybrać fragment ciągu w <xref:System.Windows.Controls.ComboBox> pola tekstowego.<br />— Można skopiować lub wkleić parametry w <xref:System.Windows.Controls.ComboBox> pola tekstowego.|  
|<xref:System.Windows.Controls.ComboBox.IsEditable%2A> jest `false`|— Można wybrać element <xref:System.Windows.Controls.ComboBox> , wprowadzając ciąg.<br />— Nie można wprowadzić ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.<br />-Nie można wybrać fragment ciągu w <xref:System.Windows.Controls.ComboBox>.<br />-Nie można skopiować lub wkleić parametry w <xref:System.Windows.Controls.ComboBox>.|— Można wybrać element <xref:System.Windows.Controls.ComboBox> , wprowadzając ciąg.<br />— Nie można wprowadzić ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.<br />-Nie można wybrać fragment ciągu w <xref:System.Windows.Controls.ComboBox>.<br />-Nie można skopiować lub wkleić parametry w <xref:System.Windows.Controls.ComboBox>.|  
  
 <xref:System.Windows.Controls.ComboBox.IsReadOnly%2A> Właściwość ma wpływ tylko wtedy, gdy <xref:System.Windows.Controls.ComboBox.IsEditable%2A> jest `true`.  
  
 <xref:System.Windows.Controls.ComboBox> Jest <xref:System.Windows.Controls.ItemsControl>, dzięki czemu może on wyświetlać zawartość inna niż zwykłe ciągi.  Na przykład można utworzyć <xref:System.Windows.Controls.ComboBox> zawierający listę obrazów. Przypadku zawartości innego niż ciągi w <xref:System.Windows.Controls.ComboBox>, pozbawiona sensu ciąg może się pojawić <xref:System.Windows.Controls.ComboBox> gdy jest ukryty listy rozwijanej. Aby wyświetlić ciąg w <xref:System.Windows.Controls.ComboBox> gdy zawiera on elementów niebędących ciągami, użyj <xref:System.Windows.Controls.TextSearch.Text%2A?displayProperty=nameWithType> lub <xref:System.Windows.Controls.TextSearch.TextPath%2A?displayProperty=nameWithType> dołączona właściwość.  
  
## <a name="customizing-the-combobox-control"></a>Dostosowywanie formantu ComboBox  
 Aby zastosować te same ustawienia właściwości z wieloma <xref:System.Windows.Controls.ComboBox> kontrolki, używać <xref:System.Windows.FrameworkElement.Style%2A> właściwości. Można zmodyfikować domyślne <xref:System.Windows.Controls.ControlTemplate> zapewnienie unikatowego wyglądu kontrolki. Aby uzyskać więcej informacji o tworzeniu <xref:System.Windows.Controls.ControlTemplate>, zobacz [Dostosowywanie wyglądu istniejącego formantu przez stworzenie ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Aby zobaczyć elementy i Stany, które są specyficzne dla <xref:System.Windows.Controls.ComboBox>, zobacz [ComboBox — style i szablony](~/docs/framework/wpf/controls/combobox-styles-and-templates.md).  
  
 Właściwości zależności dla tego formantu może być ustawione przez domyślnego stylu.  Jeśli właściwość jest ustawiana przez domyślnego stylu, zmienić właściwość z jego wartość domyślną gdy formant ma być wyświetlany w aplikacji. Domyślny styl jest określona, przez który motyw pulpitu jest używany podczas działania aplikacji.  Aby uzyskać więcej informacji, zobacz [domyślne motywy WPF](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  Ustawienie wartości właściwości wizualnej będzie miał wpływ tylko jeśli ta właściwość jest obecny w <xref:System.Windows.Controls.ComboBox> kontrolki użytkownika domyślnego szablonu i ustawić za pomocą. Lista właściwości visual można znaleźć w sekcji "Zmiana Visual struktury z Control" [Dostosowywanie wyglądu istniejącego formantu przez stworzenie ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Windows.Controls.ComboBox>. Przykład wypełnia <xref:System.Windows.Controls.ComboBox> przez powiązanie <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> właściwości do obiektu kolekcji typu `VacationSpots`. W przykładzie jest tworzony również <xref:System.Windows.Controls.TextBlock> wyświetlającą wybranego elementu <xref:System.Windows.Controls.ComboBox>.  
  
 [!code-xaml[ComboBoxItems#ComboBoxClass](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxItems/CSharp/Window1.xaml#comboboxclass)]  
  
 W poniższym przykładzie zdefiniowano obiekt kolekcji, <xref:System.Windows.Controls.ComboBox> w poprzednim przykładzie wiąże.  
  
 [!code-csharp[ComboBoxItems#Data](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxItems/CSharp/Window1.xaml.cs#data)]
 [!code-vb[ComboBoxItems#Data](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ComboBoxItems/VIsualBasic/Window1.xaml.vb#data)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.ComboBoxItem" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ComboBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ComboBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Controls.ComboBox" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DropDownClosed">
      <MemberSignature Language="C#" Value="public event EventHandler DropDownClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DropDownClosed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.ComboBox.DropDownClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DropDownClosed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DropDownClosed;" />
      <MemberSignature Language="F#" Value="member this.DropDownClosed : EventHandler " Usage="member this.DropDownClosed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zamknięciu listy rozwijanej pola kombi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano, jak przypisać procedury obsługi zdarzeń i sposób obsługi <xref:System.Windows.Controls.ComboBox.DropDownOpened> i <xref:System.Windows.Controls.ComboBox.DropDownClosed> zdarzenia.  
  
 [!code-xaml[ComboBoxSimple#ComboBoxEvents1](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxSimple/CSharp/Pane1.xaml#comboboxevents1)]  
  
 [!code-csharp[ComboBoxSimple#ComboBoxEvents2](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxSimple/CSharp/Pane1.xaml.cs#comboboxevents2)]
 [!code-vb[ComboBoxSimple#ComboBoxEvents2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ComboBoxSimple/VisualBasic/Pane1.xaml.vb#comboboxevents2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DropDownOpened">
      <MemberSignature Language="C#" Value="public event EventHandler DropDownOpened;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DropDownOpened" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.ComboBox.DropDownOpened" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DropDownOpened As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DropDownOpened;" />
      <MemberSignature Language="F#" Value="member this.DropDownOpened : EventHandler " Usage="member this.DropDownOpened : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu menu rozwijanego pola kombi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak przypisać procedury obsługi zdarzeń i obsługę <xref:System.Windows.Controls.ComboBox.DropDownOpened> i <xref:System.Windows.Controls.ComboBox.DropDownClosed> zdarzenia.  
  
 [!code-xaml[ComboBoxSimple#ComboBoxEvents1](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxSimple/CSharp/Pane1.xaml#comboboxevents1)]  
  
 [!code-csharp[ComboBoxSimple#ComboBoxEvents2](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxSimple/CSharp/Pane1.xaml.cs#comboboxevents2)]
 [!code-vb[ComboBoxSimple#ComboBoxEvents2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ComboBoxSimple/VisualBasic/Pane1.xaml.vb#comboboxevents2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.DependencyObject GetContainerForItemOverride ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.DependencyObject GetContainerForItemOverride() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.GetContainerForItemOverride" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetContainerForItemOverride () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::DependencyObject ^ GetContainerForItemOverride();" />
      <MemberSignature Language="F#" Value="override this.GetContainerForItemOverride : unit -&gt; System.Windows.DependencyObject" Usage="comboBox.GetContainerForItemOverride " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy lub identyfikuje element używany do wyświetlania określonego elementu.</summary>
        <returns>Element używany do wyświetlania określonego elementu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandlesScrolling">
      <MemberSignature Language="C#" Value="protected internal override bool HandlesScrolling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HandlesScrolling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ComboBox.HandlesScrolling" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property HandlesScrolling As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool HandlesScrolling { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HandlesScrolling : bool" Usage="System.Windows.Controls.ComboBox.HandlesScrolling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pole kombi obsługuje przewijania.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Controls.ComboBox" /> obsługuje przewijania; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli kontrolka ma <xref:System.Windows.Controls.ScrollViewer> w jego styl i ma klawiatury niestandardowej przewijanie zachowanie <xref:System.Windows.Controls.ListBox.HandlesScrolling%2A> powinna zwrócić `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasEffectiveKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal override bool HasEffectiveKeyboardFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasEffectiveKeyboardFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ComboBox.HasEffectiveKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property HasEffectiveKeyboardFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool HasEffectiveKeyboardFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasEffectiveKeyboardFocus : bool" Usage="System.Windows.Controls.ComboBox.HasEffectiveKeyboardFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Windows.Controls.ComboBox" /> jest ustawiony fokus.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Controls.ComboBox" /> ma fokus; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDropDownOpen">
      <MemberSignature Language="C#" Value="public bool IsDropDownOpen { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDropDownOpen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ComboBox.IsDropDownOpen" />
      <MemberSignature Language="VB.NET" Value="Public Property IsDropDownOpen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDropDownOpen { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsDropDownOpen : bool with get, set" Usage="System.Windows.Controls.ComboBox.IsDropDownOpen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy lista rozwijana pola kombi jest obecnie otwarty.</summary>
        <value>
          <see langword="true" /> Jeśli na liście rozwijanej jest otwarte. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsDropDownOpen"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ComboBox.IsDropDownOpenProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Controls.ComboBox.IsDropDownOpen%2A> właściwość, aby utworzyć pole kombi z listy rozwijanej kontrolki otwarte po zainicjowaniu pola kombi.  
  
 [!code-xaml[ComboBoxStyles#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxStyles/CS/app.xaml#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDropDownOpenProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsDropDownOpenProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsDropDownOpenProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ComboBox.IsDropDownOpenProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsDropDownOpenProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsDropDownOpenProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsDropDownOpenProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ComboBox.IsDropDownOpenProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ComboBox.IsDropDownOpen" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEditable">
      <MemberSignature Language="C#" Value="public bool IsEditable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEditable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ComboBox.IsEditable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEditable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEditable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEditable : bool with get, set" Usage="System.Windows.Controls.ComboBox.IsEditable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która włącza lub wyłącza edytowanie tekstu w polu tekstowym <see cref="T:System.Windows.Controls.ComboBox" />.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Controls.ComboBox" /> może być edytowany; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ComboBox.IsEditable%2A> i <xref:System.Windows.Controls.ComboBox.IsReadOnly%2A> właściwości określają sposób, w jaki <xref:System.Windows.Controls.ComboBox> działa, gdy użytkownik wykona jedną z następujących czynności:  
  
-   Wprowadza ciąg, aby wybrać element w <xref:System.Windows.Controls.ComboBox>.  
  
-   Wprowadza ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.  
  
-   Wybiera fragment ciągu, który znajduje się w polu tekstowym.  
  
-   Kopiuje i wkleja wartość w polu tekstowym.  
  
 W poniższej tabeli opisano akcje, które użytkownik może i nie może potrwać w zależności od wartości <xref:System.Windows.Controls.ComboBox.IsEditable%2A> i <xref:System.Windows.Controls.ComboBox.IsReadOnly%2A>.  
  
||<xref:System.Windows.Controls.ComboBox.IsReadOnly%2A> jest `true`|<xref:System.Windows.Controls.ComboBox.IsReadOnly%2A> jest `false`|  
|-|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Windows.Controls.ComboBox.IsEditable%2A> jest `true`|-Nie można wybrać element <xref:System.Windows.Controls.ComboBox> , wprowadzając ciąg.<br />— Nie można wprowadzić ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.<br />— Można wybrać fragment ciągu w <xref:System.Windows.Controls.ComboBox> pola tekstowego.<br />— Można skopiować ciąg w <xref:System.Windows.Controls.ComboBox> tekst pola, ale nie można wkleić ciąg do <xref:System.Windows.Controls.ComboBox> pola tekstowego.|— Można wybrać element <xref:System.Windows.Controls.ComboBox> , wprowadzając ciąg.<br />— Można wprowadzić ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.<br />— Można wybrać fragment ciągu w <xref:System.Windows.Controls.ComboBox> pola tekstowego.<br />— Można skopiować lub wkleić parametry w <xref:System.Windows.Controls.ComboBox> pola tekstowego.|  
|<xref:System.Windows.Controls.ComboBox.IsEditable%2A> jest `false`|— Można wybrać element <xref:System.Windows.Controls.ComboBox> , wprowadzając ciąg.<br />— Nie można wprowadzić ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.<br />-Nie można wybrać fragment ciągu w <xref:System.Windows.Controls.ComboBox>.<br />-Nie można skopiować lub wkleić parametry w <xref:System.Windows.Controls.ComboBox>.|— Można wybrać element <xref:System.Windows.Controls.ComboBox> , wprowadzając ciąg.<br />— Nie można wprowadzić ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.<br />-Nie można wybrać fragment ciągu w <xref:System.Windows.Controls.ComboBox>.<br />-Nie można skopiować lub wkleić parametry w <xref:System.Windows.Controls.ComboBox>.|  
  
 Gdy <xref:System.Windows.Controls.ComboBox.IsEditable%2A> jest równa `false`, <xref:System.Windows.Controls.ComboBox> używa <xref:System.Windows.Controls.ContentPresenter> Aby wyświetlić aktualnie wybranego elementu; gdy <xref:System.Windows.Controls.ComboBox.IsEditable%2A> jest równa `true`, <xref:System.Windows.Controls.TextBox> zamian jest używana w tym celu. Należy pamiętać, że <xref:System.Windows.Controls.TextBox> i zwykłego tekstu, które są wyświetlane tylko <xref:System.Windows.Controls.ComboBoxItem> mogą obejmować zawartość — zwykły tekst, taką jak obrazy.  
  
<a name="dependencyPropertyInfo_IsEditable"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ComboBox.IsEditableProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższe przykłady tworzą <xref:System.Windows.Controls.ComboBox> formantów, które zawierają obrazy jako elementy zamiast tekstu. Jeśli <xref:System.Windows.Controls.ComboBox.IsEditable%2A> właściwość jest ustawiona na `true`, <xref:System.Windows.Controls.TextBox> Wyświetla wartość zwrócona przez obiekt na ilustracji <xref:System.Object.ToString%2A> metody. Aby uniknąć <xref:System.Windows.Controls.TextBox> nieoczekiwany tekstu, należy użyć <xref:System.Windows.Controls.TextSearch.Text%2A?displayProperty=nameWithType> i <xref:System.Windows.Controls.TextSearch.TextPath%2A?displayProperty=nameWithType> właściwości, aby przypisać tekst do wyświetlenia.  
  
 [!code-xaml[ComboBoxProps_snip#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxProps_snip/CS/pane1.xaml#1)]  
  
 [!code-xaml[ComboBoxProps_snip#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxProps_snip/CS/pane1.xaml#2)]  
  
 Innym rozwiązaniem jest użycie <xref:System.Windows.Controls.ItemsControl.DisplayMemberPath%2A> właściwości. Lista rozwijana z <xref:System.Windows.Controls.ComboBox> obrazy nie będą wyświetlane, ale będzie wyświetlany tekst przypisany.  
  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Controls.ItemsControl.DisplayMemberPath%2A>.  
  
 [!code-xaml[ComboBoxProps_snip#3](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxProps_snip/CS/pane1.xaml#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEditableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEditableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEditableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ComboBox.IsEditableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEditableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEditableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsEditableProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ComboBox.IsEditableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ComboBox.IsEditable" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsItemItsOwnContainerOverride">
      <MemberSignature Language="C#" Value="protected override bool IsItemItsOwnContainerOverride (object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsItemItsOwnContainerOverride(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.IsItemItsOwnContainerOverride(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsItemItsOwnContainerOverride (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsItemItsOwnContainerOverride(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="override this.IsItemItsOwnContainerOverride : obj -&gt; bool" Usage="comboBox.IsItemItsOwnContainerOverride item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Określony element.</param>
        <summary>Określa, czy określony element jest (lub kwalifikuje się jako) swój własny <c>ItemContainer</c>.</summary>
        <returns>
          <see langword="true" /> Jeśli element znajduje się własną <c>ItemContainer</c>; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ComboBox.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool with get, set" Usage="System.Windows.Controls.ComboBox.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która włącza tryb tylko do wyboru, w którym zawartość pola kombi są można wybierać, ale nie można edytować.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Controls.ComboBox" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ComboBox.IsEditable%2A> i <xref:System.Windows.Controls.ComboBox.IsReadOnly%2A> właściwości określają sposób, w jaki <xref:System.Windows.Controls.ComboBox> działa, gdy użytkownik wykona jedną z następujących czynności:  
  
-   Wprowadza ciąg, aby wybrać element w <xref:System.Windows.Controls.ComboBox>.  
  
-   Wprowadza ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.  
  
-   Wybiera fragment ciągu, który znajduje się w polu tekstowym.  
  
-   Kopiuje i wkleja wartość w polu tekstowym.  
  
 W poniższej tabeli opisano akcje, które użytkownik może i nie może potrwać w zależności od wartości <xref:System.Windows.Controls.ComboBox.IsEditable%2A> i <xref:System.Windows.Controls.ComboBox.IsReadOnly%2A>.  
  
||<xref:System.Windows.Controls.ComboBox.IsReadOnly%2A> jest `true`|<xref:System.Windows.Controls.ComboBox.IsReadOnly%2A> jest `false`|  
|-|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Windows.Controls.ComboBox.IsEditable%2A> jest `true`|-Nie można wybrać element <xref:System.Windows.Controls.ComboBox> , wprowadzając ciąg.<br />— Nie można wprowadzić ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.<br />— Można wybrać fragment ciągu w <xref:System.Windows.Controls.ComboBox> pola tekstowego.<br />— Można skopiować ciąg w <xref:System.Windows.Controls.ComboBox> tekst pola, ale nie można wkleić ciąg do <xref:System.Windows.Controls.ComboBox> pola tekstowego.|— Można wybrać element <xref:System.Windows.Controls.ComboBox> , wprowadzając ciąg.<br />— Można wprowadzić ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.<br />— Można wybrać fragment ciągu w <xref:System.Windows.Controls.ComboBox> pola tekstowego.<br />— Można skopiować lub wkleić parametry w <xref:System.Windows.Controls.ComboBox> pola tekstowego.|  
|<xref:System.Windows.Controls.ComboBox.IsEditable%2A> jest `false`|— Można wybrać element <xref:System.Windows.Controls.ComboBox> , wprowadzając ciąg.<br />— Nie można wprowadzić ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.<br />-Nie można wybrać fragment ciągu w <xref:System.Windows.Controls.ComboBox>.<br />-Nie można skopiować lub wkleić parametry w <xref:System.Windows.Controls.ComboBox>.|— Można wybrać element <xref:System.Windows.Controls.ComboBox> , wprowadzając ciąg.<br />— Nie można wprowadzić ciąg, który jest niezgodny z elementem w <xref:System.Windows.Controls.ComboBox>.<br />-Nie można wybrać fragment ciągu w <xref:System.Windows.Controls.ComboBox>.<br />-Nie można skopiować lub wkleić parametry w <xref:System.Windows.Controls.ComboBox>.|  
  
 Gdy <xref:System.Windows.Controls.ComboBox.IsEditable%2A> jest równa `false`, <xref:System.Windows.Controls.ComboBox> używa <xref:System.Windows.Controls.ContentPresenter> Aby wyświetlić aktualnie wybranego elementu; gdy <xref:System.Windows.Controls.ComboBox.IsEditable%2A> jest równa `true`, <xref:System.Windows.Controls.TextBox> zamian jest używana w tym celu. Należy pamiętać, że <xref:System.Windows.Controls.TextBox> i zwykłego tekstu, które są wyświetlane tylko <xref:System.Windows.Controls.ComboBoxItem> mogą obejmować zawartość — zwykły tekst, taką jak obrazy.  
  
<a name="dependencyPropertyInfo_IsReadOnly"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ComboBox.IsReadOnlyProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.Windows.Controls.ComboBox> za pomocą edycji <xref:System.Windows.Controls.TextBox>. <xref:System.Windows.Controls.ComboBox.IsReadOnly%2A> Właściwość jest ustawiona na `true`, dzięki czemu użytkownik nie może wprowadzić tekst do <xref:System.Windows.Controls.TextBox>.  
  
 [!code-xaml[ComboBoxItems#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxItems/CSharp/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnlyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsReadOnlyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsReadOnlyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ComboBox.IsReadOnlyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsReadOnlyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsReadOnlyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsReadOnlyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ComboBox.IsReadOnlyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ComboBox.IsReadOnly" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSelectionBoxHighlighted">
      <MemberSignature Language="C#" Value="public bool IsSelectionBoxHighlighted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSelectionBoxHighlighted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ComboBox.IsSelectionBoxHighlighted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSelectionBoxHighlighted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSelectionBoxHighlighted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSelectionBoxHighlighted : bool" Usage="System.Windows.Controls.ComboBox.IsSelectionBoxHighlighted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy <see cref="P:System.Windows.Controls.ComboBox.SelectionBoxItem" /> zostanie wyróżniona.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="P:System.Windows.Controls.ComboBox.SelectionBoxItem" /> jest wyróżniony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest właściwość zależności. Jednak pole identyfikatora właściwości zależności <xref:System.Windows.Controls.ComboBox.IsSelectionBoxHighlighted%2A> nie jest publiczna. W związku z tym, nie można użyć właściwości zależności zapasowy dla operacji systemu właściwości, które wymaga identyfikatora właściwości zależności, takie jak wywołania <xref:System.Windows.DependencyObject.GetValue%2A>. Jednak nadal można użyć <xref:System.Windows.Controls.ComboBox.IsSelectionBoxHighlighted%2A> jako wyzwalacz właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxDropDownHeight">
      <MemberSignature Language="C#" Value="public double MaxDropDownHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxDropDownHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ComboBox.MaxDropDownHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxDropDownHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxDropDownHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxDropDownHeight : double with get, set" Usage="System.Windows.Controls.ComboBox.MaxDropDownHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną wysokość dla mierników rozwijane pole kombi.</summary>
        <value>Wartość podwójnej precyzji, która przedstawia wysokość, które są pobierane lub wysokość do ustawienia. Wartość domyślna, zgodnie z definicją w systemie właściwości jest obliczoną wartość opartą na jedną trzecią część parametrów wysokość maksymalna ekranu systemu, ale to ustawienie domyślne, potencjalnie jest zastępowany przez różne szablony kontrolek.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Automatycznego ustalania rozmiaru nie jest domyślnie i będą powodować na liście rozwijanej rozmiar potencjalnie przekracza dostępny rozmiar elementu nadrzędnego. Nie jest to zazwyczaj pożądane.  
  
<a name="dependencyPropertyInfo_MaxDropDownHeight"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ComboBox.MaxDropDownHeightProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
<a name="xamlAttributeUsage_MaxDropDownHeight"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object MaxDropDownHeight="double"/>  
- or –  
<object MaxDropDownHeight ="qualifiedDouble"/>  
- or -  
<object MaxDropDownHeight ="Auto"/>  
```  
  
<a name="xamlValues_MaxDropDownHeight"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość. To jest interpretowane jako [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] miary. Ciągi nie musi jawnie zawierać separatorów dziesiętnych. Na przykład wartość `1` jest dopuszczalna.  
  
 Taki sam <xref:System.Double> obowiązują ograniczenia zakresu, zgodnie z opisem w sekcji wartości właściwości.  
  
 *qualifiedDouble*  
 A *double* wartość zgodnie z opisem powyżej, a następnie za pomocą jednej z następujących ciągów jednostki w deklaracji: `px`, `in`, `cm`, `pt`.  
  
 `px` (domyślnie) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` centymetrów; 1cm==(96/2.54) piks.  
  
 `pt` jest punktów. 1pt==(96/72) piks.  
  
 `Auto`  
 Włącza zachowanie automatyczne określanie rozmiaru. Zobacz uwagi.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Windows.Controls.ComboBox.MaxDropDownHeight%2A> właściwości w celu określenia wysokości <xref:System.Windows.Controls.ComboBox> formantu użytkownika z listy rozwijanej.  
  
 [!code-xaml[ComboBoxStyles#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxStyles/CS/app.xaml#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxDropDownHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxDropDownHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxDropDownHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ComboBox.MaxDropDownHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxDropDownHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxDropDownHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxDropDownHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ComboBox.MaxDropDownHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ComboBox.MaxDropDownHeight" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public override void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="override this.OnApplyTemplate : unit -&gt; unit" Usage="comboBox.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływane, gdy <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" /> jest wywoływana.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="comboBox.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia odpowiednią <see cref="T:System.Windows.Automation.Peers.ComboBoxAutomationPeer" /> implementacji dla tej kontrolki, jako część [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] infrastruktury.</summary>
        <returns>Konkretny typ <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDropDownClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnDropDownClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDropDownClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.OnDropDownClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDropDownClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDropDownClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDropDownClosed : EventArgs -&gt; unit&#xA;override this.OnDropDownClosed : EventArgs -&gt; unit" Usage="comboBox.OnDropDownClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzeń dla <see cref="E:System.Windows.Controls.ComboBox.DropDownClosed" /> zdarzeń.</param>
        <summary>Raporty po zamknięciu okna podręcznego pola kombi.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDropDownOpened">
      <MemberSignature Language="C#" Value="protected virtual void OnDropDownOpened (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDropDownOpened(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.OnDropDownOpened(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDropDownOpened (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDropDownOpened(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDropDownOpened : EventArgs -&gt; unit&#xA;override this.OnDropDownOpened : EventArgs -&gt; unit" Usage="comboBox.OnDropDownOpened e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzeń dla <see cref="E:System.Windows.Controls.ComboBox.DropDownOpened" /> zdarzeń.</param>
        <summary>Raporty, gdy zostanie otwarte okno podręczne pola kombi.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected override void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="comboBox.OnIsKeyboardFocusWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzeń dla <see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /> zdarzeń.</param>
        <summary>Informuje, że <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected override void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="comboBox.OnIsMouseCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzeń dla <see cref="E:System.Windows.UIElement.IsMouseCapturedChanged" /> zdarzeń.</param>
        <summary>Wywoływane, gdy <see cref="P:System.Windows.UIElement.IsMouseCaptured" /> zmiany właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="comboBox.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> dołączone zdarzenie trasowane występuje.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="comboBox.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzeń dla <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /> zdarzeń.</param>
        <summary>Wywołuje się, aby zgłosić zwolnienie lewego przycisku myszy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="comboBox.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dane zdarzenia.</param>
        <summary>Wywoływane, gdy <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> dołączone zdarzenie trasowane występuje.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected override void OnSelectionChanged (System.Windows.Controls.SelectionChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnSelectionChanged(class System.Windows.Controls.SelectionChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.OnSelectionChanged(System.Windows.Controls.SelectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnSelectionChanged (e As SelectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnSelectionChanged(System::Windows::Controls::SelectionChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnSelectionChanged : System.Windows.Controls.SelectionChangedEventArgs -&gt; unit" Usage="comboBox.OnSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.SelectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Udostępnia dane dla <see cref="T:System.Windows.Controls.SelectionChangedEventArgs" />.</param>
        <summary>Odpowiada <see cref="T:System.Windows.Controls.ComboBox" /> zmiana zaznaczenia, tworząc <see cref="E:System.Windows.Controls.Primitives.Selector.SelectionChanged" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected override void PrepareContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void PrepareContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ComboBox.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub PrepareContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void PrepareContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="override this.PrepareContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="comboBox.PrepareContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="element">Element służący do wyświetlania określonego elementu.</param>
        <param name="item">Określony element.</param>
        <summary>Przygotowuje określony element, aby wyświetlić określony element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trwa przygotowywanie elementu może obejmować stosowanie stylów, ustawienia powiązania i tak dalej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBoxItem">
      <MemberSignature Language="C#" Value="public object SelectionBoxItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SelectionBoxItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ComboBox.SelectionBoxItem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectionBoxItem As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SelectionBoxItem { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBoxItem : obj" Usage="System.Windows.Controls.ComboBox.SelectionBoxItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element, który jest wyświetlany w polu wyboru.</summary>
        <value>Wybrany element.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ControlTemplate> z <xref:System.Windows.Controls.ComboBox> używa tej właściwości, aby wyświetlić wybranego elementu w <xref:System.Windows.Controls.ComboBox>.  Można pobrać wybranego elementu <xref:System.Windows.Controls.ComboBox> poza <xref:System.Windows.Controls.ControlTemplate>, użyj <xref:System.Windows.Controls.Primitives.Selector.SelectedItem%2A?displayProperty=nameWithType> właściwości zamiast tej właściwości.  
  
<a name="xamlAttributeUsage_SelectionBoxItem"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="{TemplateBinding SelectionBoxItem}"/>  
```  
  
<a name="dependencyPropertyInfo_SelectionBoxItem"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ComboBox.SelectionBoxItemProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład tworzy powiązanie <xref:System.Windows.Controls.ContentPresenter.Content%2A> właściwość <xref:System.Windows.Controls.ContentPresenter> do <xref:System.Windows.Controls.ComboBox.SelectionBoxItem%2A> właściwości. <xref:System.Windows.Controls.ContentPresenter> Jest częścią <xref:System.Windows.Controls.ControlTemplate> dla <xref:System.Windows.Controls.ComboBox>. Aby uzyskać pełny przykład, zobacz [style przykład ControlTemplates](http://go.microsoft.com/fwlink/?LinkID=160041).  
  
 [!code-xaml[ControlTemplateExamples#ComboBoxSelectionBox](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlTemplateExamples/CS/resources/combobox.xaml#comboboxselectionbox)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBoxItemProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SelectionBoxItemProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SelectionBoxItemProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ComboBox.SelectionBoxItemProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SelectionBoxItemProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SelectionBoxItemProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SelectionBoxItemProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ComboBox.SelectionBoxItemProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ComboBox.SelectionBoxItem" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBoxItemStringFormat">
      <MemberSignature Language="C#" Value="public string SelectionBoxItemStringFormat { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectionBoxItemStringFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ComboBox.SelectionBoxItemStringFormat" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectionBoxItemStringFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SelectionBoxItemStringFormat { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBoxItemStringFormat : string" Usage="System.Windows.Controls.ComboBox.SelectionBoxItemStringFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera złożony ciąg, który określa sposób formatowania zaznaczonego elementu w polu wyboru, jeśli jest wyświetlany jako ciąg.</summary>
        <value>Złożony ciąg, który określa sposób formatowania zaznaczonego elementu w polu wyboru, jeśli jest wyświetlany jako ciąg.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBoxItemStringFormatProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SelectionBoxItemStringFormatProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SelectionBoxItemStringFormatProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ComboBox.SelectionBoxItemStringFormatProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SelectionBoxItemStringFormatProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SelectionBoxItemStringFormatProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SelectionBoxItemStringFormatProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ComboBox.SelectionBoxItemStringFormatProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ComboBox.SelectionBoxItemStringFormat" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBoxItemTemplate">
      <MemberSignature Language="C#" Value="public System.Windows.DataTemplate SelectionBoxItemTemplate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DataTemplate SelectionBoxItemTemplate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ComboBox.SelectionBoxItemTemplate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectionBoxItemTemplate As DataTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DataTemplate ^ SelectionBoxItemTemplate { System::Windows::DataTemplate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBoxItemTemplate : System.Windows.DataTemplate" Usage="System.Windows.Controls.ComboBox.SelectionBoxItemTemplate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DataTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera szablon elementu zawartości pola wyboru.</summary>
        <value>Szablon elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_SelectionBoxItemTemplate"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="{TemplateBinding SelectionBoxItemTemplate}"/>  
```  
  
<a name="dependencyPropertyInfo_SelectionBoxItemTemplate"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ComboBox.SelectionBoxItemTemplateProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 Poniższy przykład tworzy powiązanie <xref:System.Windows.Controls.ContentPresenter.Content%2A> właściwość <xref:System.Windows.Controls.ContentPresenter> do <xref:System.Windows.Controls.ComboBox.SelectionBoxItemTemplate%2A> właściwości. <xref:System.Windows.Controls.ContentPresenter> Jest częścią <xref:System.Windows.Controls.ControlTemplate> dla <xref:System.Windows.Controls.ComboBox>. Aby uzyskać pełny przykład, zobacz [style przykład ControlTemplates](http://go.microsoft.com/fwlink/?LinkID=160041).  
  
 [!code-xaml[ControlTemplateExamples#ComboBoxSelectionBox](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlTemplateExamples/CS/resources/combobox.xaml#comboboxselectionbox)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBoxItemTemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SelectionBoxItemTemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SelectionBoxItemTemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ComboBox.SelectionBoxItemTemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SelectionBoxItemTemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SelectionBoxItemTemplateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SelectionBoxItemTemplateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ComboBox.SelectionBoxItemTemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ComboBox.SelectionBoxItemTemplate" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldPreserveUserEnteredPrefix">
      <MemberSignature Language="C#" Value="public bool ShouldPreserveUserEnteredPrefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldPreserveUserEnteredPrefix" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ComboBox.ShouldPreserveUserEnteredPrefix" />
      <MemberSignature Language="VB.NET" Value="Public Property ShouldPreserveUserEnteredPrefix As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShouldPreserveUserEnteredPrefix { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShouldPreserveUserEnteredPrefix : bool with get, set" Usage="System.Windows.Controls.ComboBox.ShouldPreserveUserEnteredPrefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Windows.Controls.ComboBox" /> przechowuje dane wejściowe podane przez użytkownika, lub zastępuje pasujący element danych wejściowych.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Windows.Controls.ComboBox" /> przechowuje wejściowych użytkownika; <see langword="false" /> Jeśli <see cref="T:System.Windows.Controls.ComboBox" /> dane wejściowe są zastępowane pasujący element zarejestrowaną wartością domyślną jest <see langword="false" />. Aby uzyskać więcej informacji o obiektach mogących wpływać wartość, zobacz [następstwo wartości właściwości](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie, gdy użytkownik wpisze ciąg do <xref:System.Windows.Controls.ComboBox> , które odpowiadają jednej z jego elementów i element jest zaznaczony tekst wpisany przez użytkownika.  Może to spowodować, że tekst, który użytkownik wprowadzi zmiany sprawy. Jeśli <xref:System.Windows.Controls.ComboBox.ShouldPreserveUserEnteredPrefix%2A> właściwość jest ustawiona na `true`, <xref:System.Windows.Controls.ComboBox> wybiera pasujący element, ale zachowuje tekst, wprowadzonej przez użytkownika.   Na przykład załóżmy, że <xref:System.Windows.Controls.ComboBox> zawiera ciąg "Hello" (z wielkiej litery H), a użytkownik wprowadzi "hello" (z małe litery h).  Jeśli <xref:System.Windows.Controls.ComboBox.ShouldPreserveUserEnteredPrefix%2A> jest `false`, <xref:System.Windows.Controls.ComboBox> wybiera pasujący element, "Hello", w swojej kolekcji i wypełnienie jej pole tekstowe z tego ciągu.    Jeśli <xref:System.Windows.Controls.ComboBox.ShouldPreserveUserEnteredPrefix%2A> jest `true`, "Hello" jest zaznaczone z kolekcji, ale pole tekstowe jest wyświetlany komunikat "hello".  
  
<a name="dependencyPropertyInfo_ShouldPreserveUserEnteredPrefix"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ComboBox.ShouldPreserveUserEnteredPrefixProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldPreserveUserEnteredPrefixProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShouldPreserveUserEnteredPrefixProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShouldPreserveUserEnteredPrefixProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ComboBox.ShouldPreserveUserEnteredPrefixProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShouldPreserveUserEnteredPrefixProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShouldPreserveUserEnteredPrefixProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShouldPreserveUserEnteredPrefixProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ComboBox.ShouldPreserveUserEnteredPrefixProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ComboBox.ShouldPreserveUserEnteredPrefix" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StaysOpenOnEdit">
      <MemberSignature Language="C#" Value="public bool StaysOpenOnEdit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool StaysOpenOnEdit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ComboBox.StaysOpenOnEdit" />
      <MemberSignature Language="VB.NET" Value="Public Property StaysOpenOnEdit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool StaysOpenOnEdit { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.StaysOpenOnEdit : bool with get, set" Usage="System.Windows.Controls.ComboBox.StaysOpenOnEdit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czy <see cref="T:System.Windows.Controls.ComboBox" /> oznacza to otwarte i wyświetla kontrolkę listy rozwijanej pozostanie Otwórz gdy użytkownik kliknie <see cref="T:System.Windows.Controls.TextBox" />.</summary>
        <value>
          <see langword="true" /> Aby zachować lista rozwijana Otwórz kiedy użytkownik kliknie w obszarze tekstowym, aby rozpocząć edycję; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_StaysOpenOnEdit"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ComboBox.StaysOpenOnEditProperty>|  
|Ustaw właściwości metadanych `true`|Brak|  
  
   
  
## Examples  
 W tym przykładzie pokazano, jak używać <xref:System.Windows.Controls.ComboBox.StaysOpenOnEdit%2A> właściwość, aby utworzyć pole kombi, którego lista rozwijana pozostanie otwarte, gdy użytkownik wprowadza informacje w polu tekstowym.  
  
 [!code-xaml[ComboBoxItems#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxItems/CSharp/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StaysOpenOnEditProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StaysOpenOnEditProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StaysOpenOnEditProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ComboBox.StaysOpenOnEditProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StaysOpenOnEditProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StaysOpenOnEditProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StaysOpenOnEditProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ComboBox.StaysOpenOnEditProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ComboBox.StaysOpenOnEdit" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ComboBox.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Controls.ComboBox.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tekst, który aktualnie wybranego elementu.</summary>
        <value>Ciąg, który aktualnie wybranego elementu. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Controls.ComboBox.IsEditable%2A> właściwość `true`, ustawienie tej właściwości umieszcza początkowy tekst wprowadzony w polu tekstowym. Gdy <xref:System.Windows.Controls.ComboBox.IsEditable%2A> jest `false`, ustawienie tej wartości nie ma wpływu.  
  
<a name="dependencyPropertyInfo_Text"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.ComboBox.TextProperty>|  
|Ustaw właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Journal%2A>|  
  
   
  
## Examples  
 Ten przykład przedstawia sposób, w jaki <xref:System.Windows.Controls.ComboBox.Text%2A> właściwość można ustawić tekst do <xref:System.Windows.Controls.TextBox> zanim użytkownik dokona zaznaczenia.  
  
 [!code-xaml[ComboBoxItems#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxItems/CSharp/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ComboBox.TextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ComboBox.TextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje <see cref="P:System.Windows.Controls.ComboBox.Text" /> właściwość zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
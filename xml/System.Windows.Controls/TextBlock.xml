<Type Name="TextBlock" FullName="System.Windows.Controls.TextBlock">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ec3eb7e60dce5d686d5835bd53db7ba07b0210f1" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69212705" /></Metadata><TypeSignature Language="C#" Value="public class TextBlock : System.Windows.FrameworkElement, IServiceProvider, System.Windows.IContentHost" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi TextBlock extends System.Windows.FrameworkElement implements class System.IServiceProvider, class System.Windows.IContentHost, class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.TextBlock" />
  <TypeSignature Language="VB.NET" Value="Public Class TextBlock&#xA;Inherits FrameworkElement&#xA;Implements IContentHost, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextBlock : System::Windows::FrameworkElement, IServiceProvider, System::Windows::IContentHost" />
  <TypeSignature Language="F#" Value="type TextBlock = class&#xA;    inherit FrameworkElement&#xA;    interface IContentHost&#xA;    interface IAddChild&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IContentHost</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Text)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Inlines")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia lekki formant do wyświetlania małych ilości zawartości przepływu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.Bold> <xref:System.Windows.Documents.Inline> <xref:System.Windows.Documents.Hyperlink> <xref:System.Windows.Controls.TextBlock.Inlines%2A> <xref:System.Windows.Documents.InlineUIContainer>Może zawierać ciąg w jego <xref:System.Windows.Controls.TextBlock.Text%2A> właściwości lub elementy zawartości przepływu, takie jak,, i, w swojej właściwości. <xref:System.Windows.Controls.TextBlock>  
  
 <xref:System.Windows.Controls.TextBlock>jest zaprojektowana jako uproszczona i jest ukierunkowana na integrowanie małych części zawartości przepływu w [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].  <xref:System.Windows.Controls.TextBlock>jest zoptymalizowany pod kątem wyświetlania jednowierszowego i zapewnia dobrą wydajność do wyświetlania kilku wierszy zawartości.  
  
 <xref:System.Windows.Controls.TextBlock>nie jest zoptymalizowany pod kątem scenariuszy, które wymagają wyświetlania więcej niż kilku wierszy zawartości; w takich scenariuszach jest to <xref:System.Windows.Documents.FlowDocument> lepszy wybór, który jest połączony z odpowiednią kontrolką wyświetlania, <xref:System.Windows.Controls.TextBlock>niż w przypadku wydajności.  Po <xref:System.Windows.Controls.TextBlock> [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], <xref:System.Windows.Controls.FlowDocumentScrollViewer> jest następną najjaśniejszym formantem do wyświetlania zawartości przepływu, a po prostu udostępnia obszar zawartości przewijanej o minimalnym stopniu.  <xref:System.Windows.Controls.FlowDocumentPageViewer>jest zoptymalizowany pod kątem trybu przeglądania "Strona-godzina" na potrzeby zawartości przepływu.  Na koniec <xref:System.Windows.Controls.FlowDocumentReader> program obsługuje bogatsze funkcje zestawu do wyświetlania zawartości przepływu, ale jest odpowiednio cięższe.  
  
 Wyrównanie tekstu w poziomie w obrębie <xref:System.Windows.Controls.TextBlock> jest wykonywane <xref:System.Windows.Controls.TextBlock.TextAlignment%2A> z właściwością. Wyrównywanie <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> w układzie strony odbywa się przy użyciu właściwości i. <xref:System.Windows.Controls.TextBlock>  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock> jak używać elementu.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockSimpleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblocksimplexaml)]  
  
 Na poniższej ilustracji przedstawiono sposób renderowania tego przykładu.  
  
 ![Zrzut ekranu ]Zrzutekranu(~/add/media/textblock-simple.png ": Bloki tekstu i przyciski")  
  
 Poniższy przykład pokazuje, jak w sposób programistyczny uzyskać podobne wyniki.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblocksimple)]
 [!code-vb[FlowDocumentSnippets#_TextBlockSimple](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblocksimple)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.Label" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160053">Przykład galerii formantów WPF</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Controls.TextBlock" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextBlock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Controls.TextBlock" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBlock (System.Windows.Documents.Inline inline);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.Inline inline) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.#ctor(System.Windows.Documents.Inline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextBlock(System::Windows::Documents::Inline ^ inline);" />
      <MemberSignature Language="F#" Value="new System.Windows.Controls.TextBlock : System.Windows.Documents.Inline -&gt; System.Windows.Controls.TextBlock" Usage="new System.Windows.Controls.TextBlock inline" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="inline" Type="System.Windows.Documents.Inline" />
      </Parameters>
      <Docs>
        <param name="inline">Obiekt pochodny klasy abstrakcyjnej <see cref="T:System.Windows.Documents.Inline" /> , który ma zostać dodany jako zawartość początkowa.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Controls.TextBlock" /> klasy, dodając określony <see cref="T:System.Windows.Documents.Inline" /> element jako początkową zawartość wyświetlaną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prawidłowe typy wejściowe dla `inline` dyrektywy <xref:System.Windows.Documents.AnchoredBlock>include <xref:System.Windows.Documents.InlineUIContainer>, <xref:System.Windows.Documents.LineBreak>, <xref:System.Windows.Documents.Run>, i <xref:System.Windows.Documents.Span>.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tego konstruktora.  W tym przypadku <xref:System.Windows.Controls.TextBlock> zawiera tekst <xref:System.Windows.Documents.Run>.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockConstructorSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockconstructorsimple)]
 [!code-vb[FlowDocumentSnippets#_TextBlockConstructorSimple](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockconstructorsimple)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="inline" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size ArrangeOverride (System.Windows.Size arrangeSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function ArrangeOverride (arrangeSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeSize);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="textBlock.ArrangeOverride arrangeSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeSize">W elemencie nadrzędnym hostingu <see cref="T:System.Windows.Controls.TextBlock" /> , którego powinien używać, aby rozmieścić siebie i jej elementy podrzędne. <see cref="T:System.Windows.Size" /> Ograniczenia rozmiaru mogą mieć wpływ na ten żądany rozmiar.</param>
        <summary>Ustawia elementy podrzędne i określa rozmiar <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <returns>Rzeczywista <see cref="T:System.Windows.Size" /> wartość użyta do rozmieszczenia elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.Windows.FrameworkElement.ArrangeOverride%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Background : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.TextBlock.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.Brush" /> używany do wypełnienia tła obszaru zawartości.</summary>
        <value>Pędzel używany do wypełniania tła obszaru zawartości lub <see langword="null" /> nie do używania pędzla w tle. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Windows.Controls.TextBlock.Background%2A> ustawienia elementów podrzędnych przesłaniają to ustawienie najwyższego poziomu.  
  
 Aby uzyskać tabelę próbek pokazującą dostępne wstępnie zdefiniowane kolory pędzla, zobacz <xref:System.Windows.Media.Brushes>.  
  
<a name="dependencyPropertyInfo_Background"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.BackgroundProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.Background%2A> jak ustawić atrybut <xref:System.Windows.Controls.TextBlock> elementu.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.Background%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BackgroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.Background" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaselineOffset">
      <MemberSignature Language="C#" Value="public double BaselineOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 BaselineOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.BaselineOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property BaselineOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double BaselineOffset { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.BaselineOffset : double with get, set" Usage="System.Windows.Controls.TextBlock.BaselineOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wielkość, o jaką każdy wiersz tekstu ma być przesunięty z linii bazowej.</summary>
        <value>Wielkość, o którą każdy wiersz tekstu jest przesunięty z linii bazowej, w pikselach niezależnych od urządzenia. <see cref="F:System.Double.NaN" />wskazuje, że optymalne przesunięcie linii bazowej jest automatycznie obliczane na podstawie bieżących cech czcionki. Wartość domyślna to <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Linia bazowa to linia urojona w poziomie, z którą jest wyrównywana podstawa każdego znaku w wierszu tekstu.  
  
 Ta właściwość zależności ma również przypisane użycie właściwości. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie użycie `<object TextBlock.BaselineOffset="double".../>`ma wartość, gdzie *obiekt* jest elementem obiektu (zazwyczaj jest <xref:System.Windows.Controls.TextBlock>to element przepływu) zawarty w elemencie. W kodzie użycie dołączonej właściwości jest obsługiwane przez <xref:System.Windows.Controls.TextBlock.GetBaselineOffset%2A> i. <xref:System.Windows.Controls.TextBlock.SetBaselineOffset%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaselineOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BaselineOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BaselineOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.BaselineOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BaselineOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BaselineOffsetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BaselineOffsetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.BaselineOffsetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BreakAfter">
      <MemberSignature Language="C#" Value="public System.Windows.LineBreakCondition BreakAfter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineBreakCondition BreakAfter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.BreakAfter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BreakAfter As LineBreakCondition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineBreakCondition BreakAfter { System::Windows::LineBreakCondition get(); };" />
      <MemberSignature Language="F#" Value="member this.BreakAfter : System.Windows.LineBreakCondition" Usage="System.Windows.Controls.TextBlock.BreakAfter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineBreakCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.LineBreakCondition" /> Pobiera, który wskazuje, jak zawartość powinna zostać przerwana po bieżącym elemencie.</summary>
        <value>Warunki podziału zawartości po bieżącym elemencie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca <xref:System.Windows.LineBreakCondition.BreakDesired>wartość.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.BreakBefore" />
      </Docs>
    </Member>
    <Member MemberName="BreakBefore">
      <MemberSignature Language="C#" Value="public System.Windows.LineBreakCondition BreakBefore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineBreakCondition BreakBefore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.BreakBefore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BreakBefore As LineBreakCondition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineBreakCondition BreakBefore { System::Windows::LineBreakCondition get(); };" />
      <MemberSignature Language="F#" Value="member this.BreakBefore : System.Windows.LineBreakCondition" Usage="System.Windows.Controls.TextBlock.BreakBefore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineBreakCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.LineBreakCondition" /> Pobiera, który wskazuje, jak zawartość powinna zostać przerwana przed bieżącym elementem.</summary>
        <value>Warunki podziału zawartości po bieżącym elemencie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca <xref:System.Windows.LineBreakCondition.BreakDesired>wartość.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.BreakAfter" />
      </Docs>
    </Member>
    <Member MemberName="ContentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer ContentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer ContentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.ContentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ ContentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Controls.TextBlock.ContentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera do końca zawartości <see cref="T:System.Windows.Controls.TextBlock" />w. <see cref="T:System.Windows.Documents.TextPointer" /></summary>
        <value>Od <see cref="T:System.Windows.Documents.TextPointer" /> A do końca zawartości <see cref="T:System.Windows.Controls.TextBlock" />w.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Koniec zawartości jest traktowany jako pozycja wstawiania bezpośrednio po ostatnim znaku w <xref:System.Windows.Controls.TextBlock>.  
  
 Wartość zwracana przez tę właściwość zawsze <xref:System.Windows.Documents.LogicalDirection.Forward>ma ustawiony na. <xref:System.Windows.Documents.TextPointer> <xref:System.Windows.Documents.LogicalDirection>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.ContentStart" />
      </Docs>
    </Member>
    <Member MemberName="ContentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer ContentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer ContentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.ContentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ ContentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Controls.TextBlock.ContentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera do początku zawartości <see cref="T:System.Windows.Controls.TextBlock" />w. <see cref="T:System.Windows.Documents.TextPointer" /></summary>
        <value>Od <see cref="T:System.Windows.Documents.TextPointer" /> A do początku zawartości <see cref="T:System.Windows.Controls.TextBlock" />w.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Początek zawartości jest traktowany jako pozycja wstawiania bezpośrednio poprzedzającej pierwszy znak w <xref:System.Windows.Controls.TextBlock>.  
  
 Wartość zwracana przez tę właściwość zawsze <xref:System.Windows.Documents.LogicalDirection.Backward>ma ustawiony na. <xref:System.Windows.Documents.TextPointer> <xref:System.Windows.Documents.LogicalDirection>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.ContentEnd" />
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FontFamily : System.Windows.Media.FontFamily with get, set" Usage="System.Windows.Controls.TextBlock.FontFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia preferowaną rodzinę czcionek najwyższego poziomu <see cref="T:System.Windows.Controls.TextBlock" />dla.</summary>
        <value><see cref="T:System.Windows.Media.FontFamily" /> Obiekt określający preferowaną rodzinę czcionek lub podstawową preferowaną rodzinę czcionek z co najmniej jedną rodziną czcionek bazowych. Wartością domyślną jest czcionka określona przez <see cref="P:System.Windows.SystemFonts.MessageFontFamily" /> wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Windows.Controls.TextBlock.FontFamily%2A> ustawienia elementów podrzędnych przesłaniają to ustawienie najwyższego poziomu.  
  
 Jeśli określono wiele rodzin, druga i kolejna Rodzina czcionek służy jako rodziny powrotu do użycia w przypadkach, gdy główna Rodzina czcionek jest niedostępna lub nie ma zastosowania.  
  
 Ta właściwość określa tylko preferencję.  Jeśli określona Rodzina czcionek nie jest dostępna, <xref:System.Windows.Controls.TextBlock> dyskretnie powraca do czcionki określonej <xref:System.Windows.SystemFonts.MessageFontFamily%2A> przez wartość.  
  
 Ta właściwość zależności ma również przypisane użycie właściwości. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] `<object TextBlock.FontFamily="value".../>`programie użycie ma wartość, gdzie *obiekt* jest elementem obiektu (zazwyczaj element Flow) zawartym w <xref:System.Windows.Controls.TextBlock>, a *wartość* jest jedną z wartości formatu ciągu, jak wyjaśniono w wartościach XAML. W kodzie użycie dołączonej właściwości jest obsługiwane przez <xref:System.Windows.Controls.TextBlock.GetFontFamily%2A> i. <xref:System.Windows.Controls.TextBlock.SetFontFamily%2A> Użycie dołączonej właściwości nie jest wspólne, ponieważ większość elementów, które mogą być zawarte w <xref:System.Windows.Controls.TextBlock> obsłudze analogicznej niedołączonej `FontFamily` właściwości, <xref:System.Windows.Controls.TextBlock> której używa do renderowania.  
  
<a name="xamlAttributeUsage_FontFamily"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object FontFamily="fontFamilyName"/>  
- or -  
<object FontFamily="fontFamilyNamesList"/>  
- or -  
<object FontFamily="fontFamilyFolderReference"/>  
- or -  
<object FontFamily="fontFamilyUriReference"/>  
```  
  
<a name="xamlValues_FontFamily"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *fontFamilyName*  
 Ciąg określający nazwę rodziny czcionek.  Na przykład `"Arial"` lub `"Century Gothic"`.  
  
 *fontFamilyNamesList*  
 Ciąg określający wiele nazw rodzin czcionek, z których każda oddzielona przecinkami (dowolny biały znak po przecinku jest ignorowany).  Pierwsza określona Rodzina czcionek służy jako Rodzina czcionek głównych. kolejne rodziny czcionek służą jako rodziny powrotu do użycia w przypadkach, gdy główna Rodzina czcionek jest niedostępna lub nie ma zastosowania.  Na przykład `"Arial, Century Gothic"` określa czcionkę Arial jako rodzinę czcionek podstawowych, z Century Gothic jako rodziną czcionek rezerwowych.  
  
 *fontFamilyFolderReference*  
 Ciąg określający folder zawierający czcionkę wraz z nazwą rodziny czcionek.  Nazwa folderu i rodziny czcionek są rozdzielane znakami #.  Odwołanie do folderu może być bezwzględne lub względne.  Na przykład `"Custom Fonts\#My Custom Font"`.  
  
 *fontFamilyUriReference*  
 Ciąg określający [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] czcionkę oraz nazwę rodziny czcionek.  Nazwa rodziny czcionek i jest rozdzielana znakiem #. [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]  Na przykład `"http://MyFontServer/Fonts/#My Custom Font"`.  
  
<a name="dependencyPropertyInfo_FontFamily"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.FontFamilyProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.FontFamily%2A> jak ustawić atrybut <xref:System.Windows.Controls.TextBlock> elementu.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.FontFamily%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontFamilyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.FontFamilyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.FontSize : double with get, set" Usage="System.Windows.Controls.TextBlock.FontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar czcionki najwyższego poziomu dla <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Żądany rozmiar czcionki do użycia w pikselach niezależnych od urządzenia). <see cref="P:System.Windows.SystemFonts.MessageFontSize" /> Wartość domyślna jest określana na podstawie wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Windows.Controls.TextBlock.FontSize%2A> ustawienia elementów podrzędnych przesłaniają to ustawienie najwyższego poziomu.  
  
 Ta właściwość zależności ma również przypisane użycie właściwości. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] `<object TextBlock.FontSize="value".../>`programie użycie ma wartość, gdzie *obiekt* jest elementem obiektu (zazwyczaj element Flow) zawartym w <xref:System.Windows.Controls.TextBlock>, a *wartość* jest jedną z wartości formatu ciągu, jak wyjaśniono w wartościach XAML. W kodzie użycie dołączonej właściwości jest obsługiwane przez <xref:System.Windows.Controls.TextBlock.GetFontSize%2A> i. <xref:System.Windows.Controls.TextBlock.SetFontSize%2A> Użycie dołączonej właściwości nie jest wspólne, ponieważ większość elementów, które mogą być zawarte w <xref:System.Windows.Controls.TextBlock> obsłudze analogicznej niedołączonej `FontSize` właściwości, <xref:System.Windows.Controls.TextBlock> której używa do renderowania.  
  
<a name="xamlAttributeUsage_FontSize"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object FontSize="double"/>  
- or -  
<object FontSize="qualifiedDouble"/>  
```  
  
<a name="xamlValues_FontSize"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż 0,0, ale mniejszą niż <xref:System.Double.PositiveInfinity>. Niekwalifikowana wartość jest mierzona w pikselach niezależnych od urządzenia. Ciągi nie muszą jawnie zawierać punktów dziesiętnych.  
  
 *qualifiedDouble*  
 Wartość *Podwójna* , jak opisano powyżej, a po niej jeden z następujących specyfikatorów jednostek `px`: `in`, `cm`, `pt`,.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm`jest centymetry; 1cm = = (96/2.54) px  
  
 `pt`to punkty; 1 pkt = = (96/72) px  
  
<a name="dependencyPropertyInfo_FontSize"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.FontSizeProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.FontSize%2A> jak ustawić atrybut <xref:System.Windows.Controls.TextBlock> elementu.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.FontSize%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontSizeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.FontSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretch">
      <MemberSignature Language="C#" Value="public System.Windows.FontStretch FontStretch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStretch FontStretch" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontStretch" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStretch As FontStretch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStretch FontStretch { System::Windows::FontStretch get(); void set(System::Windows::FontStretch value); };" />
      <MemberSignature Language="F#" Value="member this.FontStretch : System.Windows.FontStretch with get, set" Usage="System.Windows.Controls.TextBlock.FontStretch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStretch</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia charakterystykę najwyższego poziomu czcionki dla <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Element członkowski <see cref="T:System.Windows.FontStretch" /> klasy, określający pożądaną charakterystykę rozciągania czcionki do użycia. Wartość domyślna to <see cref="P:System.Windows.FontStretches.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Windows.Controls.TextBlock.FontStretch%2A> ustawienia elementów podrzędnych przesłaniają to ustawienie najwyższego poziomu.  
  
 Ta właściwość zależności ma również przypisane użycie właściwości. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie użycie ma `<object TextBlock.FontStretch="value".../>`wartość, gdzie *obiekt* jest elementem obiektu (zazwyczaj element Flow) zawartym w <xref:System.Windows.Controls.TextBlock>, a *wartość* jest jedną z nazw <xref:System.Windows.FontStretch> właściwości formatu ciągu klasy. W kodzie użycie dołączonej właściwości jest obsługiwane przez <xref:System.Windows.Controls.TextBlock.GetFontStretch%2A> i. <xref:System.Windows.Controls.TextBlock.SetFontStretch%2A> Użycie dołączonej właściwości nie jest wspólne, ponieważ większość elementów, które mogą być zawarte w <xref:System.Windows.Controls.TextBlock> obsłudze analogicznej niedołączonej `FontStretch` właściwości, <xref:System.Windows.Controls.TextBlock> której używa do renderowania.  
  
<a name="dependencyPropertyInfo_FontStretch"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.FontStretchProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.FontStretch%2A> jak ustawić atrybut <xref:System.Windows.Controls.TextBlock> elementu.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.FontStretch%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretchProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStretchProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStretchProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontStretchProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStretchProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStretchProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontStretchProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.FontStretchProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyle">
      <MemberSignature Language="C#" Value="public System.Windows.FontStyle FontStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStyle FontStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStyle As FontStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStyle FontStyle { System::Windows::FontStyle get(); void set(System::Windows::FontStyle value); };" />
      <MemberSignature Language="F#" Value="member this.FontStyle : System.Windows.FontStyle with get, set" Usage="System.Windows.Controls.TextBlock.FontStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia styl czcionki najwyższego poziomu dla <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Element członkowski <see cref="T:System.Windows.FontStyles" /> klasy, określający żądany styl czcionki. <see cref="P:System.Windows.SystemFonts.MessageFontStyle" /> Wartość domyślna jest określana na podstawie wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Windows.Controls.TextBlock.FontStyle%2A> ustawienia elementów podrzędnych przesłaniają to ustawienie najwyższego poziomu.  
  
 Ta właściwość zależności ma również przypisane użycie właściwości. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie użycie ma `<object TextBlock.FontStyle="value".../>`wartość, gdzie *obiekt* jest elementem obiektu (zazwyczaj element Flow) zawartym w <xref:System.Windows.Controls.TextBlock>, a *wartość* jest jedną z nazw właściwości formatowania ciągu w <xref:System.Windows.FontStyles> klasie. W kodzie użycie dołączonej właściwości jest obsługiwane przez <xref:System.Windows.Controls.TextBlock.GetFontStyle%2A> i. <xref:System.Windows.Controls.TextBlock.SetFontStyle%2A> Użycie dołączonej właściwości nie jest wspólne, ponieważ większość elementów, które mogą być zawarte w <xref:System.Windows.Controls.TextBlock> obsłudze analogicznej niedołączonej `FontStyle` właściwości, <xref:System.Windows.Controls.TextBlock> której używa do renderowania.  
  
<a name="dependencyPropertyInfo_FontStyle"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.FontStyleProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.FontStyle%2A> jak ustawić atrybut <xref:System.Windows.Controls.TextBlock> elementu.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.FontStyle%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.FontStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeight">
      <MemberSignature Language="C#" Value="public System.Windows.FontWeight FontWeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontWeight FontWeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontWeight" />
      <MemberSignature Language="VB.NET" Value="Public Property FontWeight As FontWeight" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontWeight FontWeight { System::Windows::FontWeight get(); void set(System::Windows::FontWeight value); };" />
      <MemberSignature Language="F#" Value="member this.FontWeight : System.Windows.FontWeight with get, set" Usage="System.Windows.Controls.TextBlock.FontWeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontWeight</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia grubość czcionki najwyższego poziomu dla <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Element członkowski <see cref="T:System.Windows.FontWeights" /> klasy, określający pożądaną grubość czcionki. <see cref="P:System.Windows.SystemFonts.MessageFontWeight" /> Wartość domyślna jest określana na podstawie wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Windows.Controls.TextBlock.FontWeight%2A> ustawienia elementów podrzędnych przesłaniają to ustawienie najwyższego poziomu.  
  
 Aby uzyskać listę prawidłowych wartości wag czcionek, zobacz <xref:System.Windows.FontWeights> Klasa.  
  
 Ta właściwość zależności ma również przypisane użycie właściwości. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie użycie jest `<object TextBlock.FontWeight="value".../>`, gdzie *obiekt* jest elementem obiektu (zazwyczaj element Flow) zawartym w <xref:System.Windows.Controls.TextBlock>, a *wartość* jest <xref:System.Windows.FontWeights> jedną z wartości formatu ciągu właściwości klasy. W kodzie użycie dołączonej właściwości jest obsługiwane przez <xref:System.Windows.Controls.TextBlock.GetFontWeight%2A> i. <xref:System.Windows.Controls.TextBlock.SetFontWeight%2A> Użycie dołączonej właściwości nie jest wspólne, ponieważ większość elementów, które mogą być zawarte w <xref:System.Windows.Controls.TextBlock> obsłudze analogicznej niedołączonej `FontWeight` właściwości, <xref:System.Windows.Controls.TextBlock> której używa do renderowania.  
  
<a name="dependencyPropertyInfo_FontWeight"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.FontWeightProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.FontWeight%2A> jak ustawić atrybut <xref:System.Windows.Controls.TextBlock> elementu.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.FontWeight%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontWeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontWeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontWeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontWeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontWeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontWeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.FontWeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Foreground : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.TextBlock.Foreground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Media.Brush" /> do zastosowania do zawartości <see cref="T:System.Windows.Controls.TextBlock" />tekstowej.</summary>
        <value>Pędzel używany do zastosowania do zawartości tekstowej. Wartość domyślna to <see cref="P:System.Windows.Media.Brushes.Black" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać tabelę próbek pokazującą dostępne wstępnie zdefiniowane kolory pędzla, zobacz <xref:System.Windows.Media.Brushes>.  
  
 Wszystkie <xref:System.Windows.Controls.TextBlock.Foreground%2A> ustawienia elementów podrzędnych przesłaniają to ustawienie najwyższego poziomu.  
  
 Ta właściwość zależności ma również przypisane użycie właściwości. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie użycie ma `<object TextBlock.Foreground="value".../>`wartość, gdzie *obiekt* jest elementem obiektu (zazwyczaj element Flow) zawartym w <xref:System.Windows.Controls.TextBlock> <xref:System.Windows.Media.Brush> , a *wartość* jest ciągiem, który jest rozpoznawany jako wartość implementacji. W kodzie użycie dołączonej właściwości jest obsługiwane przez <xref:System.Windows.Controls.TextBlock.GetForeground%2A> i. <xref:System.Windows.Controls.TextBlock.SetForeground%2A> Użycie dołączonej właściwości nie jest wspólne, ponieważ większość elementów, które mogą być zawarte w <xref:System.Windows.Controls.TextBlock> obsłudze analogicznej niedołączonej `Foreground` właściwości, <xref:System.Windows.Controls.TextBlock> której używa do renderowania.  
  
<a name="dependencyPropertyInfo_Foreground"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.ForegroundProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.Foreground%2A> jak ustawić atrybut <xref:System.Windows.Controls.TextBlock> elementu.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.Foreground%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForegroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.ForegroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaselineOffset">
      <MemberSignature Language="C#" Value="public static double GetBaselineOffset (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetBaselineOffset(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetBaselineOffset(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBaselineOffset (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetBaselineOffset(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetBaselineOffset : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Controls.TextBlock.GetBaselineOffset element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetBaselineOffset(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontFamily">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.FontFamily GetFontFamily (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Media.FontFamily GetFontFamily(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontFamily(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontFamily (element As DependencyObject) As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::FontFamily ^ GetFontFamily(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFontFamily : System.Windows.DependencyObject -&gt; System.Windows.Media.FontFamily" Usage="System.Windows.Controls.TextBlock.GetFontFamily element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="F:System.Windows.Controls.TextBlock.FontFamilyProperty" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontFamily(System.Windows.DependencyObject,System.Windows.Media.FontFamily)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontSize">
      <MemberSignature Language="C#" Value="public static double GetFontSize (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetFontSize(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontSize(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontSize (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetFontSize(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFontSize : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Controls.TextBlock.GetFontSize element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontSize(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontStretch">
      <MemberSignature Language="C#" Value="public static System.Windows.FontStretch GetFontStretch (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FontStretch GetFontStretch(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontStretch(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontStretch (element As DependencyObject) As FontStretch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FontStretch GetFontStretch(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFontStretch : System.Windows.DependencyObject -&gt; System.Windows.FontStretch" Usage="System.Windows.Controls.TextBlock.GetFontStretch element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStretch</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontStretch(System.Windows.DependencyObject,System.Windows.FontStretch)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontStyle">
      <MemberSignature Language="C#" Value="public static System.Windows.FontStyle GetFontStyle (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FontStyle GetFontStyle(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontStyle(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontStyle (element As DependencyObject) As FontStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FontStyle GetFontStyle(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFontStyle : System.Windows.DependencyObject -&gt; System.Windows.FontStyle" Usage="System.Windows.Controls.TextBlock.GetFontStyle element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStyle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontStyle(System.Windows.DependencyObject,System.Windows.FontStyle)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontWeight">
      <MemberSignature Language="C#" Value="public static System.Windows.FontWeight GetFontWeight (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FontWeight GetFontWeight(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontWeight(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontWeight (element As DependencyObject) As FontWeight" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FontWeight GetFontWeight(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFontWeight : System.Windows.DependencyObject -&gt; System.Windows.FontWeight" Usage="System.Windows.Controls.TextBlock.GetFontWeight element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontWeight</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontWeight(System.Windows.DependencyObject,System.Windows.FontWeight)" />
      </Docs>
    </Member>
    <Member MemberName="GetForeground">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Brush GetForeground (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Media.Brush GetForeground(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetForeground(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetForeground (element As DependencyObject) As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::Brush ^ GetForeground(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetForeground : System.Windows.DependencyObject -&gt; System.Windows.Media.Brush" Usage="System.Windows.Controls.TextBlock.GetForeground element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetForeground(System.Windows.DependencyObject,System.Windows.Media.Brush)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineHeight">
      <MemberSignature Language="C#" Value="public static double GetLineHeight (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetLineHeight(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetLineHeight(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLineHeight (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetLineHeight(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetLineHeight : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Controls.TextBlock.GetLineHeight element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetLineHeight(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineStackingStrategy">
      <MemberSignature Language="C#" Value="public static System.Windows.LineStackingStrategy GetLineStackingStrategy (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.LineStackingStrategy GetLineStackingStrategy(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetLineStackingStrategy(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLineStackingStrategy (element As DependencyObject) As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::LineStackingStrategy GetLineStackingStrategy(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetLineStackingStrategy : System.Windows.DependencyObject -&gt; System.Windows.LineStackingStrategy" Usage="System.Windows.Controls.TextBlock.GetLineStackingStrategy element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetLineStackingStrategy(System.Windows.DependencyObject,System.Windows.LineStackingStrategy)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionFromPoint (System.Windows.Point point, bool snapToText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionFromPoint(valuetype System.Windows.Point point, bool snapToText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetPositionFromPoint(System.Windows.Point,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionFromPoint(System::Windows::Point point, bool snapToText);" />
      <MemberSignature Language="F#" Value="member this.GetPositionFromPoint : System.Windows.Point * bool -&gt; System.Windows.Documents.TextPointer" Usage="textBlock.GetPositionFromPoint (point, snapToText)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="snapToText" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">A <see cref="T:System.Windows.Point" /> w przestrzeni współrzędnych dla <see cref="T:System.Windows.Controls.TextBlock" /> , dla którego ma zostać <see cref="T:System.Windows.Documents.TextPointer" />zwrócona wartość.</param>
        <param name="snapToText"><see langword="true" />Aby zwrócić <see cref="T:System.Windows.Documents.TextPointer" /> do punktu wstawiania znajdującego się <paramref name="point" />najbliżej, niezależnie od <paramref name="point" /> tego, czy znajduje się w polu ograniczenia znaku; <see langword="false" /> zwraca ,<see langword="null" /> Jeśli nie<paramref name="point" /> znajduje się wewnątrz pola ograniczenia znaku.</param>
        <summary>Zwraca do pozycji najbliżej określonego <see cref="T:System.Windows.Point" />. <see cref="T:System.Windows.Documents.TextPointer" /></summary>
        <returns><paramref name="snapToText" /> <see cref="T:System.Windows.Controls.TextBlock" /> Do określonego punktu lub <see langword="null" /> jeśli jest <see langword="false" /> , a określony punkt nie należy do pola ograniczenia znaku w obszarze zawartości. <see cref="T:System.Windows.Documents.TextPointer" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zawsze zwraca prawidłowy <xref:System.Windows.Documents.TextPointer> czas, gdy `true` `snapToText` ma wartość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżące informacje o układzie dla formantu są niedostępne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRectanglesCore">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt; GetRectanglesCore (System.Windows.ContentElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;valuetype System.Windows.Rect&gt; GetRectanglesCore(class System.Windows.ContentElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetRectanglesCore(System.Windows.ContentElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRectanglesCore (child As ContentElement) As ReadOnlyCollection(Of Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Rect&gt; ^ GetRectanglesCore(System::Windows::ContentElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member GetRectanglesCore : System.Windows.ContentElement -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt;&#xA;override this.GetRectanglesCore : System.Windows.ContentElement -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt;" Usage="textBlock.GetRectanglesCore child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.ContentElement" />
      </Parameters>
      <Docs>
        <param name="child">A <see cref="T:System.Windows.ContentElement" /> , dla którego ma zostać wygenerowana i zwrócona kolekcja prostokątów powiązanych.</param>
        <summary>Zwraca kolekcję dla określonego <see cref="T:System.Windows.ContentElement" />prostokątów z ograniczeniami tylko do odczytu.</summary>
        <returns>Kolekcja powiązanych prostokątów dla określonego <see cref="T:System.Windows.ContentElement" />elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy prostokąt ograniczający w kolekcji odnosi się do wiersza zawartości w <xref:System.Windows.ContentElement>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="child" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTextAlignment">
      <MemberSignature Language="C#" Value="public static System.Windows.TextAlignment GetTextAlignment (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.TextAlignment GetTextAlignment(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetTextAlignment(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTextAlignment (element As DependencyObject) As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::TextAlignment GetTextAlignment(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTextAlignment : System.Windows.DependencyObject -&gt; System.Windows.TextAlignment" Usage="System.Windows.Controls.TextBlock.GetTextAlignment element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, z którego ma zostać pobrana wartość <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> dołączonej właściwości.</param>
        <summary>Zwraca wartość <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <returns>Bieżąca wartość <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> dołączonej właściwości w określonym obiekcie Dependency.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetTextAlignment(System.Windows.DependencyObject,System.Windows.TextAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="textBlock.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) określający <see cref="T:System.Windows.Media.Visual" /> element podrzędny do zwrócenia.  Ta wartość musi należeć do zakresu od<see cref="P:System.Windows.Controls.TextBlock.VisualChildrenCount" /> 0 do (minus 1)</param>
        <summary><see cref="T:System.Windows.Media.Visual" /> Zwraca element podrzędny o określonym indeksie.</summary>
        <returns><see cref="T:System.Windows.Media.Visual" /> Element podrzędny o określonym indeksie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.Windows.FrameworkElement.GetVisualChild%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />nie jest z zakresu od 0<see cref="P:System.Windows.Controls.TextBlock.VisualChildrenCount" /> do (minus 1)</exception>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="override this.HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult" Usage="textBlock.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters"><see cref="T:System.Windows.Media.PointHitTestParameters" /> Obiekt określający parametry, dla których ma zostać trafiony test.</param>
        <summary><see cref="T:System.Windows.Media.PointHitTestParameters" />Zwraca wartość <see cref="T:System.Windows.Media.PointHitTestResult" /> dla określonego.</summary>
        <returns>A <see cref="T:System.Windows.Media.PointHitTestResult" /> dla określonych parametrów testu trafień.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przeznaczona do włączania dokładnego testowania trafień dla renderowanej zawartości.  
  
 Ta metoda przesłania <xref:System.Windows.UIElement.HitTestCore%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hitTestParameters" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostedElementsCore">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt; HostedElementsCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerator`1&lt;class System.Windows.IInputElement&gt; HostedElementsCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.HostedElementsCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property HostedElementsCore As IEnumerator(Of IInputElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ HostedElementsCore { System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HostedElementsCore : System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt;" Usage="System.Windows.Controls.TextBlock.HostedElementsCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł wyliczający, który może być używany do iteracji elementów hostowanych przez ten <see cref="T:System.Windows.Controls.TextBlock" />element.</summary>
        <value>Moduł wyliczający, który może wykonywać iterację <see cref="T:System.Windows.Controls.TextBlock" />elementów hostowanych w tym elemencie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Inlines">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.InlineCollection Inlines { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.InlineCollection Inlines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Inlines" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Inlines As InlineCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::InlineCollection ^ Inlines { System::Windows::Documents::InlineCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Inlines : System.Windows.Documents.InlineCollection" Usage="System.Windows.Controls.TextBlock.Inlines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.InlineCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawierający elementy najwyższego poziomu <see cref="T:System.Windows.Documents.Inline" /> , które składają się na zawartość <see cref="T:System.Windows.Controls.TextBlock" />. <see cref="T:System.Windows.Documents.InlineCollection" /></summary>
        <value>Zawierający elementy, które składają się na zawartość <see cref="T:System.Windows.Controls.TextBlock" />. <see cref="T:System.Windows.Documents.InlineCollection" /> <see cref="T:System.Windows.Documents.Inline" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj zwracanej przez tę właściwość, aby wyliczyć lub manipulować zawartością elementu <xref:System.Windows.Controls.TextBlock>. <xref:System.Windows.Documents.InlineCollection>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputHitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.IInputElement InputHitTestCore (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.IInputElement InputHitTestCore(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.InputHitTestCore(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::IInputElement ^ InputHitTestCore(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="abstract member InputHitTestCore : System.Windows.Point -&gt; System.Windows.IInputElement&#xA;override this.InputHitTestCore : System.Windows.Point -&gt; System.Windows.IInputElement" Usage="textBlock.InputHitTestCore point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">A <see cref="T:System.Windows.Point" />, w przestrzeni <see cref="T:System.Windows.Controls.TextBlock" />współrzędnych, dla którego ma zostać zwrócona odpowiednia <see cref="T:System.Windows.IInputElement" />.</param>
        <summary>Zwraca wartość określoną <see cref="T:System.Windows.Point" /> w elemencie <see cref="T:System.Windows.Controls.TextBlock" />. <see cref="T:System.Windows.IInputElement" /></summary>
        <returns>Znaleziono w określonym punkcie lub <see langword="null" /> Jeśli nie <see cref="T:System.Windows.IInputElement" /> można go znaleźć. <see cref="T:System.Windows.IInputElement" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHyphenationEnabled">
      <MemberSignature Language="C#" Value="public bool IsHyphenationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHyphenationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.IsHyphenationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsHyphenationEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHyphenationEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsHyphenationEnabled : bool with get, set" Usage="System.Windows.Controls.TextBlock.IsHyphenationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy automatyczne dzielenie wyrazów jest włączone czy wyłączone.</summary>
        <value><see langword="true" />Aby wskazać, że jest włączone automatyczne przerywanie i dzielenie wyrazów; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcja automatycznego dzielenia wyrazów słów umożliwia <xref:System.Windows.Controls.TextBlock> automatyczne przerywanie wyrazów i dzielenie ich wyrazów w oparciu o bieżące warunki układu.  Dzięki temu długie słowa zaczynają się w jednym wierszu i kontynuują na tym następnym, a następnie osiągają bardziej równomierną dystrybucję białych znaków w wyjustowanym tekście.  Wyrazy są dzielone i dzielone na standardowe reguły gramatyki.  
  
<a name="dependencyPropertyInfo_IsHyphenationEnabled"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.IsHyphenationEnabledProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.IsHyphenationEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsHyphenationEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHyphenationEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHyphenationEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.IsHyphenationEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsHyphenationEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsHyphenationEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsHyphenationEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.IsHyphenationEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.IsHyphenationEnabled" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineHeight">
      <MemberSignature Language="C#" Value="public double LineHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 LineHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.LineHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property LineHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double LineHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.LineHeight : double with get, set" Usage="System.Windows.Controls.TextBlock.LineHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wysokość każdego wiersza zawartości.</summary>
        <value>Wysokość linii w pikselach niezależnych od urządzenia, z zakresu od 0,0034 do 160000. Wartość <see cref="F:System.Double.NaN" /> (równoważna wartości atrybutu "Auto") wskazuje<c></c>, że wysokość linii jest ustalana automatycznie z bieżącej charakterystyki czcionki. Wartość domyślna to <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmiana tej wartości nie powoduje zmiany wysokości skojarzonego tekstu; Zamiast tego zmienia wysokość linii zawierającej tekst. Aby zmienić rozmiar tekstu, użyj <xref:System.Windows.Controls.TextBlock.FontSize%2A> właściwości.  
  
 Oprócz tej właściwości ma wpływ <xref:System.Windows.Controls.TextBlock> <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A> na układ wierszy w elemencie.  
  
 Ta właściwość zależności ma również przypisane użycie właściwości. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] `<object TextBlock.LineHeight="value".../>`programie użycie jest, gdzie *obiekt* jest elementem obiektu (zazwyczaj jest <xref:System.Windows.Controls.TextBlock>to element przepływu) zawarty w, a *wartość* jest ciągiem, jak wyjaśniono w wartościach XAML. W kodzie użycie dołączonej właściwości jest obsługiwane przez <xref:System.Windows.Controls.TextBlock.GetLineHeight%2A> i. <xref:System.Windows.Controls.TextBlock.SetLineHeight%2A> Użycie dołączonej właściwości nie jest wspólne.  
  
<a name="xamlAttributeUsage_LineHeight"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object LineHeight="double"/>  
- or -  
<object LineHeight="qualifiedDouble"/>  
- or -  
<object LineHeight="Auto"/>  
```  
  
<a name="xamlValues_LineHeight"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 <xref:System.Double>  
  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż `0.0034` i `160000`równą lub mniejszą. Niekwalifikowana wartość jest mierzona w pikselach niezależnych od urządzenia. Ciągi nie muszą jawnie zawierać punktów dziesiętnych.  
  
 *qualifiedDouble*  
 Wartość *Podwójna* , jak opisano powyżej (z wyjątkiem `Auto`), po której następuje jeden z następujących specyfikatorów jednostek `px`: `in`, `cm`, `pt`,.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm`jest centymetry; 1cm = = (96/2.54) px  
  
 `pt`to punkty; 1 pkt = = (96/72) px  
  
 Auto  
 Powoduje, że wysokość linii ma być ustalana automatycznie z bieżącej charakterystyki czcionki.  Odpowiednik wartości <xref:System.Double.NaN?displayProperty=nameWithType>właściwości.  
  
<a name="dependencyPropertyInfo_LineHeight"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.LineHeightProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.LineHeight%2A> jak ustawić atrybut <xref:System.Windows.Controls.TextBlock> elementu.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.LineHeight%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Windows.Controls.TextBlock.LineHeight" />jest ustawiona na wartość niedodatnią.</exception>
        <altmember cref="P:System.Windows.Documents.FlowDocument.LineHeight" />
      </Docs>
    </Member>
    <Member MemberName="LineHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.LineHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.LineHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategy">
      <MemberSignature Language="C#" Value="public System.Windows.LineStackingStrategy LineStackingStrategy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineStackingStrategy LineStackingStrategy" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.LineStackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Public Property LineStackingStrategy As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineStackingStrategy LineStackingStrategy { System::Windows::LineStackingStrategy get(); void set(System::Windows::LineStackingStrategy value); };" />
      <MemberSignature Language="F#" Value="member this.LineStackingStrategy : System.Windows.LineStackingStrategy with get, set" Usage="System.Windows.Controls.TextBlock.LineStackingStrategy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia mechanizm, za pomocą którego pole wiersza jest ustalane dla każdego wiersza tekstu w obrębie <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Mechanizm, za pomocą którego pole wiersza jest ustalane dla każdego wiersza tekstu w obrębie <see cref="T:System.Windows.Controls.TextBlock" />. Wartość domyślna to <see cref="F:System.Windows.LineStackingStrategy.MaxHeight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zależności ma również przypisane użycie właściwości. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie użycie jest `<object TextBlock.LineStackingStrategy="value".../>`, gdzie *obiekt* jest elementem obiektu (zazwyczaj jest <xref:System.Windows.Controls.TextBlock>to element przepływu) zawarty w, a *wartość* jest wartością <xref:System.Windows.LineStackingStrategy> ciągu wyliczenia. W kodzie użycie dołączonej właściwości jest obsługiwane przez <xref:System.Windows.Controls.TextBlock.GetLineStackingStrategy%2A> i. <xref:System.Windows.Controls.TextBlock.SetLineStackingStrategy%2A> Użycie dołączonej właściwości nie jest wspólne.  
  
<a name="dependencyPropertyInfo_LineStackingStrategy"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.LineStackingStrategyProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A> jak używać właściwości, aby określić sposób tworzenia pól liniowych dla wierszy <xref:System.Windows.Controls.TextBlock>tekstu. Pierwszy <xref:System.Windows.Controls.TextBlock> <xref:System.Windows.LineStackingStrategy.BlockLineHeight>ma wartość ,<xref:System.Windows.LineStackingStrategy.MaxHeight> a drugi<xref:System.Windows.Controls.TextBlock>mawartość. <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A>  
  
 [!code-xaml[FlowMiscSnippets_snip#LineStackingStrategyExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowMiscSnippets_snip/cs/linestackingstrategyexample.xaml#linestackingstrategyexamplewholepage)]  
  
 Na poniższej ilustracji przedstawiono wynik poprzedniego kodu.  
  
 ![Zrzut ekranu Porównuje LineStackingStrategy]wartości(~/add/media/flow-linestackingstrategy.gif "zrzutu ekranu: Porównaj wartości LineStackingStrategy")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineStackingStrategyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineStackingStrategyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.LineStackingStrategyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineStackingStrategyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineStackingStrategyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineStackingStrategyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.LineStackingStrategyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.TextBlock.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł wyliczający, który może wykonywać iterację logicznych <see cref="T:System.Windows.Controls.TextBlock" />elementów podrzędnych.</summary>
        <value>Moduł wyliczający dla logicznych elementów podrzędnych.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="textBlock.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Struktura określająca wszelkie ograniczenia dotyczące rozmiaru <see cref="T:System.Windows.Controls.TextBlock" />. <see cref="T:System.Windows.Size" /></param>
        <summary>Wywołuje się, <see cref="T:System.Windows.Controls.TextBlock" />by zmienić miarę.</summary>
        <returns>Struktura wskazująca nowy rozmiar <see cref="T:System.Windows.Controls.TextBlock" />. <see cref="T:System.Windows.Size" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąp tę metodę, aby zaimplementować niestandardowe zachowanie dotyczące zmiany rozmiarów.  
  
 Ta metoda przesłania <xref:System.Windows.FrameworkElement.MeasureOverride%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChildDesiredSizeChangedCore">
      <MemberSignature Language="C#" Value="protected virtual void OnChildDesiredSizeChangedCore (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChildDesiredSizeChangedCore(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnChildDesiredSizeChangedCore(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChildDesiredSizeChangedCore (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChildDesiredSizeChangedCore(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member OnChildDesiredSizeChangedCore : System.Windows.UIElement -&gt; unit&#xA;override this.OnChildDesiredSizeChangedCore : System.Windows.UIElement -&gt; unit" Usage="textBlock.OnChildDesiredSizeChangedCore child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Element podrzędny <see cref="T:System.Windows.UIElement" /> , którego <see cref="P:System.Windows.UIElement.DesiredSize" /> wartość została zmieniona.</param>
        <summary>Wywołuje się, gdy element podrzędny wyprowadza ze <see cref="T:System.Windows.UIElement" /> <see cref="P:System.Windows.UIElement.DesiredSize" />zmian.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="textBlock.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> obiekt dla tego <see cref="T:System.Windows.Controls.TextBlock" />obiektu.</summary>
        <returns>Obiekt dla tego <see cref="T:System.Windows.Controls.TextBlock" />elementu. <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override sealed void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="textBlock.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Argumenty skojarzonego zdarzenia.</param>
        <summary>Wywołuje się, gdy wartość jednej lub więcej właściwości hostowanej zależności ulegnie zmianie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyChangedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnRender">
      <MemberSignature Language="C#" Value="protected override sealed void OnRender (System.Windows.Media.DrawingContext ctx);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnRender(class System.Windows.Media.DrawingContext ctx) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnRender(System.Windows.Media.DrawingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub OnRender (ctx As DrawingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnRender(System::Windows::Media::DrawingContext ^ ctx);" />
      <MemberSignature Language="F#" Value="override this.OnRender : System.Windows.Media.DrawingContext -&gt; unit" Usage="textBlock.OnRender ctx" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctx" Type="System.Windows.Media.DrawingContext" />
      </Parameters>
      <Docs>
        <param name="ctx">W <see cref="T:System.Windows.Media.DrawingContext" /> celu renderowania formantu.</param>
        <summary>Renderuje zawartość <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez system układu w celu renderowania zawartości <xref:System.Windows.Controls.TextBlock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="ctx" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Padding { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Thickness with get, set" Usage="System.Windows.Controls.TextBlock.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą grubość odstępu wypełnienia między granicami obszaru zawartości i zawartością wyświetlaną przez <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value><see cref="T:System.Windows.Thickness" /> Struktura określająca ilość dopełnienia do zastosowania w pikselach niezależnych od urządzenia. Wartość domyślna to <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.TextBlock.Padding%2A>może być opisany jako jednorodny we wszystkich kierunkach (`Padding="10"`) lub jako cztery odrębne wartości, które reprezentują lewe, górne, prawe i dolne uzupełnienie (`Padding="5,0,10,20"`).  
  
 Jeśli określona grubość wypełnienia przekroczy odpowiedni wymiar obszaru zawartości (na przykład Suma szerokości wypełnienia w lewo i w prawo przekracza szerokość obszaru zawartości), grubość wypełnienia jest proporcjonalnie zredukowana do wartości większej niż odpowiednia wymiar obszaru zawartości.  
  
<a name="xamlAttributeUsage_Padding"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Padding="uniformThickness"/>  
- or -  
<object Padding="independentThickness"/>  
- or -  
<object Padding="qualifiedUniformThickness"/>  
- or -  
<object Padding="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_Padding"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *uniformThickness*  
 Reprezentacja pojedynczej <xref:System.Double> wartości w postaci ciągu, która ma być jednolicie stosowana do wszystkich wymiarów z czterema grubościami.  Na przykład wartość `"10"` jest równa `"10,10,10,10"`wartości.  Niekwalifikowana wartość jest mierzona w pikselach niezależnych od urządzenia. Ciągi nie muszą jawnie zawierać punktów dziesiętnych.  
  
 *independentThickness*  
 Ciąg reprezentujący cztery uporządkowane <xref:System.Double> wartości, które odpowiadają niezależnym wymiarom grubości dla lewego, górnego, prawego i dolnego, w tej kolejności.  Cztery wartości muszą być oddzielone przecinkami; spacje są niedozwolone.  Na przykład "5, 10, 15, 20" skutkuje dopełnieniem do lewej strony zawartości, 10 pikselami wypełnienia powyżej zawartości, 15 pikselami wypełnienia po prawej stronie zawartości oraz 20 pikseli wypełnienia poniżej zawartości.  
  
 *qualifiedUniformThickness*  
 Wartość opisana przez *uniformThickness* , po której następuje jeden z następujących specyfikatorów jednostek: `px`, `in`.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 Na przykład program `"1in"` zapewnia jednolite uzupełnienie 1 cala we wszystkich kierunkach.  
  
 *qualifiedIndependentThickness*  
 Wartość opisana przez *independentThickness*, z każdą niezależną wartością, a po niej jeden z następujących specyfikatorów `px`jednostek `in`:,.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 Na przykład `"1.5in,0.8in,1.5in,0.8in"`.  Specyfikatory jednostek mogą być mieszane lub pomijane z co najmniej jednej wartości.  
  
<a name="dependencyPropertyInfo_Padding"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.PaddingProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.Padding%2A> jak ustawić atrybut <xref:System.Windows.Controls.TextBlock> elementu.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.Padding%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PaddingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PaddingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.PaddingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PaddingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PaddingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PaddingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.PaddingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.Padding" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBaselineOffset">
      <MemberSignature Language="C#" Value="public static void SetBaselineOffset (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBaselineOffset(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetBaselineOffset(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBaselineOffset (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBaselineOffset(System::Windows::DependencyObject ^ element, double value);" />
      <MemberSignature Language="F#" Value="static member SetBaselineOffset : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetBaselineOffset (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> właściwości.</param>
        <param name="value">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetBaselineOffset(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontFamily">
      <MemberSignature Language="C#" Value="public static void SetFontFamily (System.Windows.DependencyObject element, System.Windows.Media.FontFamily value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontFamily(class System.Windows.DependencyObject element, class System.Windows.Media.FontFamily value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontFamily(System.Windows.DependencyObject,System.Windows.Media.FontFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontFamily (element As DependencyObject, value As FontFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontFamily(System::Windows::DependencyObject ^ element, System::Windows::Media::FontFamily ^ value);" />
      <MemberSignature Language="F#" Value="static member SetFontFamily : System.Windows.DependencyObject * System.Windows.Media.FontFamily -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetFontFamily (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.Media.FontFamily" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> właściwości.</param>
        <param name="value">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontFamily(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontSize">
      <MemberSignature Language="C#" Value="public static void SetFontSize (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontSize(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontSize(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontSize (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontSize(System::Windows::DependencyObject ^ element, double value);" />
      <MemberSignature Language="F#" Value="static member SetFontSize : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetFontSize (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> właściwości.</param>
        <param name="value">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontSize(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontStretch">
      <MemberSignature Language="C#" Value="public static void SetFontStretch (System.Windows.DependencyObject element, System.Windows.FontStretch value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontStretch(class System.Windows.DependencyObject element, valuetype System.Windows.FontStretch value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontStretch(System.Windows.DependencyObject,System.Windows.FontStretch)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontStretch (element As DependencyObject, value As FontStretch)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontStretch(System::Windows::DependencyObject ^ element, System::Windows::FontStretch value);" />
      <MemberSignature Language="F#" Value="static member SetFontStretch : System.Windows.DependencyObject * System.Windows.FontStretch -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetFontStretch (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FontStretch" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> właściwości.</param>
        <param name="value">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontStretch(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontStyle">
      <MemberSignature Language="C#" Value="public static void SetFontStyle (System.Windows.DependencyObject element, System.Windows.FontStyle value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontStyle(class System.Windows.DependencyObject element, valuetype System.Windows.FontStyle value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontStyle(System.Windows.DependencyObject,System.Windows.FontStyle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontStyle (element As DependencyObject, value As FontStyle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontStyle(System::Windows::DependencyObject ^ element, System::Windows::FontStyle value);" />
      <MemberSignature Language="F#" Value="static member SetFontStyle : System.Windows.DependencyObject * System.Windows.FontStyle -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetFontStyle (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FontStyle" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> właściwości.</param>
        <param name="value">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontStyle(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontWeight">
      <MemberSignature Language="C#" Value="public static void SetFontWeight (System.Windows.DependencyObject element, System.Windows.FontWeight value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontWeight(class System.Windows.DependencyObject element, valuetype System.Windows.FontWeight value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontWeight(System.Windows.DependencyObject,System.Windows.FontWeight)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontWeight (element As DependencyObject, value As FontWeight)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontWeight(System::Windows::DependencyObject ^ element, System::Windows::FontWeight value);" />
      <MemberSignature Language="F#" Value="static member SetFontWeight : System.Windows.DependencyObject * System.Windows.FontWeight -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetFontWeight (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FontWeight" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> właściwości.</param>
        <param name="value">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontWeight(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetForeground">
      <MemberSignature Language="C#" Value="public static void SetForeground (System.Windows.DependencyObject element, System.Windows.Media.Brush value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetForeground(class System.Windows.DependencyObject element, class System.Windows.Media.Brush value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetForeground(System.Windows.DependencyObject,System.Windows.Media.Brush)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetForeground (element As DependencyObject, value As Brush)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetForeground(System::Windows::DependencyObject ^ element, System::Windows::Media::Brush ^ value);" />
      <MemberSignature Language="F#" Value="static member SetForeground : System.Windows.DependencyObject * System.Windows.Media.Brush -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetForeground (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.Media.Brush" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> właściwości.</param>
        <param name="value">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetForeground(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetLineHeight">
      <MemberSignature Language="C#" Value="public static void SetLineHeight (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLineHeight(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetLineHeight(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLineHeight (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLineHeight(System::Windows::DependencyObject ^ element, double value);" />
      <MemberSignature Language="F#" Value="static member SetLineHeight : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetLineHeight (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> właściwości.</param>
        <param name="value">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Windows.Controls.TextBlock.LineHeight" />jest ustawiona na wartość niedodatnią.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetLineHeight(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetLineStackingStrategy">
      <MemberSignature Language="C#" Value="public static void SetLineStackingStrategy (System.Windows.DependencyObject element, System.Windows.LineStackingStrategy value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLineStackingStrategy(class System.Windows.DependencyObject element, valuetype System.Windows.LineStackingStrategy value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetLineStackingStrategy(System.Windows.DependencyObject,System.Windows.LineStackingStrategy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLineStackingStrategy (element As DependencyObject, value As LineStackingStrategy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLineStackingStrategy(System::Windows::DependencyObject ^ element, System::Windows::LineStackingStrategy value);" />
      <MemberSignature Language="F#" Value="static member SetLineStackingStrategy : System.Windows.DependencyObject * System.Windows.LineStackingStrategy -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetLineStackingStrategy (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.LineStackingStrategy" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> właściwości.</param>
        <param name="value">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontSize(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetTextAlignment">
      <MemberSignature Language="C#" Value="public static void SetTextAlignment (System.Windows.DependencyObject element, System.Windows.TextAlignment value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTextAlignment(class System.Windows.DependencyObject element, valuetype System.Windows.TextAlignment value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetTextAlignment(System.Windows.DependencyObject,System.Windows.TextAlignment)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTextAlignment (element As DependencyObject, value As TextAlignment)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTextAlignment(System::Windows::DependencyObject ^ element, System::Windows::TextAlignment value);" />
      <MemberSignature Language="F#" Value="static member SetTextAlignment : System.Windows.DependencyObject * System.Windows.TextAlignment -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetTextAlignment (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.TextAlignment" />
      </Parameters>
      <Docs>
        <param name="element">Obiekt zależności, na którym ma zostać ustawiona wartość <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> właściwości.</param>
        <param name="value">Nowa wartość, dla której ma zostać ustawiona właściwość.</param>
        <summary>Ustawia wartość <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> dołączonej właściwości dla określonego obiektu zależności.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetTextAlignment(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeBaselineOffset">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeBaselineOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeBaselineOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ShouldSerializeBaselineOffset" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeBaselineOffset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeBaselineOffset();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeBaselineOffset : unit -&gt; bool" Usage="textBlock.ShouldSerializeBaselineOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy efektywna wartość <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> właściwości powinna być serializowana podczas serializacji <see cref="T:System.Windows.Controls.TextBlock" /> obiektu.</summary>
        <returns><see langword="true" />Jeśli właściwość powinna być serializowana; <see langword="false" />w przeciwnym razie. <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInlines">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInlines (System.Windows.Markup.XamlDesignerSerializationManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInlines(class System.Windows.Markup.XamlDesignerSerializationManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ShouldSerializeInlines(System.Windows.Markup.XamlDesignerSerializationManager)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInlines (manager As XamlDesignerSerializationManager) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInlines(System::Windows::Markup::XamlDesignerSerializationManager ^ manager);" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeInlines : System.Windows.Markup.XamlDesignerSerializationManager -&gt; bool" Usage="textBlock.ShouldSerializeInlines manager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.Windows.Markup.XamlDesignerSerializationManager" />
      </Parameters>
      <Docs>
        <param name="manager">Obiekt Menedżera usługi serializacji dla tego obiektu.</param>
        <summary>Zwraca wartość wskazującą, czy efektywna wartość <see cref="P:System.Windows.Controls.TextBlock.Inlines" /> właściwości powinna być serializowana podczas serializacji <see cref="T:System.Windows.Controls.TextBlock" /> obiektu.</summary>
        <returns><see langword="true" />Jeśli właściwość powinna być serializowana; <see langword="false" />w przeciwnym razie. <see cref="P:System.Windows.Controls.TextBlock.Inlines" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="manager" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeText">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ShouldSerializeText" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeText () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeText();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeText : unit -&gt; bool" Usage="textBlock.ShouldSerializeText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy efektywna wartość <see cref="P:System.Windows.Controls.TextBlock.Text" /> właściwości powinna być serializowana podczas serializacji <see cref="T:System.Windows.Controls.TextBlock" /> obiektu.</summary>
        <returns><see langword="true" />Jeśli właściwość powinna być serializowana; <see langword="false" />w przeciwnym razie. <see cref="P:System.Windows.Controls.TextBlock.Text" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (serviceType As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ serviceType) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">Obiekt, który określa typ obiektu usługi do pobrania.</param>
        <summary>Ta metoda obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <returns>Obiekt usługi typu <paramref name="serviceType" />lub <see langword="null" /> Jeśli nie ma obiektu usługi typu <paramref name="serviceType" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.GetRectangles">
      <MemberSignature Language="C#" Value="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt; IContentHost.GetRectangles (System.Windows.ContentElement child);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;valuetype System.Windows.Rect&gt; System.Windows.IContentHost.GetRectangles(class System.Windows.ContentElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#IContentHost#GetRectangles(System.Windows.ContentElement)" />
      <MemberSignature Language="VB.NET" Value="Function GetRectangles (child As ContentElement) As ReadOnlyCollection(Of Rect) Implements IContentHost.GetRectangles" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Rect&gt; ^ System.Windows.IContentHost.GetRectangles(System::Windows::ContentElement ^ child) = System::Windows::IContentHost::GetRectangles;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IContentHost.GetRectangles(System.Windows.ContentElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.ContentElement" />
      </Parameters>
      <Docs>
        <param name="child">A <see cref="T:System.Windows.ContentElement" /> , dla którego ma zostać wygenerowana i zwrócona kolekcja prostokątów powiązanych.</param>
        <summary>Ta metoda obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.  Zamiast tego użyj metody bezpiecznego <see cref="M:System.Windows.Controls.TextBlock.GetRectanglesCore(System.Windows.ContentElement)" /> typu.</summary>
        <returns>Kolekcja powiązanych prostokątów dla określonego <see cref="T:System.Windows.ContentElement" />elementu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.HostedElements">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt; System.Windows.IContentHost.HostedElements { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerator`1&lt;class System.Windows.IInputElement&gt; System.Windows.IContentHost.HostedElements" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.System#Windows#IContentHost#HostedElements" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HostedElements As IEnumerator(Of IInputElement) Implements IContentHost.HostedElements" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ System::Windows::IContentHost::HostedElements { System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Windows.IContentHost.HostedElements" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IContentHost.HostedElements</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ten typ lub element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczony do użycia bezpośrednio w kodzie.  Zamiast tego użyj właściwości bezpiecznego <see cref="P:System.Windows.Controls.TextBlock.HostedElementsCore" /> typu.</summary>
        <value>Elementy hostowane przez hosta zawartości.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.InputHitTest">
      <MemberSignature Language="C#" Value="System.Windows.IInputElement IContentHost.InputHitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Windows.IInputElement System.Windows.IContentHost.InputHitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#IContentHost#InputHitTest(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Windows::IInputElement ^ System.Windows.IContentHost.InputHitTest(System::Windows::Point point) = System::Windows::IContentHost::InputHitTest;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IContentHost.InputHitTest(System.Windows.Point)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Współrzędne myszy względem hosta zawartości.</param>
        <summary>Ta metoda obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.  Zamiast tego użyj metody bezpiecznego <see cref="M:System.Windows.Controls.TextBlock.InputHitTestCore(System.Windows.Point)" /> typu.</summary>
        <returns>Element, który został trafiony.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.OnChildDesiredSizeChanged">
      <MemberSignature Language="C#" Value="void IContentHost.OnChildDesiredSizeChanged (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.IContentHost.OnChildDesiredSizeChanged(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#IContentHost#OnChildDesiredSizeChanged(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Sub OnChildDesiredSizeChanged (child As UIElement) Implements IContentHost.OnChildDesiredSizeChanged" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.IContentHost.OnChildDesiredSizeChanged(System::Windows::UIElement ^ child) = System::Windows::IContentHost::OnChildDesiredSizeChanged;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IContentHost.OnChildDesiredSizeChanged(System.Windows.UIElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Element podrzędny <see cref="T:System.Windows.UIElement" /> , którego <see cref="P:System.Windows.UIElement.DesiredSize" /> wartość została zmieniona.</param>
        <summary>Ta metoda obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.  Zamiast tego użyj metody bezpiecznego <see cref="M:System.Windows.Controls.TextBlock.OnChildDesiredSizeChangedCore(System.Windows.UIElement)" /> typu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który ma zostać dodany jako element podrzędny.</param>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczony do użycia bezpośrednio w kodzie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Ciąg, który ma zostać dodany do obiektu.</param>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczony do użycia bezpośrednio w kodzie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Controls.TextBlock.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Text)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zawartość <see cref="T:System.Windows.Controls.TextBlock" />tekstową.</summary>
        <value>Zawartość tekstowa tego <see cref="T:System.Windows.Controls.TextBlock" />elementu. Należy zauważyć, że cała zawartość nietekstowa jest usuwana, co oznacza, że <see cref="T:System.Windows.Controls.TextBlock" /> zawartość jest reprezentowana w postaci zwykłego tekstu. Wartość domyślna to <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej właściwości, jeśli chcesz wyświetlić zwykły tekst w <xref:System.Windows.Controls.TextBlock>.  Aby sformatować tekst, należy dodać <xref:System.Windows.Documents.Inline> obiekty <xref:System.Windows.Controls.TextBlock.Inlines%2A> do właściwości.  
  
<a name="dependencyPropertyInfo_Text"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.TextProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.Text%2A> jak ustawić atrybut <xref:System.Windows.Controls.TextBlock> elementu.  
  
 [!code-xaml[SpanSnippets#_TextBlock_Text1XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/SpanSnippets/CSharp/Window1.xaml#_textblock_text1xaml)]  
  
 Alternatywnie zawartość przebiegu tekstu może być po prostu zawarta w <xref:System.Windows.Controls.TextBlock> tagach elementu.  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.Text%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[SpanSnippets#_TextBlock_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/SpanSnippets/CSharp/Window1.xaml.cs#_textblock_text)]
 [!code-vb[SpanSnippets#_TextBlock_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/SpanSnippets/visualbasic/window1.xaml.vb#_textblock_text)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.TextAlignment TextAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextAlignment TextAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property TextAlignment As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextAlignment TextAlignment { System::Windows::TextAlignment get(); void set(System::Windows::TextAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.TextAlignment : System.Windows.TextAlignment with get, set" Usage="System.Windows.Controls.TextBlock.TextAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą poziome wyrównanie zawartości tekstowej.</summary>
        <value>Jedna z <see cref="T:System.Windows.TextAlignment" /> wartości, która określa pożądaną wartość wyrównania. Wartość domyślna to <see cref="F:System.Windows.TextAlignment.Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zależności ma również przypisane użycie właściwości. W [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie użycie jest `<object TextBlock.TextAlignment="value".../>`, gdzie *obiekt* jest elementem obiektu (zazwyczaj jest <xref:System.Windows.Controls.TextBlock>to element przepływu) zawarty w, a *wartość* jest wartością <xref:System.Windows.TextAlignment> ciągu wyliczenia. W kodzie użycie dołączonej właściwości jest obsługiwane przez <xref:System.Windows.Controls.TextBlock.GetTextAlignment%2A> i. <xref:System.Windows.Controls.TextBlock.SetTextAlignment%2A> Użycie dołączonej właściwości nie jest wspólne.  
  
<a name="dependencyPropertyInfo_TextAlignment"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.TextAlignmentProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.TextAlignment%2A> jak ustawić atrybut <xref:System.Windows.Controls.TextBlock> elementu.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.TextAlignment%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.TextAlignment" />
      </Docs>
    </Member>
    <Member MemberName="TextAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.TextAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextDecorations">
      <MemberSignature Language="C#" Value="public System.Windows.TextDecorationCollection TextDecorations { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TextDecorationCollection TextDecorations" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextDecorations" />
      <MemberSignature Language="VB.NET" Value="Public Property TextDecorations As TextDecorationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextDecorationCollection ^ TextDecorations { System::Windows::TextDecorationCollection ^ get(); void set(System::Windows::TextDecorationCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TextDecorations : System.Windows.TextDecorationCollection with get, set" Usage="System.Windows.Controls.TextBlock.TextDecorations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextDecorationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt <see cref="T:System.Windows.TextDecorationCollection" /> zawierający efekty, które mają zostać zastosowane do tekstu. <see cref="T:System.Windows.Controls.TextBlock" /></summary>
        <value><see cref="T:System.Windows.TextDecorationCollection" /> Kolekcja zawierająca dekoracje tekstu do zastosowania do tego elementu. Wartość domyślna to <see langword="null" /> (nie zastosowano dekoracji tekstu).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.TextDecoration> Obiekt jest wizualną wizualizacją, którą można dodać do tekstu. Istnieją cztery typy dekoracji tekstu: podkreolenie, linie bazowe, przekreślenie i nadkreślenie.  Aby uzyskać więcej informacji na temat dekoracji tekstu [, zobacz How to: Utwórz dekorację](~/docs/framework/wpf/advanced/how-to-create-a-text-decoration.md)tekstu.  
  
 Domyślnie ta właściwość jest ustawiona na `null` i nie <xref:System.Windows.TextDecorationCollection> jest skojarzona z nią.  Przed dodaniem jakichkolwiek efektów tekstowych Utwórz nowe <xref:System.Windows.TextDecorationCollection> i przypisz je do tej właściwości.  
  
<a name="dependencyPropertyInfo_TextDecorations"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.TextDecorationsProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.TextDecorations%2A> jak ustawić atrybut.  
  
 [!code-xaml[InlineSnippets#_TextBlock_TextDecXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InlineSnippets/CSharp/Window1.xaml#_textblock_textdecxaml)]  
  
 Na poniższej ilustracji przedstawiono sposób renderowania tego przykładu.  
  
 ![Zrzut ekranu Tekst z domyślnym efektem](~/add/media/inline-textdec-strike.png "przekreślenia: Tekst z domyślnym efektem przekreślenia")  
  
 Poniższe ilustracje pokazują, jak <xref:System.Windows.TextDecorations.OverLine%2A>są <xref:System.Windows.TextDecorations.Baseline%2A>renderowane, <xref:System.Windows.TextDecorations.Underline%2A> i i dekoracje.  
  
 ![Zrzut ekranu Zrzut ekranu TextDecorator]:(~/add/media/inline-textdec-over.png " TextDecorator nadkreślenia")  
  
 ![Zrzut ekranu Domyślny efekt linii bazowej na]zrzucie ekranu tekstu(~/add/media/inline-textdec-base.png ": Domyślny efekt linii bazowej dla tekstu")  
  
 ![Zrzut ekranu Tekst z domyślnym efektem](~/add/media/inline-textdec-under.png "podkreślenia: Tekst z domyślnym efektem podkreślenia")  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.TextDecorations%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[InlineSnippets#_TextBlock_TextDec](~/samples/snippets/csharp/VS_Snippets_Wpf/InlineSnippets/CSharp/Window1.xaml.cs#_textblock_textdec)]
 [!code-vb[InlineSnippets#_TextBlock_TextDec](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InlineSnippets/visualbasic/window1.xaml.vb#_textblock_textdec)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextDecorationsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextDecorationsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextDecorationsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextDecorationsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextDecorationsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextDecorationsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextDecorationsProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.TextDecorationsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.TextDecorations" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextEffects">
      <MemberSignature Language="C#" Value="public System.Windows.Media.TextEffectCollection TextEffects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.TextEffectCollection TextEffects" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextEffects" />
      <MemberSignature Language="VB.NET" Value="Public Property TextEffects As TextEffectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::TextEffectCollection ^ TextEffects { System::Windows::Media::TextEffectCollection ^ get(); void set(System::Windows::Media::TextEffectCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TextEffects : System.Windows.Media.TextEffectCollection with get, set" Usage="System.Windows.Controls.TextBlock.TextEffects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextEffectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia efekty do zastosowania do zawartości tekstowej w tym elemencie.</summary>
        <value>Zawierający jeden lub więcej <see cref="T:System.Windows.Media.TextEffect" /> obiektów, które definiują efekty do zastosowania <see cref="T:System.Windows.Controls.TextBlock" />do tekstu. <see cref="T:System.Windows.Media.TextEffectCollection" /> Wartość domyślna to <see langword="null" /> (nie zastosowano żadnych efektów).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta właściwość jest ustawiona na `null` i nie <xref:System.Windows.Media.TextEffectCollection> jest skojarzona z nią.  Przed dodaniem jakichkolwiek efektów tekstowych Utwórz nowe <xref:System.Windows.Media.TextEffectCollection> i przypisz je do tej właściwości.  
  
<a name="dependencyPropertyInfo_TextEffects"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.TextEffectsProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć prosty efekt tekstowy i zastosować go do tekstu <xref:System.Windows.Controls.TextBlock>.  
  
 [!code-csharp[TextElementSnippets#_TextBlock_TextEffects](~/samples/snippets/csharp/VS_Snippets_Wpf/TextElementSnippets/CSharp/Window1.xaml.cs#_textblock_texteffects)]
 [!code-vb[TextElementSnippets#_TextBlock_TextEffects](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextElementSnippets/visualbasic/window1.xaml.vb#_textblock_texteffects)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextEffectsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextEffectsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextEffectsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextEffectsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextEffectsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextEffectsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextEffectsProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.TextEffectsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.TextEffects" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.TextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.Text" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextTrimming">
      <MemberSignature Language="C#" Value="public System.Windows.TextTrimming TextTrimming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextTrimming TextTrimming" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextTrimming" />
      <MemberSignature Language="VB.NET" Value="Public Property TextTrimming As TextTrimming" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextTrimming TextTrimming { System::Windows::TextTrimming get(); void set(System::Windows::TextTrimming value); };" />
      <MemberSignature Language="F#" Value="member this.TextTrimming : System.Windows.TextTrimming with get, set" Usage="System.Windows.Controls.TextBlock.TextTrimming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextTrimming</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zachowanie przycinania tekstu do zastosowania, gdy zawartość przepływa obszar zawartości.</summary>
        <value>Jedna z <see cref="T:System.Windows.TextTrimming" /> wartości, która określa zachowanie przycinania tekstu do użycia. Wartość domyślna to <see cref="F:System.Windows.TextTrimming.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextTrimming"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.TextTrimmingProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextTrimmingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextTrimmingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextTrimmingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextTrimmingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextTrimmingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextTrimmingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextTrimmingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.TextTrimmingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.TextTrimming" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextWrapping">
      <MemberSignature Language="C#" Value="public System.Windows.TextWrapping TextWrapping { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextWrapping TextWrapping" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextWrapping" />
      <MemberSignature Language="VB.NET" Value="Public Property TextWrapping As TextWrapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextWrapping TextWrapping { System::Windows::TextWrapping get(); void set(System::Windows::TextWrapping value); };" />
      <MemberSignature Language="F#" Value="member this.TextWrapping : System.Windows.TextWrapping with get, set" Usage="System.Windows.Controls.TextBlock.TextWrapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextWrapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia sposób <see cref="T:System.Windows.Controls.TextBlock" /> zawijania tekstu.</summary>
        <value>Jedna z <see cref="T:System.Windows.TextWrapping" /> wartości. Wartość domyślna to <see cref="F:System.Windows.TextWrapping.NoWrap" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextWrapping"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Controls.TextBlock.TextWrappingProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.TextWrapping%2A> jak ustawić atrybut <xref:System.Windows.Controls.TextBlock> elementu.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.TextWrapping%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextWrappingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextWrappingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextWrappingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextWrappingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextWrappingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextWrappingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextWrappingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.TextWrappingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Controls.TextBlock.TextWrapping" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Typography">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Typography Typography { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Typography Typography" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Typography" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Typography As Typography" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Typography ^ Typography { System::Windows::Documents::Typography ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Typography : System.Windows.Documents.Typography" Usage="System.Windows.Controls.TextBlock.Typography" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Typography</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obecnie obowiązujące wahania typografii dla zawartości tego elementu.</summary>
        <value><see cref="T:System.Windows.Documents.Typography" /> Obiekt, który określa aktualnie obowiązujące wahania typografii. Aby uzyskać listę domyślnych wartości typografii, zobacz <see cref="T:System.Windows.Documents.Typography" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość ma zastosowanie tylko do [!INCLUDE[TLA#tla_opentype](~/includes/tlasharptla-opentype-md.md)] czcionek. <xref:System.Windows.Controls.TextBlock.Typography%2A> Wariant typografii nie ma wpływu na czcionki, które nie obsługują tego wariantu.  Aby uzyskać więcej informacji na temat tego tematu, zobacz [Typografia w WPF](~/docs/framework/wpf/advanced/typography-in-wpf.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.Typography%2A> jak ustawić atrybut <xref:System.Windows.Controls.TextBlock> elementu.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.Typography%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.Typography" />
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.Controls.TextBlock.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę <see cref="T:System.Windows.Media.Visual" /> elementów podrzędnych hostowanych <see cref="T:System.Windows.Controls.TextBlock" />przez.</summary>
        <value>Liczba elementów podrzędnych wizualnych hostowanych przez <see cref="T:System.Windows.Controls.TextBlock" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

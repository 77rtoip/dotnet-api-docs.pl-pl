<Type Name="ItemCollection" FullName="System.Windows.Controls.ItemCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5a368c24eebd6392784198aab1be17b1b819fe2c" /><Meta Name="ms.sourcegitcommit" Value="f9e71795ba0f9c2dfaa74bec233343ed0f3ffd99" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/14/2019" /><Meta Name="ms.locfileid" Value="57922786" /></Metadata><TypeSignature Language="C#" Value="public sealed class ItemCollection : System.Windows.Data.CollectionView, System.Collections.IList, System.ComponentModel.ICollectionViewLiveShaping, System.ComponentModel.IEditableCollectionViewAddNewItem, System.ComponentModel.IItemProperties, System.Windows.IWeakEventListener" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ItemCollection extends System.Windows.Data.CollectionView implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ComponentModel.ICollectionViewLiveShaping, class System.ComponentModel.IEditableCollectionView, class System.ComponentModel.IEditableCollectionViewAddNewItem, class System.ComponentModel.IItemProperties, class System.Windows.IWeakEventListener" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.ItemCollection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ItemCollection&#xA;Inherits CollectionView&#xA;Implements ICollectionViewLiveShaping, IEditableCollectionViewAddNewItem, IItemProperties, IList, IWeakEventListener" />
  <TypeSignature Language="C++ CLI" Value="public ref class ItemCollection sealed : System::Windows::Data::CollectionView, System::Collections::IList, System::ComponentModel::ICollectionViewLiveShaping, System::ComponentModel::IEditableCollectionViewAddNewItem, System::ComponentModel::IItemProperties, System::Windows::IWeakEventListener" />
  <TypeSignature Language="F#" Value="type ItemCollection = class&#xA;    inherit CollectionView&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IEditableCollectionViewAddNewItem&#xA;    interface IEditableCollectionView&#xA;    interface ICollectionViewLiveShaping&#xA;    interface IItemProperties&#xA;    interface IWeakEventListener" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Data.CollectionView</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ICollectionViewLiveShaping</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IEditableCollectionView</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IEditableCollectionViewAddNewItem</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IItemProperties</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IWeakEventListener</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera listę elementów, które stanowią zawartość <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ItemCollection> przechowuje kolekcję elementów, takich jak ciągi, obiekty, [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] węzłów, elementy i innych kolekcji. <xref:System.Windows.Controls.ItemsControl> Korzysta z danych w <xref:System.Windows.Controls.ItemCollection> do generowania jego zawartości. Jeśli chcesz agregować więcej niż jedną kolekcję, Przypisz <xref:System.Windows.Data.CompositeCollection> do <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> właściwości usługi <xref:System.Windows.Controls.ItemsControl>.  
  
 Użyj jednej <xref:System.Windows.Controls.ItemsControl.Items%2A> właściwości lub <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> właściwości w celu określenia kolekcji, które mają być używane do generowania zawartości Twojej <xref:System.Windows.Controls.ItemsControl>. Gdy <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> ustawiono właściwość <xref:System.Windows.Controls.ItemsControl.Items%2A> kolekcji zostaną wprowadzone w trybie tylko do odczytu i stałym rozmiarze. Oznacza to, że jeśli używasz <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> właściwości, nie możesz dodawać, usuwać ani modyfikować elementy w <xref:System.Windows.Controls.ItemCollection> bezpośrednio.  
  
 <xref:System.Windows.Controls.ItemCollection> jest <xref:System.Windows.Data.CollectionView> i dlatego zapewnia funkcje związane z widoku kolekcji, takich jak sortowanie, grupowanie i filtrowanie. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Controls.ItemCollection.SortDescriptions%2A>, <xref:System.Windows.Controls.ItemCollection.Filter%2A>, i <xref:System.Windows.Controls.ItemCollection.GroupDescriptions%2A>.  
  
 Aby uzyskać więcej informacji na temat widoki kolekcji zobacz [Przegląd wiązanie danych](~/docs/framework/wpf/data/data-binding-overview.md).  
  
   
  
## Examples  
 Jeśli masz <xref:System.Windows.Controls.ItemsControl>, takich jak <xref:System.Windows.Controls.ListBox> zawierającego zawartość, możesz użyć <xref:System.Windows.Controls.ItemsControl.Items%2A> właściwości w celu uzyskania dostępu do <xref:System.Windows.Controls.ItemCollection>, który jest widokiem. Ponieważ jest to widok, można następnie użyć Wyświetl powiązane funkcje, takie jak sortowanie, filtrowanie i grupowanie. Należy pamiętać, że po ustawieniu ItemsSource wyświetlanie operacji delegować do widoku przez kolekcję ItemsSource. W związku z tym ItemCollection obsługuje sortowanie, filtrowanie i grupowanie tylko wtedy, gdy widok delegowanego obsługiwane je.  
  
 Poniższy przykład pokazuje sposób sortowania zawartości <xref:System.Windows.Controls.ListBox> o nazwie `myListBox`. W tym przykładzie `Content` jest nazwą właściwości, aby posortować według.  
  
 [!code-csharp[ListBoxSort_snip#Sort](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxSort_snip/CSharp/Window1.xaml.cs#sort)]
 [!code-vb[ListBoxSort_snip#Sort](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxSort_snip/visualbasic/window1.xaml.vb#sort)]  
  
 Gdy to zrobisz, widok może lub nie może być domyślny widok, w zależności od konfiguracji danych w górę na Twoje <xref:System.Windows.Controls.ItemsControl>. Na przykład, gdy <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> właściwość jest powiązana z <xref:System.Windows.Data.CollectionViewSource>, widok, który można uzyskać za pomocą <xref:System.Windows.Controls.ItemsControl.Items%2A> właściwość nie jest domyślny widok.  
  
 Jeśli usługi <xref:System.Windows.Controls.ItemsControl> jest powiązany (używasz <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> właściwości), a następnie może wykonać następujące polecenie, aby pobrać domyślny widok:  
  
 [!code-csharp[GroupingSample#MyView](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#myview)]
 [!code-vb[GroupingSample#MyView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#myview)]  
[!code-csharp[GroupingSample#GetView](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#getview)]
[!code-vb[GroupingSample#GetView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#getview)]  
  
 Alternatywnie można określić filtrowanie, sortowanie i grupowanie kryteria [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] przy użyciu <xref:System.Windows.Data.CollectionViewSource>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.ItemsControl" />
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public int Add (object newItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Add(object newItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (newItem As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Add(System::Object ^ newItem);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj -&gt; int&#xA;override this.Add : obj -&gt; int" Usage="itemCollection.Add newItem" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="newItem">Element do dodania do kolekcji.</param>
        <summary>Dodaje element do <see cref="T:System.Windows.Controls.ItemCollection" />.</summary>
        <returns>Liczony od zera indeks, w którym obiekt zostanie dodany lub -1, jeśli nie można dodać elementu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Kolekcja jest w trybie ItemsSource.</exception>
        <altmember cref="T:System.Windows.Controls.ItemsControl" />
      </Docs>
    </Member>
    <Member MemberName="CanChangeLiveFiltering">
      <MemberSignature Language="C#" Value="public bool CanChangeLiveFiltering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanChangeLiveFiltering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.CanChangeLiveFiltering" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanChangeLiveFiltering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanChangeLiveFiltering { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanChangeLiveFiltering : bool" Usage="System.Windows.Controls.ItemCollection.CanChangeLiveFiltering" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionViewLiveShaping.CanChangeLiveFiltering</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy widok kolekcji obsługuje włączenie filtrowania danych w czasie rzeczywistym lub wyłączyć.</summary>
        <value><see langword="true" /> Jeśli widok kolekcji obsługuje Włączanie na żywo i wyłącza filtrowanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanChangeLiveGrouping">
      <MemberSignature Language="C#" Value="public bool CanChangeLiveGrouping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanChangeLiveGrouping" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.CanChangeLiveGrouping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanChangeLiveGrouping As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanChangeLiveGrouping { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanChangeLiveGrouping : bool" Usage="System.Windows.Controls.ItemCollection.CanChangeLiveGrouping" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionViewLiveShaping.CanChangeLiveGrouping</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy widok kolekcji obsługuje Włączanie grupowania danych w czasie rzeczywistym lub wyłączyć.</summary>
        <value><see langword="true" /> Jeśli widok kolekcji obsługuje grupowania na żywo Włączanie lub wyłączanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanChangeLiveSorting">
      <MemberSignature Language="C#" Value="public bool CanChangeLiveSorting { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanChangeLiveSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.CanChangeLiveSorting" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanChangeLiveSorting As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanChangeLiveSorting { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanChangeLiveSorting : bool" Usage="System.Windows.Controls.ItemCollection.CanChangeLiveSorting" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionViewLiveShaping.CanChangeLiveSorting</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy widok kolekcji obsługuje Włączanie sortowania danych w czasie rzeczywistym i wyłączanie.</summary>
        <value><see langword="true" /> Jeśli widok kolekcji obsługuje Włączanie na żywo sortowanie lub wyłączyć; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFilter">
      <MemberSignature Language="C#" Value="public override bool CanFilter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFilter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.CanFilter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanFilter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanFilter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFilter : bool" Usage="System.Windows.Controls.ItemCollection.CanFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten widok kolekcji obsługuje filtrowania.</summary>
        <value><see langword="true" /> Jeśli ten widok obsługuje filtrowanie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do Sprawdź, czy ta kolekcja obsługuje filtrowanie przed przypisaniem zwrotnym filtra do <xref:System.Windows.Controls.ItemCollection.Filter%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanGroup">
      <MemberSignature Language="C#" Value="public override bool CanGroup { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.CanGroup" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanGroup As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanGroup { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGroup : bool" Usage="System.Windows.Controls.ItemCollection.CanGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten widok kolekcji obsługuje grupowania.</summary>
        <value><see langword="true" /> Jeśli kolekcja obsługuje grupowanie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do Sprawdź, czy bieżąca implementacja obsługuje grupowanie przed użyciem <xref:System.Windows.Controls.ItemCollection.GroupDescriptions%2A> właściwości do dodania <xref:System.ComponentModel.GroupDescription> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSort">
      <MemberSignature Language="C#" Value="public override bool CanSort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSort" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.CanSort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSort : bool" Usage="System.Windows.Controls.ItemCollection.CanSort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten widok kolekcji obsługuje sortowanie.</summary>
        <value><see langword="true" /> Jeśli ten widok obsługuje sortowanie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej właściwości, aby sprawdzić, czy ta kolekcja obsługuje sortowanie, przed rozpoczęciem korzystania z <xref:System.Windows.Controls.ItemCollection.SortDescriptions%2A> właściwości do dodania <xref:System.ComponentModel.SortDescription> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="itemCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści kolekcję i zwalnia odwołania na wszystkich elementach aktualnie w kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak użyć tej metody. W tym przykładzie `sbar` jest <xref:System.Windows.Controls.Primitives.StatusBar> formant, który jest <xref:System.Windows.Controls.ItemsControl>.  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Controls.ItemCollection" /> Znajduje się w <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> trybu. (Gdy <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> ustawiono właściwość <see cref="P:System.Windows.Controls.ItemsControl.Items" /> kolekcji zostaną wprowadzone w trybie tylko do odczytu i stałym rozmiarze.)</exception>
        <altmember cref="T:System.Windows.Controls.ItemsControl" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public override bool Contains (object containItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Contains(object containItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Contains (containItem As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Contains(System::Object ^ containItem);" />
      <MemberSignature Language="F#" Value="override this.Contains : obj -&gt; bool" Usage="itemCollection.Contains containItem" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="containItem">Obiekt do sprawdzenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony element jest w tym widoku.</summary>
        <returns><see langword="true" /> Aby wskazać, że element należy do tej kolekcji i przekazuje filtra aktywnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="itemCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica docelowa, można skopiować do.</param>
        <param name="index">Liczony od zera indeks w tablicy docelowej.</param>
        <summary>Kopiuje elementy kolekcji do tablicy, zaczynając od określonego indeksu tablicy.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Miejsce docelowe <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> Parametru jest mniejszy niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public override int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.Controls.ItemCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę rekordów w kolekcji.</summary>
        <value>Liczba elementów w kolekcji lub 0, jeśli kolekcja została zainicjowana lub jeśli brak kolekcji w <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> trybu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentItem">
      <MemberSignature Language="C#" Value="public override object CurrentItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CurrentItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.CurrentItem" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CurrentItem As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ CurrentItem { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentItem : obj" Usage="System.Windows.Controls.ItemCollection.CurrentItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący element w widoku.</summary>
        <value>Bieżący obiekt w widoku lub <see langword="null" /> Jeśli kolekcja została zainicjowana lub Brak kolekcji w <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> trybu.  
  
Domyślnie jako bieżący element rozpoczyna się pierwszego elementu w kolekcji.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.CurrentItem" />
      </Docs>
    </Member>
    <Member MemberName="CurrentPosition">
      <MemberSignature Language="C#" Value="public override int CurrentPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.CurrentPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CurrentPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CurrentPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPosition : int" Usage="System.Windows.Controls.ItemCollection.CurrentPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera porządkowym bieżącego elementu w widoku.</summary>
        <value>Porządkowym bieżącego elementu w widoku lub wartość-1, jeśli kolekcja została zainicjowana lub jeśli brak kolekcji w <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> trybu.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemCollection.CurrentItem" />
      </Docs>
    </Member>
    <Member MemberName="DeferRefresh">
      <MemberSignature Language="C#" Value="public override IDisposable DeferRefresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IDisposable DeferRefresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.DeferRefresh" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeferRefresh () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IDisposable ^ DeferRefresh();" />
      <MemberSignature Language="F#" Value="override this.DeferRefresh : unit -&gt; IDisposable" Usage="itemCollection.DeferRefresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wprowadza cyklu Ustąp, który służy do scalania zmian wprowadzonych do automatycznego odświeżania widoku i opóźnienie.</summary>
        <returns><see cref="T:System.IDisposable" /> Obiekt, który służy do usuwania obiektu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle używana do tworzenia `using` zakresu, a następnie umieść wiele wywołań zmiana widoku w zakresie. Opóźnia automatyczne odświeżanie, dopóki nie zostanie zakończone cyklu Ustąp.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public override Predicate&lt;object&gt; Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Predicate`1&lt;object&gt; Filter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Filter As Predicate(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Predicate&lt;System::Object ^&gt; ^ Filter { Predicate&lt;System::Object ^&gt; ^ get(); void set(Predicate&lt;System::Object ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : Predicate&lt;obj&gt; with get, set" Usage="System.Windows.Controls.ItemCollection.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Predicate&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wywołanie zwrotne używane do określenia, czy element jest odpowiednia do włączenia w widoku.</summary>
        <value>Metoda używana do określenia, czy element jest odpowiednia do włączenia w widoku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Controls.ItemCollection.CanFilter%2A> właściwości, aby sprawdzić, czy bieżąca implementacja obsługuje filtrowanie przed przypisaniem tego właściwość o wartości innej niż null.  
  
   
  
## Examples  
 Aby uzyskać powiązanym przykładem, zobacz [jak: Filtrowanie danych w widoku](~/docs/framework/wpf/data/how-to-filter-data-in-a-view.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Filtrowanie nie jest obsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected override System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="itemCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemAt">
      <MemberSignature Language="C#" Value="public override object GetItemAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetItemAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.GetItemAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetItemAt (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetItemAt(int index);" />
      <MemberSignature Language="F#" Value="override this.GetItemAt : int -&gt; obj" Usage="itemCollection.GetItemAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w której znajduje się element.</param>
        <summary>Zwraca wartość elementu wskazywanego przez określony indeks zaczynający się od zera, w tym widoku.</summary>
        <returns>Element pod określonym indeksem liczony od zera, w tym widoku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ocenia indeksu za pomocą dowolnego sortowanie, filtrowanie lub kryteria, które są ustawione w widoku przy użyciu grupowania <xref:System.Windows.Data.CollectionView.SortDescriptions%2A> lub <xref:System.Windows.Data.CollectionView.Filter%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest poza zakresem.</exception>
        <exception cref="T:System.InvalidOperationException">Kolekcja została zainicjowana lub powiązania na <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> dostarczony <see langword="null" /> wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupDescriptions">
      <MemberSignature Language="C#" Value="public override System.Collections.ObjectModel.ObservableCollection&lt;System.ComponentModel.GroupDescription&gt; GroupDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ObservableCollection`1&lt;class System.ComponentModel.GroupDescription&gt; GroupDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.GroupDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GroupDescriptions As ObservableCollection(Of GroupDescription)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ObjectModel::ObservableCollection&lt;System::ComponentModel::GroupDescription ^&gt; ^ GroupDescriptions { System::Collections::ObjectModel::ObservableCollection&lt;System::ComponentModel::GroupDescription ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GroupDescriptions : System.Collections.ObjectModel.ObservableCollection&lt;System.ComponentModel.GroupDescription&gt;" Usage="System.Windows.Controls.ItemCollection.GroupDescriptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ObservableCollection&lt;System.ComponentModel.GroupDescription&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.ComponentModel.GroupDescription" /> obiektów, które definiuje sposób grupowania elementów.</summary>
        <value><see cref="T:System.Collections.ObjectModel.ObservableCollection`1" /> z <see cref="T:System.ComponentModel.GroupDescription" /> obiektów. Kolekcja jest indeksowana przez poziomy grupowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Controls.ItemCollection.CanGroup%2A> właściwości, aby sprawdzić, czy bieżąca implementacja obsługuje grupowanie przed dodaniem <xref:System.ComponentModel.GroupDescription> obiektów.  
  
> [!NOTE]
>  Tę właściwość można ustawić tylko dostęp do obiektu kolekcji, a przy użyciu jego różnych metod, takich jak `Add`. Właściwości dostępu do obiektu kolekcji jest tylko do odczytu, gdy samotnou kolekci odczytu i zapisu.  
  
   
  
## Examples  
 Aby uzyskać powiązanym przykładem, zobacz <xref:System.Windows.Data.PropertyGroupDescription>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.GroupStyle" />
      </Docs>
    </Member>
    <Member MemberName="Groups">
      <MemberSignature Language="C#" Value="public override System.Collections.ObjectModel.ReadOnlyObservableCollection&lt;object&gt; Groups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyObservableCollection`1&lt;object&gt; Groups" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.Groups" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Groups As ReadOnlyObservableCollection(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ObjectModel::ReadOnlyObservableCollection&lt;System::Object ^&gt; ^ Groups { System::Collections::ObjectModel::ReadOnlyObservableCollection&lt;System::Object ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Groups : System.Collections.ObjectModel.ReadOnlyObservableCollection&lt;obj&gt;" Usage="System.Windows.Controls.ItemCollection.Groups" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyObservableCollection&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera grup najwyższego poziomu, które są skonstruowane zgodnie z opisem w <see cref="P:System.Windows.Controls.ItemCollection.GroupDescriptions" />.</summary>
        <value>Grup najwyższego poziomu, które są skonstruowane zgodnie z opisem w <see cref="P:System.Windows.Controls.ItemCollection.GroupDescriptions" />. Wartość domyślna to <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Data.PropertyGroupDescription" />
        <altmember cref="T:System.Windows.Controls.GroupStyle" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public override int IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IndexOf (item As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int IndexOf(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="override this.IndexOf : obj -&gt; int" Usage="itemCollection.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do wyszukania w kolekcji.</param>
        <summary>Zwraca indeks w tej kolekcji, w którym znajduje się określony element.</summary>
        <returns>Indeks elementu w kolekcji lub -1, jeśli element nie istnieje w kolekcji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int insertIndex, object insertItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 insertIndex, object insertItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (insertIndex As Integer, insertItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int insertIndex, System::Object ^ insertItem);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * obj -&gt; unit&#xA;override this.Insert : int * obj -&gt; unit" Usage="itemCollection.Insert (insertIndex, insertItem)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="insertIndex" Type="System.Int32" />
        <Parameter Name="insertItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="insertIndex">Liczony od zera indeks, pod którym ma zostać wstawiony element.</param>
        <param name="insertItem">Element do wstawienia.</param>
        <summary>Wstawia element do kolekcji pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie elementy od określonej pozycji są przenoszone w dół o jeden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolekcja jest w trybie ItemsSource.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks jest poza zakresem.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsCurrentAfterLast">
      <MemberSignature Language="C#" Value="public override bool IsCurrentAfterLast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentAfterLast" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.IsCurrentAfterLast" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsCurrentAfterLast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCurrentAfterLast { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCurrentAfterLast : bool" Usage="System.Windows.Controls.ItemCollection.IsCurrentAfterLast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżącego elementu widoku jest poza końcem kolekcji.</summary>
        <value><see langword="true" /> Jeśli bieżący element w widoku jest poza końcem kolekcji w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemCollection.CurrentItem" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrentBeforeFirst">
      <MemberSignature Language="C#" Value="public override bool IsCurrentBeforeFirst { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentBeforeFirst" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.IsCurrentBeforeFirst" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsCurrentBeforeFirst As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCurrentBeforeFirst { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCurrentBeforeFirst : bool" Usage="System.Windows.Controls.ItemCollection.IsCurrentBeforeFirst" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżącego elementu widoku jest wyższy niż początku kolekcji.</summary>
        <value><see langword="true" /> Jeśli bieżący element w widoku jest wyższy niż początku kolekcji w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemCollection.CurrentItem" />
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public override bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Windows.Controls.ItemCollection.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wynikowym widoku (filtrowane) jest pusty.</summary>
        <value><see langword="true" /> Jeśli w wynikowym widoku jest pusta. w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiveFiltering">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsLiveFiltering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; IsLiveFiltering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.IsLiveFiltering" />
      <MemberSignature Language="VB.NET" Value="Public Property IsLiveFiltering As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; IsLiveFiltering { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.IsLiveFiltering : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Controls.ItemCollection.IsLiveFiltering" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionViewLiveShaping.IsLiveFiltering</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy filtrowanie danych w czasie rzeczywistym jest włączona.</summary>
        <value><see langword="true" /> Jeśli filtrowanie danych w czasie rzeczywistym jest włączona; <see langword="false" /> Jeśli filtrowanie na żywo nie jest włączone; <see langword="null" /> Jeżeli nie można ustalić, czy widok kolekcji implementuje filtrowania na żywo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiveGrouping">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsLiveGrouping { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; IsLiveGrouping" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.IsLiveGrouping" />
      <MemberSignature Language="VB.NET" Value="Public Property IsLiveGrouping As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; IsLiveGrouping { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.IsLiveGrouping : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Controls.ItemCollection.IsLiveGrouping" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionViewLiveShaping.IsLiveGrouping</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy grupowanie danych w czasie rzeczywistym jest włączona.</summary>
        <value><see langword="true" /> Jeśli grupowanie danych w czasie rzeczywistym jest włączona; <see langword="false" /> Jeśli grupowanie na żywo nie jest włączone; <see langword="null" /> Jeżeli nie można ustalić, czy widok kolekcji implementuje grupowania na żywo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiveSorting">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsLiveSorting { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; IsLiveSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.IsLiveSorting" />
      <MemberSignature Language="VB.NET" Value="Public Property IsLiveSorting As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; IsLiveSorting { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.IsLiveSorting : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Controls.ItemCollection.IsLiveSorting" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionViewLiveShaping.IsLiveSorting</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy jest włączone sortowanie w czasie rzeczywistym.</summary>
        <value><see langword="true" /> Jeśli sortowanie danych w czasie rzeczywistym jest włączona; <see langword="false" /> Jeśli sortowanie na żywo nie jest włączone; <see langword="null" /> Jeżeli nie można ustalić, czy widok kolekcji implementuje sortowania na żywo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj with get, set" Usage="System.Windows.Controls.ItemCollection.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu.</param>
        <summary>Pobiera lub ustawia element pod danym indeksem liczony od zera.</summary>
        <value>Obiekt pobierane lub obiekt, który jest ustawiana na określonym indeksie.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Kolekcja została zainicjowana, lub element, aby ustawić już ma logiczną innego elementu nadrzędnego lub kolekcja jest w <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> trybu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks jest poza zakresem.</exception>
      </Docs>
    </Member>
    <Member MemberName="LiveFilteringProperties">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ObservableCollection&lt;string&gt; LiveFilteringProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ObservableCollection`1&lt;string&gt; LiveFilteringProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.LiveFilteringProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LiveFilteringProperties As ObservableCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ObservableCollection&lt;System::String ^&gt; ^ LiveFilteringProperties { System::Collections::ObjectModel::ObservableCollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LiveFilteringProperties : System.Collections.ObjectModel.ObservableCollection&lt;string&gt;" Usage="System.Windows.Controls.ItemCollection.LiveFilteringProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionViewLiveShaping.LiveFilteringProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ObservableCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję ciągów, które są określone właściwości, które uczestniczą w filtrowanie danych w czasie rzeczywistym.</summary>
        <value>Kolekcja ciągów, które są określone właściwości, które uczestniczą w filtrowanie danych w czasie rzeczywistym.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LiveGroupingProperties">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ObservableCollection&lt;string&gt; LiveGroupingProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ObservableCollection`1&lt;string&gt; LiveGroupingProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.LiveGroupingProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LiveGroupingProperties As ObservableCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ObservableCollection&lt;System::String ^&gt; ^ LiveGroupingProperties { System::Collections::ObjectModel::ObservableCollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LiveGroupingProperties : System.Collections.ObjectModel.ObservableCollection&lt;string&gt;" Usage="System.Windows.Controls.ItemCollection.LiveGroupingProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionViewLiveShaping.LiveGroupingProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ObservableCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję ciągów, które określają właściwości, które uczestniczą w procesie grupowania danych w czasie rzeczywistym.</summary>
        <value>Kolekcja ciągów, które określają właściwości, które uczestniczą w procesie grupowania danych w czasie rzeczywistym.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LiveSortingProperties">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ObservableCollection&lt;string&gt; LiveSortingProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ObservableCollection`1&lt;string&gt; LiveSortingProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.LiveSortingProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LiveSortingProperties As ObservableCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ObservableCollection&lt;System::String ^&gt; ^ LiveSortingProperties { System::Collections::ObjectModel::ObservableCollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LiveSortingProperties : System.Collections.ObjectModel.ObservableCollection&lt;string&gt;" Usage="System.Windows.Controls.ItemCollection.LiveSortingProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ICollectionViewLiveShaping.LiveSortingProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ObservableCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję ciągów, które są określone właściwości, które uczestniczą w sortowanie danych w czasie rzeczywistym.</summary>
        <value>Kolekcja ciągów, które są określone właściwości, które uczestniczą w sortowanie danych w czasie rzeczywistym.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentTo">
      <MemberSignature Language="C#" Value="public override bool MoveCurrentTo (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveCurrentTo(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.MoveCurrentTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveCurrentTo (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveCurrentTo(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="override this.MoveCurrentTo : obj -&gt; bool" Usage="itemCollection.MoveCurrentTo item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Ustaw jako element <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" />.</param>
        <summary>Ustawia określony element w kolekcji jako <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" />.</summary>
        <returns><see langword="true" /> Aby wskazać, że wynikowy <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" /> element w widoku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.MoveCurrentTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToFirst">
      <MemberSignature Language="C#" Value="public override bool MoveCurrentToFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveCurrentToFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.MoveCurrentToFirst" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveCurrentToFirst () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveCurrentToFirst();" />
      <MemberSignature Language="F#" Value="override this.MoveCurrentToFirst : unit -&gt; bool" Usage="itemCollection.MoveCurrentToFirst " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia pierwszy element w widoku w postaci <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" />.</summary>
        <returns><see langword="true" /> Aby wskazać, że wynikowy <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" /> element w widoku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.MoveCurrentToFirst" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToLast">
      <MemberSignature Language="C#" Value="public override bool MoveCurrentToLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveCurrentToLast() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.MoveCurrentToLast" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveCurrentToLast () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveCurrentToLast();" />
      <MemberSignature Language="F#" Value="override this.MoveCurrentToLast : unit -&gt; bool" Usage="itemCollection.MoveCurrentToLast " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia ostatniego elementu w widoku w postaci <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" />.</summary>
        <returns><see langword="true" /> Aby wskazać, że wynikowy <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" /> element w widoku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.MoveCurrentToLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToNext">
      <MemberSignature Language="C#" Value="public override bool MoveCurrentToNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveCurrentToNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.MoveCurrentToNext" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveCurrentToNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveCurrentToNext();" />
      <MemberSignature Language="F#" Value="override this.MoveCurrentToNext : unit -&gt; bool" Usage="itemCollection.MoveCurrentToNext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia element po <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" /> w widoku jako <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" />.</summary>
        <returns><see langword="true" /> Aby wskazać, że wynikowy <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" /> element w widoku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.MoveCurrentToNext" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToPosition">
      <MemberSignature Language="C#" Value="public override bool MoveCurrentToPosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveCurrentToPosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.MoveCurrentToPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveCurrentToPosition (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveCurrentToPosition(int position);" />
      <MemberSignature Language="F#" Value="override this.MoveCurrentToPosition : int -&gt; bool" Usage="itemCollection.MoveCurrentToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Liczony od zera indeks elementu do ustawienia jako <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" />.</param>
        <summary>Ustawia element pod określonym indeksem jako <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" /> w widoku.</summary>
        <returns><see langword="true" /> Aby wskazać, że wynikowy <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" /> element w widoku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToPrevious">
      <MemberSignature Language="C#" Value="public override bool MoveCurrentToPrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveCurrentToPrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.MoveCurrentToPrevious" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveCurrentToPrevious () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveCurrentToPrevious();" />
      <MemberSignature Language="F#" Value="override this.MoveCurrentToPrevious : unit -&gt; bool" Usage="itemCollection.MoveCurrentToPrevious " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia element przed <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" /> w widoku jako <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" />.</summary>
        <returns><see langword="true" /> Aby wskazać, że wynikowy <see cref="P:System.Windows.Controls.ItemCollection.CurrentItem" /> element w widoku; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.MoveCurrentToPrevious" />
      </Docs>
    </Member>
    <Member MemberName="NeedsRefresh">
      <MemberSignature Language="C#" Value="public override bool NeedsRefresh { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NeedsRefresh" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.NeedsRefresh" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NeedsRefresh As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool NeedsRefresh { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.NeedsRefresh : bool" Usage="System.Windows.Controls.ItemCollection.NeedsRefresh" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kolekcja musi zostać odświeżona.</summary>
        <value><see langword="true" /> Jeśli kolekcja musi być odświeżane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.Refresh" />
        <altmember cref="M:System.Windows.Controls.ItemCollection.DeferRefresh" />
      </Docs>
    </Member>
    <Member MemberName="PassesFilter">
      <MemberSignature Language="C#" Value="public override bool PassesFilter (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool PassesFilter(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.PassesFilter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function PassesFilter (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool PassesFilter(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="override this.PassesFilter : obj -&gt; bool" Usage="itemCollection.PassesFilter item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do przetestowania.</param>
        <summary>Zwraca wartość wskazującą, czy określony element należy do tego widoku.</summary>
        <returns><see langword="true" /> Aby wskazać, że określony element należy do tego widoku lub nie jest filtr w ramach tego widoku kolekcji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle używana podczas powiadomienia o zmianie kolekcji do określenia, czy określony element należy do tego widoku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RefreshOverride">
      <MemberSignature Language="C#" Value="protected override void RefreshOverride ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RefreshOverride() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.RefreshOverride" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RefreshOverride ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RefreshOverride();" />
      <MemberSignature Language="F#" Value="override this.RefreshOverride : unit -&gt; unit" Usage="itemCollection.RefreshOverride " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (object removeItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object removeItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (removeItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ removeItem);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="itemCollection.Remove removeItem" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="removeItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="removeItem">Obiekt do usunięcia.</param>
        <summary>Usuwa odwołanie określony element z kolekcji lub widoku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element zostanie usunięty z kolekcji, wszystkie pozostałe elementy o wyższych wartościach indeksu dekrementacja zwija rozmiar kolekcji ich indeksu za pomocą jednej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Controls.ItemCollection" /> Jest tylko do odczytu, ponieważ jest on <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> trybu, lub jeśli DeferRefresh jest aktywna.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int removeIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 removeIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (removeIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int removeIndex);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="itemCollection.RemoveAt removeIndex" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="removeIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="removeIndex">Liczony od zera indeks elementu, który ma zostać usunięty.</param>
        <summary>Usuwa element o określonym indeksie kolekcji lub tego widoku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy element zostanie usunięty z kolekcji, wszystkie pozostałe elementy o wyższych wartościach indeksu dekrementacja zwija rozmiar kolekcji ich indeksu za pomocą jednej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Controls.ItemCollection" /> Jest tylko do odczytu, ponieważ jest on <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> trybu, lub jeśli DeferRefresh jest aktywna.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks jest poza zakresem.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortDescriptions">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.SortDescriptionCollection SortDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.SortDescriptionCollection SortDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.SortDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SortDescriptions As SortDescriptionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::SortDescriptionCollection ^ SortDescriptions { System::ComponentModel::SortDescriptionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SortDescriptions : System.ComponentModel.SortDescriptionCollection" Usage="System.Windows.Controls.ItemCollection.SortDescriptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.SortDescriptionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.ComponentModel.SortDescription" /> obiekty, które opisują sposób sortowania elementów w kolekcji w widoku.</summary>
        <value>Kolekcja <see cref="T:System.ComponentModel.SortDescription" /> obiekty, które opisują sposób sortowania elementów w kolekcji w widoku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Controls.ItemCollection.CanSort%2A> właściwości, aby sprawdzić, czy bieżąca implementacja obsługuje sortowanie przed dodaniem <xref:System.ComponentModel.SortDescription> obiekty do <xref:System.ComponentModel.SortDescriptionCollection>.  
  
> [!NOTE]
>  Tę właściwość można ustawić tylko dostęp do obiektu kolekcji, a przy użyciu jego różnych metod, takich jak `Add`. Właściwości dostępu do obiektu kolekcji jest tylko do odczytu, gdy samotnou kolekci odczytu i zapisu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceCollection">
      <MemberSignature Language="C#" Value="public override System.Collections.IEnumerable SourceCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerable SourceCollection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.SourceCollection" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SourceCollection As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IEnumerable ^ SourceCollection { System::Collections::IEnumerable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceCollection : System.Collections.IEnumerable" Usage="System.Windows.Controls.ItemCollection.SourceCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję nieposortowane i niefiltrowane, która jest podporządkowana narzędziu tego widoku kolekcji.</summary>
        <value><see cref="T:System.Collections.IEnumerable" /> Obiekt, który jest odpowiednia Kolekcja lub podanego przez użytkownika <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> kolekcji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <value><see langword="true" /> Jeśli dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wątkowo); w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Collections.IList" /> ma stały rozmiar; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ten element członkowski obsługuje [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastrukturę i nie jest przeznaczona do użycia bezpośrednio w kodzie.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Collections.IList" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.AddNew">
      <MemberSignature Language="C#" Value="object IEditableCollectionView.AddNew ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ComponentModel.IEditableCollectionView.AddNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#AddNew" />
      <MemberSignature Language="VB.NET" Value="Function AddNew () As Object Implements IEditableCollectionView.AddNew" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ComponentModel.IEditableCollectionView.AddNew() = System::ComponentModel::IEditableCollectionView::AddNew;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IEditableCollectionView.AddNew</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dodaje nowy element do kolekcji.</summary>
        <returns>Nowy element zostanie dodany do kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.CanAddNew">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IEditableCollectionView.CanAddNew { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IEditableCollectionView.CanAddNew" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#CanAddNew" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CanAddNew As Boolean Implements IEditableCollectionView.CanAddNew" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IEditableCollectionView::CanAddNew { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IEditableCollectionView.CanAddNew" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IEditableCollectionView.CanAddNew</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy nowy element może być dodany do kolekcji.</summary>
        <value><see langword="true" /> Jeśli nowy element może być dodany do kolekcji w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.CanCancelEdit">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IEditableCollectionView.CanCancelEdit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IEditableCollectionView.CanCancelEdit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#CanCancelEdit" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CanCancelEdit As Boolean Implements IEditableCollectionView.CanCancelEdit" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IEditableCollectionView::CanCancelEdit { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IEditableCollectionView.CanCancelEdit" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IEditableCollectionView.CanCancelEdit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy widok kolekcji można odrzucić oczekujące zmiany i przywrócić oryginalnych wartości edytowanego obiektu.</summary>
        <value><see langword="true" /> Jeśli widok kolekcji można odrzucić oczekujące zmiany i przywrócić oryginalnych wartości edytowanych obiektów. w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.CancelEdit">
      <MemberSignature Language="C#" Value="void IEditableCollectionView.CancelEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IEditableCollectionView.CancelEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#CancelEdit" />
      <MemberSignature Language="VB.NET" Value="Sub CancelEdit () Implements IEditableCollectionView.CancelEdit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IEditableCollectionView.CancelEdit() = System::ComponentModel::IEditableCollectionView::CancelEdit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IEditableCollectionView.CancelEdit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się transakcji edycji, a jeśli to możliwe, spowoduje przywrócenie oryginalnej wartości elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.CancelNew">
      <MemberSignature Language="C#" Value="void IEditableCollectionView.CancelNew ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IEditableCollectionView.CancelNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#CancelNew" />
      <MemberSignature Language="VB.NET" Value="Sub CancelNew () Implements IEditableCollectionView.CancelNew" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IEditableCollectionView.CancelNew() = System::ComponentModel::IEditableCollectionView::CancelNew;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IEditableCollectionView.CancelNew</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy transakcji Dodaj i odrzuca wszystkie oczekujące nowy element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.CanRemove">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IEditableCollectionView.CanRemove { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IEditableCollectionView.CanRemove" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#CanRemove" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CanRemove As Boolean Implements IEditableCollectionView.CanRemove" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IEditableCollectionView::CanRemove { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IEditableCollectionView.CanRemove" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IEditableCollectionView.CanRemove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy element może być usunięty z kolekcji.</summary>
        <value><see langword="true" /> Jeśli element może być usunięty z kolekcji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.CommitEdit">
      <MemberSignature Language="C#" Value="void IEditableCollectionView.CommitEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IEditableCollectionView.CommitEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#CommitEdit" />
      <MemberSignature Language="VB.NET" Value="Sub CommitEdit () Implements IEditableCollectionView.CommitEdit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IEditableCollectionView.CommitEdit() = System::ComponentModel::IEditableCollectionView::CommitEdit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IEditableCollectionView.CommitEdit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się transakcji edycji, a następnie zapisuje oczekujące zmiany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.CommitNew">
      <MemberSignature Language="C#" Value="void IEditableCollectionView.CommitNew ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IEditableCollectionView.CommitNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#CommitNew" />
      <MemberSignature Language="VB.NET" Value="Sub CommitNew () Implements IEditableCollectionView.CommitNew" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IEditableCollectionView.CommitNew() = System::ComponentModel::IEditableCollectionView::CommitNew;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IEditableCollectionView.CommitNew</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się transakcji Dodaj i zapisuje oczekujące nowy element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.CurrentAddItem">
      <MemberSignature Language="C#" Value="object System.ComponentModel.IEditableCollectionView.CurrentAddItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.ComponentModel.IEditableCollectionView.CurrentAddItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#CurrentAddItem" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CurrentAddItem As Object Implements IEditableCollectionView.CurrentAddItem" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::ComponentModel::IEditableCollectionView::CurrentAddItem { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IEditableCollectionView.CurrentAddItem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IEditableCollectionView.CurrentAddItem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element, który jest dodawany w trakcie bieżącego Dodaj transakcję.</summary>
        <value>Element, który jest dodawany, jeśli <see cref="P:System.ComponentModel.IEditableCollectionView.IsAddingNew" /> jest <see langword="true" />; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.CurrentEditItem">
      <MemberSignature Language="C#" Value="object System.ComponentModel.IEditableCollectionView.CurrentEditItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.ComponentModel.IEditableCollectionView.CurrentEditItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#CurrentEditItem" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CurrentEditItem As Object Implements IEditableCollectionView.CurrentEditItem" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::ComponentModel::IEditableCollectionView::CurrentEditItem { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IEditableCollectionView.CurrentEditItem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IEditableCollectionView.CurrentEditItem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element w kolekcji, która jest edytowany.</summary>
        <value>Element w kolekcji, która jest edytowany, jeśli <see cref="P:System.ComponentModel.IEditableCollectionView.IsEditingItem" /> jest <see langword="true" />; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.EditItem">
      <MemberSignature Language="C#" Value="void IEditableCollectionView.EditItem (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IEditableCollectionView.EditItem(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#EditItem(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub EditItem (item As Object) Implements IEditableCollectionView.EditItem" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IEditableCollectionView.EditItem(System::Object ^ item) = System::ComponentModel::IEditableCollectionView::EditItem;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IEditableCollectionView.EditItem(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Do edycji elementu.</param>
        <summary>Rozpoczyna się transakcja edycji określonego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.IsAddingNew">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IEditableCollectionView.IsAddingNew { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IEditableCollectionView.IsAddingNew" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#IsAddingNew" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAddingNew As Boolean Implements IEditableCollectionView.IsAddingNew" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IEditableCollectionView::IsAddingNew { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IEditableCollectionView.IsAddingNew" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IEditableCollectionView.IsAddingNew</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy transakcja Dodaj jest w toku.</summary>
        <value><see langword="true" /> Jeśli transakcja Dodaj jest w toku; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.IsEditingItem">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IEditableCollectionView.IsEditingItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IEditableCollectionView.IsEditingItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#IsEditingItem" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsEditingItem As Boolean Implements IEditableCollectionView.IsEditingItem" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IEditableCollectionView::IsEditingItem { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IEditableCollectionView.IsEditingItem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IEditableCollectionView.IsEditingItem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy transakcja Edycja jest w toku.</summary>
        <value><see langword="true" /> Jeśli transakcja Edycja jest w toku; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition">
      <MemberSignature Language="C#" Value="System.ComponentModel.NewItemPlaceholderPosition System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.NewItemPlaceholderPosition System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#NewItemPlaceholderPosition" />
      <MemberSignature Language="VB.NET" Value=" Property NewItemPlaceholderPosition As NewItemPlaceholderPosition Implements IEditableCollectionView.NewItemPlaceholderPosition" />
      <MemberSignature Language="C++ CLI" Value="property System::ComponentModel::NewItemPlaceholderPosition System::ComponentModel::IEditableCollectionView::NewItemPlaceholderPosition { System::ComponentModel::NewItemPlaceholderPosition get(); void set(System::ComponentModel::NewItemPlaceholderPosition value); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.NewItemPlaceholderPosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie symbolu zastępczego nowego elementu w widoku kolekcji.</summary>
        <value>Jedna z wartości wyliczenia, które określa pozycję Nowy symbol zastępczy element w widoku kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.Remove">
      <MemberSignature Language="C#" Value="void IEditableCollectionView.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IEditableCollectionView.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IEditableCollectionView.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IEditableCollectionView.Remove(System::Object ^ item) = System::ComponentModel::IEditableCollectionView::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Element do usunięcia.</param>
        <summary>Usuwa określony element z kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionView.RemoveAt">
      <MemberSignature Language="C#" Value="void IEditableCollectionView.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IEditableCollectionView.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionView#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IEditableCollectionView.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IEditableCollectionView.RemoveAt(int index) = System::ComponentModel::IEditableCollectionView::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Położenie elementu do usunięcia.</param>
        <summary>Usuwa element w określonej pozycji z kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionView> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionViewAddNewItem.AddNewItem">
      <MemberSignature Language="C#" Value="object IEditableCollectionViewAddNewItem.AddNewItem (object newItem);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ComponentModel.IEditableCollectionViewAddNewItem.AddNewItem(object newItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionViewAddNewItem#AddNewItem(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function AddNewItem (newItem As Object) As Object Implements IEditableCollectionViewAddNewItem.AddNewItem" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ComponentModel.IEditableCollectionViewAddNewItem.AddNewItem(System::Object ^ newItem) = System::ComponentModel::IEditableCollectionViewAddNewItem::AddNewItem;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IEditableCollectionViewAddNewItem.AddNewItem(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newItem" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="newItem">Obiekt do dodania do kolekcji.</param>
        <summary>Dodaje określony obiekt do kolekcji.</summary>
        <returns>Obiekt, który został dodany do kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionViewAddNewItem> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IEditableCollectionViewAddNewItem.CanAddNewItem">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IEditableCollectionViewAddNewItem.CanAddNewItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IEditableCollectionViewAddNewItem.CanAddNewItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#ComponentModel#IEditableCollectionViewAddNewItem#CanAddNewItem" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CanAddNewItem As Boolean Implements IEditableCollectionViewAddNewItem.CanAddNewItem" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IEditableCollectionViewAddNewItem::CanAddNewItem { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IEditableCollectionViewAddNewItem.CanAddNewItem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IEditableCollectionViewAddNewItem.CanAddNewItem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy określony obiekt może być dodany do kolekcji.</summary>
        <value><see langword="true" /> Jeśli określony obiekt można dodać do kolekcji w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IEditableCollectionViewAddNewItem> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IItemProperties.ItemProperties">
      <MemberSignature Language="C#" Value="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.ComponentModel.ItemPropertyInfo&gt; System.ComponentModel.IItemProperties.ItemProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.ComponentModel.ItemPropertyInfo&gt; System.ComponentModel.IItemProperties.ItemProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemCollection.System#ComponentModel#IItemProperties#ItemProperties" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ItemProperties As ReadOnlyCollection(Of ItemPropertyInfo) Implements IItemProperties.ItemProperties" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::ComponentModel::ItemPropertyInfo ^&gt; ^ System::ComponentModel::IItemProperties::ItemProperties { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::ComponentModel::ItemPropertyInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IItemProperties.ItemProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IItemProperties.ItemProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.ComponentModel.ItemPropertyInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję, która zawiera informacje na temat właściwości, które są dostępne dla elementów w kolekcji.</summary>
        <value>Kolekcja, która zawiera informacje na temat właściwości, które są dostępne dla elementów w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.ComponentModel.IItemProperties> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IWeakEventListener.ReceiveWeakEvent">
      <MemberSignature Language="C#" Value="bool IWeakEventListener.ReceiveWeakEvent (Type managerType, object sender, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.IWeakEventListener.ReceiveWeakEvent(class System.Type managerType, object sender, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemCollection.System#Windows#IWeakEventListener#ReceiveWeakEvent(System.Type,System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Function ReceiveWeakEvent (managerType As Type, sender As Object, e As EventArgs) As Boolean Implements IWeakEventListener.ReceiveWeakEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type ^ managerType, System::Object ^ sender, EventArgs ^ e) = System::Windows::IWeakEventListener::ReceiveWeakEvent;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IWeakEventListener.ReceiveWeakEvent(System.Type,System.Object,System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="managerType">Typ <see cref="T:System.Windows.WeakEventManager" /> wywołanie tej metody.</param>
        <param name="sender">Obiekt, który pochodzi zdarzenie.</param>
        <param name="e">Dane zdarzenia.</param>
        <summary>Odbiera zdarzenia z Menedżera scentralizowane zdarzeń.</summary>
        <returns><see langword="true" /> Jeśli odbiornik obsługi zdarzenia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Windows.Controls.ItemCollection> wystąpienia jest rzutowany na <xref:System.Windows.IWeakEventListener> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="423f853a60d99a5767f47d8a9e4d3ef0dce3cb15" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39845061" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiuje zachowanie niektórych aspektów właściwości zależności, natychmiast po zastosowaniu do określonego typu, w tym warunki, który został zarejestrowany za pomocą.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane właściwości mogą być definiowane i używany podczas rejestracji właściwość zależności podczas wywoływania <xref:System.Windows.DependencyProperty.Register%2A> — metoda (lub odmiany dołączone właściwości lub właściwości zależności tylko do odczytu) lub po pierwotnej rejestracji właściciel podczas wywoływania <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> metody. <xref:System.Windows.DependencyProperty.AddOwner%2A> pobiera również metadanych właściwości modelu.  
  
 Ta klasa jest konkretnej klasy podstawowej, która może być używana w każdej z tych wywołań. Jednak to bardzo powszechne, aby określić metadanych przy użyciu jednej z klas pochodnych, takich jak <xref:System.Windows.FrameworkPropertyMetadata>. Te klasy pochodnej obsługuje bardziej szczegółowe metadanych jako wartości właściwości typu Boolean, które są przydatne w przypadku wykrycia lub włączenie niektórych właściwości systemu i układ zachowania, które są implementowane tylko na [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] poziomie struktury.  
  
 Kilka właściwości tej klasy jest odczytu i zapisu w modelu obiektów, ale może być zapisany tylko przed wystąpienia, takich jak używane w ramach operacji systemu właściwości <xref:System.Windows.DependencyProperty.Register%2A> lub <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>. Każda z tych właściwości może być także ustawiona przez konstruktora, ale są widoczne, aby <xref:System.Windows.PropertyMetadata.Merge%2A> je ustawić implementacje metod.  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Ten typ i elementy członkowskie tego typu nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna do określenia dla właściwości zależności, zwykle dostarczane jako wartości niektóre określonego typu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy z określoną wartość domyślną dla właściwości zależności, które te metadane zostaną zastosowane do.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości parametru `defaultValue` muszą być zgodne, lub być one związane z typem określonym w oryginalnej rejestrację właściwości zależności, które te metadane zostaną zastosowane do. Niezgodności między metadanych domyślny typ wartości i typ właściwości zależności, które są stosowane do może być trudne do debugowania, ponieważ ta niezgodność występuje wykrywalny podczas kompilacji (niezgodność zgłosi wyjątek czasu wykonywania).  
  
 Chociaż istnieje domyślny dla konstruktora bez parametrów `defaultValue` z <xref:System.Windows.DependencyProperty.UnsetValue> nie może być określony. Próby podjęły zgłosi wyjątek.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> Nie można ustawić na wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który ma być wywoływany przez system właściwości, zawsze wtedy, gdy zmienia się od wartości właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy z określonym <see cref="T:System.Windows.PropertyChangedCallback" /> odwołanie do implementacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle dostarczane jako wartości niektóre określonego typu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który ma być wywoływany przez system właściwości, zawsze wtedy, gdy zmienia się od wartości właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy z określoną wartość domyślną i <see cref="T:System.Windows.PropertyChangedCallback" /> odwołanie do implementacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości, podane `defaultValue` muszą być zgodne, lub być one związane z typem określonym w oryginalnej rejestrację właściwości zależności, które te metadane zostaną zastosowane do. Niezgodności między metadanych domyślny typ wartości i typ właściwości zależności, które są stosowane do może być trudne do debugowania, ponieważ ta niezgodność występuje wykrywalny podczas kompilacji (niezgodność zgłosi wyjątek czasu wykonywania).  
  
 Chociaż istnieje domyślny dla konstruktora bez parametrów `defaultValue` z <xref:System.Windows.DependencyProperty.UnsetValue> nie może być określony. Próby podjęły zgłosi wyjątek.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> Nie można ustawić na wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle dostarczane jako wartości niektóre określonego typu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, który ma być wywoływany przez system właściwości, zawsze wtedy, gdy zmienia się od wartości właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, który ma być wywoływana zawsze wtedy, gdy system właściwość wywołuje <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> względem tej właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy z określoną wartość domyślną i wywołania zwrotne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli chcesz określić <xref:System.Windows.CoerceValueCallback> , ale nie <xref:System.Windows.PropertyChangedCallback>, można przekazać `null` dla `propertyChangedCallback` parametru.  
  
 Typ wartości parametru `defaultValue` muszą być zgodne, lub być one związane z typem określonym w oryginalnej rejestrację właściwości zależności, które te metadane zostaną zastosowane do. Niezgodności między metadanych domyślny typ wartości i typ właściwości zależności, które są stosowane do może być trudne do debugowania, ponieważ ta niezgodność występuje wykrywalny podczas kompilacji (niezgodność zgłosi wyjątek czasu wykonywania).  
  
 Chociaż istnieje domyślny dla konstruktora bez parametrów `defaultValue` z <xref:System.Windows.DependencyProperty.UnsetValue> nie może być określony. Próby podjęły zgłosi wyjątek.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> Nie można ustawić na wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odwołanie <see cref="T:System.Windows.CoerceValueCallback" /> implementacji określonego w metadanych.</summary>
        <value>A <see cref="T:System.Windows.CoerceValueCallback" /> odwołanie do implementacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania zwrotne w metadanych właściwości nie są zwykle publiczne elementy członkowskie w typie zawierającym, więc wartość tej właściwości nie jest ważna w przypadku większości scenariuszy korzystających z tylko metadanych istniejącej właściwości zależności. Jednym z powodów ta właściwość jest uwidaczniana jest tak, aby podklasy metadanych może wykonać logikę żądaną scalania, jeśli podstawowy metadane i zastępowanie/Dodawanie metadanych określ <xref:System.Windows.CoerceValueCallback>. Jednak domyślnie scalania logikę <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> ma zastąpić poprzedni.  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> jest zdefiniowany w modelu obiektu jako odczytu i zapisu. Dzieje się tak <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> można zmienić po zainicjowaniu elementu <xref:System.Windows.PropertyMetadata> sam obiekt. Jednak po zużyciu metadanych jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości są teraz uważany za niezmienialny. Trwa próba skonfigurowania <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić właściwości metadanych, po zastosowaniu operacji właściwość zależności.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślną wartość właściwości zależności.</summary>
        <value>Wartość domyślna właściwości. Wartość domyślna dla <see cref="T:System.Windows.PropertyMetadata" /> wystąpienia utworzone za pomocą konstruktora bez parametrów zostaną <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> jest zdefiniowany w modelu obiektu jako odczytu i zapisu. Dzieje się tak <xref:System.Windows.PropertyMetadata.DefaultValue%2A> można zmienić po zainicjowaniu elementu <xref:System.Windows.PropertyMetadata> sam obiekt. Jednak po zużyciu metadanych jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości są teraz uważany za niezmienialny. Trwa próba skonfigurowania <xref:System.Windows.PropertyMetadata.DefaultValue%2A> po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
 Chociaż istnieje domyślny dla konstruktora bez parametrów `defaultValue` z <xref:System.Windows.DependencyProperty.UnsetValue> nie można ustawić za pomocą <xref:System.Windows.PropertyMetadata.DefaultValue%2A> lub konstruktora. Próby podjęły zgłosi wyjątek.  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tego typu nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie można ustawić na wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> po utworzeniu.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić właściwości metadanych, po zastosowaniu operacji właściwość zależności.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy metadane zostały zastosowane do właściwości w jakiś sposób skutkuje niezmiennego stanu danego wystąpienia metadanych.</summary>
        <value>
          <see langword="true" /> Jeśli wystąpienie metadanych jest niezmienny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Różne właściwości <xref:System.Windows.PropertyMetadata>, takich jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, są zdefiniowane w modelu obiektu jako odczytu i zapisu. Jest to, aby te właściwości można zmienić po zainicjowaniu elementu <xref:System.Windows.PropertyMetadata> sam obiekt. Jednak po zastosowaniu metadanych właściwości zależności jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości są teraz uważany za niezmienialny. W czasie jednej z tych wywołań <xref:System.Windows.PropertyMetadata.OnApply%2A> nosi nazwę, a wartość tej właściwości jest równa `true`.  
  
   
  
## Examples  
 Następujące testy przykład <xref:System.Windows.PropertyMetadata.IsSealed%2A> przed operacją zestaw właściwości niestandardowych metadanych.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Podstawowy metadane do scalenia z wartościami tego wystąpienia.</param>
        <param name="dp">Właściwości zależności, do którego jest stosowane w metadanych.</param>
        <summary>Scala te metadane za pomocą podstawowej metadanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana wewnętrznie, gdy metadane są zastępowane (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metody).  
  
   
  
## Examples  
 Poniższy przykład implementuje scalania dla typu niestandardowych metadanych, który dodaje dodatkowe właściwości metadanych właściwości modelu.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Klasa implementacji, które wynikają z <see cref="T:System.Windows.PropertyMetadata" /> powinny przesłaniać tę metodę, aby uwzględnić wszystkie właściwości metadanych dodali w implementacji. Na przykład implementacji, że dodano nową wartość wyliczenia flagwise i <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementacji następnie powinien mieć możliwość łączenia tych flag poprawnie.  Zawsze wywoływać implementację podstawową przed kod implementacji, ponieważ Podstawowa implementacja dba o wszystkie właściwości, które są już zdefiniowane na scalanie <see cref="T:System.Windows.PropertyMetadata" /> typu.  Dokładne zachowanie scalania jest do Ciebie. Można wybrać wartości w połączeniu, przywrócić wartości bazowej, jeśli pozostawiono pochodnej metadanych na domyślny lub wielu innych zachowań na podstawie typów właściwości, które zostały dodane do klasy określonej metadanych i ich znaczenie.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwości zależności, do którego zastosowano metadanych.</param>
        <param name="targetType">Typ skojarzony z metadanych, jeśli jest to metadane specyficzne dla danego typu. Jeśli jest to domyślny metadanych, ta wartość jest odwołanie o wartości null.</param>
        <summary>Wywołuje się, gdy metadane zostały doliczone do właściwości, co oznacza, że metadane jest zapieczętowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podklasy powinny zapewnić, że wszelkie zmienność struktury danych <xref:System.Windows.PropertyMetadata> podklasy powinien być oznaczony jako niezmienialny raz <xref:System.Windows.PropertyMetadata.OnApply%2A> jest wywoływana. Ta zostanie wywołana, po zastosowaniu metadanych dla działania systemu właściwości (rejestrowanie, dodawanie właściciela, Zastąp metadane).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odwołanie <see cref="T:System.Windows.PropertyChangedCallback" /> implementacji określonego w metadanych.</summary>
        <value>A <see cref="T:System.Windows.PropertyChangedCallback" /> odwołanie do implementacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania zwrotne w metadanych właściwości nie są zwykle publiczne elementy członkowskie na typ definiujący, więc wartość tej właściwości nie jest ważna w przypadku większości scenariuszy korzystających z tylko metadanych istniejącej właściwości zależności. Jednym z powodów ta właściwość jest uwidaczniana jest tak, aby metadanych klas może wykonać logikę żądaną scalania, jeśli podstawowy metadane i zastępowanie/Dodawanie metadanych określ <xref:System.Windows.PropertyChangedCallback>. Domyślną logikę scalania jest zachowanie wszystkich <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementacji w tabeli i wywołania ich za pomocą wywołania zwrotne ustanowione przez klasę najgłębiej zagnieżdżoną w hierarchii systemem pierwsze.  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> jest zdefiniowany w modelu obiektu jako odczytu i zapisu. Dzieje się tak <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> można zmienić po zainicjowaniu elementu <xref:System.Windows.PropertyMetadata> sam obiekt. Jednak po zużyciu metadanych jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości zostanie zapieczętowania to wystąpienie metadanych i właściwości są teraz uważany za niezmienialny. Trwa próba skonfigurowania <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić właściwości metadanych, po zastosowaniu operacji właściwość zależności.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
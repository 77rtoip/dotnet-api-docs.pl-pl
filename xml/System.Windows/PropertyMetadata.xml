<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cfaa68a67cd83c15d520906814bae974a118e88e" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69444313" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiuje pewne aspekty zachowania właściwości zależności, które są stosowane do określonego typu, włącznie z warunkami, w których zostały zarejestrowane.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane właściwości mogą być definiowane i używane podczas rejestracji właściwości zależności podczas wywoływania <xref:System.Windows.DependencyProperty.Register%2A> metody (lub odmian dla dołączonych właściwości lub właściwości zależności tylko do odczytu) lub po zakończeniu rejestracji pierwotnego właściciela podczas wywoływania <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> Metoda. <xref:System.Windows.DependencyProperty.AddOwner%2A>Pobiera również metadane właściwości.  
  
 Ta klasa jest konkretną klasą bazową, która może być używana w każdym z tych wywołań. Jednak bardzo często należy określić metadane przy użyciu jednej z klas pochodnych, takich jak <xref:System.Windows.FrameworkPropertyMetadata>. Te klasy pochodne obsługują bardziej szczegółowe metadane przenoszone jako wartości właściwości logicznych, które są przydatne do wykrywania lub włączania niektórych zachowań systemu właściwości i układu, które są implementowane tylko [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] na poziomie platformy.  
  
 Niektóre właściwości tej klasy są do odczytu i zapisu do modelu obiektów, ale mogą być zapisywane tylko przed wystąpieniem używanym w operacji systemu właściwości, takiej jak <xref:System.Windows.DependencyProperty.Register%2A> lub. <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> Każdą z tych właściwości można również ustawić przez konstruktora, ale są one uwidocznione, aby <xref:System.Windows.PropertyMetadata.Merge%2A> implementacje metod mogły je skonfigurować.  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Ten typ i składowe tego typu nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna do określenia dla właściwości zależności, zazwyczaj określona jako wartość określonego typu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.PropertyMetadata" /> klasy z określoną wartością domyślną dla właściwości zależności, do której zostaną zastosowane te metadane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ podanej `defaultValue` wartości musi być zgodny lub być powiązany z typem określonym w oryginalnej rejestracji właściwości zależności, do której zostaną zastosowane te metadane. Niezgodność między domyślnym typem wartości metadanych a typem właściwości zależności, która jest stosowana, może być trudna do debugowania, ponieważ nie jest wykrywalna podczas kompilacji (niezgodność spowoduje wystąpienie wyjątku czasu wykonywania).  
  
 Chociaż jest to wartość domyślna dla konstruktora bez parametrów, `defaultValue` <xref:System.Windows.DependencyProperty.UnsetValue> nie można określić elementu. Próba wykonania tej czynności spowoduje wystąpienie wyjątku.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />nie można ustawić wartości <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, która ma zostać wywołana przez system właściwości za każdym razem, gdy rzeczywista wartość właściwości zostanie zmieniona.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.PropertyMetadata" /> klasy z określonym <see cref="T:System.Windows.PropertyChangedCallback" /> odwołaniem do implementacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zazwyczaj określona jako wartość pewnego określonego typu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, która ma zostać wywołana przez system właściwości za każdym razem, gdy rzeczywista wartość właściwości zostanie zmieniona.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.PropertyMetadata" /> klasy z określoną wartością domyślną i <see cref="T:System.Windows.PropertyChangedCallback" /> odwołaniem do implementacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ podanej `defaultValue` wartości musi być zgodny lub być powiązany z typem określonym w oryginalnej rejestracji właściwości zależności, do której zostaną zastosowane te metadane. Niezgodność między domyślnym typem wartości metadanych a typem właściwości zależności, która jest stosowana, może być trudna do debugowania, ponieważ nie jest wykrywalna podczas kompilacji (niezgodność spowoduje wystąpienie wyjątku czasu wykonywania).  
  
 Chociaż jest to wartość domyślna dla konstruktora bez parametrów, `defaultValue` <xref:System.Windows.DependencyProperty.UnsetValue> nie można określić elementu. Próba wykonania tej czynności spowoduje wystąpienie wyjątku.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />nie można ustawić wartości <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zazwyczaj określona jako wartość pewnego określonego typu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, która ma zostać wywołana przez system właściwości za każdym razem, gdy rzeczywista wartość właściwości zostanie zmieniona.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, która ma być wywoływana za każdym razem, gdy <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> system właściwości wywołuje tę właściwość.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.PropertyMetadata" /> klasy z określoną wartością domyślną i wywołaniami zwrotnymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.CoerceValueCallback> chcesz określić <xref:System.Windows.PropertyChangedCallback>, ale nie do, można przekazać `null` `propertyChangedCallback` parametr.  
  
 Typ podanej `defaultValue` wartości musi być zgodny lub być powiązany z typem określonym w oryginalnej rejestracji właściwości zależności, do której zostaną zastosowane te metadane. Niezgodność między domyślnym typem wartości metadanych a typem właściwości zależności, która jest stosowana, może być trudna do debugowania, ponieważ nie jest wykrywalna podczas kompilacji (niezgodność spowoduje wystąpienie wyjątku czasu wykonywania).  
  
 Chociaż jest to wartość domyślna dla konstruktora bez parametrów, `defaultValue` <xref:System.Windows.DependencyProperty.UnsetValue> nie można określić elementu. Próba wykonania tej czynności spowoduje wystąpienie wyjątku.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />nie można ustawić wartości <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odwołanie do <see cref="T:System.Windows.CoerceValueCallback" /> implementacji określonej w tych metadanych.</summary>
        <value>Odwołanie <see cref="T:System.Windows.CoerceValueCallback" /> do implementacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania zwrotne w metadanych właściwości nie są zwykle publicznymi elementami członkowskimi typu zawierającego, więc wartość tej właściwości nie jest istotna dla większości scenariuszy, które po prostu zużywają metadane istniejącej właściwości zależności. Jednym z powodów, dla których ta właściwość jest narażona, jest to, że podklasy metadanych mogą wykonywać żądaną logikę scalania, jeśli oba metadane <xref:System.Windows.CoerceValueCallback>podstawowe i przesłanianie/dodawanie metadanych określają. Jednak domyślna logika scalania dla a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> ma zastąpić poprzednią.  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>jest zdefiniowany w modelu obiektów jako do odczytu i zapisu. Można to zmienić po zainicjowaniu <xref:System.Windows.PropertyMetadata> samego obiektu. <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje opieczętowanie, że wystąpienie metadanych i właściwości są teraz traktowane jako niezmienne. Próba ustawienia <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A> raz wtymwystąpieniumetadanychspowodujewystąpieniewyjątku.`true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić właściwości metadanych, gdy zostanie ona zastosowana do operacji właściwości zależności.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość domyślną właściwości zależności.</summary>
        <value>Wartość domyślna właściwości. Wartość domyślna w <see cref="T:System.Windows.PropertyMetadata" /> wystąpieniu utworzonym za pomocą konstruktora bez parametrów <see cref="F:System.Windows.DependencyProperty.UnsetValue" />będzie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>jest zdefiniowany w modelu obiektów jako do odczytu i zapisu. Można to zmienić po zainicjowaniu <xref:System.Windows.PropertyMetadata> samego obiektu. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje opieczętowanie, że wystąpienie metadanych i właściwości są teraz traktowane jako niezmienne. Próba ustawienia <xref:System.Windows.PropertyMetadata.DefaultValue%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A> raz wtymwystąpieniumetadanychspowodujewystąpieniewyjątku.`true`  
  
 Chociaż jest to wartość domyślna dla konstruktora bez parametrów, `defaultValue` <xref:System.Windows.DependencyProperty.UnsetValue> <xref:System.Windows.PropertyMetadata.DefaultValue%2A> nie można ustawiać przy użyciu ani konstruktora. Próba wykonania tej czynności spowoduje wystąpienie wyjątku.  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tego typu nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]programie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie można ustawić na wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> po utworzeniu.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić właściwości metadanych, gdy zostanie ona zastosowana do operacji właściwości zależności.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy metadane zostały zastosowane do właściwości w jakiś sposób, co skutkuje niezmiennym stanem tego wystąpienia metadanych.</summary>
        <value><see langword="true" />Jeśli wystąpienie metadanych jest niezmienne; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Różne właściwości <xref:System.Windows.PropertyMetadata>, takie jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, są zdefiniowane w modelu obiektów jako do odczytu i zapisu. Dzieje się tak, aby można było dostosować te właściwości po zainicjowaniu <xref:System.Windows.PropertyMetadata> samego obiektu. Jednak po zastosowaniu metadanych do właściwości zależności w ramach wywołania do <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości będzie zapieczętować to wystąpienie metadanych i właściwości są teraz traktowane jako niezmienne. W czasie jednego z tych wywołań <xref:System.Windows.PropertyMetadata.OnApply%2A> jest wywoływana, a wartość tej właściwości jest ustawiona na. `true`  
  
   
  
## Examples  
 Poniższy przykład sprawdza <xref:System.Windows.PropertyMetadata.IsSealed%2A> przed operacją ustawiania niestandardowej właściwości metadanych.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Podstawowe metadane do scalenia z wartościami tego wystąpienia.</param>
        <param name="dp">Właściwość zależności, do której są stosowane te metadane.</param>
        <summary>Scala te metadane z podstawowymi metadanymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana wewnętrznie w przypadku przesłaniania metadanych (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Metoda).  
  
   
  
## Examples  
 Poniższy przykład implementuje scalanie dla niestandardowego typu metadanych, który dodaje dodatkową właściwość do metadanych właściwości.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Implementacje klas, które <see cref="T:System.Windows.PropertyMetadata" /> pochodzą z powinny zastąpić tę metodę, w celu uwzględnienia wszelkich właściwości metadanych, które zostały dodane do ich implementacji. Na przykład Twoja implementacja mogła dodać nową wartość wyliczenia flagwise, a <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementacja powinna mieć możliwość poprawnego łączenia tych flag.  
  
Zawsze należy wywoływać implementację podstawową przed kodem implementacji, ponieważ podstawowa implementacja jest w trakcie scalania wszystkich właściwości już zdefiniowanych w <see cref="T:System.Windows.PropertyMetadata" /> typie.  
  
Dokładne zachowanie scalania jest aktualne. Można wybrać opcję łączenia wartości, przywrócić wartość bazową, jeśli metadane pochodne zostały pozostawione domyślnie lub wiele innych zachowań opartych na typach właściwości, które zostały dodane do określonej klasy metadanych, i ich znaczenia.</para></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwość zależności, do której zastosowano metadane.</param>
        <param name="targetType">Typ skojarzony z tymi metadanymi, jeśli jest to metadane specyficzne dla określonego typu. Jeśli jest to metadane domyślne, ta wartość jest odwołaniem o wartości null.</param>
        <summary>Wywoływana, gdy te metadane zostały zastosowane do właściwości, co oznacza, że metadane są zapieczętowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podklasy powinny zapewnić, że wszystkie zmienność struktury <xref:System.Windows.PropertyMetadata> danych podklasy powinny być oznaczone jako niezmienne, gdy <xref:System.Windows.PropertyMetadata.OnApply%2A> jest wywoływana. Ten element zostanie wywołany po zastosowaniu metadanych do operacji systemu właściwości (Register, Add Owner, override Metadata).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odwołanie do <see cref="T:System.Windows.PropertyChangedCallback" /> implementacji określonej w tych metadanych.</summary>
        <value>Odwołanie <see cref="T:System.Windows.PropertyChangedCallback" /> do implementacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania zwrotne w metadanych właściwości nie są zwykle publicznymi elementami członkowskimi typu definiującego, więc wartość tej właściwości nie jest istotna dla większości scenariuszy, które po prostu zużywają metadane istniejącej właściwości zależności. Jednym z powodów, dla których ta właściwość jest ujawniana, jest to, że klasy metadanych mogą wykonywać żądaną logikę scalania, jeśli oba <xref:System.Windows.PropertyChangedCallback>metadane podstawowe i przesłanianie/dodawanie metadanych określają. Domyślna logika scalania dla programu to obsługa wszystkich <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementacji w tabeli i wywoływanie każdej z nich, z wywołaniami zwrotnymi ustanowionymi przez najgłębszej klasy w hierarchii uruchomionej jako pierwsze.  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>jest zdefiniowany w modelu obiektów jako do odczytu i zapisu. Można to zmienić po zainicjowaniu <xref:System.Windows.PropertyMetadata> samego obiektu. <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> Jednak po wykorzystaniu metadanych jako części wywołania metody <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwości spowoduje opieczętowanie, że wystąpienie metadanych i właściwości są teraz traktowane jako niezmienne. Próba ustawienia <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> <xref:System.Windows.PropertyMetadata.IsSealed%2A> raz wtymwystąpieniumetadanychspowodujewystąpieniewyjątku.`true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić właściwości metadanych, gdy zostanie ona zastosowana do operacji właściwości zależności.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

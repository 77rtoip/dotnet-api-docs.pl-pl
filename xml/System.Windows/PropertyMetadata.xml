<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5c5dfef7a02e9b858a22854c1ef79b198ef1d9bc" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30715541" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiuje zachowanie niektórych aspektów właściwości zależności, ponieważ jest ono stosowane do określonego typu, w tym warunki, który został zarejestrowany.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane właściwości mogą być definiowane i używanych podczas rejestrowania właściwości zależności, podczas wywoływania metody <xref:System.Windows.DependencyProperty.Register%2A> — metoda (lub odchyleń dla właściwości tylko do odczytu zależności lub dołączone właściwości) lub po pierwotnej rejestracji właściciel podczas wywoływania metody <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> metody. <xref:System.Windows.DependencyProperty.AddOwner%2A> ma również metadane właściwości.  
  
 Ta klasa jest klasą bazową konkretnych mogą być używane w każdej z tych wywołań. Jednak często zdarza się, aby określić przy użyciu jednej z klas pochodnych takich jak metadanych <xref:System.Windows.FrameworkPropertyMetadata>. Te klasy pochodnej obsługuje bardziej szczegółowe metadanych jako wartości właściwości typu Boolean, które są przydatne w przypadku wykrycia albo włączenie niektórych właściwości systemu i układu zachowania, które są implementowane tylko na [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] poziom framework.  
  
 Kilka właściwości tej klasy są odczytu i zapisu do modelu obiektu, ale można zapisywać tylko przed wystąpienia, takich jak używane w ramach operacji systemu właściwość <xref:System.Windows.DependencyProperty.Register%2A> lub <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>. Każdej z tych właściwości można również zostały ustawione przez konstruktora, ale są dostępne, aby <xref:System.Windows.PropertyMetadata.Merge%2A> implementacje metod można włączyć dla nich.  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Ten typ i elementy członkowskie tego typu nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna, aby określić dla właściwości zależności, zwykle dostarczonych jako wartość określonego typu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy z określoną wartość domyślną dla właściwości zależności, który będzie dotyczyć tych metadanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ wartości podanej dla `defaultValue` muszą być zgodne, lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych. Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji (niezgodność zgłosi wyjątek czasu wykonywania).  
  
 Chociaż jest to wartość domyślna dla konstruktora bez parametrów, `defaultValue` z <xref:System.Windows.DependencyProperty.UnsetValue> nie może zostać określony. Takie próby zgłosi wyjątek.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> Nie można ustawić na wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, która jest wywoływana przez system właściwości przy każdej zmianie efektywną wartość właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy z określonym <see cref="T:System.Windows.PropertyChangedCallback" /> odwołanie do implementacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle dostarczonych jako wartość określonego typu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, która jest wywoływana przez system właściwości przy każdej zmianie efektywną wartość właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> klasy z wartością określoną wartość domyślną i <see cref="T:System.Windows.PropertyChangedCallback" /> odwołanie do implementacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ podanej wartości `defaultValue` muszą być zgodne, lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych. Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji (niezgodność zgłosi wyjątek czasu wykonywania).  
  
 Chociaż jest to wartość domyślna dla konstruktora bez parametrów, `defaultValue` z <xref:System.Windows.DependencyProperty.UnsetValue> nie może zostać określony. Takie próby zgłosi wyjątek.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> Nie można ustawić na wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna właściwości zależności, zwykle dostarczonych jako wartość określonego typu.</param>
        <param name="propertyChangedCallback">Odwołanie do implementacji programu obsługi, która jest wywoływana przez system właściwości przy każdej zmianie efektywną wartość właściwości.</param>
        <param name="coerceValueCallback">Odwołanie do implementacji programu obsługi, który ma być wywoływana, gdy wywołań systemowych właściwości <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> względem tej właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.PropertyMetadata" /> z określoną wartość domyślną i wywołania zwrotne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli chcesz określić <xref:System.Windows.CoerceValueCallback> , ale nie <xref:System.Windows.PropertyChangedCallback>, można przekazać `null` dla `propertyChangedCallback` parametru.  
  
 Typ wartości podanej dla `defaultValue` muszą być zgodne, lub być związane z typem określonym w pierwotnej rejestracji właściwości zależności, która będzie dotyczyć tych metadanych. Niezgodność między typ wartości domyślnej metadanych i typu właściwości zależności, który jest stosowany do może być trudne do debugowania, ponieważ niezgodność nie jest wykrywalny podczas kompilacji (niezgodność zgłosi wyjątek czasu wykonywania).  
  
 Chociaż jest to wartość domyślna dla konstruktora bez parametrów, `defaultValue` z <xref:System.Windows.DependencyProperty.UnsetValue> nie może zostać określony. Takie próby zgłosi wyjątek.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> Nie można ustawić na wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odwołanie do <see cref="T:System.Windows.CoerceValueCallback" /> implementacji określony w metadanych.</summary>
        <value>A <see cref="T:System.Windows.CoerceValueCallback" /> odwołanie do implementacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania zwrotne w metadanych właściwości nie są zwykle publicznych elementów członkowskich w typie zawierającym, więc wartość tej właściwości nie jest ważna w przypadku większości scenariuszy używające tylko metadane istniejącej właściwości zależności. Jedną z przyczyn jest uwidaczniana, ta właściwość jest tak, aby podklasy metadanych można wykonać ich logiki żądaną scalania, jeśli zarówno podstawowe, jak i zastępowanie Dodawanie metadanych określ <xref:System.Windows.CoerceValueCallback>. Jednak domyślnie scalania logikę <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> jest zastąpienie poprzedniej.  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> jest zdefiniowany w modelu obiektów w trybie odczytu i zapisu. Dzieje się tak <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> można dostosować po zainicjowaniu elementu <xref:System.Windows.PropertyMetadata> samego obiektu. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości są teraz uważany za niezmienialny. Trwa próba skonfigurowania <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić właściwości metadanych, po zastosowaniu ich do operacji właściwości zależności.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość domyślna właściwości zależności.</summary>
        <value>Wartość domyślna właściwości. Wartość domyślna dla <see cref="T:System.Windows.PropertyMetadata" /> wystąpienia utworzone za pomocą konstruktora bez parametrów zostaną <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> jest zdefiniowany w modelu obiektów w trybie odczytu i zapisu. Dzieje się tak <xref:System.Windows.PropertyMetadata.DefaultValue%2A> można dostosować po zainicjowaniu elementu <xref:System.Windows.PropertyMetadata> samego obiektu. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości są teraz uważany za niezmienialny. Trwa próba skonfigurowania <xref:System.Windows.PropertyMetadata.DefaultValue%2A> po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
 Chociaż jest to wartość domyślna dla konstruktora bez parametrów, `defaultValue` z <xref:System.Windows.DependencyProperty.UnsetValue> nie można ustawić za pomocą <xref:System.Windows.PropertyMetadata.DefaultValue%2A> lub konstruktora. Takie próby zgłosi wyjątek.  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a>Użycie tekstu w języku XAML  
 Elementy członkowskie tego typu nie są zwykle używane w [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie można ustawić na wartość <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> raz utworzony.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić właściwości metadanych, po zastosowaniu ich do operacji właściwości zależności.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy metadane zostały zastosowane do właściwości w sposób, co w stanie modyfikować tego wystąpienia metadanych.</summary>
        <value>
          <see langword="true" /> Jeśli wystąpienie metadanych jest niezmienialny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Różne właściwości <xref:System.Windows.PropertyMetadata>, takich jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, są zdefiniowane w modelu obiektów w trybie odczytu i zapisu. Jest więc te właściwości można dostosować po zainicjowaniu elementu <xref:System.Windows.PropertyMetadata> samego obiektu. Jednak po metadanych jest stosowany do właściwości zależności w ramach wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości są teraz uważany za niezmienialny. W czasie jednej z tych wywołań <xref:System.Windows.PropertyMetadata.OnApply%2A> nosi nazwę, a wartość tej właściwości jest równa `true`.  
  
   
  
## Examples  
 Następujące testy przykład <xref:System.Windows.PropertyMetadata.IsSealed%2A> przed operacją zestaw właściwości niestandardowych metadanych.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Podstawowy metadanych do scalenia z wartościami tego wystąpienia.</param>
        <param name="dp">Właściwości zależności, do którego stosowana jest metadanych.</param>
        <summary>Scala te metadane z metadanymi podstawowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana wewnętrznie, gdy metadane są zastępowane (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metody).  
  
   
  
## Examples  
 Poniższy przykład implementuje scalania dla typu niestandardowych metadanych, który dodaje właściwość dodatkowe metadane właściwości.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Klasa implementacji, które pochodzą z <see cref="T:System.Windows.PropertyMetadata" /> powinny przesłaniać tę metodę, aby uwzględnić wszystkie właściwości metadanych dodali do ich implementacji. Na przykład implementacji może dodano nową wartość wyliczenia flagwise i <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementacji następnie powinny mieć możliwość łączenia tych flag poprawnie.  
  
 Zawsze wywoływać implementację podstawową przed kod implementacji, ponieważ Podstawowa implementacja zajmuje się wszystkie właściwości, które są już zdefiniowane na scalanie <see cref="T:System.Windows.PropertyMetadata" /> typu.  
  
 Dokładne zachowanie scalania zależy od użytkownika. Można wybrać wartości połączone, przywrócić wartości podstawowej Jeśli pochodnej metadanych pozostawiono domyślne lub wielu innych zachowań na podstawie typów właściwości, które zostały dodane do metadanych konkretnej klasy i ich znaczenie.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Właściwości zależności, do którego zastosowano metadanych.</param>
        <param name="targetType">Typ skojarzony z metadanych, jeśli jest to metadanych określonego typu. Jeśli jest to domyślny metadanych, ta wartość jest odwołanie o wartości null.</param>
        <summary>Wywoływane, gdy zastosowano te metadane dla właściwości, co oznacza, że metadane jest zapieczętowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podklasy powinny zapewnić, że wszystkie zmienność struktury danych <xref:System.Windows.PropertyMetadata> podklasy powinien być oznaczony jako niezmienialny raz <xref:System.Windows.PropertyMetadata.OnApply%2A> jest wywoływana. To będzie wywoływana po zastosowaniu metadanych dla działania systemu właściwości (rejestrowanie, dodawanie właściciela, zastępowanie metadanych).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odwołanie do <see cref="T:System.Windows.PropertyChangedCallback" /> implementacji określony w metadanych.</summary>
        <value>A <see cref="T:System.Windows.PropertyChangedCallback" /> odwołanie do implementacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania zwrotne w metadanych właściwości nie są zwykle publiczne elementy członkowskie na typ definiujący, dlatego wartość tej właściwości nie jest ważna w przypadku większości scenariuszy używające tylko metadane istniejącej właściwości zależności. Jedną z przyczyn jest uwidaczniana, ta właściwość jest tak, aby klasy metadanych można wykonać ich logiki żądaną scalania, jeśli zarówno podstawowe, jak i zastępowanie Dodawanie metadanych określ <xref:System.Windows.PropertyChangedCallback>. Domyślna logika scalania dla jest obsługa wszystkich <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementacje w tabeli i połączenie ich z ustanowiono przez klasę najgłębszym w hierarchii z pierwszego.  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> jest zdefiniowany w modelu obiektów w trybie odczytu i zapisu. Dzieje się tak <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> można dostosować po zainicjowaniu elementu <xref:System.Windows.PropertyMetadata> samego obiektu. Jednak po metadanych jest używany jako część wywołania <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, system właściwość zostanie zapieczętować tego wystąpienia metadanych i właściwości są teraz uważany za niezmienialny. Trwa próba skonfigurowania <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> po <xref:System.Windows.PropertyMetadata.IsSealed%2A> jest `true` na te metadane wystąpienia zgłosi wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić właściwości metadanych, po zastosowaniu ich do operacji właściwości zależności.</exception>
      </Docs>
    </Member>
  </Members>
</Type>